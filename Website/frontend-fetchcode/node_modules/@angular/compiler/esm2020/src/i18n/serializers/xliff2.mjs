ipelineTopicExpression(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodePipelineTopicExpression)
  declare export function assertPipelineTopicExpression(node: ?Object, opts?: ?Object): void
  declare export function isPipelineBareFunction(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodePipelineBareFunction)
  declare export function assertPipelineBareFunction(node: ?Object, opts?: ?Object): void
  declare export function isPipelinePrimaryTopicReference(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodePipelinePrimaryTopicReference)
  declare export function assertPipelinePrimaryTopicReference(node: ?Object, opts?: ?Object): void
  declare export function isTSParameterProperty(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSParameterProperty)
  declare export function assertTSParameterProperty(node: ?Object, opts?: ?Object): void
  declare export function isTSDeclareFunction(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSDeclareFunction)
  declare export function assertTSDeclareFunction(node: ?Object, opts?: ?Object): void
  declare export function isTSDeclareMethod(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSDeclareMethod)
  declare export function assertTSDeclareMethod(node: ?Object, opts?: ?Object): void
  declare export function isTSQualifiedName(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSQualifiedName)
  declare export function assertTSQualifiedName(node: ?Object, opts?: ?Object): void
  declare export function isTSCallSignatureDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSCallSignatureDeclaration)
  declare export function assertTSCallSignatureDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSConstructSignatureDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSConstructSignatureDeclaration)
  declare export function assertTSConstructSignatureDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSPropertySignature(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSPropertySignature)
  declare export function assertTSPropertySignature(node: ?Object, opts?: ?Object): void
  declare export function isTSMethodSignature(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSMethodSignature)
  declare export function assertTSMethodSignature(node: ?Object, opts?: ?Object): void
  declare export function isTSIndexSignature(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSIndexSignature)
  declare export function assertTSIndexSignature(node: ?Object, opts?: ?Object): void
  declare export function isTSAnyKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSAnyKeyword)
  declare export function assertTSAnyKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSBooleanKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSBooleanKeyword)
  declare export function assertTSBooleanKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSBigIntKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSBigIntKeyword)
  declare export function assertTSBigIntKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSIntrinsicKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSIntrinsicKeyword)
  declare export function assertTSIntrinsicKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSNeverKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSNeverKeyword)
  declare export function assertTSNeverKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSNullKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSNullKeyword)
  declare export function assertTSNullKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSNumberKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSNumberKeyword)
  declare export function assertTSNumberKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSObjectKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSObjectKeyword)
  declare export function assertTSObjectKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSStringKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSStringKeyword)
  declare export function assertTSStringKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSSymbolKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSSymbolKeyword)
  declare export function assertTSSymbolKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSUndefinedKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSUndefinedKeyword)
  declare export function assertTSUndefinedKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSUnknownKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSUnknownKeyword)
  declare export function assertTSUnknownKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSVoidKeyword(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSVoidKeyword)
  declare export function assertTSVoidKeyword(node: ?Object, opts?: ?Object): void
  declare export function isTSThisType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSThisType)
  declare export function assertTSThisType(node: ?Object, opts?: ?Object): void
  declare export function isTSFunctionType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSFunctionType)
  declare export function assertTSFunctionType(node: ?Object, opts?: ?Object): void
  declare export function isTSConstructorType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSConstructorType)
  declare export function assertTSConstructorType(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeReference(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeReference)
  declare export function assertTSTypeReference(node: ?Object, opts?: ?Object): void
  declare export function isTSTypePredicate(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypePredicate)
  declare export function assertTSTypePredicate(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeQuery(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeQuery)
  declare export function assertTSTypeQuery(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeLiteral(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeLiteral)
  declare export function assertTSTypeLiteral(node: ?Object, opts?: ?Object): void
  declare export function isTSArrayType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSArrayType)
  declare export function assertTSArrayType(node: ?Object, opts?: ?Object): void
  declare export function isTSTupleType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTupleType)
  declare export function assertTSTupleType(node: ?Object, opts?: ?Object): void
  declare export function isTSOptionalType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSOptionalType)
  declare export function assertTSOptionalType(node: ?Object, opts?: ?Object): void
  declare export function isTSRestType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSRestType)
  declare export function assertTSRestType(node: ?Object, opts?: ?Object): void
  declare export function isTSNamedTupleMember(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSNamedTupleMember)
  declare export function assertTSNamedTupleMember(node: ?Object, opts?: ?Object): void
  declare export function isTSUnionType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSUnionType)
  declare export function assertTSUnionType(node: ?Object, opts?: ?Object): void
  declare export function isTSIntersectionType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSIntersectionType)
  declare export function assertTSIntersectionType(node: ?Object, opts?: ?Object): void
  declare export function isTSConditionalType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSConditionalType)
  declare export function assertTSConditionalType(node: ?Object, opts?: ?Object): void
  declare export function isTSInferType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSInferType)
  declare export function assertTSInferType(node: ?Object, opts?: ?Object): void
  declare export function isTSParenthesizedType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSParenthesizedType)
  declare export function assertTSParenthesizedType(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeOperator(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeOperator)
  declare export function assertTSTypeOperator(node: ?Object, opts?: ?Object): void
  declare export function isTSIndexedAccessType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSIndexedAccessType)
  declare export function assertTSIndexedAccessType(node: ?Object, opts?: ?Object): void
  declare export function isTSMappedType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSMappedType)
  declare export function assertTSMappedType(node: ?Object, opts?: ?Object): void
  declare export function isTSLiteralType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSLiteralType)
  declare export function assertTSLiteralType(node: ?Object, opts?: ?Object): void
  declare export function isTSExpressionWithTypeArguments(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSExpressionWithTypeArguments)
  declare export function assertTSExpressionWithTypeArguments(node: ?Object, opts?: ?Object): void
  declare export function isTSInterfaceDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSInterfaceDeclaration)
  declare export function assertTSInterfaceDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSInterfaceBody(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSInterfaceBody)
  declare export function assertTSInterfaceBody(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeAliasDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeAliasDeclaration)
  declare export function assertTSTypeAliasDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSInstantiationExpression(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSInstantiationExpression)
  declare export function assertTSInstantiationExpression(node: ?Object, opts?: ?Object): void
  declare export function isTSAsExpression(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSAsExpression)
  declare export function assertTSAsExpression(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeAssertion(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeAssertion)
  declare export function assertTSTypeAssertion(node: ?Object, opts?: ?Object): void
  declare export function isTSEnumDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSEnumDeclaration)
  declare export function assertTSEnumDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSEnumMember(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSEnumMember)
  declare export function assertTSEnumMember(node: ?Object, opts?: ?Object): void
  declare export function isTSModuleDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSModuleDeclaration)
  declare export function assertTSModuleDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSModuleBlock(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSModuleBlock)
  declare export function assertTSModuleBlock(node: ?Object, opts?: ?Object): void
  declare export function isTSImportType(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSImportType)
  declare export function assertTSImportType(node: ?Object, opts?: ?Object): void
  declare export function isTSImportEqualsDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSImportEqualsDeclaration)
  declare export function assertTSImportEqualsDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSExternalModuleReference(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSExternalModuleReference)
  declare export function assertTSExternalModuleReference(node: ?Object, opts?: ?Object): void
  declare export function isTSNonNullExpression(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSNonNullExpression)
  declare export function assertTSNonNullExpression(node: ?Object, opts?: ?Object): void
  declare export function isTSExportAssignment(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSExportAssignment)
  declare export function assertTSExportAssignment(node: ?Object, opts?: ?Object): void
  declare export function isTSNamespaceExportDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSNamespaceExportDeclaration)
  declare export function assertTSNamespaceExportDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeAnnotation(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeAnnotation)
  declare export function assertTSTypeAnnotation(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeParameterInstantiation(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeParameterInstantiation)
  declare export function assertTSTypeParameterInstantiation(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeParameterDeclaration(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeParameterDeclaration)
  declare export function assertTSTypeParameterDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeParameter(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeTSTypeParameter)
  declare export function assertTSTypeParameter(node: ?Object, opts?: ?Object): void
  declare export function isStandardized(node: ?Object, opts?: ?Object): boolean
  declare export function assertStandardized(node: ?Object, opts?: ?Object): void
  declare export function isExpression(node: ?Object, opts?: ?Object): boolean
  declare export function assertExpression(node: ?Object, opts?: ?Object): void
  declare export function isBinary(node: ?Object, opts?: ?Object): boolean
  declare export function assertBinary(node: ?Object, opts?: ?Object): void
  declare export function isScopable(node: ?Object, opts?: ?Object): boolean
  declare export function assertScopable(node: ?Object, opts?: ?Object): void
  declare export function isBlockParent(node: ?Object, opts?: ?Object): boolean
  declare export function assertBlockParent(node: ?Object, opts?: ?Object): void
  declare export function isBlock(node: ?Object, opts?: ?Object): boolean
  declare export function assertBlock(node: ?Object, opts?: ?Object): void
  declare export function isStatement(node: ?Object, opts?: ?Object): boolean
  declare export function assertStatement(node: ?Object, opts?: ?Object): void
  declare export function isTerminatorless(node: ?Object, opts?: ?Object): boolean
  declare export function assertTerminatorless(node: ?Object, opts?: ?Object): void
  declare export function isCompletionStatement(node: ?Object, opts?: ?Object): boolean
  declare export function assertCompletionStatement(node: ?Object, opts?: ?Object): void
  declare export function isConditional(node: ?Object, opts?: ?Object): boolean
  declare export function assertConditional(node: ?Object, opts?: ?Object): void
  declare export function isLoop(node: ?Object, opts?: ?Object): boolean
  declare export function assertLoop(node: ?Object, opts?: ?Object): void
  declare export function isWhile(node: ?Object, opts?: ?Object): boolean
  declare export function assertWhile(node: ?Object, opts?: ?Object): void
  declare export function isExpressionWrapper(node: ?Object, opts?: ?Object): boolean
  declare export function assertExpressionWrapper(node: ?Object, opts?: ?Object): void
  declare export function isFor(node: ?Object, opts?: ?Object): boolean
  declare export function assertFor(node: ?Object, opts?: ?Object): void
  declare export function isForXStatement(node: ?Object, opts?: ?Object): boolean
  declare export function assertForXStatement(node: ?Object, opts?: ?Object): void
  declare export function isFunction(node: ?Object, opts?: ?Object): boolean
  declare export function assertFunction(node: ?Object, opts?: ?Object): void
  declare export function isFunctionParent(node: ?Object, opts?: ?Object): boolean
  declare export function assertFunctionParent(node: ?Object, opts?: ?Object): void
  declare export function isPureish(node: ?Object, opts?: ?Object): boolean
  declare export function assertPureish(node: ?Object, opts?: ?Object): void
  declare export function isDeclaration(node: ?Object, opts?: ?Object): boolean
  declare export function assertDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isPatternLike(node: ?Object, opts?: ?Object): boolean
  declare export function assertPatternLike(node: ?Object, opts?: ?Object): void
  declare export function isLVal(node: ?Object, opts?: ?Object): boolean
  declare export function assertLVal(node: ?Object, opts?: ?Object): void
  declare export function isTSEntityName(node: ?Object, opts?: ?Object): boolean
  declare export function assertTSEntityName(node: ?Object, opts?: ?Object): void
  declare export function isLiteral(node: ?Object, opts?: ?Object): boolean
  declare export function assertLiteral(node: ?Object, opts?: ?Object): void
  declare export function isImmutable(node: ?Object, opts?: ?Object): boolean
  declare export function assertImmutable(node: ?Object, opts?: ?Object): void
  declare export function isUserWhitespacable(node: ?Object, opts?: ?Object): boolean
  declare export function assertUserWhitespacable(node: ?Object, opts?: ?Object): void
  declare export function isMethod(node: ?Object, opts?: ?Object): boolean
  declare export function assertMethod(node: ?Object, opts?: ?Object): void
  declare export function isObjectMember(node: ?Object, opts?: ?Object): boolean
  declare export function assertObjectMember(node: ?Object, opts?: ?Object): void
  declare export function isProperty(node: ?Object, opts?: ?Object): boolean
  declare export function assertProperty(node: ?Object, opts?: ?Object): void
  declare export function isUnaryLike(node: ?Object, opts?: ?Object): boolean
  declare export function assertUnaryLike(node: ?Object, opts?: ?Object): void
  declare export function isPattern(node: ?Object, opts?: ?Object): boolean
  declare export function assertPattern(node: ?Object, opts?: ?Object): void
  declare export function isClass(node: ?Object, opts?: ?Object): boolean
  declare export function assertClass(node: ?Object, opts?: ?Object): void
  declare export function isModuleDeclaration(node: ?Object, opts?: ?Object): boolean
  declare export function assertModuleDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isExportDeclaration(node: ?Object, opts?: ?Object): boolean
  declare export function assertExportDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isModuleSpecifier(node: ?Object, opts?: ?Object): boolean
  declare export function assertModuleSpecifier(node: ?Object, opts?: ?Object): void
  declare export function isAccessor(node: ?Object, opts?: ?Object): boolean
  declare export function assertAccessor(node: ?Object, opts?: ?Object): void
  declare export function isPrivate(node: ?Object, opts?: ?Object): boolean
  declare export function assertPrivate(node: ?Object, opts?: ?Object): void
  declare export function isFlow(node: ?Object, opts?: ?Object): boolean
  declare export function assertFlow(node: ?Object, opts?: ?Object): void
  declare export function isFlowType(node: ?Object, opts?: ?Object): boolean
  declare export function assertFlowType(node: ?Object, opts?: ?Object): void
  declare export function isFlowBaseAnnotation(node: ?Object, opts?: ?Object): boolean
  declare export function assertFlowBaseAnnotation(node: ?Object, opts?: ?Object): void
  declare export function isFlowDeclaration(node: ?Object, opts?: ?Object): boolean
  declare export function assertFlowDeclaration(node: ?Object, opts?: ?Object): void
  declare export function isFlowPredicate(node: ?Object, opts?: ?Object): boolean
  declare export function assertFlowPredicate(node: ?Object, opts?: ?Object): void
  declare export function isEnumBody(node: ?Object, opts?: ?Object): boolean
  declare export function assertEnumBody(node: ?Object, opts?: ?Object): void
  declare export function isEnumMember(node: ?Object, opts?: ?Object): boolean
  declare export function assertEnumMember(node: ?Object, opts?: ?Object): void
  declare export function isJSX(node: ?Object, opts?: ?Object): boolean
  declare export function assertJSX(node: ?Object, opts?: ?Object): void
  declare export function isMiscellaneous(node: ?Object, opts?: ?Object): boolean
  declare export function assertMiscellaneous(node: ?Object, opts?: ?Object): void
  declare export function isTypeScript(node: ?Object, opts?: ?Object): boolean
  declare export function assertTypeScript(node: ?Object, opts?: ?Object): void
  declare export function isTSTypeElement(node: ?Object, opts?: ?Object): boolean
  declare export function assertTSTypeElement(node: ?Object, opts?: ?Object): void
  declare export function isTSType(node: ?Object, opts?: ?Object): boolean
  declare export function assertTSType(node: ?Object, opts?: ?Object): void
  declare export function isTSBaseType(node: ?Object, opts?: ?Object): boolean
  declare export function assertTSBaseType(node: ?Object, opts?: ?Object): void
  declare export function isNumberLiteral(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeNumericLiteral)
  declare export function assertNumberLiteral(node: ?Object, opts?: ?Object): void
  declare export function isRegexLiteral(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeRegExpLiteral)
  declare export function assertRegexLiteral(node: ?Object, opts?: ?Object): void
  declare export function isRestProperty(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeRestElement)
  declare export function assertRestProperty(node: ?Object, opts?: ?Object): void
  declare export function isSpreadProperty(node: ?Object, opts?: ?Object): boolean %checks (node instanceof BabelNodeSpreadElement)
  declare export function assertSpreadProperty(node: ?Object, opts?: ?Object): void
  declare export var VISITOR_KEYS: { [type: string]: string[] }
  declare export function assertNode(obj: any): void
  declare export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): BabelNodeTypeAnnotation
  declare export function createUnionTypeAnnotation(types: Array<BabelNodeFlowType>): BabelNodeUnionTypeAnnotation
  declare export function createFlowUnionType(types: Array<BabelNodeFlowType>): BabelNodeUnionTypeAnnotation
  declare export function buildChildren(node: { children: Array<BabelNodeJSXText | BabelNodeJSXExpressionContainer | BabelNodeJSXSpreadChild | BabelNodeJSXElement | BabelNodeJSXFragment | BabelNodeJSXEmptyExpression> }): Array<BabelNodeJSXText | BabelNodeJSXExpressionContainer | BabelNodeJSXSpreadChild | BabelNodeJSXElement | BabelNodeJSXFragment>
  declare export function clone<T>(n: T): T;
  declare export function cloneDeep<T>(n: T): T;
  declare export function cloneDeepWithoutLoc<T>(n: T): T;
  declare export function cloneNode<T>(n: T, deep?: boolean, withoutLoc?: boolean): T;
  declare export function cloneWithoutLoc<T>(n: T): T;
  declare type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'
  declare export function addComment<T: BabelNode>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T
  declare export function addComments<T: BabelNode>(node: T, type: CommentTypeShorthand, comments: Array<Comment>): T
  declare export function inheritInnerComments(node: BabelNode, parent: BabelNode): void
  declare export function inheritLeadingComments(node: BabelNode, parent: BabelNode): void
  declare export function inheritsComments<T: BabelNode>(node: T, parent: BabelNode): void
  declare export function inheritTrailingComments(node: BabelNode, parent: BabelNode): void
  declare export function removeComments<T: BabelNode>(node: T): T
  declare export function ensureBlock(node: BabelNode, key: string): BabelNodeBlockStatement
  declare export function toBindingIdentifierName(name?: ?string): string
  declare export function toBlock(node: BabelNodeStatement | BabelNodeExpression, parent?: BabelNodeFunction | null): BabelNodeBlockStatement
  declare export function toComputedKey(node: BabelNodeMethod | BabelNodeProperty, key?: BabelNodeExpression | BabelNodeIdentifier): BabelNodeExpression
  declare export function toExpression(node: BabelNodeExpressionStatement | BabelNodeExpression | BabelNodeClass | BabelNodeFunction): BabelNodeExpression
  declare export function toIdentifier(name?: ?string): string
  declare export function toKeyAlias(node: BabelNodeMethod | BabelNodeProperty, key?: BabelNode): string
  declare export function toStatement(node: BabelNodeStatement | BabelNodeClass | BabelNodeFunction | BabelNodeAssignmentExpression, ignore?: boolean): BabelNodeStatement | void
  declare export function valueToNode(value: any): BabelNodeExpression
  declare export function removeTypeDuplicates(types: Array<BabelNodeFlowType>): Array<BabelNodeFlowType>
  declare export function appendToMemberExpression(member: BabelNodeMemberExpression, append: BabelNode, computed?: boolean): BabelNodeMemberExpression
  declare export function inherits<T: BabelNode>(child: T, parent: BabelNode | null | void): T
  declare export function prependToMemberExpression(member: BabelNodeMemberExpression, prepend: BabelNodeExpression): BabelNodeMemberExpression
  declare export function removeProperties<T>(n: T, opts: ?{}): void;
  declare export function removePropertiesDeep<T>(n: T, opts: ?{}): T;
  declare export var getBindingIdentifiers: {
      (node: BabelNode, duplicates?: boolean, outerOnly?: boolean): { [key: string]: BabelNodeIdentifier | Array<BabelNodeIdentifier> },
      keys: { [type: string]: string[] }
    }
  declare export function getOuterBindingIdentifiers(node: BabelNode, duplicates?: boolean): { [key: string]: BabelNodeIdentifier | Array<BabelNodeIdentifier> }
  declare type TraversalAncestors = Array<{
    node: BabelNode,
    key: string,
    index?: number,
  }>;
  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;
  declare type TraversalHandlers<T> = {
    enter?: TraversalHandler<T>,
    exit?: TraversalHandler<T>,
  };
  declare export function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;
  declare export function traverseFast<T>(n: BabelNode, h: TraversalHandler<T>, state?: T): void;
  declare export function shallowEqual(actual: Object, expected: Object): boolean
  declare export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (?BabelNode) => boolean
  declare export function is(type: string, n: BabelNode, opts: Object): boolean;
  declare export function isBinding(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean
  declare export function isBlockScoped(node: BabelNode): boolean
  declare export function isImmutable(node: BabelNode): boolean
  declare export function isLet(node: BabelNode): boolean
  declare export function isNode(node: ?Object): boolean
  declare export function isNodesEquivalent(a: any, b: any): boolean
  declare export function isPlaceholderType(placeholderType: string, targetType: string): boolean
  declare export function isReferenced(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean
  declare export function isScope(node: BabelNode, parent: BabelNode): boolean
  declare export function isSpecifierDefault(specifier: BabelNodeModuleSpecifier): boolean
  declare export function isType(nodetype: ?string, targetType: string): boolean
  declare export function isValidES3Identifier(name: string): boolean
  declare export function isValidES3Identifier(name: string): boolean
  declare export function isValidIdentifier(name: string): boolean
  declare export function isVar(node: BabelNode): boolean
  declare export function matchesPattern(node: ?BabelNode, match: string | Array<string>, allowPartial?: boolean): boolean
  declare export function validate(n: BabelNode, key: string, value: mixed): void;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 'use strict';

const constants = require('./constants');
const utils = require('./utils');

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dot