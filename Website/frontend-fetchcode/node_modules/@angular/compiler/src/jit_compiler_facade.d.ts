ecordInner, TRecord[K]>
    ): QueryBuilder<TRecord, TResult>;
    <TRecordInner extends {}, TResultInner>(
      columnName: string,
      values: Value[] | QueryBuilder<TRecordInner, TResultInner>
    ): QueryBuilder<TRecord, TResult>;
    <K extends keyof TRecord, TRecordInner extends {}, TResultInner>(
      columnNames: readonly K[],
      values: QueryBuilder<TRecordInner, TRecord[K]>
    ): QueryBuilder<TRecord, TResult>;
    <TRecordInner extends {}, TResultInner>(
      columnNames: readonly string[],
      values: QueryBuilder<TRecordInner, TResultInner>
    ): QueryBuilder<TRecord, TResult>;
  }

  // Note: Attempting to unify AsymmetricAggregation & TypePreservingAggregation
  // by extracting out a common base interface will not work because order of overloads
  // is significant.

  interface AsymmetricAggregation<TRecord extends {} = any, TResult = unknown[], TValue = any> {
    <
      TOptions extends { "as": string },
      TResult2 = AggregationQueryResult<TResult, {[k in TOptions["as"]]: TValue}>
      >(
      columnName: Readonly<keyof ResolveTableType<TRecord>>,
      options: Readonly<TOptions>
    ): QueryBuilder<TRecord, TResult2>;
    <TResult2 = AggregationQueryResult<TResult, Dict<TValue>>>(
      ...columnNames: readonly (keyof ResolveTableType<TRecord>)[]
    ): QueryBuilder<TRecord, TResult2>;
    <
      TAliases extends {} = Record<string, string | string[] | Knex.Raw>,
      TResult2 = AggregationQueryResult<TResult, {[k in keyof TAliases]?: TValue}>
      >(aliases: TAliases): QueryBuilder<TRecord, TResult2>;
    <TResult2 = AggregationQueryResult<TResult, Dict<TValue>>>(
      ...columnNames: ReadonlyArray<Readonly<Record<string, string | string[] | Knex.Raw>> | Knex.Raw | string>
    ): QueryBuilder<TRecord, TResult2>;
  }

  interface TypePreservingAggregation<TRecord extends {} = any, TResult = unknown[], TValue = any> {
    <
      TKey extends keyof ResolveTableType<TRecord>,
      TOptions extends { "as": string },
      TResult2 = AggregationQueryResult<TResult, {
        [k in TOptions["as"]]: ResolveTableType<TRecord>[TKey]
      }>
      >(
      columnName: Readonly<TKey>,
      options: Readonly<TOptions>
    ): QueryBuilder<TRecord, TResult2>;
    <
      TKey extends keyof ResolveTableType<TRecord>,
      TResult2 = AggregationQueryResult<TResult, Dict<ResolveTableType<TRecord>[TKey]>>
      >(
      ...columnNames: readonly TKey[]
    ): QueryBuilder<TRecord, TResult2>;
    <
      TAliases extends {} = Readonly<Record<string, string | string[] | Knex.Raw>>,
      TResult2 = AggregationQueryResult<TResult, {
        // We have optional here because in most dialects aggregating by multiple keys simultaneously
        // causes rest of the keys to be dropped and only first to be considered
        [K in keyof TAliases]?: K extends keyof TRecord ?
        TRecord[K] :
        TValue
      }>
      >(aliases: TAliases): QueryBuilder<TRecord, TResult2>;
    <TResult2 = AggregationQueryResult<TResult, Dict<TValue>>>(
      ...columnNames: ReadonlyArray<Readonly<Record<string, string | readonly string[] | Knex.Raw>> | Knex.Raw | string>
    ): QueryBuilder<TRecord, TResult2>;
  }

  interface AnalyticFunction<TRecord extends {} = any, TResult = unknown[]> {
    <
      TAlias extends string,
      TResult2 = AggregationQueryResult<TResult, {[x in TAlias]: number}>
      >(alias: TAlias, raw: Raw | QueryCallback<TRecord, TResult>): QueryBuilder<TReco