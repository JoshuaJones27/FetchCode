er<TRecord, TResult>,
    ColumnNameQueryBuilder<TRecord, TResult> {}

  interface OrderBy<TRecord extends {} = any, TResult = unknown[]> {
    (columnName: keyof TRecord | QueryBuilder, order?: 'asc' | 'desc', nulls?: 'first' | 'last'): QueryBuilder<
      TRecord,
      TResult
    >;
    (columnName: string | QueryBuilder, order?: string, nulls?: string): QueryBuilder<TRecord, TResult>;
    (
      columnDefs: Array<
        keyof TRecord | Readonly<{
          column: keyof TRecord | QueryBuilder;
          order?: 'asc' | 'desc',
          nulls?: 'first' | 'last'
        }>
      >
    ): QueryBuilder<TRecord, TResult>;
    (
      columnDefs: Array<string | Readonly<{
        column: string | QueryBuilder;
        order?: string;
        nulls?: string;
      }>>
    ): QueryBuilder<TRecord, TResult>;
  }

  interface PartitionBy<TRecord extends {} = any, TResult = unknown[]>
    extends OrderBy<TRecord, TResult> {}

  interface Intersect<TRecord extends {} = any, TResult = unknown[]> {
    (
      callback: MaybeArray<QueryCallback | QueryBuilder<TRecord> | Raw>,
      wrap?: boolean
    ): QueryBuilder<TRecord, TResult>;
    (
      ...callbacks: readonly (QueryCallback | Raw | QueryBuilder<TRecord>)[]
    ): QueryBuilder<TRecord, TResult>;
  }

  interface Union<TRecord extends {} = any, TResult = unknown[]>
    extends Intersect<TRecord, TResult> {}

  interface Having<TRecord extends {} = any, TResult = unknown[]>
    extends WhereWrapped<TRecord, TResult> {
    <K extends keyof TRecord>(
      column: K,
      operator: ComparisonOperator,
      value: DbColumn<TRecord[K]>
    ): QueryBuilder<TRecord, TResult>;

    (
      column: string | Raw,
      operator: string,
      value: Value | QueryBuilder | null
    ): QueryBuilder<TRecord, TResult>;

    (raw: Raw): QueryBuilder<
      TRecord,
      TResult
    >;
  }

  interface HavingRange<TRecord extends {} = any, TResult = unknown[]> {
    <K extends keyof TRecord>(
      columnName: K,
      values: readonly DbColumn<TRecord[K]>[]
    ): QueryBuilder<TRecord, TResult>;
    (columnName: string, values: readonly Value[]): QueryBuilder<TRecord, TResult>;
  }

  // commons

  interface ColumnNameQueryBuilder<TRecord extends {} = any, TResult = unknown[]> {
    // When all columns are known to be keys of original record,
    // we can extend our selection by these columns
    (columnName: '*'): QueryBuilder<
      TRecord,
      ArrayIfAlready<TResult, DeferredKeySelection<TRecord, string>>
    >;

    <
      ColNameUT extends keyof ResolveTableType<TRecord>,
      TResult2 = DeferredKeySelection.Augment<
        UnwrapArrayMember<TResult>,
        ResolveTableType<TRecord>,
        ColNameUT & string
      >[]
      >(
      ...columnNames: readonly ColNameUT[]
    ): QueryBuilder<TRecord, TResult2>;
