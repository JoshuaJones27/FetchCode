VideoFrames,de:c.totalVideoFrames},oKa()));return!0};
qKa=function(a,b){return 0>=g.eA(a.U.experiments,"hfr_dropped_framerate_fallback_threshold")||!(b&&b.video&&32<b.video.fps)?!1:3<=a.u?(a.u=0,!0):!1};
mKa=function(a,b){var c=b.j,d=b.video.fps;b=b.video.j-1;var e=Uz();c=Pua(c,d);0<+e[c]&&(b=Math.min(+e[c],b));e[c]!==b&&(e[c]=b,g.Zu("yt-player-performance-cap",e,604800));a.qa.ew()};
rKa=function(a,b){if(!b.j.j)return a.C?new Kw(0,360,!1,"b"):lD;for(var c=!1,d=!1,e=g.r(b.j.videoInfos),f=e.next();!f.done;f=e.next())gz(f.value)?c=!0:d=!0;c=c&&d;d=0;f=g.eA(a.U.experiments,"html5_performance_cap_floor");a=a.U.isMobile?240:f;b=g.r(b.j.videoInfos);for(f=b.next();!f.done;f=b.next())if(e=f.value,!c||!gz(e))if(f=Vz(e.j,e.video.fps),e=e.video.j,Math.max(f,a)>=e){d=e;break}return new Kw(0,d,!1,"b")};
sKa=function(a){a=a.qa.Cp();return a.isInline()?new Kw(0,480,!1,"v"):a.isBackground()&&60<xt()/1E3?new Kw(0,360,!1,"v"):lD};
uKa=function(a,b,c){if(a.U.experiments.fb("html5_disable_client_autonav_cap_for_onesie")&&"onesie"===b.fetchType||g.oB(a.U)&&(1080<=Tz(-1)||b.osid))return lD;var d=g.eA(a.U.experiments,"html5_autonav_quality_cap"),e=g.eA(a.U.experiments,"html5_autonav_cap_idle_secs");return d&&b.Am&&xt()/1E3>e?(c&&(d=tKa(a,c,d)),new Kw(0,d,!1,"e")):lD};
tKa=function(a,b,c){if(a.K("html5_optimality_defaults_chooses_next_higher")&&c)for(a=b.j.videoInfos,b=1;b<a.length;b++)if(a[b].video.j<c)return a[b-1].video.j;return c};
vKa=function(a,b){a.K("html5_log_media_perf_info")&&(a.qa.ra("perfdb",oKa()),a.qa.ra("hwc",{nch:navigator.hardwareConcurrency},!0),b&&a.qa.ra("mcdb",{itags:b.j.videoInfos.filter(function(c){var d;return!1===(null==(d=c.u)?void 0:d.smooth)}).map(function(c){return c.Vb()}).join("-")}))};
oKa=function(){return Ke(Uz(),function(a){return""+a})};
WQ=function(a,b){g.I.call(this);this.j=a;this.J=b;this.u=-1;this.I=!1;this.B=-1;this.playerState=new g.zF;this.seekCount=this.nonNetworkErrorCount=this.networkErrorCount=this.rebufferTimeSecs=this.playTimeSecs=this.D=0;this.delay=new g.K(this.send,6E4,this);this.C=!1;g.J(this,this.delay)};
XQ=function(a){0<=a.u||(3===a.j.qa.getVisibilityState()?a.I=!0:(a.u=g.GN(a.j),a.delay.start()))};
wKa=function(a){if(!(0>a.B)){var b=g.GN(a.j),c=b-a.D;a.D=b;8===a.playerState.state?a.playTimeSecs+=c:g.HF(a.playerState)&&!g.V(a.playerState,16)&&(a.rebufferTimeSecs+=c)}};
YQ=function(a,b){b?xKa.test(a):(a=g.bq(a),Object.keys(a).includes("cpn"))};
ZQ=function(a,b,c,d,e,f,h){var l={format:"RAW"},m={};if(eq(a)&&fq()){if(h){var n;2!==(null==(n=yKa.uaChPolyfill)?void 0:n.state.type)?h=null:(h=yKa.uaChPolyfill.state.data.values,h={"Synth-Sec-CH-UA-Arch":h.architecture,"Synth-Sec-CH-UA-Model":h.model,"Synth-Sec-CH-UA-Platform":h.platform,"Synth-Sec-CH-UA-Platform-Version":h.platformVersion,"Synth-Sec-CH-UA-Full-Version":h.uaFullVersion});m=Object.assign(m,h);l.withCredentials=!0}h=g.P("EOM_VISITOR_DATA");b.K("enable_web_eom_visitor_data")&&h?m["X-Goog-EOM-Visitor-Id"]=
h:d?m["X-Goog-Visitor-Id"]=d:b.K("enable_visitor_header_for_vss")&&g.P("VISITOR_DATA")&&(m["X-Goog-Visitor-Id"]=g.P("VISITOR_DATA"));c&&(m["X-Goog-PageId"]=c);e&&(m.Authorization="Bearer "+e);h||m["X-Goog-Visitor-Id"]||e||c?l.withCredentials=!0:b.K("html5_send_cpn_with_options")&&xKa.test(a)&&(l.withCredentials=!0)}0<Object.keys(m).length&&(l.headers=m);f&&(l.onFinish=f);return 1<Object.keys(l).length?l:null};
$Q=function(a,b,c,d,e,f,h,l){fq()&&c.token&&(a=cq(a,{ctt:c.token,cttype:c.SJ,mdx_environment:c.mdxEnvironment}));f||l&&d.K("nwl_skip_retry")?(null==b?b={}:YQ(a,d.K("html5_assert_cpn_with_regex")),h?d.K("use_new_nwl_saw")?Ps().sendAndWrite(a,b):Xs(a,b):d.K("use_new_nwl_stw")?Ps().sendThenWrite(a,b,l):Ws(a,b,l)):d.gi?(b=b||{},YQ(a,d.K("html5_assert_cpn_with_regex")),d.gi.enqueue(a,b)):b?(YQ(a,d.K("html5_assert_cpn_with_regex")),g.pq(a,b)):g.Gs(a,e)};
g.bR=function(a){g.I.call(this);var b=this;this.j=a;this.logger=new g.qO("qoe");this.u={};this.sequenceNumber=1;this.Ta=NaN;this.Rd="N";this.N=this.Ib=this.eb=this.Sa=this.C=0;this.Da=this.Kb="";this.kb=this.Y=NaN;this.bb=0;this.Zb=-1;this.qb=1;this.playTimeSecs=this.rebufferTimeSecs=0;this.Pa=this.ma=this.isOffline=this.oa=!1;this.Hc=[];this.W=null;this.D=this.Ia=this.I=!1;this.B=-1;this.Ga=!1;this.qc=new g.K(this.wW,750,this);this.V=this.adCpn="";this.adFormat=void 0;this.Nc=0;this.Jc=new Set("cl fexp drm drm_system drm_product ns el adformat live cat".split(" "));
g.J(this,this.qc);(a="function"===typeof navigator.getBattery?navigator.getBattery():null)&&a.then&&a.then(function(c){b.W=c});
g.aR(this,0,"vps",["N"])};
g.aR=function(a,b,c,d){var e=a.u[c];e||(e=[],a.u[c]=e);e.push(b.toFixed(3)+":"+d.join(":"))};
cR=function(a,b){var c=a.j.qa.getCurrentTime();g.aR(a,b,"cmt",[c.toFixed(3)]);c=a.j.qa.Ui();if(a.J&&1E3*c>a.J.uP+100&&a.J){var d=a.J,e=d.isAd;c=1E3*c-d.uP;a.va=1E3*b-d.t0-c-d.g0;if(!a.j.videoData.K("web_player_dai_csi_killswitch")){c=(0,g.R)()-c;b=a.va;d=a.j.videoData;var f=d.isAd();if(e||f){f=(e?"ad":"video")+"_to_"+(f?"ad":"video");var h={};!d.K("web_player_csi_ctt_killswitch")&&d.J&&(h.cttAuthInfo={token:d.J,videoId:d.videoId});h.startTime=c-b;ow(f,h);nw({targetVideoId:d.videoId,targetCpn:d.clientPlaybackNonce},
f);mw("pbs",c,f)}else c=a.j.qa.Ti(),c.J!==d.clientPlaybackNonce?(c.I=d.clientPlaybackNonce,c.B=b):g.Bu(new g.Ar("CSI timing logged before gllat",{cpn:d.clientPlaybackNonce}))}a.ra("gllat",{l:a.va.toFixed(),prev_ad:+e});delete a.J}};
dR=function(a,b){b=void 0===b?NaN:b;b=0<=b?b:g.GN(a.j);var c=a.j.qa.MB();if(!isNaN(a.Y)&&!isNaN(c.j)){var d=c.j-a.Y;0<d&&g.aR(a,b,"bwm",[d,(c.C-a.kb).toFixed(3)])}isNaN(a.Y)&&c.j&&a.isOffline&&zKa(a,!1);a.Y=c.j;a.kb=c.C;isNaN(c.bandwidthEstimate)||g.aR(a,b,"bwe",[c.bandwidthEstimate.toFixed(0)]);dC(a.j.U)&&0!==Object.keys(c.u).length&&a.ra("bwinfo",c.u);if(dC(a.j.U)||a.j.U.K("html5_log_meminfo"))d=WIa(),Object.values(d).some(function(e){return void 0!==e})&&a.ra("meminfo",d);
a.W&&g.aR(a,b,"bat",[a.W.level,a.W.charging?"1":"0"]);d=a.j.qa.getVisibilityState();a.Zb!==d&&(g.aR(a,b,"vis",[d]),a.Zb=d);cR(a,b);(d=AKa(a.j))&&d!==a.bb&&(g.aR(a,b,"conn",[d]),a.bb=d);BKa(a,b,c)};
BKa=function(a,b,c){if(!isNaN(c.Xq)){var d=c.Xq;c.B<d&&(d=c.B);g.aR(a,b,"bh",[d.toFixed(3)])}};
CKa=function(a,b,c){g.cC(a.j.U,g.WD(a.j.videoData)).then(function(d){var e=!1;if(b.includes("&dt=")||b.includes("&cotn=")){if(a.j.U.K("kevlar_woffle")||a.j.U.K("qoe_nwl_downloads"))e=!0}else a.j.U.K("qoe_with_networkless")&&(e=!0);var f=a.j.U.K("qoe_send_and_write"),h=a.j.U,l=a.j.K("web_player_vss_pageid_header")?a.j.U.pageId:void 0;d=ZQ(b,h,l,a.j.U.sendVisitorIdHeader?a.j.videoData.visitorData:void 0,d);h.K("html5_simplify_pings")&&(d=d||{});d?(d.method="POST",d.postBody=c,$Q(b,d,{token:a.j.videoData.J,
SJ:a.j.videoData.qj,mdxEnvironment:a.j.videoData.mdxEnvironment},h,void 0,e,f&&a.ma)):e?(e=a.j.U.K("networkless_ajax"),h={method:"POST",postBody:c},f&&a.ma?a.j.U.K("use_new_nwl_saw")?Ps().sendAndWrite(b,h):Xs(b,h):e?g.pq(b,{method:"POST",postBody:c}):a.j.U.K("use_new_nwl_stw")?Ps().sendThenWrite(b,h):Ws(b,h)):(f=c,f=void 0===f?"":f,ipa(b,f)||g.Gs(b,void 0,void 0,void 0,f))})};
eR=function(a){for(var b=0,c=g.r(Object.keys(a.u)),d=c.next();!d.done;d=c.next())d=d.value,b+=d.length+Number(mk(a.u[d],function(e,f){return e+f.length},0));
96E3<b&&(new g.K(a.reportStats,0,a)).start()};
DKa=function(a){a.j.videoData.Je&&fR(a,"prefetch");a.j.videoData.Zb&&a.ra("reload",{r:a.j.videoData.reloadReason,ct:a.j.videoData.Zb});a.j.videoData.Ib&&fR(a,"monitor");a.j.videoData.isLivePlayback&&fR(a,"live");a.j.videoData.kh&&a.ra("ctrl",{mode:a.j.videoData.kh},!0);if(a.j.videoData.Jh){var b=a.j.videoData.Jh.replace(/,/g,"_");a.ra("ytp",{type:b},!0)}a.j.videoData.oO&&(b=a.j.videoData.oO.replace(/,/g,"."),a.ra("ytrexp",{ids:b},!0));if(!a.j.U.K("html5_disable_gpu_reporting")){var c=a.j.videoData;
b=a.j.U.K("enable_white_noise")||a.j.U.K("enable_webgl_noop")||a.j.U.K("enable_gpu_logging");c=g.OD(c)||g.MD(c)||g.ND(c)||g.PD(c);(b||c)&&(b=(0,g.gR)())&&(a.u.gpu=[b])}XD(a.j.videoData)&&g.aR(a,g.GN(a.j),"dt",["1"]);dC(a.j.U)&&(b=(0,g.R)()-a.j.U.Le,a.ra("playerage",{secs:Math.pow(1.6,Math.round(Math.log(b/1E3)/Math.log(1.6))).toFixed()}));a.D=!0;a.Ta=g.lq(function(){a.reportStats()},1E4)};
FKa=function(a,b,c){var d=g.GN(a.j);EKa(a,d,b,0,c);dR(a,d);eR(a)};
EKa=function(a,b,c,d,e){var f=a.j.qa.getCurrentTime();c=[c,1===d?"fatal":"",f.toFixed(3)];e&&c.push(GKa(e));g.aR(a,b,"error",c);a.D=!0};
hR=function(a){0<=a.B||(a.j.U.ye||3!==a.j.qa.getVisibilityState()?a.B=g.GN(a.j):a.Ga=!0)};
fR=function(a,b){var c=a.u.cat||[];c.push(b);a.u.cat=c};
zKa=function(a,b){a.isOffline=b;g.aR(a,g.GN(a.j),"is_offline",[a.isOffline?"1":"0"])};
HKa=function(a,b,c,d,e){var f=g.GN(a.j);1===b&&g.aR(a,f,"vps",[a.Rd]);var h=a.u.xvt||[];h.push("t."+f.toFixed(3)+";m."+e.toFixed(3)+";g.2;tt."+b+";np.0;c."+c+";d."+d);a.u.xvt=h};
GKa=function(a){/[^a-zA-Z0-9;.!_-]/.test(a)&&(a=a.replace(/[+]/g,"-").replace(/[^a-zA-Z0-9;.!_-]/g,"_"));return a};
IKa=function(a){this.j=a;this.N=!1;this.u=0;this.D=-1;this.lastUpdateTime=NaN;this.B=0;this.segments=[];this.J=this.I=0;this.W=this.j.Vi().volume;this.V=this.j.Vi().muted;this.C=iR(this.j)};
jR=function(a){a.C.startTime=a.B;a.C.endTime=a.u;a.segments.length&&g.Rb(a.segments).isEmpty()?a.segments[a.segments.length-1]=a.C:a.segments.length&&a.C.isEmpty()||a.segments.push(a.C);a.I+=a.u-a.B;a.C=iR(a.j);a.B=a.u};
JKa=function(a){a.segments.length&&a.u===a.B||jR(a);var b=a.segments;a.segments=[];return b};
LKa=function(a){KKa(a);a.J=g.lq(function(){a.update()},100);
a.lastUpdateTime=g.GN(a.j);a.C=iR(a.j)};
KKa=function(a){window.clearInterval(a.J);a.J=NaN};
MKa=function(a,b,c){c-=a.lastUpdateTime;return b===a.u&&.5<c};
kR=function(a,b,c,d){this.U=b;this.segments=[];this.experimentIds=[];this.Sa=this.Zb=this.isFinal=this.Ke=this.Kb=this.autoplay=this.autonav=!1;this.Hc="yt";this.I=this.J=null;this.sendVisitorIdHeader=this.Ta=!1;this.pageId="";this.B="watchtime"===c;this.C="playback"===c;this.Y="delayplay"===c;this.W="atr"===c;this.Le="engage"===c;this.sendVisitorIdHeader=!1;this.uri=this.W?"/api/stats/"+c:"//"+b.rk+"/api/stats/"+c;this.vj=!b.K("embeds_disable_event_label_embedded_unbranded_killswitch")&&this.C&&
b.pfpChazalUi&&a.D;d&&(this.Zb=d.fs,d.rtn&&(this.I=d.rtn),this.B?(this.playerState=d.state,0<d.rti&&(this.J=d.rti)):(this.Me=d.mos,this.Ff=d.volume,d.at&&(this.adType=d.at)),d.autonav&&(this.autonav=d.autonav),null!=d.inview&&(this.Nc=d.inview),d.size&&(this.Jc=d.size));this.deviceParams=g.We(b.deviceParams);this.Je=b.Ke;b.K("embeds_js_api_set_1p_cookie")&&b.embedsTokenValue&&(this.embedsTokenValue=b.embedsTokenValue);this.experimentIds=b.experiments.experimentIds;this.Pa=b.zg;this.Hc=b.Ga;this.region=
b.region;this.userAge=b.userAge;this.qb=b.Ag;this.qd=xt();this.sendVisitorIdHeader=b.sendVisitorIdHeader;this.oa=b.K("vss_pings_using_networkless")||b.K("kevlar_woffle");this.Ye=b.K("vss_final_ping_send_and_write");this.ma=b.K("vss_use_send_and_write");this.pageId=b.pageId;this.Ze=b.K("vss_playback_use_send_and_write");this.Zc=b.K("use_new_nwl_saw");this.md=b.K("use_new_nwl_stw");b.livingRoomAppMode&&(this.livingRoomAppMode=b.livingRoomAppMode);this.ze=b.j&&b.K("embeds_append_synth_ch_headers");g.YA(b)&&
!b.K("embeds_rct_killswitch")&&(this.embedsRct=b.embedsRct);g.YA(b)&&!b.K("embeds_enable_epm_killswitch")&&(this.Ia=b.va);this.accessToken=g.WD(a);a.fM&&(this.D=a.fM);this.adFormat=a.adFormat;this.adQueryId=a.adQueryId;this.autoplay=VD(a);this.autonav=a.Am||this.autonav;this.Ug=TD(a);this.clientPlaybackNonce=a.clientPlaybackNonce;this.Kb=a.D;a.J&&(this.N=a.J,this.Ib=a.qj);a.mdxEnvironment&&(this.mdxEnvironment=a.mdxEnvironment);this.j=a.Tw;this.Ga=a.Hc;a.B&&(this.videoFormat=a.B.Vb(),a.I&&a.I.Vb()!==
this.videoFormat&&(this.audioFormat=a.I.Vb()));a.j&&Rw(a.j)&&(this.offlineDownloadUserChoice="1");this.eventLabel=this.vj?"embedded_unbranded":SD(a);this.Sa=a.zg;this.Ad=a.ql;if(b=HD(a))this.bf=b;this.Kd=a.Ym;this.eventId=a.eventId;this.playlistId=a.kP||a.playlistId;this.kh=a.kh;this.Jh=a.Jh;this.ye=a.Vw;this.subscribed=a.subscribed;this.videoId=a.videoId;this.videoMetadata=a.videoMetadata;this.visitorData=a.visitorData;this.osid=a.osid;this.ge=a.I1;this.referrer=a.referrer;this.bb=a.YN||a.DN;this.eb=
a.Xw;this.kb=a.J1;this.userGenderAge=a.userGenderAge;this.Da=a.S0};
lR=function(a,b){var c=a.sendVisitorIdHeader?a.visitorData:void 0;return g.cC(a.U,a.accessToken).then(function(d){return ZQ(a.uri,a.U,a.pageId,c,d,b,a.ze)})};
NKa=function(a,b){return function(){a.U.K("html5_simplify_pings")?(a.j=a.va,a.Yc=b(),a.qd=0,a.send()):lR(a).then(function(c){var d=a.uri,e=mR(a),f=a.oa,h=a.ma,l=a.Zc,m=a.md;l=void 0===l?!1:l;m=void 0===m?!1:m;e.cmt=e.len;e.lact="0";var n=b().toFixed(3);e.rt=Number(n).toString();d=g.Mh(d,e);f?(null==c&&(c={}),h?l?Ps().sendAndWrite(d,c):Xs(d,c):m?Ps().sendThenWrite(d,c):Ws(d,c)):c?g.pq(d,c):g.Gs(d)})}};
mR=function(a){var b={ns:a.Hc,el:a.eventLabel,cpn:a.clientPlaybackNonce,ver:2,cmt:a.u(a.j),fmt:a.videoFormat,fs:a.Zb?"1":"0",rt:a.u(a.Yc),adformat:a.adFormat,content_v:a.Ug,etv:a.embedsTokenValue,euri:a.Je,lact:a.qd,live:a.bf,cl:(452150644).toString(),mos:a.Me,state:a.playerState,volume:a.Ff};a.subscribed&&(b.subscribed="1");Object.assign(b,a.deviceParams);a.autoplay&&(b.autoplay="1");a.Kb&&(b.dni="1");!a.B&&a.Ia&&(b.epm=OKa[a.Ia]);a.isFinal&&(b["final"]="1");a.Sa&&(b.splay="1");a.Ga&&(b.delay=a.Ga);
a.Pa&&(b.hl=a.Pa);a.region&&(b.cr=a.region);a.userGenderAge&&(b.uga=a.userGenderAge);void 0!==a.userAge&&a.qb&&(b.uga=a.qb+a.userAge);void 0!==a.va&&(b.len=a.u(a.va));!a.B&&0<a.experimentIds.length&&(b.fexp=a.experimentIds.toString());null!==a.I&&(b.rtn=a.u(a.I));a.bb&&(b.feature=a.bb);a.kh&&(b.ctrl=a.kh);a.Jh&&(b.ytr=a.Jh);a.audioFormat&&(b.afmt=a.audioFormat);a.offlineDownloadUserChoice&&(b.ODUC=a.offlineDownloadUserChoice);a.qc&&(b.lio=a.u(a.qc));a.B?(b.idpj=a.Ad,b.ldpj=a.Kd,null!=a.J&&(b.rti=
a.u(a.J)),a.Da&&(b.ald=a.Da)):void 0!==a.adType&&(b.at=a.adType);a.Jc&&(a.C||a.Y||a.B)&&(b.size=a.Jc);null!=a.Nc&&(a.C||a.Y||a.B)&&(b.inview=a.u(a.Nc));a.B&&(b.volume=nR(a,g.kk(a.segments,function(d){return d.volume})),b.st=nR(a,g.kk(a.segments,function(d){return d.startTime})),b.et=nR(a,g.kk(a.segments,function(d){return d.endTime})),pl(a.segments,function(d){return 1!==d.playbackRate})&&(b.rate=nR(a,g.kk(a.segments,function(d){return d.playbackRate}))),pl(a.segments,function(d){return"-"!==d.j})&&
(b.als=g.kk(a.segments,function(d){return d.j}).join(",")));
b.muted=nR(a,g.kk(a.segments,function(d){return d.muted?1:0}));
pl(a.segments,function(d){return 0!==d.visibilityState})&&(b.vis=nR(a,g.kk(a.segments,function(d){return d.visibilityState})));
pl(a.segments,function(d){return 0!==d.connectionType})&&(b.conn=nR(a,g.kk(a.segments,function(d){return d.connectionType})));
pl(a.segments,function(d){return 0!==d.u})&&(b.blo=nR(a,g.kk(a.segments,function(d){return d.u})));
pl(a.segments,function(d){return"-"!==d.C})&&(b.cc=g.kk(a.segments,function(d){return d.C}).join(","));
pl(a.segments,function(d){return"-"!==d.clipId})&&(b.clipid=g.kk(a.segments,function(d){return d.clipId}).join(","));
if(pl(a.segments,function(d){return!!d.B})){var c="au";
a.C&&(c="au_d");b[c]=g.kk(a.segments,function(d){return d.B}).join(",")}fq()&&a.N&&(b.ctt=a.N,b.cttype=a.Ib,b.mdx_environment=a.mdxEnvironment);
a.Le&&(b.etype=void 0!==a.V?a.V:0);a.eb&&(b.uoo=a.eb);a.livingRoomAppMode&&"LIVING_ROOM_APP_MODE_UNSPECIFIED"!==a.livingRoomAppMode&&(b.clram=PKa[a.livingRoomAppMode]||a.livingRoomAppMode);a.D&&a.U.K("html5_log_server_url_param")?QKa(a,b):(b.docid=a.videoId,b.referrer=a.referrer,b.ei=a.eventId,b.of=a.ge,b.osid=a.osid,b.vm=a.videoMetadata,a.adQueryId&&(b.aqi=a.adQueryId),a.autonav&&(b.autonav="1"),a.playlistId&&(b.list=a.playlistId),a.ye&&(b.ssrt="1"),a.kb&&(b.upt=a.kb));(a.C||a.Y)&&a.embedsRct&&(b.rct=
a.embedsRct);return b};
QKa=function(a,b){if(b&&a.D)for(var c=new Set(["q","feature","mos"]),d=new Set("autoplay cl len fexp delay el ns adformat".split(" ")),e=new Set(["aqi","autonav","list","ssrt","upt"]),f=g.r(Object.keys(a.D)),h=f.next();!h.done;h=f.next())h=h.value,d.has(h)||c.has(h)||e.has(h)&&!a.D[h]||(b[h]=a.D[h])};
nR=function(a,b){return g.kk(b,a.u).join(",")};
RKa=function(a,b){a.attestationResponse&&lR(a).then(function(c){c=c||{};c.method="POST";c.postParams={atr:a.attestationResponse};a.oa?a.ma?a.Zc?Ps().sendAndWrite(b,c):Xs(b,c):a.md?Ps().sendThenWrite(b,c):Ws(b,c):g.pq(b,c)})};
oR=function(a){g.I.call(this);this.j=a;this.currentPlayerState="paused";this.B=NaN;this.I=[10,10,10,40];this.N=this.J=0;this.oa=this.Y=this.va=this.ma=this.W=this.V=this.C=!1;this.D=NaN;this.u=new IKa(a)};
TKa=function(a){if(!a.C){a.j.U.K("disable_embedpage_playback_logging")||16623!==a.j.videoData.zz||g.Bu(Error("Playback for EmbedPage"));var b=pR(a,"playback");a:{if(a.j.U.K("web_player_use_server_vss_schedule")){var c,d=null==(c=a.j.videoData.getPlayerResponse())?void 0:c.playbackTracking,e=null==d?void 0:d.videostatsScheduledFlushWalltimeSeconds;d=null==d?void 0:d.videostatsDefaultFlushIntervalSeconds;if(e&&0<e.length&&d){c=[];var f=a.j.videoData.ql,h=a.j.videoData.Ym,l=-f;e=g.r(e);for(var m=e.next();!m.done;m=
e.next())m=m.value,c.push(m-l),l=m;c.push(d+h-f);c.push(d);a.I=c;break a}}a.I=[10+a.j.videoData.ql,10,10,40+a.j.videoData.Ym-a.j.videoData.ql,40]}LKa(a.u);b.I=qR(a,!0);0<a.D&&(b.j-=a.D);b.send();a.j.videoData.Ts&&(b=a.j.U,d=a.j.videoData,c={html5:"1",video_id:d.videoId,cpn:d.clientPlaybackNonce,ei:d.eventId,ptk:d.Ts,oid:d.WL,ptchn:d.VL,pltype:d.XL,content_v:TD(d)},d.Gr&&Object.assign(c,{m:d.Gr}),b=g.Mh(b.Y+"ptracking",c),rR(a,b));a.j.videoData.Hc||SKa(a);a.C=!0;a=a.u;a.u=a.j.qa.getCurrentTime();a.j.U.K("html5_vss_media_time_killswitch")||
(a.u=a.j.qa.Ui());a.lastUpdateTime=g.GN(a.j);!(0===a.B&&5>a.u)&&2<a.u-a.B&&(a.B=a.u);a.N=!0}};
qR=function(a,b,c){c=void 0===c?NaN:c;var d=g.GN(a.j);c=isNaN(c)?d:c;c=Math.ceil(c);var e=a.I[a.J];a.J+1<a.I.length&&a.J++;var f=c+e;a.B=g.kq(function(){if(!a.isDisposed()){a.B=NaN;a.u.update();var h=JKa(a.u),l=UKa(a,h);b&&(l.J=f);var m=1E3<a.N;!(1<h.length)&&h[0].isEmpty()||m||(l.I=qR(a,!0,f));l.send();a.N++}},1E3*(f-d));
return f};
pR=function(a,b){var c=a.j;c=Object.assign(c.Vi(),c.videoData.Vi());Object.assign(c,{state:a.currentPlayerState});b=new kR(a.j.videoData,a.j.U,b,c);b.j=a.j.qa.getCurrentTime();a.j.U.K("html5_vss_media_time_killswitch")||(b.j=a.j.qa.Ui());a.j.videoData.isLivePlayback||(b.va=a.j.qa.getDuration());a.j.videoData.j&&(c=a.j.videoData.j.getIngestionTime(b.j))&&(b.qc=c-b.j);b.Yc=g.GN(a.j);b.segments=[iR(a.j)];return b};
UKa=function(a,b){var c=pR(a,"watchtime");if(0<a.D){for(var d=g.r(b),e=d.next();!e.done;e=d.next())e=e.value,e.startTime-=a.D,e.endTime-=a.D;c.j-=a.D}else c.j=a.u.u;c.segments=b;return c};
sR=function(a){a.u.update();return UKa(a,JKa(a.u))};
SKa=function(a){a.j.videoData.remarketingUrl&&!a.ma&&(rR(a,a.j.videoData.remarketingUrl),a.ma=!0);a.j.videoData.youtubeRemarketingUrl&&!a.va&&(rR(a,a.j.videoData.youtubeRemarketingUrl),a.va=!0);a.j.videoData.googleRemarketingUrl&&!a.Y&&(rR(a,a.j.videoData.googleRemarketingUrl),a.Y=!0);a.j.videoData.ppvRemarketingUrl&&!a.oa&&(rR(a,a.j.videoData.ppvRemarketingUrl),a.oa=!0);a.hw()};
tR=function(a){if(!a.isDisposed()&&a.C){a.currentPlayerState="paused";var b=sR(a);b.isFinal=!0;b.send();a.dispose()}};
VKa=function(a,b,c){if(!a.V){c||(c=pR(a,"atr"));c.attestationResponse=b;try{c.send()}catch(d){if("Unknown Error"!==d.message)throw d;}a.V=!0}};
rR=function(a,b){var c=a.j.U;g.cC(a.j.U,g.WD(a.j.videoData)).then(function(d){var e=a.j.K("web_player_vss_pageid_header")?a.j.U.pageId:void 0,f=a.j.U.sendVisitorIdHeader?a.j.videoData.visitorData:void 0,h=a.j.U.K("vss_pings_using_networkless")||a.j.U.K("kevlar_woffle"),l=a.j.U.K("allow_skip_networkless");d=ZQ(b,c,e,f,d);$Q(b,d,{token:a.j.videoData.J,SJ:a.j.videoData.qj,mdxEnvironment:a.j.videoData.mdxEnvironment},c,void 0,h&&!l,!1,!0)})};
WKa=function(){this.endTime=this.startTime=-1;this.C="-";this.playbackRate=1;this.visibilityState=0;this.B="";this.volume=this.connectionType=this.u=0;this.muted=!1;this.j=this.clipId="-"};
uR=function(a,b,c,d){this.videoData=a;this.U=b;this.qa=c;this.Vi=d;this.j=void 0};
g.GN=function(a){return XKa(a)()};
XKa=function(a){if(!a.j){var b=g.Ta(function(d){var e=(0,g.R)();d&&631152E6>=e&&(g.S(Error("invalid coreTime.now value: "+e)),e=(new Date).getTime()+2);return e},a.U.K("html5_validate_yt_now")),c=b();
a.j=function(){return Math.round(b()-c)/1E3};
a.qa.zI()}return a.j};
AKa=function(a){if(navigator.connection&&navigator.connection.type)return YKa[navigator.connection.type]||YKa.other;if(g.oB(a.U)){a=navigator.userAgent;if(/[Ww]ireless[)]/.test(a))return 3;if(/[Ww]ired[)]/.test(a))return 1}return 0};
iR=function(a){var b=new WKa;b.C=a.Vi().cc||"-";b.playbackRate=a.qa.getPlaybackRate();var c=a.qa.getVisibilityState();0!==c&&(b.visibilityState=c);a.U.Yc&&(b.u=1);c=a.qa.getAudioTrack();c.Fc&&c.Fc.id&&"und"!==c.Fc.id&&(b.B=c.Fc.id);b.connectionType=AKa(a);b.volume=a.Vi().volume;b.muted=a.Vi().muted;b.clipId=a.Vi().clipid||"-";b.j=a.videoData.dM||"-";return b};
g.vR=function(a){g.I.call(this);var b=this;this.u=a;this.qoe=this.j=null;this.Zg=void 0;this.B=new Map;this.u.videoData.isValid()&&!this.u.videoData.Gj&&(this.j=new oR(this.u),g.J(this,this.j),this.qoe=new g.bR(this.u),g.J(this,this.qoe),this.u.videoData.enableServerStitchedDai&&(this.Zg=this.u.videoData.clientPlaybackNonce)&&this.B.set(this.Zg,this.j));this.C=new WQ(this.u,function(c){b.ra("h5h",c)});
g.J(this,this.C)};
ZKa=function(a){if(a.u.videoData.enableServerStitchedDai&&a.Zg){var b;null!=(b=a.B.get(a.Zg))&&jR(b.u)}else a.j&&jR(a.j.u)};
$Ka=function(a){a.C.send();if(a.qoe){var b=a.qoe;if(b.D){"PL"===b.Rd&&(b.Rd="N");var c=g.GN(b.j);g.aR(b,c,"vps",[b.Rd]);b.I||(0<=b.B&&(b.u.user_intent=[b.B.toString()]),b.I=!0);dC(b.j.U)&&b.ra("finalized",{});b.ma=!0;b.reportStats(c)}}if(a.u.videoData.enableServerStitchedDai)for(b=g.r(a.B.values()),c=b.next();!c.done;c=b.next())tR(c.value);else a.j&&tR(a.j);a.dispose()};
aLa=function(a,b){a.j&&VKa(a.j,b)};
bLa=function(a){if(!a.j)return null;var b=pR(a.j,"atr");return function(c){a.j&&VKa(a.j,c,b)}};
cLa=function(a,b,c,d){c.adFormat=c.qd;var e=b.qa;b=new oR(new uR(c,b.U,{getDuration:function(){return c.lengthSeconds},
getCurrentTime:function(){return e.getCurrentTime()},
Ui:function(){return e.Ui()},
MB:function(){return e.MB()},
getPlayerSize:function(){return e.getPlayerSize()},
getAudioTrack:function(){return c.getAudioTrack()},
getPlaybackRate:function(){return e.getPlaybackRate()},
ey:function(){return e.ey()},
getVisibilityState:function(){return e.getVisibilityState()},
Ti:function(){return e.Ti()},
zI:function(){e.zI()},
Uy:function(){e.Uy()}},b.Vi));
b.D=d;g.J(a,b);return b};
dLa=function(){this.Xq=0;this.D=this.C=this.j=this.B=NaN;this.u={};this.bandwidthEstimate=NaN};
eLa=function(){this.u=g.Bv;this.j=[]};
gLa=function(a,b,c){var d=[];for(b=fLa(a,b);b<a.j.length;++b){var e=a.j[b];(e.end<=c||e.contains(c))&&d.push(e);if(e.start>c)break}return d};
hLa=function(a,b){var c=[];a=g.r(a.j);for(var d=a.next();!d.done&&!(d=d.value,d.contains(b)&&c.push(d),d.start>b);d=a.next());return c};
iLa=function(a){return a.j.slice(fLa(a,0x7ffffffffffff),a.j.length)};
fLa=function(a,b){a=lc(a.j,function(c){return b-c.start||1});
return 0>a?-(a+1):a};
jLa=function(a,b){var c=NaN;a=g.r(a.j);for(var d=a.next();!d.done;d=a.next())if(d=d.value,d.contains(b)&&(isNaN(c)||d.end<c)&&(c=d.end),d.start>b&&(isNaN(c)||d.start<c)){c=d.start;break}return c};
kLa=function(a,b){a.j=a.j.filter(function(c){return!b.has(c)})};
wR=function(a,b,c,d){g.I.call(this);this.N=a;this.Y=b;this.D=c;this.V=d;this.u=NaN;this.I=this.J=this.started=!1;this.B=[];this.W=new g.K(this.Kl,250,this);g.J(this,this.W);this.C=new g.K(this.Kl,0,this);g.J(this,this.C);this.j=new eLa};
lLa=function(a,b){b=g.r(b);for(var c=b.next();!c.done;c=b.next()){c=c.value;var d=c[1];1===c[0]?a.V(g.Cv(d.namespace),d):a.V(g.Dv(d.namespace),d)}};
mLa=function(a){this.u=this.mediaTime=NaN;this.B=this.j=!1;this.C=.001;g.oB(a)&&(this.C=.01)};
xR=function(a,b){return b>a.mediaTime+a.C&&b<a.mediaTime+5};
yR=function(a,b,c,d){if(d=1<d)a.B=!0;if(a.j)b!==a.mediaTime&&(a.j=!1);else if(0<b&&a.mediaTime===b)return c-a.u>(d||!a.B?1500:400);a.mediaTime=b;a.u=c;return!1};
nLa=function(a,b){this.videoData=a;this.j=b};
oLa=function(a,b,c){return Nxa(b,c).then(function(){return vq(new nLa(b,b.C))},function(d){d instanceof Error&&Xp(d);
d=b.isLivePlayback&&!g.lA(a.u,!0)?"html5.unsupportedlive":"fmt.noneavailable";var e=b.isLivePlayback&&!g.lA(a.u,!0)?2:1,f={buildRej:"1",a:""+ +!!b.adaptiveFormats,d:""+ +!!b.qb,drm:""+ +yD(b),f18:""+ +(0<=b.Lj.indexOf("itag=18")),c18:""+ +mz('video/mp4; codecs="avc1.42001E, mp4a.40.2"')};b.j&&(yD(b)?(f.f142=""+ +!!b.j.j["142"],f.f149=""+ +!!b.j.j["149"],f.f279=""+ +!!b.j.j["279"]):(f.f133=""+ +!!b.j.j["133"],f.f140=""+ +!!b.j.j["140"],f.f242=""+ +!!b.j.j["242"]),f.cAVC=""+ +nz('video/mp4; codecs="avc1.42001E"'),
f.cAAC=""+ +nz('audio/mp4; codecs="mp4a.40.2"'),f.cVP9=""+ +nz('video/webm; codecs="vp9"'));if(b.V){f.drmsys=b.V.keySystem;var h=0;b.V.j&&(h=Object.keys(b.V.j).length);f.drmst=""+h}return new fC(d,f,e)})};
pLa=function(a){this.D=a;this.B=this.u=0;this.C=new tO(50)};
AR=function(a,b,c){g.iu.call(this);this.videoData=a;this.experiments=b;this.N=c;this.u=[];this.C=0;this.B=!0;this.D=!1;this.I=0;c=new qLa;"ULTRALOW"===a.latencyClass&&(c.C=!1);a.Ib?c.u=3:g.KD(a)&&(c.u=2);b.fb("html5_adaptive_seek_to_head_killswitch")||"NORMAL"!==a.latencyClass||(c.N=!0);var d=Fxa(a);c.D=2===d||-1===d;c.D&&(c.Y++,21530001===DD(a)&&(c.I=g.eA(b,"html5_jumbo_ull_nonstreaming_mffa_ms")||NaN));if(Aq("trident/")||Aq("edge/"))c.B=Math.max(c.B,g.eA(b,"html5_platform_minimum_readahead_seconds")||
3);g.eA(b,"html5_minimum_readahead_seconds")&&(c.B=g.eA(b,"html5_minimum_readahead_seconds"));g.eA(b,"html5_maximum_readahead_seconds")&&(c.V=g.eA(b,"html5_maximum_readahead_seconds"));b.fb("html5_force_adaptive_readahead")&&(c.C=!0);g.eA(b,"html5_allowable_liveness_drift_chunks")&&(c.j=g.eA(b,"html5_allowable_liveness_drift_chunks"));g.eA(b,"html5_readahead_ratelimit")&&(c.W=g.eA(b,"html5_readahead_ratelimit"));switch(DD(a)){case 21530001:c.j=(c.j+1)/5,"LOW"===a.latencyClass&&(c.j*=2),c.J=b.fb("html5_live_smoothly_extend_max_seekable_time")}this.policy=
c;this.J=1!==this.policy.u;b=isNaN(a.liveChunkReadahead)?3:a.liveChunkReadahead;a.Ib&&b--;a.isLowLatencyLiveStream&&"NORMAL"!==a.latencyClass||b++;switch(DD(a)){case 21530001:b=1;break;case 2153E4:b=2}this.policy.D&&b++;this.j=zR(this,b)};
rLa=function(a,b){var c=a.j;(void 0===b?0:b)&&a.policy.J&&3===Fxa(a.videoData)&&--c;return BR(a)*c};
CR=function(a,b){var c=a.Hk(),d=a.policy.j;a.D||(d=Math.max(d-1,0));a=d*BR(a);return b>=c-a};
sLa=function(a,b,c){b=CR(a,b);c||b?b&&(a.B=!0):a.B=!1;a.J=2===a.policy.u||3===a.policy.u&&a.B};
tLa=function(a,b){b=CR(a,b);a.D!==b&&a.X("livestatusshift",b);a.D=b};
BR=function(a){return a.videoData.j?Qz(a.videoData.j)||5:5};
zR=function(a,b){b=Math.max(Math.max(a.policy.Y,Math.ceil(a.policy.B/BR(a))),b);return Math.min(Math.min(8,Math.floor(a.policy.V/BR(a))),b)};
qLa=function(){this.Y=1;this.B=0;this.V=Infinity;this.W=0;this.C=!0;this.j=2;this.u=1;this.D=!1;this.I=NaN;this.J=this.N=!1};
FR=function(a){g.I.call(this);this.qa=a;this.U=this.qa.S();this.C=this.j=0;this.B=new g.K(this.D,1E3,this);this.va=new DR({delayMs:g.eA(this.U.experiments,"html5_seek_timeout_delay_ms")});this.V=new DR({delayMs:g.eA(this.U.experiments,"html5_long_rebuffer_threshold_ms")});this.Da=ER(this,"html5_seek_set_cmt");this.Y=ER(this,"html5_seek_jiggle_cmt");this.oa=ER(this,"html5_seek_new_elem");this.Sa=ER(this,"html5_unreported_seek_reseek");this.J=ER(this,"html5_long_rebuffer_jiggle_cmt");this.N=new DR({delayMs:2E4});
this.I=ER(this,"html5_ads_preroll_lock_timeout");this.Ga=new DR({delayMs:g.eA(this.U.experiments,"html5_skip_slow_ad_delay_ms")||5E3,uu:!this.U.K("html5_report_slow_ads_as_error")});this.Ia=new DR({delayMs:g.eA(this.U.experiments,"html5_skip_slow_ad_delay_ms")||5E3,uu:!this.U.K("html5_skip_slow_buffering_ad")});this.ma=ER(this,"html5_seek_over_discontinuities");this.Pa=new DR({delayMs:g.eA(this.U.experiments,"html5_slow_start_timeout_delay_ms")});this.W=ER(this,"html5_slow_start_no_media_source");
this.u={};g.J(this,this.B)};
ER=function(a,b){var c=g.eA(a.U.experiments,b+"_delay_ms");a=a.U.K(b+"_cfl");return new DR({delayMs:c,uu:a})};
uLa=function(a,b,c,d,e,f,h){var l=uz(c,Math.max(d-3.5,0)),m=0<=l&&d>c.end(l)-1.1&&l+1<c.length&&11>c.start(l+1)-c.end(l);m=f&&h&&m;var n=l+1<c.length?c.start(l+1):d;GR(a,a.ma,m&&!e,f&&!h,"qoe.longrebuffer",function(){b.seekTo(n+.2)},"seekover")};
GR=function(a,b,c,d,e,f,h){vLa(b,c)?(a.xd(e,b,h),b.uu||f()):(b.kD&&b.triggerTimestamp&&!b.B?(c=(0,g.R)(),d?b.j||(b.j=c):b.j=0,f=!d&&c-b.triggerTimestamp>b.kD,c=b.j&&c-b.j>b.aJ||f?b.B=!0:!1):c=!1,c&&(c=Object.assign({},a.Nb(b)),c.wn=h,c.we=e,c.wsuc=d,a.qa.ra("workaroundReport",c),d&&(b.reset(),a.u[e]=!1)))};
DR=function(a){var b=void 0===a?{}:a;a=void 0===b.delayMs?0:b.delayMs;var c=void 0===b.aJ?1E3:b.aJ,d=void 0===b.kD?3E4:b.kD;b=void 0===b.uu?!1:b.uu;this.j=this.triggerTimestamp=this.u=this.startTimestamp=0;this.B=!1;this.C=Math.ceil(a/1E3);this.aJ=c;this.kD=d;this.uu=b};
vLa=function(a,b){if(!a.C||a.triggerTimestamp)return!1;if(!b)return a.reset(),!1;b=(0,g.R)();if(!a.startTimestamp)a.startTimestamp=b,a.u=0;else if(a.u>=a.C)return a.triggerTimestamp=b,!0;a.u+=1;return!1};
IR=function(a){g.I.call(this);var b=this;this.qa=a;this.U=this.qa.S();this.videoData=this.qa.getVideoData();this.policy=new wLa(this.U);this.W=new FR(this.qa);this.playbackData=null;this.Ia=new g.kz;this.I=this.u=this.Fa=this.mediaElement=null;this.j=NaN;this.C=0;this.ma=NaN;this.B=null;this.va=NaN;this.D=this.J=null;this.V=this.N=!1;this.oa=new g.K(function(){xLa(b,!1)},2E3);
this.Ta=new g.K(function(){HR(b)});
this.Ga=new g.K(function(){b.N=!0;yLa(b)});
this.timestampOffset=0;this.Pa=!0;this.Da=0;this.Sa=NaN;this.Y=new g.K(function(){var c=b.U.ge;c.j+=1E4/36E5;c.j-c.B>1/6&&(Lva(c),c.B=c.j);b.Y.start()},1E4);
g.J(this,this.W);g.J(this,this.Ia);g.J(this,this.oa);g.J(this,this.Ga);g.J(this,this.Ta);g.J(this,this.Y)};
zLa=function(a,b){a.playbackData=b;a.videoData.isLivePlayback&&(a.I=new pLa(function(){a:{if(a.playbackData&&a.playbackData.j.j){if(tD(a.videoData)&&a.Fa){var c=a.Fa.WA.Dh()||0;break a}if(a.videoData.j){c=a.videoData.j.oa;break a}}c=0}return c}),a.u=new AR(a.videoData,a.U.experiments,function(){return a.Gd(!0)}));
a.videoData.startSeconds&&isFinite(a.videoData.startSeconds)&&1E9<a.videoData.startSeconds||(a.C=a.C||a.videoData.startSeconds||0)};
LR=function(a,b){(a.Fa=b)?JR(a,!0):KR(a)};
ALa=function(a,b){var c=a.getCurrentTime(),d=a.isAtLiveHead(c);if(a.I&&d){var e=a.I;if(e.j&&!(c>=e.u&&c<e.B)){var f=e.j.getSegmentNumberForTime(c);-1!==f&&(e.u=e.j.getStartTime(f),e.B=e.u+e.j.getDuration(f),f=Date.now()/1E3-e.j.getIngestionTime(f),f-=e.D(),e.C.add(f))}}a.u&&(d&&(d=a.u,e=a.mediaElement?wF(a.mediaElement):0,d.C++,3>d.C||g.Ua()-d.I<d.policy.W||(d.I=g.Ua(),d.u.push(e),50<d.u.length&&d.u.shift())),d=a.u,sLa(d,c,void 0===b?!0:b),tLa(d,c),b&&xLa(a,!0))};
xLa=function(a,b){if(a.u){var c=a.u;var d=a.getCurrentTime();!CR(c,d)&&c.Mn()?(c.policy.N&&(c.policy.j=Math.max(c.policy.j+1,10)),c=Infinity):c=d<c.videoData.getMinSeekableTime()?Math.min(c.videoData.getMinSeekableTime()+10,c.Hk()):NaN;if(!isNaN(c)){if(a.Fa&&b&&(b=a.oa.isActive(),d=a.u.Hk(),(d=lJa(a.Fa,d-a.ud()))&&!b)){a.oa.start();a.qa.ra("inBufferPtl",{cmt:a.getCurrentTime(),seekTo:d+a.ud()});a.seekTo(d+a.ud(),{Ee:"playbacktimeline_inBufferSeek"});return}a.seekTo(c,{Ee:"playbacktimeline_pegToLive"})}}};
JR=function(a,b){if(a.u&&a.Fa){var c=!1;if(b)c=!0;else if(a.videoData.isLowLatencyLiveStream||"LOW"===a.videoData.latencyClass||"ULTRALOW"===a.videoData.latencyClass)if(b=a.u,b.u.length){c=b.j;b:{if(b.u.length){if(1<Math.min.apply(null,b.u)){var d=zR(b,b.j-1);break b}if(b.policy.C){d=zR(b,b.j+1);break b}}d=b.j}b.j=d;if(c=c!==b.j)b.u=[],b.C=0}else c=!1;c&&(c=a.qa.logging,b=rLa(a.u),c.qoe&&(c=c.qoe,g.aR(c,g.GN(c.j),"lra",[b]),c.ra("live-readahead-seconds",{v:b})));b=a.Fa;c=a.u.j;d=a.u;d=(d.j-1+d.policy.j)*
BR(d);var e=b.u;a=a.u.policy.I;e.Hf=Math.max(c-1,0);e.Y=a;b.C&&(b.C.Y=d)}};
BLa=function(a,b){a.C=b};
MR=function(a){return a.videoData.isLivePlayback&&!!a.videoData.C&&!a.videoData.C.j};
yLa=function(a){CLa(a).then(void 0,function(){KR(a)});
NR(a).then(function(c){DLa(a,c)},function(){KR(a)});
YN(a.qa);if(2<=a.U.V){var b=a.Nb();b["native"]=""+ +a.V;b.tgt=""+a.j;a.qa.ra("startSeek",b)}};
CLa=function(a){a.J||(a.Fa?isFinite(a.j)?a.J=a.Fa.seek(a.j-a.timestampOffset):(a.J=mJa(a.Fa),a.j=a.Fa.getCurrentTime()+a.timestampOffset):a.J=Ug(a.j-a.timestampOffset));return a.J};
NR=function(a){var b=a.B;b||(a.B=new tF,b=a.B,HR(a));return b};
ELa=function(a,b,c){return isNaN(b)?NaN:g.Xf(b,a.getMinSeekableTime(),a.Gd(c))};
HR=function(a){if(a.B)if(!a.K("html5_nondash_live_seek_killswitch")&&MR(a)&&a.mediaElement&&0<a.mediaElement.Pi()&&0<vF(a.mediaElement)&&(a.j=ELa(a,a.j,!1)),!a.mediaElement||!FLa(a))a.Ta.start(750);else if(!isNaN(a.j)&&isFinite(a.j)&&a.va!==a.j-a.timestampOffset){var b=a.mediaElement.getCurrentTime()-a.j;if(Math.abs(b)<=a.Da)a.B&&a.B.resolve(a.mediaElement.getCurrentTime());else if(!a.videoData.isLiveHeadPlayable&&a.j>=a.Gd()-.1)a.j=a.Gd(),a.B.resolve(a.Gd()),HN(a.qa);else try{var c=a.j-a.timestampOffset;
a.mediaElement.seekTo(c);a.W.j=c;a.va=c;a.C=a.j}catch(d){}}};
FLa=function(a){if(!a.mediaElement||0===a.mediaElement.Pi()||0<a.mediaElement.wk())return!1;var b=0<a.mediaElement.getCurrentTime();if(!(a.K("html5_nondash_mediaelementready_killswitch")||a.videoData.C&&a.videoData.C.j||a.videoData.isLivePlayback)&&yD(a.videoData))return b;if(0<=a.j){var c=a.mediaElement.Zx();if(c.length||!b)return vz(c,a.j-a.timestampOffset)}return b};
DLa=function(a,b){a.D&&(a.D.resolve(b),a.qa.X("SEEK_COMPLETE"),2<=a.U.V&&(b=a.Nb(),b["native"]=""+ +a.V,a.qa.ra("seekEnd",b)));KR(a)};
KR=function(a){a.j=NaN;a.va=NaN;a.B=null;a.J=null;a.D=null;a.N=!1;a.V=!1;a.Da=0;a.oa.stop();a.Ga.stop()};
GLa=function(a){if(a.mediaElement){for(var b=g.r(["loadedmetadata","progress","seeked","seeking"]),c=b.next();!c.done;c=b.next())a.Ia.P(a.mediaElement,c.value,function(d){var e=a.mediaElement;switch(d.type){case "seeking":d=e.getCurrentTime()+a.timestampOffset;if(!a.B||a.V&&d!==a.j)a.B=new tF,a.va=d,e=e.getCurrentTime(),a.W.j=e,a.seekTo(d,{Ee:"playbacktimeline_mediaElementEvent"}),a.V=!0;break;case "seeked":a.B&&a.B.resolve(a.mediaElement.getCurrentTime());break;case "loadedmetadata":if(a.Pa){e="ss";
d=0;(LD(a.videoData)||a.videoData.liveUtcStartSeconds)&&(a.videoData.liveUtcStartSeconds||a.videoData.startSeconds&&isFinite(a.videoData.startSeconds)&&1E9<a.videoData.startSeconds)&&a.videoData.j?(d=a.videoData.liveUtcStartSeconds||a.videoData.md,e="utc",d=a.Gd()-a.getIngestionTime(a.Gd())+d):a.videoData.j&&a.videoData.j.isManifestless&&a.videoData.md?(e="mss",d=a.videoData.md+a.ud()):a.videoData.zq&&(e="stss",d=a.videoData.zq);var f={};d?(a.seekTo(d,{Ee:"playbacktimeline_startSeconds"}),f[e]=d,
a.qa.ra("startSeconds",f),a.Pa=!1):a.videoData.md&&(f[e]=a.videoData.md+a.ud(),a.qa.ra("startSeconds",f));e=!!d}else e=!1;a.K("html5_nondash_live_seek_killswitch")&&!e&&MR(a)&&(a.j=isFinite(a.j)?g.Xf(a.j,a.getMinSeekableTime(),a.Gd()):a.Gd());HR(a);break;case "progress":HR(a)}});
a.D||a.C||a.policy.u||!a.mediaElement.dJ()||a.seekTo(.01,{Ee:"playbacktimeline_setupMediaElement"})}};
wLa=function(a){this.j=a.K("html5_live_smoothly_extend_max_seekable_time");this.u=a.K("html5_requires_seek_for_playback_at_zero_killswitch")};
OR=function(){this.finished=this.started=!1};
PR=function(a){this.j=a;this.iv=KJa(Gu(16))};
HLa=function(a,b){var c;return g.B(function(d){c=Eva(a.j);return d.return(c.encrypt(b,a.iv))})};
ILa=function(a,b){var c;return g.B(function(d){var e=a.j;e.C||(e.C=new wva(e.B));c=e.C;return d.return(zva(c,b,a.iv))})};
JLa=function(a,b,c){var d;return g.B(function(e){d=Eva(a.j);return e.return(d.decrypt(b,c))})};
QR=function(a){g.I.call(this);this.u=a;this.logger=new g.qO("onesie");this.Ud=new Map;this.j=!1};
CP=function(a,b){return a.Ud.has(b)};
YIa=function(a,b){return(a=a.Ud.get(b))?a.fP:[]};
dIa=function(a,b,c){a.Ud.get(b).Od=c};
SR=function(a,b){CP(a,b)&&(a.Ud.get(b).Fe=new kx,RR(a,b))};
KLa=function(a){for(var b=g.r(a.Ud),c=b.next();!c.done;c=b.next()){var d=g.r(c.value);c=d.next().value;d=d.next().value;d.Od||SR(a,c)}};
ZIa=function(a,b){var c;return(null==(c=a.Ud.get(b))?void 0:c.Dk)||0};
cIa=function(a,b){var c=a.Ud.get(b),d=!c.Dk&&!!c.bytesReceived;b=a.Gg(b);return d&&a.j&&void 0!==b?b:(d||c.bytesReceived===c.Dk)&&c.MA+c.Fe.totalLength===c.bytesReceived};
LLa=function(a,b,c){c=void 0===c?!1:c;a.Ud.set(b,{Fe:new kx,MA:0,bytesReceived:0,SI:!1,Kf:!1,Gg:!1,Jn:c,fP:[]})};
TR=function(a){a=g.r(a.Ud.values());for(var b=a.next();!b.done;b=a.next())b=b.value,b.SI&&(b.Od&&b.Od(),b.SI=!1)};
RR=function(a,b){if((b=a.Ud.get(b))&&!b.Kf){b.Kf=!0;b.Od&&b.Od();a:{b=g.r(a.Ud.values());for(var c=b.next();!c.done;c=b.next())if(!c.value.Kf){b=!1;break a}b=!0}if(b&&(a=a.u,a.playerResponse)){var d;null==(d=a.xhr)||d.abort()}}};
MLa=function(a,b){for(var c=!1,d=g.r(a.Ud.keys()),e=d.next();!e.done;e=d.next()){e=a.Ud.get(e.value);var f=void 0,h=void 0;(null==(f=e)?0:f.Dk)&&0<(null==(h=e)?void 0:h.Dk)&&(e.Jn?c=!0:b=!0)}return b&&c};
OLa=function(a,b){zC(a,13,b.timeSinceLastManualFormatSelectionMs);var c=b.lastManualDirection;void 0!==c&&(yC(a,112),yC(a,c<<1^c>>31));zC(a,16,b.iX);zC(a,18,b.zV);zC(a,19,b.yV);zC(a,21,b.H0);zC(a,23,b.nV);zC(a,34,b.visibility);DC(a,38,b.mediaCapabilities,NLa,3);zC(a,39,b.V0);zC(a,40,b.sN)};
PLa=function(a){for(var b=[];sC(a,2);)b.push(rC(a));return{CF:b.length?b:void 0,oK:tC(a,4)}};
NLa=function(a,b){var c;if(b.nK)for(c=0;c<b.nK.length;c++)DC(a,1,b.nK[c],QLa,1);if(b.BF)for(c=0;c<b.BF.length;c++)DC(a,2,b.BF[c],RLa,1)};
RLa=function(a,b){zC(a,1,b.mV);zC(a,2,b.numChannels);zC(a,3,b.qX)};
QLa=function(a,b){zC(a,1,b.C1);zC(a,3,b.rX);zC(a,4,b.sX);zC(a,11,b.maxFramerate);zC(a,12,b.qX)};
ULa=function(a){return{Q_:tC(a,1),itag:vC(a,3),xQ:rwa(a,4,SLa),lmt:tC(a,5),bka:tC(a,7),xtags:vC(a,15),xX:rwa(a,23,TLa)}};
SLa=function(a){return{iv:uC(a,5),bX:qwa(a,7)}};
TLa=function(a){return{videoId:vC(a,2)}};
WLa=function(a,b){DC(a,2,b.ZM,OLa,3);DC(a,3,b.qH,VLa,3);BC(a,4,b.onesieUstreamerConfig);BC(a,9,b.aA)};
VLa=function(a,b){BC(a,2,b.encryptedOnesieInnertubeRequest);BC(a,5,b.encryptedClientKey);BC(a,6,b.iv);BC(a,7,b.hmac);AC(a,10,b.serializeResponseAsJson);AC(a,13,b.enableAdPlacementsPreroll);AC(a,14,b.enableCompressionResponseOnly);BC(a,16,b.unencryptedOnesieInnertubeRequest)};
XLa=function(a,b){CC(a,1,b.name);CC(a,2,b.value)};
YLa=function(a,b){CC(a,1,b.url);var c;if(b.httpHeaders)for(c=0;c<b.httpHeaders.length;c++)DC(a,2,b.httpHeaders[c],XLa,3);BC(a,3,b.postBody);AC(a,4,b.proxiedByTrustedBandaid);AC(a,6,b.skipResponseEncryption)};
ZLa=function(a){return{onesieProxyStatus:tC(a,1),httpStatus:tC(a,2),body:uC(a,4)}};
UR=function(a){this.Jj=a;this.u=!1;this.j=[]};
WR=function(a){for(;a.j.length&&!a.j[0].isEncrypted;){var b=a.j.shift(),c=b.JJ;if(b=b.buffer)$La(a.Jj.Bd,c,b);else if(b=a.Jj,b.j[c].lO=!0,b=VR(b.Bd,c),null==b?0:CP(b,c))null==b||RR(b,c)}};
aMa=function(a,b){a.j.push({JJ:b,isEncrypted:!1});a.u||WR(a)};
g.bMa=function(a){this.data=a;this.j=0;this.D=!1;this.B=0;this.error=!1;this.register=this.u=0;if(0===YR.length){YR.length=288;YR.fill(8);for(a=144;280>a;a++)YR[a]=255>=a?9:7;ZR.length=32;ZR.fill(5);$R.length=286;$R.fill(0);for(a=261;285>a;a++)$R[a]=Math.floor((a-261)/4);aS[257]=3;for(a=258;285>a;a++){var b=aS[a-1];b+=1<<$R[a-1];aS[a]=b}aS[285]=258;for(a=0;30>a;a++)bS[a]=3>=a?0:Math.floor((a-2)/2);for(a=cS[0]=1;30>a;a++)b=cS[a-1],b+=1<<bS[a-1],cS[a]=b}a=100+7*this.data.length;31===this.data[0]&&139===
this.data[1]&&(a=(new DataView(this.data.buffer,this.data.byteOffset+this.data.length-4)).getUint32(0,!0),this.data=this.data.subarray(10,this.data.length-8));this.C=new Uint8Array(a)};
g.fMa=function(a){for(;!a.D&&!a.error;){var b=a;b.D=!!dS(b,1);switch(dS(b,2)){case 2:var c=[],d=[];d.length=19;d.fill(0);var e=dS(b,5)+257;var f=dS(b,5)+1;for(var h=dS(b,4)+4,l=0;l<h;l++)d[cMa[l]]=dS(b,3);d=eS(d);for(h=e+f;c.length<h;){l=dMa(b,d);switch(l){case 16:l=c[c.length-1];var m=dS(b,2)+3;break;case 17:l=0;m=dS(b,3)+3;break;case 18:l=0;m=dS(b,7)+11;break;default:m=1}for(;0<m;m--)c.push(l)}c.length!==h?b.error=!0:(f=c.slice(-f),c.length=e,eMa(b,c,f));break;case 1:eMa(b,YR,ZR);break;case 0:fS(b,
b.j&7);c=dS(b,16);e=dS(b,16);65535!==(c^e)&&(b.error=!0);b.C.set(b.data.subarray(b.u,b.u+c),b.B);b.u+=c;b.B+=c;break;default:b.error=!0}a.B>a.C.length&&(a.C=new Uint8Array(2*a.B),a.B=0,a.u=0,a.D=!1,a.j=0,a.register=0)}a.C.length!==a.B&&(a.C=a.C.subarray(0,a.B));return a.error?new Uint8Array(0):a.C};
eMa=function(a,b,c){b=eS(b);c=eS(c);for(var d=a.data,e=a.C,f=a.B,h=a.register,l=a.j,m=a.u;;){if(15>l){if(m>d.length){a.error=!0;break}h|=(d[m+1]<<8)+d[m]<<l;m+=2;l+=16}var n=b[h&127];if(0>n)for(h>>=7;0>n;)n=b[(h&1)-n],h>>=1;else h>>=n&15;l-=n&15;n>>=4;if(256>n)e[f++]=n;else if(a.register=h,a.j=l,a.u=m,256<n){h=aS[n];h+=dS(a,$R[n]);m=dMa(a,c);l=cS[m];l+=dS(a,bS[m]);if(gMa&&h<l)l=f-l,e.copyWithin(f,l,l+h);else for(m=f+h,n=f;n<m;n+=4)e[n]=e[n-l],e[n+1]=e[n-l+1],e[n+2]=e[n-l+2],e[n+3]=e[n-l+3];f+=h;h=
a.register;l=a.j;m=a.u}else break}a.B=f};
dMa=function(a,b){if(7>a.j){var c=a.data,d=a.u;d>c.length&&(a.error=!0);a.register|=(c[d+1]<<8)+c[d]<<a.j;a.u+=2;a.j+=16}c=b[a.register&127];if(0<=c)return fS(a,c&15),c>>4;for(fS(a,7);0>c;)c=b[dS(a,1)-c];return c>>4};
dS=function(a,b){for(;a.j<b;){if(a.u>=a.data.length)return a.error=!0,0;a.register|=a.data[a.u++]<<a.j;a.j+=8}var c=a.register&(1<<b)-1;a.register>>=b;a.j-=b;return c};
fS=function(a,b){a.j-=b;a.register>>=b};
eS=function(a){for(var b=[],c=g.r(a),d=c.next();!d.done;d=c.next())d=d.value,b[d]||(b[d]=0),b[d]++;var e=b[0]=0;c=[];var f=0;d=0;for(var h=1;h<b.length;h++)b[h]?d=h:b[h]=0,e=e+b[h-1]<<1,c[h]=e,7<h&&(f+=b[h]);for(e=1;e<f;)e<<=1;b=128;d=new Int16Array(128+2*(e+d));for(f=0;f<a.length;f++)if(h=a[f]){for(var l=c[h]++,m=e=0;m<h;m++)e=e<<1|l>>m&1;l=f<<4|h;if(7>=h)for(m=1<<7-h;m--;)d[m<<h|e]=l;else{m=e&127;h-=7;for(e>>=7;h--;){d[m]||(d[m]=-b,b+=2);var n=e&1;e>>=1;m=n-d[m]}d[m]=l}}return d};
hMa=function(a){var b,c,d,e,f,h,l;return g.B(function(m){switch(m.j){case 1:if(!("DecompressionStream"in window))return m.return(g.fMa(new g.bMa(a)));b=new DecompressionStream("gzip");c=b.writable.getWriter();c.write(a);c.close();d=b.readable.getReader();e=new kx([]);case 2:return g.A(m,d.read(),4);case 4:f=m.u;h=f.value;if(l=f.done){m.Ra(3);break}e.append(h);m.Ra(2);break;case 3:return m.return(px(e))}})};
jMa=function(a,b){var c=[];b=g.r(b);for(var d=b.next();!d.done;d=b.next()){d=d.value;var e=iMa[d]||0;a.j&&e>a.j||c.push(d)}return c};
mMa=function(a,b){var c=a[a.length-1];a.push.apply(a,g.v(kMa[c]||[]));b.K("html5_early_media_for_drm")&&a.push.apply(a,g.v(lMa[c]||[]))};
rMa=function(a,b){var c=zD(a),d=a.S().u;if(gS&&!d.j)return gS;for(var e=[],f=[],h={},l=g.r(nMa),m=l.next();!m.done;m=l.next()){var n=!1;m=g.r(m.value);for(var p=m.next();!p.done;p=m.next()){p=p.value;var q=oMa(p);!q||!q.video||gz(q)&&!c.oa&&q.video.j>c.V||(n?e.push(p):(q=Sw(c,q,d),!0===q?(n=!0,e.push(p)):h[p]=q))}e&&mMa(e,a)}l=g.r(pMa);for(n=l.next();!n.done;n=l.next()){n=g.r(n.value);for(p=n.next();!p.done;p=n.next())if(m=p.value,(p=qMa(m))&&p.audio)if(p=Sw(c,p,d),!0===p){f.push(m);break}else h[m]=
p;f&&mMa(f,a)}c.B&&b("orfmts",h);gS={video:e,audio:f};d.j=!1;return gS};
oMa=function(a){var b=sMa[cz[a]],c=tMa[a];if(!c||!b)return null;var d=new $y(c.width,c.height,c.fps);b=uua(b,d);return new dz(a,b,{video:d,Ob:c.bitrate/8})};
qMa=function(a){var b=sMa[cz[a]],c=uMa[a];return c&&b?new dz(a,b,{audio:new Yy(c.audioSampleRate,c.numChannels)}):null};
vMa=function(a){this.Bd=a;this.logger=new g.qO("onesie");this.B={};this.j={};this.C=!0;this.u=null;this.queue=new UR(this)};
hS=function(a){var b=a.queue;b.j.length&&b.j[0].isEncrypted&&!b.u&&(b.j.length=0);b=g.r(Object.keys(a.j));for(var c=b.next();!c.done;c=b.next())c=c.value,a.j[c].lO||aMa(a.queue,c)};
wMa=function(a,b){var c=b.totalLength,d=!1;switch(a.u){case 0:a.yI(b,a.C).then(function(e){var f=a.Bd;f.Mc("oprr");f.playerResponse=e;f.QH||(f.Kv=!1);iS(f)},function(e){a.Bd.fail(e)});
break;case 2:a.Mc("ormk");b=px(b);a.queue.decrypt(b);break;default:d=!0}a.Bd.Yi&&a.Bd.ra("ombup","id.11;pt."+a.u+";len."+c+(d?";ignored.1":""));a.u=null};
xMa=function(a,b,c){var d=qx(b,0);a.Bd.Yi&&a.Bd.ra("ombup","id."+(c?12:21)+";len."+b.totalLength+";hid."+d);1!==b.totalLength&&(b=b.split(1).Rs,d=a.B[d]||null)&&(a.Co(a.j[d].Jn?"oafs_r":"ovfs_r"),a.queue.enqueue(d,b,c))};
AMa=function(a,b,c,d){var e={},f=Tz(0);f&&(e.iX=f,e.lastManualDirection=Nua(),f=cra()||0,0<f&&(e.timeSinceLastManualFormatSelectionMs=(0,g.R)()-f));e.H0=Tz();if(a.schedule.N||!a.K("html5_onesie_enable_server_side_badwidth_estimation"))e.nV=PA(a.schedule,!0);f=g.wB();e.zV=c.width*f;e.yV=c.height*f;e.visibility=d;e.V0=xt();a.K("html5_onesie_media_capabilities")&&(e.sN=3);a.K("html5_onesie_audio_only_playback")&&xD(b)&&(e.sN=1);if(a.K("html5_onesie_media_capabilities")){b=zD(b);a=a.u;c=[];d=[];f=g.r(nMa);
for(var h=f.next();!h.done;h=f.next()){h=g.r(h.value);for(var l=h.next();!l.done;l=h.next()){l=l.value;var m=oMa(l);if(m&&m.video&&!0===Sw(b,m,a)){c.push({C1:yMa[cz[l]],sX:m.video.width,rX:m.video.height,maxFramerate:m.video.fps});break}}}f=g.r(pMa);for(h=f.next();!h.done;h=f.next())for(h=g.r(h.value),l=h.next();!l.done;l=h.next())if(l=l.value,(m=qMa(l))&&m.audio&&!0===Sw(b,m,a)){d.push({mV:zMa[cz[l]],numChannels:m.audio.numChannels});break}e.mediaCapabilities={nK:c,BF:d}}return e};
CMa=function(a,b,c){var d,e,f;return g.B(function(h){if(1==h.j)return d=EC(b,YLa),g.A(h,HLa(c,d),2);if(3!=h.j)return e=h.u,g.A(h,ILa(c,e),3);f=h.u;return h.return({encryptedOnesieInnertubeRequest:e,encryptedClientKey:c.j.encryptedClientKey,iv:c.iv,hmac:f,serializeResponseAsJson:!0,enableAdPlacementsPreroll:a.K("html5_onesie_ads"),enableCompressionResponseOnly:BMa(a,!!b.skipResponseEncryption)})})};
DMa=function(a,b,c,d,e,f,h,l){var m,n;return g.B(function(p){if(1==p.j)return g.A(p,CMa(c,a,b),2);m=p.u;n=AMa(c,d,e,f);return p.return({qH:m,ZM:n,onesieUstreamerConfig:h,aA:l})})};
BMa=function(a,b){var c=PA(a.schedule,!0);a=b&&a.K("html5_onesie_disable_js_cleartext_compression")||!!xA()&&1572864<c;return"DecompressionStream"in window||!a};
EMa=function(a,b){if(b+1<=a.totalLength){var c=qx(a,b);c=128>c?1:192>c?2:224>c?3:240>c?4:5}else c=0;if(1>c||!(b+c<=a.totalLength))return[-1,b];if(1===c)a=qx(a,b++);else if(2===c)c=qx(a,b++),a=qx(a,b++),a=(c&63)+64*a;else if(3===c){c=qx(a,b++);var d=qx(a,b++);a=qx(a,b++);a=(c&31)+32*(d+256*a)}else if(4===c){c=qx(a,b++);d=qx(a,b++);var e=qx(a,b++);a=qx(a,b++);a=(c&15)+16*(d+256*(e+256*a))}else c=b+1,a.focus(c),ox(a,c,4)?a=Isa(a).getUint32(c-a.B,!0):(d=qx(a,c+2)+256*qx(a,c+3),a=qx(a,c)+256*(qx(a,c+1)+
256*d)),b+=5;return[a,b]};
jS=function(a){this.callbacks=a;this.j=new kx};
FMa=function(a,b){var c=g.Xz(b.U.experiments,"debug_bandaid_hostname");if(c)b=qN(b,c);else if(c=b.j.get(0)){var d=c;if(b.U.K("html5_onesie_host_racing_during_prewarming")){var e=b.j.values();e=g.r(e);for(var f=e.next();!f.done;f=e.next())f=f.value,vN(f)<vN(d)&&(d=f);e=g.eA(b.U.experiments,"html5_onesie_host_racing_cap_ms");0<e&&0!==d.qO&&vN(c)-vN(d)<=e&&(d=c);var h;b.D=null==(h=d)?void 0:h.jX}b=d.location.clone()}else b=void 0;if(b&&a.videoId){h=IA(a.videoId);a=[];if(h)for(h=g.r(h),c=h.next();!c.done;c=
h.next())a.push(c.value.toString(16).padStart(2,"0"));b.set("id",a.join(""));return b}};
GMa=function(a,b){return b.load().then(function(){return FMa(a,b)})};
kS=function(a,b){g.I.call(this);this.qa=a;this.playerRequest=b;this.U=this.qa.S();this.videoData=this.qa.getVideoData();this.logger=new g.qO("onesie");this.Yi=2<=this.U.V;this.bG=this.U.di;this.LC=new PR(this.bG.j);this.xhr=null;this.Lm=new tF;this.nO=!1;this.playerResponse="";this.RR=new jS(this);this.Jj=new vMa(this);this.zv=new g.K(this.iO,1E4,this);this.oQ=new g.K(this.uX,2E3,this);this.Ds="";this.bC=this.AO=!1;this.Gp=this.qa.JB();this.Av="";this.Kv=this.K("html5_onesie_wait_for_media_availability");
this.enableCompression=this.QH=this.aC=!1;g.J(this.videoData,this);g.J(this,this.zv);g.J(this,this.oQ);a=Hw();b=kA(this.U.u);this.K("html5_onesie_media_bytes")&&a&&b&&(this.K("html5_onesie_ads")?this.Bf=new Map:(this.Yd=new QR(this),g.J(this,this.Yd)));this.ra("sxhr",{s:""+ +a,a:""+ +(!!window.AbortController||Iw())},!0)};
VR=function(a,b){return a.Bf?(b=b.split(";")[0],a.Bf.get(b)):a.Yd};
HMa=function(a,b,c){var d;return g.B(function(e){if(1==e.j)return a.Mc("oprd_s"),xA()?g.A(e,JLa(a.LC,b,c),3):(d=a.LC.decrypt(b,c),e.Ra(2));2!=e.j&&(d=e.u);a.Mc("oprd_c");return e.return(d)})};
IMa=function(a){return a.K("html5_onesie_host_probing")||a.Yi};
$La=function(a,b,c){null!=(a=VR(a,b))&&(b=a.Ud.get(b))&&!b.Kf&&(lx(b.Fe,c),b.bytesReceived+=c.totalLength,b.SI=!0)};
iS=function(a){if(!a.playerResponse)return!1;if(a.aC)return!0;var b=a.videoData.K("html5_onesie_audio_only_playback")&&xD(a.videoData);if(!a.Bf&&a.Kv&&a.Yd&&!MLa(a.Yd,b))return!1;if(a.Bf&&a.Kv){if(!a.Bf.has(a.Ds))return!1;var c=a.Bf.get(a.Ds);if(c&&!MLa(c,b))return!1}a.Mc("ofr");a.Lm.resolve(a.playerResponse);a.K("html5_onesie_time_out_after_resolving")?a.zv.start():a.zv.stop();return a.aC=!0};
KMa=function(a){var b;if((null!=(b=a.Bf)?b:a.Yd)&&!a.K("html5_onesie_media_capabilities")){a.Mc("ogsf_s");b=rMa(a.qa.getVideoData(),function(d,e){a.ra(d,e)});
var c=JMa(a.qa);b.video=jMa(c,b.video);a.Mc("ogsf_c");if(b.video.length)return b;a.ra("ombspf","l."+c.u+";u."+c.j+";o."+c.B+";r."+c.reason)}};
LMa=function(a){if(!a.Im)return{};var b=SP(a.Im);b.d=BIa(a.Im);b.shost=a.gR;b.ty="o";return b};
RMa=function(a){function b(e){return(d.Xh&&!c.K("web_player_no_force_gvi")||!((c.Wj?0:c.K("web_player_gvi_wexit")||(g.oB(c)?"TVHTML5"===mB(c)?Xva(c)?c.K("web_player_gvi_wexit_living_room_pangea"):c.K("web_player_gvi_wexit_living_room_bedrock"):"TVHTML5_KIDS"===mB(c)?c.K("web_player_gvi_wexit_living_room_kids"):"TVHTML5_SIMPLY"===mB(c)||TA(c)?c.K("web_player_gvi_wexit_living_room_simply"):TB(c)||"TV_UNPLUGGED_CAST"===mB(c)?c.K("web_player_gvi_wexit_living_room_unplugged"):c.K("web_player_gvi_wexit_living_room_other"):
1))||d.qk&&d.u.B)?0:"yt"!==c.Ga?38===d.Ga&&"books"===c.playerStyle||30===d.Ga&&"docs"===c.playerStyle||33===d.Ga&&"google-live"===c.playerStyle?0:c.K("web_player_gvi_wexit_all_player_styles"):"adunit"!==SD(d)||c.K("web_player_gvi_wexit_adunit"))?MMa(a,d).then(function(){lS(a,d)},function(f){lS(a,d,!0);
throw f;}):NMa(a,d,e)}
var c=a.S(),d=a.getVideoData();d.isDisposed();d.va=!0;return OMa(a)?PMa(a,d).then(function(){lS(a,d)},function(e){e=hC(e);
if(gC(e.severity))return lS(a,d,!0),Promise.reject(e);"onesie.response.badproxystatus"===e.errorCode&&"3"===""+e.details.st&&(QMa=!0);a.handleError(e);return b("onesie")}):b("gvi")};
OMa=function(a){var b=a.S();if(!b.K("html5_onesie"))return!1;var c=a.getVideoData();if(!b.K("html5_onesie_cast")&&(c.J||c.kh)||!b.K("html5_onesie_inline")&&5===a.getVisibilityState()||"yt"!==b.Ga||QMa)return!1;b=b.di;if(!b||!b.j)return a.handleError(new fC("onesie.unavailable.hotconfig",{key:"0"})),!1;b={};return 0<Object.keys(b).length?(b.onesie="0",a.handleError(new fC("html5.missingapi",b)),!1):!0};
SMa=function(a){var b=XF();vza(b,a);return g.cI(b,XBa())};
PMa=function(a,b){var c,d,e,f,h,l,m,n,p,q,t,u,x,y;return g.B(function(z){if(1==z.j)return b.fetchType="onesie",c=xCa(b,a.getPlayerSize(),a.getVisibilityState()),d=new kS(a,c),g.A(z,d.fetch(),2);e=z.u;f={player_response:e};b.va=!1;h=a.S();l=h.K("html5_onesie_ads");if(!l)b.wl=d.Yd;else if(l&&d.Bf)for(m=g.r(d.Bf.keys()),n=m.next();!n.done;n=m.next())p=n.value,(q=d.Bf.get(p))&&a.ph.tv.j.set(p,q,180);if(l){var D=d.Cu;a.ph.fd().Cu=D}else b.Cu=d.Cu;g.pD(b,f,!0);if(b.va||nD(b))return z.return(Promise.resolve());
l?LGa(a.ph.tv.j):b.wl=void 0;t={};u="onesie.response";x=0;b.errorCode?(u="auth",t.ec=b.errorCode,t.ed=b.errorDetail,t.es=b.Ck||"",x=2):(t.successButUnplayable="1",t.disposed=""+ +b.isDisposed(),t.afmts=""+ +/adaptiveFormats/.test(e),t.cpn=b.clientPlaybackNonce);y=new fC(u,t,x);return z.return(Promise.reject(y))})};
MMa=function(a,b){var c,d,e,f,h,l,m,n,p,q;return g.B(function(t){switch(t.j){case 1:c=b.isAd(),d=!c,e=c?1:3,f=0;case 2:if(!(f<e)){t.Ra(4);break}if(!(0<f)){t.Ra(5);break}return g.A(t,ah(5E3),6);case 6:h=new g.Ar("Retrying OnePlatform request",{attempt:f}),g.Bu(h);case 5:return g.wa(t,7),g.A(t,TMa(a,b),9);case 9:return t.return();case 7:l=g.ya(t);m=hC(l);n=m.errorCode;d&&"manifest.net.badstatus"===n&&"401"===m.details.rc&&(d=!1,f===e-1&&(e+=1));if("auth"===n||"manifest.net.retryexhausted"===n)return t.return(Promise.reject(m));
a.handleError(m);if(gC(m.severity)){t.Ra(4);break}case 3:f++;t.Ra(2);break;case 4:return p=c?"auth":"manifest.net.retryexhausted",q=c?2:1,t.return(Promise.reject(new fC(p,{backend:"op"},q)))}})};
TMa=function(a,b){var c;return g.B(function(d){c=a.S();b.fetchType="gp";return c.K("html5_use_oauth_callback")?d.return(g.cC(c,g.WD(b)).then(function(e){return UMa(a,b,e)},void 0)):d.return(UMa(a,b,g.WD(b)))})};
UMa=function(a,b,c){var d,e,f,h,l,m,n,p,q,t,u,x,y,z,D,H,G,L,aa;return g.B(function(M){if(1==M.j)return d=SMa(c),e=xCa(b,a.getPlayerSize(),a.getVisibilityState()),f=g.OH(VMa),h=g.WD(b),l=(0,g.R)(),m=!1,n="empty",p=0,a.Mc("ps_s"),q=function(sa){2===sa.readyState&&a.Mc("ps_c")},t={xv:q},g.A(M,g.ZF(d,e,f,void 0,t),2);
u=M.u;a.Mc("ps_r");if(b.isDisposed())return M.return();u?u.error?(m=!0,n="esf:"+u.error.message,p=u.error.code):u.errorMetadata&&(m=!0,n="its",p=u.errorMetadata.status):m=!0;if(m)return x=0,y=((0,g.R)()-l).toFixed(),z=a.S(),D={backend:"op",rc:""+p,rt:y,reason:n,has_kpt:b.Kb?"1":"0",has_mdx_env:b.mdxEnvironment?"1":"0",has_omit_key_flag:g.P("INNERTUBE_OMIT_API_KEY_WHEN_AUTH_HEADER_IS_PRESENT")?"1":"0",has_page_id:z.pageId?"1":"0",has_token:h?"1":"0",has_vvt:b.Pa?"1":"0",is_mdx:b.isMdxPlayback?"1":
"0",mdx_ctrl:b.kh||"",token_eq:h===g.WD(b)?"1":"0"},H="manifest.net.connect",429===p?(H="auth",x=2):200<p&&(H="manifest.net.badstatus",400===p&&(x=2)),M.return(Promise.reject(new fC(H,D,x)));b.va=!1;g.pD(b,{raw_player_response:u},!0);if(b.errorCode)return G={ec:b.errorCode,ed:b.errorDetail,es:b.Ck||""},M.return(Promise.reject(new fC("auth",G,2)));if(!b.va&&!nD(b))return L=b.isAd()?"auth":"manifest.net.retryexhausted",aa=b.isAd()?2:1,M.return(Promise.reject(new fC(L,{successButUnplayable:"1",hasMedia:JD(b)?
"1":"0"},aa)));g.va(M)})};
NMa=function(a,b,c){var d,e,f,h,l,m,n,p,q,t,u;return g.B(function(x){switch(x.j){case 1:d=lCa(a.S(),b,a.getPlayerSize(),a.getVisibilityState(),a.isFullscreen()),e=function(){return!0},f=function(y){y=hC(y);
if(gC(y.severity))return Promise.reject(y);a.handleError(y);return!1},l=(h=b.isAd())?1:3,m=0;
case 2:if(!(m<l)){x.Ra(4);break}n=d;if(!(0<m)){x.Ra(5);break}return g.A(x,ah(5E3),6);case 6:p={playerretry:m,playerretrysrc:c},h||(p.recover="embedded"),n=dq(d,p);case 5:return g.A(x,WMa(b,n).then(e,f),7);case 7:if(q=x.u)return x.return();m++;x.Ra(2);break;case 4:t=h?"auth":"manifest.net.retryexhausted";u=h?2:1;if(!h&&1E-4>Math.random())try{g.Bu(new g.Ar("b/152131571",btoa(d)))}catch(y){}return x.return(Promise.reject(new fC(t,{backend:"gvi"},u)))}})};
WMa=function(a,b){var c,d,e,f,h,l,m,n,p,q,t,u,x,y;return g.B(function(z){if(1==z.j)return a.fetchType="gvi",c=a.S(),(f=mCa(a))?(d={format:"RAW",method:"POST",withCredentials:!0,timeout:3E4,postParams:f},e=dq(b,{action_display_post:1})):(d={format:"RAW",method:"GET",withCredentials:!0,timeout:3E4},e=b),h={},c.sendVisitorIdHeader&&a.visitorData&&(h["X-Goog-Visitor-Id"]=a.visitorData),(l=g.Xz(c.experiments,"debug_sherlog_username"))&&(h["X-Youtube-Sherlog-Username"]=l),0<Object.keys(h).length&&(d.headers=
h),m=(0,g.R)(),n=function(D){if(!a.isDisposed()){D=D?D.status:-1;var H=0,G=((0,g.R)()-m).toFixed();G={backend:"gvi",rc:""+D,rt:G};var L="manifest.net.connect";429===D?(L="auth",H=2):200<D&&(L="manifest.net.badstatus",400===D&&(H=2));return Promise.reject(new fC(L,G,H))}},p=function(D){return n(D.xhr)},g.A(z,Hz(rq,e,d).then(void 0,p),2);
q=z.u;if(!q||!q.responseText)return z.return(n(q));a.va=!1;t=$p(q.responseText);g.pD(a,t,!0);if(a.errorCode)return u={ec:a.errorCode,ed:a.errorDetail,es:a.Ck||""},z.return(Promise.reject(new fC("auth",u,2)));if(!a.va&&!nD(a))return x=a.isAd()?"auth":"manifest.net.retryexhausted",y=a.isAd()?2:1,z.return(Promise.reject(new fC(x,{successButUnplayable:"1"},y)));g.va(z)})};
lS=function(a,b,c){c=void 0===c?!1:c;var d;g.B(function(e){d=a.S();return c&&(!g.VB(d)||"embedded"!==SD(b))||b.wr||"adunit"!==SD(b)&&(g.oB(d)||pB(d)||g.gB(d)||g.fB(d)||"WEB_CREATOR"===mB(d))?e.return():d.K("html5_use_oauth_callback")?e.return(g.cC(d,g.WD(b)).then(function(f){return XMa(a,b,f)})):e.return(XMa(a,b,g.WD(b)))})};
XMa=function(a,b,c){var d,e,f,h;return g.B(function(l){if(1==l.j){g.wa(l,2);d=SMa(c);var m=b.S();g.cr.getInstance();var n={context:g.pI(b),videoId:b.videoId,racyCheckOk:b.racyCheckOk,contentCheckOk:b.contentCheckOk,autonavState:"STATE_NONE"};"adunit"===SD(b)&&(n.isAdPlayback=!0);m.embedConfig&&(n.serializedThirdPartyEmbedConfig=m.embedConfig);m.rl&&(n.showContentOwnerOnly=!0);g.dr(0,141)&&(n.autonavState=g.dr(0,140)?"STATE_OFF":"STATE_ON");if(g.WB(m)){m=g.dr(0,65);m=null!=m?!m:!1;var p=!!g.$u("yt-player-sticky-caption");
n.captionsRequested=m&&p}e=n;f=g.OH(YMa);a.Mc("wn_s");return g.A(l,g.ZF(d,e,f),4)}if(2!=l.j)return h=l.u,a.Mc("wn_r"),h&&!h.error&&g.pD(b,{raw_watch_next_response:h},!1),g.xa(l,0);g.ya(l);g.va(l)})};
ZMa=function(a){function b(){a.Mc("virc");Dw("virc",void 0,"video_to_ad")}
a.Mc("vir");Dw("vir",void 0,"video_to_ad");var c=RMa(a);c.then(b,b);return c};
g.qS=function(a,b,c,d,e,f,h,l,m,n){m=void 0===m?new g.mD(a):m;n=void 0===n?!0:n;g.iu.call(this);var p=this;this.U=a;this.playerType=b;this.zb=c;this.Iz=d;this.getVisibilityState=f;this.visibility=h;this.ph=l;this.videoData=m;this.pV=n;this.logger=new g.qO("VideoPlayer");this.mx=new mLa(this.U);this.me=null;this.Bv=new LQ;this.zn=null;this.ih=new UQ(this.U,this.Iz,this);this.kO=!0;this.mediaSource=this.Fa=null;this.Tj=[];this.Xn=new OR;this.vf=this.ez=null;this.Yn=new OR;this.RC=null;this.cH=this.Yu=
!1;this.SC=NaN;this.playerState=new g.zF;this.UC=[];this.mw=new g.kz;this.Bk=new RQ(this);this.mediaElement=null;this.Wr=new g.K(this.YY,15E3,this);this.kJ=this.zC=!1;this.Cs=NaN;this.JA=!1;this.zF=0;this.AF=new g.K(this.nJ,4500,this);this.uy=!1;this.hC=NaN;this.HJ=new uO(new Map([["bufferhealth",function(){var q=p.Xc;return q.mediaElement?wF(q.mediaElement):0}],
["bandwidth",function(){return p.xG()}],
["networkactivity",function(){return p.U.schedule.V}],
["livelatency",function(){return p.isAtLiveHead()&&p.Kc()?mS(p):NaN}],
["rawlivelatency",function(){return mS(p)}]]));
this.By=0;this.loop=!1;this.playbackRate=1;this.NO=0;this.Xc=new IR(this);this.FM=!1;this.TC=[];this.CH=this.wQ=0;this.hJ=this.YR=!1;this.oF=new g.K(this.mW,0,this);this.jd=null;this.wP=new g.K(this.tV,0,this);this.ZC=new g.K(this.UQ,3E4,this);this.OX=[this.mw,this.oF,this.Wr,this.ZC,this.AF,this.HJ,this.wP];this.uf=function(){var q=p.logging;q.u.U.ye||3===q.u.qa.getVisibilityState()||(q.u.U.ye=!0);ZKa(q);var t=q.C;t.I&&0>t.u&&3!==t.j.qa.getVisibilityState()&&XQ(t);q.qoe&&(q=q.qoe,q.Ga&&0>q.B&&q.j.U.ye&&
hR(q));p.Fa&&nS(p);p.U.Nl&&!p.videoData.backgroundable&&p.mediaElement&&!p.eg()&&(p.isBackground()&&p.mediaElement.uA()?(p.ra("bgmobile",{suspend:1}),p.jo(!0)):p.isBackground()||oS(p)&&p.ra("bgmobile",{resume:1}))};
this.uh=new wR(function(){return p.getCurrentTime()},function(){return p.getPlaybackRate()},function(){return p.getPlayerState()},function(q,t){q!==g.Cv("endcr")||g.V(p.playerState,32)||HN(p);
e(q,t,p.playerType)});
g.J(this,this.uh);g.J(this,this.Xc);$Ma(this,m);this.videoData.subscribe("dataupdated",this.G_,this);this.videoData.subscribe("dataloaded",this.LF,this);this.videoData.subscribe("dataloaderror",this.handleError,this);this.videoData.subscribe("ctmp",this.ra,this);this.videoData.subscribe("ctmpstr",this.YI,this);aNa(this);fGa(this.uf);this.visibility.subscribe("visibilitystatechange",this.uf);this.videoData.Ia&&bNa(this);!Rxa(this.videoData)&&Xxa(this.videoData)||cNa(this);1===this.playerType&&pS.isActive()&&
this.ZC.start();this.videoData.Ye=this.getUserAudio51Preference();this.K("html5_generate_content_po_token")&&dNa(this)};
$Ma=function(a,b){if(2===a.playerType||a.U.Pl)b.GK=!0;var c=Twa(b.qd,b.zt,a.U.j,a.U.B);c&&(b.adFormat=c);2===a.playerType&&(b.Fm=!0);if(a.isFullscreen()||a.U.j)c=g.$u("yt-player-autonavstate"),b.autonavState=c||(a.U.j?2:a.videoData.autonavState);b.endSeconds&&b.endSeconds>b.startSeconds&&rS(a,b.endSeconds)};
aNa=function(a){!a.logging||a.logging.isDisposed();a.logging=new g.vR(new uR(a.videoData,a.U,a,function(){return a.ph.Vi()}))};
QE=function(a){return a.mediaElement&&a.mediaElement.Hq()?a.mediaElement.mf():null};
sS=function(a){if(a.videoData.isValid())return!0;a.qg("api.invalidparam",2,void 0,"invalidVideodata.1");return!1};
bNa=function(a){var b=a.ph.Ic();a.videoData.Zm=a.videoData.Zm||(null==b?void 0:b.AG());a.videoData.cn=a.videoData.cn||(null==b?void 0:b.BG())};
g.FN=function(a,b){b=void 0===b?!1:b;if(!b){var c=a.logging;XQ(c.C);c.qoe&&hR(c.qoe)}a.Yu=b;!sS(a)||a.Xn.started?g.oB(a.U)&&a.videoData.isLivePlayback&&a.Xn.started&&!a.Xn.isFinished()&&!a.Yu&&a.LF():(a.Xn.start(),b=a.logging,g.GN(b.u),b.qoe&&DKa(b.qoe),a.LF())};
eNa=function(a){var b=a.videoData;ZMa(a).then(void 0,function(c){a.videoData!==b||b.isDisposed()||(c=hC(c),"auth"===c.errorCode&&a.videoData.errorDetail?a.qg("auth",2,unescape(a.videoData.errorReason),eC(c.details),a.videoData.errorDetail,a.videoData.Ck||void 0):a.handleError(c))})};
iGa=function(a,b){a.jd=b;a.Fa&&jJa(a.Fa,new g.yQ(b))};
fNa=function(a){if(!g.V(a.playerState,128))if(a.videoData.isLoaded(),4!==a.playerType&&(a.Tj=g.ec(a.videoData.oa)),JD(a.videoData)){a.zb.tick("bpd_s");tS(a).then(function(){a.zb.tick("bpd_c");if(!a.isDisposed()){a.Yu&&(a.Rb(BF(BF(a.playerState,512),1)),oS(a));var c=a.videoData;c.endSeconds&&c.endSeconds>c.startSeconds&&rS(a,c.endSeconds);a.Xn.finished=!0;uS(a,"dataloaded");a.Yn.started&&vS(a);vKa(a.ih,a.vf)}});
a.K("html5_log_media_perf_info")&&a.ra("loudness",{v:a.videoData.Me.toFixed(3)},!0);var b=Yxa(a.videoData);b&&a.ra("playerResponseExperiment",{id:b},!0);a.yF()}else uS(a,"dataloaded")};
tS=function(a){wS(a);a.vf=null;var b=oLa(a.U,a.videoData,a.eg());a.ez=b;a.ez.then(function(c){gNa(a,c)},function(c){a.isDisposed()||(c=hC(c),a.visibility.isBackground()?(xS(a,"vp_none_avail"),a.ez=null,a.Xn.reset()):(a.Xn.finished=!0,a.qg(c.errorCode,c.severity,"HTML5_NO_AVAILABLE_FORMATS_FALLBACK",eC(c.details))))});
return b};
SQ=function(a){tS(a).then(function(){return oS(a)});
g.FF(a.playerState)&&a.playVideo()};
gNa=function(a,b){if(!a.isDisposed()&&!b.videoData.isDisposed()){a.vf=b;zLa(a.Xc,a.vf);if(a.videoData.isLivePlayback){var c=(a.K("html5_onesie_ads")?MGa(a.ph.tv,a.videoData.videoId):!!a.videoData.wl)||a.Fa&&!isNaN(a.Fa.oa);c=a.K("html5_onesie_live")&&c;0<a.videoData.md&&!tD(a.videoData)||c||a.seekTo(a.Gd(),{Ee:"videoplayer_playbackData"})}a.videoData.C.j?a.Fa?g.Bu(Error("Duplicated Loader")):(c=g.eA(a.U.experiments,"html5_onesie_defer_content_loader_ms"),a.K("html5_onesie_ads")&&c&&g.Xb(a.Tj,"ad")&&
MGa(a.ph.tv,a.videoData.GS)?g.kq(function(){a.isDisposed()||a.Fa||yS(a)},c):yS(a)):!a.videoData.C.j&&XD(a.videoData)&&a.EC(new lP(a.videoData.videoId||"",4));
zS(a);lKa(b).then(function(){a.ew();AS(a)})}};
BS=function(a){a.mediaElement&&a.mediaElement.Ut();g.FN(a);if(sS(a)&&!g.V(a.playerState,128)){a.Yn.started||(a.Yn.start(),a.Rb(BF(BF(a.playerState,8),1)));var b=a.ph.Ic();b=b&&2===b.getPlayerType();a.K("html5_suspend_for_preroll_join_latency")&&b&&1===a.getPlayerType()&&!g.V(a.playerState,512)&&a.Rb(BF(a.playerState,512));vS(a)}};
vS=function(a){a.isDisposed();if(!a.Yn.isFinished()&&a.Xn.isFinished()&&!g.V(a.playerState,128)&&!a.Tj.length){if(!a.uh.started){var b=a.uh;b.started=!0;b.Kl()}if(!a.qm()){a.Fa&&(b=a.Fa.timing,a.cH=!!b.u&&!!b.D);a.Yn.isFinished()||(a.Yn.finished=!0);b=a.K("html5_onesie_live")&&a.Fa&&!isNaN(a.Fa.oa);!a.videoData.isLivePlayback||0<a.videoData.md&&!tD(a.videoData)||b||(a.seekTo(Infinity,{Ee:"videoplayer_readying"}),a.isBackground()&&(a.kJ=!0));b=a.logging;if(b.qoe){b=b.qoe;b.j.videoData.Dl&&fR(b,b.j.videoData.Dl);
if(b.j.videoData.isLivePlayback){var c=b.j.videoData.j;tD(b.j.videoData)&&fR(b,"manifestless");c&&Qz(c)&&fR(b,"live-segment-"+Qz(c).toFixed(1))}"yt"!==b.j.U.Ga&&(b.u.len=[b.j.videoData.lengthSeconds.toFixed(2)]);b.j.videoData.cotn&&!XD(b.j.videoData)&&zKa(b,!0);dC(b.j.U)&&(c=OFa())&&b.ra("cblt",{m:c})}a.X("playbackready",a);Cw("pl_c",a.zb.timerName)||(a.zb.tick("pl_c"),Dw("pl_c",void 0,"video_to_ad"));Cw("pbr",a.zb.timerName)||(a.zb.tick("pbr"),Dw("pbr",void 0,"video_to_ad"))}}};
HN=function(a,b,c){b=void 0===b?!0:b;(void 0===c||c)&&a.mediaElement&&a.mediaElement.pause();a.Rb(b?new g.zF(14):new g.zF)};
rS=function(a,b){a.zn&&CS(a);a.zn=new g.Av(1E3*b,0x7ffffffffffff);a.zn.namespace="endcr";a.addCueRange(a.zn)};
CS=function(a){a.removeCueRange(a.zn);a.zn=null};
ES=function(a,b,c,d){a.videoData.B=c;d&&tQ(a,b,d);d=(d=g.DS(a))?d.Vb():"";a.logging.bz(new gKa(a.videoData,c,b,d));c=a.ih;c.B=0;c.j=0;a.X("internalvideoformatchange",a.videoData,"m"===b)};
g.DS=function(a){var b=GS(a);return Nw(b)||!a.vf?null:g.Ub(a.vf.j.videoInfos,function(c){return b.C(c)})};
tQ=function(a,b,c){if(c!==a.videoData.I){var d=!a.videoData.I;a.videoData.I=c;"m"!==b&&(b=d?"i":"a");a.logging.Sy(new gKa(a.videoData,c,b,""));d||a.X("internalaudioformatchange",a.videoData,"m"===b)}};
uQ=function(a,b){b&&a.xd(new fC("qoe.restart",b));a.Rb(BF(a.playerState,2048));HS(a);b=a.videoData.j&&Xw(a.videoData.j);var c=a.mediaElement&&a.mediaElement.isView();b||c?(a.Fa&&bJa(a.Fa),QQ(a)):(oS(a),g.FF(a.playerState)&&a.playVideo())};
GS=function(a){if(a.vf){var b=a.ih;var c=a.vf;a=a.Ju();if(b.qa.Cp().isInline())var d=lD;else b.K("html5_exponential_memory_for_sticky")?d=.5>SA(b.U.ge,"sticky-lifetime")?"auto":Ow[Tz()]:d=Ow[Tz()],d=g.Mw("auto",d,!1,"s");if(Nw(d)){d=hKa(b,c);var e=d.compose,f;a:if((f=c.j)&&f.videoInfos.length){for(var h=g.r(f.videoInfos),l=h.next();!l.done;l=h.next()){l=l.value;var m=void 0;if(null==(m=l.u)?0:m.smooth){f=l.video.j;break a}}f=f.videoInfos[0].video.j}else f=0;ona()&&!g.oB(b.U)&&ez(c.j.videoInfos[0])&&
(f=Math.min(f,g.Lw.large));d=e.call(d,new Kw(0,f,!1,"o"));e=d.compose;f=4320;!b.U.isMobile||g.dB(b.U)||Hq()||b.U.K("hls_for_vod")||(f=b.U.K("mweb_default_hd720")?g.Lw.hd720:g.Lw.medium);(h=g.eA(b.U.experiments,"html5_default_quality_cap"))&&c.j.j&&!c.videoData.kh&&!c.videoData.Wd&&(f=Math.min(f,h));h=g.eA(b.U.experiments,"html5_random_playback_cap");l=/[a-h]$/;h&&l.test(c.videoData.clientPlaybackNonce)&&(f=Math.min(f,h));if(l=h=g.eA(b.U.experiments,"html5_hfr_quality_cap"))a:{l=c.j;if(l.j)for(l=g.r(l.videoInfos),
m=l.next();!m.done;m=l.next())if(32<m.value.video.fps){l=!0;break a}l=!1}l&&(f=Math.min(f,h));(h=g.eA(b.U.experiments,"html5_live_quality_cap"))&&c.videoData.isLivePlayback&&(f=Math.min(f,h));f=tKa(b,c,f);d=e.call(d,new Kw(0,4320===f?0:f,!1,"d")).compose(sKa(b)).compose(uKa(b,c.videoData,c)).compose(rKa(b,c)).compose(kKa(b,c)).compose(jKa(b,c))}else b.K("html5_perf_cap_override_sticky")&&(d=d.compose(rKa(b,c))),b.K("html5_ustreamer_cap_override_sticky")&&(d=d.compose(kKa(b,c)));b.K("html5_varispeed_playback_rate")&&
(d=d.compose(jKa(b,c)));b=c.videoData.xt.compose(d).compose(c.videoData.RQ).compose(a)}else b=lD;return b};
JMa=function(a){var b=a.ih;a=a.videoData;var c=sKa(b);b.K("html5_disable_client_autonav_cap_for_onesie")||c.compose(uKa(b,a));return c};
g.hNa=function(a,b,c){a.videoData.xt=b;if(a.vf&&c){c=a.ih;var d=a.vf;if(d.j.j){var e=Tz(),f=d.j.videoInfos[0].video.j;if(!(e>f&&0!==f&&b.j===f)){e=!0;f=c.playbackRate;if(c.K("html5_cap_quality_for_tv_hfr")){var h;e=VQ(c,null==(h=d.j)?void 0:h.videoInfos);f=c.qa.getPlaybackRate()}1<f&&e&&c.K("html5_varispeed_playback_rate")&&(h=eva(c.U.u,d.j.videoInfos,f),0!==b.j&&h<b.j&&c.qa.setPlaybackRate(1));var l,m;d=(null==(l=d.videoData.B)?void 0:null==(m=l.video)?void 0:m.j)||0;g.Zu("yt-player-quality",{quality:g.Lw[Pw(b)],
previousQuality:d},31104E3);c.U.schedule.policy.C=480<=Tz();if(c.K("html5_exponential_memory_for_sticky")){b=c.U.ge;l=1;var n=void 0===n?!1:n;Nva(b,"sticky-lifetime");b.values["sticky-lifetime"]&&b.Gn["sticky-lifetime"]||(b.values["sticky-lifetime"]=0,b.Gn["sticky-lifetime"]=0);n&&.0625<SA(b,"sticky-lifetime")&&(l=2*b.Gn["sticky-lifetime"]);b.values["sticky-lifetime"]+=1*Math.pow(2,b.j/l);b.Gn["sticky-lifetime"]=l;b.C.start()}if(c.K("html5_perf_cap_override_sticky"))if(c.K("html5_perserve_av1_perf_cap")){n=
Uz();c=g.r(Object.keys(n));for(b=c.next();!b.done;b=c.next())b=b.value,0!==b.indexOf("1")&&(n[b]=0);g.Zu("yt-player-performance-cap",n,604800)}else g.av("yt-player-performance-cap")}}}zS(a)};
dNa=function(a){a.videoData.videoId?iNa(a.ph,a.videoData.videoId).then(function(b){a.videoData.P8=b}):a.ra("pomvid",{})};
zS=function(a){if(!a.isDisposed()&&!g.V(a.playerState,128)&&a.videoData.C){if(a.videoData.C.j)AS(a);else{var b=GS(a),c=a.videoData;a:{var d=a.videoData.qc;if(b.j){for(var e=g.r(d),f=e.next();!f.done;f=e.next()){f=f.value;var h=f.cg(),l=g.Lw[h.video.quality];if((!b.B||"auto"!==h.video.quality)&&l<=b.j){d=f;break a}}d=d[d.length-1]}else d=d[0]}c.eb=d;ES(a,b.reason,jNa(a,a.videoData.eb))}if(a.K("html5_check_unstarted")?g.FF(a.playerState):a.Kc())a.Xc.Pa=!1,a.playVideo()}};
AS=function(a){if(a.videoData.C&&a.videoData.C.j){var b=GS(a);if(a.Fa&&(a=a.Fa,!a.isDisposed()&&!a.Td.j.equals(b)&&a.videoTrack)){var c=a.Td.j;dJa(a,tHa(a.Td,b));pQ(a);var d=a.Td.j.isLocked()&&"m"===b.reason&&a.Td.W,e=a.policy.ql&&"l"===b.reason&&PP(a.videoTrack);b=c.j>b.j&&"b"===b.reason;c=a.Td.Ta&&!Bz();d||e||b||c?uQ(a.qa,{reattchOnConstraint:d?"u":e?"drm":c?"codec":"perf"}):g.Fn(a.W)}}};
nS=function(a){a.K("html5_update_constraint")?AS(a):zS(a)};
kNa=function(a){var b;return!!(a.K("html5_native_audio_track_switching")&&g.Ir&&(null==(b=a.videoData.B)?0:hz(b)))};
lNa=function(a){if(!kNa(a))return!1;var b;a=null==(b=a.mediaElement)?void 0:b.audioTracks();return!!(a&&1<a.length)};
nNa=function(a){var b=mNa(a);if(b)return a.videoData.getAvailableAudioTracks().find(function(c){return c.Fc.getName()===b})};
mNa=function(a){var b;if(a=null==(b=a.mediaElement)?void 0:b.audioTracks())for(b=0;b<a.length;++b){var c=a[b];if(c.enabled)return c.label}};
yS=function(a){Gua(a.videoData.j,{cpn:a.videoData.clientPlaybackNonce,c:a.U.deviceParams.c,cver:a.U.deviceParams.cver});var b=a.U,c=a.videoData,d=new g.$Ca(b),e=ZCa(b,{hasSubfragmentedFmp4:c.hasSubfragmentedFmp4,wm:c.wm});d.D=e;d.oa=g.eA(b.experiments,"html5_subsegment_readahead_target_buffer_health_secs");d.Kd=g.eA(b.experiments,"html5_subsegment_readahead_timeout_secs");d.Ts=g.eA(b.experiments,"html5_subsegment_readahead_min_buffer_health_secs");d.Ad=g.eA(b.experiments,"html5_subsegment_readahead_min_buffer_health_secs_on_timeout");
d.Us=g.eA(b.experiments,"html5_subsegment_readahead_min_load_speed");d.oi=g.eA(b.experiments,"html5_subsegment_readahead_load_speed_check_interval");d.Ys=g.eA(b.experiments,"html5_subsegment_readahead_seek_latency_fudge");d.wr=b.K("html5_restrict_streaming_xhr_on_sqless_requests");d.Dl=g.eA(b.experiments,"html5_max_headm_for_streaming_xhr");d.Pl=b.K("html5_pipeline_manifestless_allow_nonstreaming");d.Zm=b.K("html5_prefer_server_bwe3");d.zi=1024*g.eA(b.experiments,"html5_video_tbd_min_kb");d.rk=b.K("html5_last_slice_transition");
d.Sr=b.K("html5_store_xhr_headers_readable");d.Nc=g.eA(b.experiments,"html5_probe_primary_delay_base_ms")||d.Nc;d.Sh=b.K("html5_no_placeholder_rollbacks");d.Es=b.K("html5_subsegment_readahead_enable_mffa");b.K("html5_allow_video_keyframe_without_audio")&&(d.va=!0);d.zq=b.K("html5_webm_init_skipping");d.Je=b.K("html5_abs_buffer_health");d.qk=b.K("html5_interruption_resets_seeked_time");d.vj=g.eA(b.experiments,"html5_max_live_dvr_window_plus_margin_secs")||d.vj;d.Le=b.K("html5_explicitly_dispose_xhr");
d.Mq=b.K("html5_restart_on_unexpected_detach");d.bf=g.eA(b.experiments,"html5_manifestless_seg_drift_limit_secs");d.Ff=g.eA(b.experiments,"html5_max_drift_per_track_secs");d.qd=g.eA(b.experiments,"html5_static_abr_resolution_shelf");d.Xj=!b.K("html5_encourage_array_coalescing");d.yl=b.K("html5_filter_non_efficient_formats_for_safari");d.wt=b.K("html5_format_hybridization");d.Gj=b.K("html5_abort_before_separate_init");d.Gr=b.K("html5_serialize_server_stitched_ad_request");d.Wg=b.K("html5_never_pause_appends");
d.Vg=g.eA(b.experiments,"html5_min_startup_buffered_media_duration_secs");d.Lj=b.K("html5_attach_po_token_to_bandaid");b.K("html5_allow_video_keyframe_without_audio")&&(d.va=!0);0<g.eA(b.experiments,"html5_max_redirect_response_length")&&(d.zg=g.eA(b.experiments,"html5_max_redirect_response_length"));e=g.eA(b.experiments,"html5_resource_bad_status_delay_scaling");0<e&&(d.Lq=e);d.Zc=b.K("html5_rewrite_timestamps_for_webm");d.Ia=b.K("html5_only_media_duration_for_discontinuities");b.K("html5_media_common_config_killswitch")||
(d.I=c.maxReadAheadMediaTimeMs/1E3||d.I,e=b.schedule,e.B.Dh()===e.policy.B?d.Da=10:d.Da=c.minReadAheadMediaTimeMs/1E3||d.Da,d.Ke=c.readAheadGrowthRateMs/1E3||d.Ke);bl&&(d.Ga=41943040);d.bb=!Gz();g.oB(b)||!Gz()?(e=b.experiments,d.J=8388608,d.W=524288,d.Wj=5,d.Zb=2097152,d.Pa=1048576,d.Iq=1.5,d.Nl=!1,d.Ob=4587520,Eq()&&(d.Ob=786432),d.B*=1.1,d.C*=1.1,d.Yc=!0,d.Ga=d.J,d.qc=d.W,d.ze=e.fb("persist_disable_player_preload_on_tv")||e.fb("persist_disable_player_preload_on_tv_for_living_room")||!1):b.isMobile&&
(d.B*=1.3,d.C*=1.3);g.oz&&Aq("crkey")&&(e="CHROMECAST/ANCHOVY"===b.deviceParams.cmodel,d.J=20971520,d.W=1572864,e&&(d.Ob=812500,d.Ug=1E3,d.yq=5,d.Pa=2097152));!b.K("html5_disable_firefox_init_skipping")&&g.Gw&&(d.Yc=!0);b.supportsGaplessAudio()||(d.wl=!1);VA&&(d.Sa=!0);d.Jc=b.K("html5_peak_shave");"onesie"===c.fetchType&&b.K("html5_disable_peak_shave_for_onesie")&&(d.Jc=!1);var f;e=null==(f=c.j)?void 0:Xw(f);if(tD(c)){d.ge=!0;d.zl=!0;d.Ia=!0;d.Zc=!0;d.Pr=!0;if("ULTRALOW"===c.latencyClass||"LOW"===
c.latencyClass&&!b.K("html5_disable_low_pipeline"))d.Bl=2,d.El=4;d.xn=c.defraggedFromSubfragments;c.Ce&&(d.dn=!0);g.KD(c)&&(d.Ta=!1);d.gk=g.UB(b)}c.isAd()&&(d.Hc=0,d.Ye=0,d.Vg=g.eA(b.experiments,"html5_min_startup_buffered_ad_media_duration_secs"));Exa(c)&&(d.ma=!0,b.K("html5_aggressive_timeout_for_streaming_xhr")&&(d.Ug=400,d.Fl=10,d.cn=1,d.Ol=!0,d.Th=5,d.Cl=2,d.Ag=3,d.gi=1.4));d.qb=b.K("html5_enable_subsegment_readahead_v3")||b.K("html5_ultra_low_latency_subsegment_readahead")&&"ULTRALOW"===c.latencyClass;
d.Ib=dC(b);d.Y=d.Ib&&(/^rq[a-f]/.test(c.clientPlaybackNonce)||2<=b.V);Mq()&&/(K\d{3}|KS\d{3}|KU\d{3})/.test(b.deviceParams.cmodel)&&!b.K("html5_disable_move_pssh_to_moov")&&e&&(d.Yc=!1);var h=0;b.K("html5_live_use_alternate_bandwidth_window_sizes")&&(h=b.schedule.policy.u,c.isLivePlayback&&(h=g.eA(b.experiments,"ULTRALOW"===c.latencyClass?"html5_live_ultra_low_latency_bandwidth_window":c.isLowLatencyLiveStream?"html5_live_low_latency_bandwidth_window":"html5_live_normal_latency_bandwidth_window")||
h));f=b.schedule;f.oa.j=tD(c)?.5:0;if(!f.policy.j&&h&&(f=f.B,h=Math.round(h*f.resolution),h!==f.j)){var l=Array(h),m=Math.min(h,f.u?f.j:f.valueIndex),n=f.valueIndex-m;0>n&&(n+=f.j);for(var p=0;p<m;++p)l[p]=f.values[(n+p)%f.j];for(;p<h;++p)l[p]=Infinity;f.j=h;f.values=l;f.valueIndex=m%h;f.u=m===h;f.C=!0;f.I=Gva(f)}d.Wg=c.isLivePlayback;switch(DD(c)){case 21530001:d.aj=b.K("html5_live_smoothly_extend_max_seekable_time");d.qb=!0;"LOW"===c.latencyClass?d.oa=g.eA(b.experiments,"html5_jumbo_mobile_subsegment_readahead_target"):
"ULTRALOW"===c.latencyClass&&(d.oa=g.eA(b.experiments,"html5_jumbo_ull_subsegment_readahead_target"));d.Sh=!0;break;case 2153E4:d.qb=!1}c.fg()&&(d.Zj=1.3);d.Sa=d.Sa||c.Uw;d.md=c.Ia;2<=b.V&&(d.Kb=!0);c.Ia&&!e&&b.K("html5_hack_gapless_init")&&(d.di=!0);(e=g.eA(b.experiments,"html5_gapless_ad_byterate_multiplier"))&&c.Ia&&c.isAd()&&(d.B*=e,d.C*=e);XD(c)&&(d.u=c.videoId,b.K("woffle_pending_promises_killswitch")&&(d.eb=!1),d.Je=!0,d.Zs=4,c.Xm&&0<c.Xm.length&&(d.ye=c.Xm));d.ql=c.Th;d.V=Wz(b,{},c.C||void 0);
c=480<=Tz();e=g.eA(b.experiments,"html5_deadzone_multiplier")||1;d.B*=e;d.C*=e;if(e=g.eA(b.experiments,"html5_request_sizing_multiplier"))d.Jq=e;Uw(b.u,Vw.BITRATE)&&(d.Ob=NaN);b.u.B&&(d.xl="; "+Vw.EXPERIMENTAL.name+"=allowed");c&&(d.qd=0);b.K("html5_prefer_low_quality_audio_means_64k")&&VA&&(d.Ym=!0);b.K("debug_html5_random_stun_format")&&(d.Xh=!0);b.K("html5_log_audio_abr")&&(d.vk=!0);b=a.getAudioTrack();b=b.Fc.isDefault?void 0:b;MQ(a.Bv);if(a.K("html5_onesie_ads"))a:{c=a.ph.tv;if(e=a.videoData.videoId)if(f=
c.j.get(e)){c.j.remove(e);c=f;break a}c=void 0}else c=a.videoData,e=c.wl,delete c.wl,c=e;a.Fa=new g.oQ(a,a.U.schedule,d,a.videoData.j,a.videoData.C,GS(a),b,a.videoData.enableServerStitchedDai,c,a.videoData.Da);d=oNa(a)?!0:a.Yu&&g.oB(a.U)&&a.videoData.isLivePlayback;a.Fa.initialize(a.getCurrentTime(),GS(a),d);a.videoData.probeUrl&&(a.Fa.ma=a.videoData.probeUrl);!a.Tj.length&&!a.Yu||!a.K("woffle_disable_suspend_loader_killswitch")&&a.videoData.cotn||IS(a,!1);LR(a.Xc,a.Fa);a.jd&&jJa(a.Fa,new g.yQ(a.jd));
g.YD(a.videoData)&&(a.Fa.policy.Me=2)};
wS=function(a){a.Fa&&(a.Fa.dispose(),a.Fa=null,LR(a.Xc,null));HS(a)};
HS=function(a){if(a.mediaSource){if(a.Fa){var b=tD(a.videoData)&&a.videoData.Ce&&!a.videoData.isAd();rQ(a.Fa,b)}a.mediaSource.dispose();a.mediaSource=null}};
pNa=function(a){if(a.mediaSource)return a.mediaSource.Hy;a:{try{if(g.Cq()&&a.videoData.tH()){var b=a.mediaElement;b.B&&(b.B.dispose(),b.B=void 0)}var c=a.mediaElement.Br()}catch(d){if(TQ(a.Bk,"html5.missingapi",{updateMs:"1"}))break a;console.error("window.URL object overwritten by external code",d);a.qg("html5.missingapi",2,"HTML5_NO_AVAILABLE_FORMATS_FALLBACK","updateMs.1");break a}BN(a,c)}return a.mediaSource?a.mediaSource.Hy:null};
BN=function(a,b){qNa(a);a.mediaSource=b;hua(a.mediaSource,function(c){try{if(a.mediaSource&&(!c||a.mediaSource===c)){var d=a.getDuration();!d&&tD(a.videoData)&&(d=25200);a.mediaSource.isView?(c=d,c>a.mediaSource.getDuration()&&a.mediaSource.bl(c)):a.mediaSource.bl(d);var e=a.Fa,f=a.mediaSource;e.policy.N&&(e.Si(),e.policy.N=!1);cJa(e);if(!f.j&&!f.u){var h=e.videoTrack.jg(),l=h?h.info.j:e.videoTrack.j,m=e.audioTrack.jg(),n=l.info.mimeType+e.policy.xl,p=(m?m.info.j:e.audioTrack.j).info.mimeType,q,t=
null==(q=f.mediaSource)?void 0:q.addSourceBuffer(p),u,x="fakesb"===n.split(";")[0]?void 0:null==(u=f.mediaSource)?void 0:u.addSourceBuffer(n);f.Cf&&(f.Cf.webkitSourceAddId("0",p),f.Cf.webkitSourceAddId("1",n));var y=new Az(t,f.Cf,"0",bz(p),!1),z=new Az(x,f.Cf,"1",bz(n),!0);f.j=y;f.u=z;g.J(f,y);g.J(f,z)}EP(e.videoTrack,f.u||null);EP(e.audioTrack,f.j||null);e.mediaSource=f;e.resume();g.ju(f.j,e.va,e);g.ju(f.u,e.va,e);try{e.uj()}catch(D){g.S(D)}a.X("mediasourceattached")}}catch(D){g.Bu(D),a.handleError(new fC("fmt.unplayable",
{msi:"1",ename:D.name},1))}})};
qNa=function(a){a.Fa?a.Fa.seek(a.getCurrentTime()-a.ud()).Li(function(){}):yS(a)};
QQ=function(a,b){b=void 0===b?!1:b;return g.B(function(c){if(1==c.j)return!a.K("html5_reset_daistate_on_newelement_killswitch")&&a.Fa&&a.Fa.Er(),a.Fa&&a.Fa.isDisposed()&&wS(a),a.Rb(BF(a.playerState,2048)),a.X("newelementrequired"),b?g.A(c,tS(a),2):c.Ra(2);g.V(a.playerState,8)&&a.playVideo();g.va(c)})};
cGa=function(a,b){a.ra("newelem",{r:b});QQ(a)};
JS=function(a){a.zb.D.gI();g.V(a.playerState,32)||(a.Rb(BF(a.playerState,32)),g.V(a.playerState,8)&&a.pauseVideo(!0),a.X("beginseeking",a));a.Sb()};
YN=function(a){g.V(a.playerState,32)?(a.Rb(DF(a.playerState,16,32)),a.X("endseeking",a)):g.V(a.playerState,2)||a.Rb(BF(a.playerState,16));a.zb.D.lI(a.videoData,g.V(a.playerState,4))};
cNa=function(a){var b=a.videoData.errorDetail;a.qg("auth",2,unescape(a.videoData.errorReason),b,b,a.videoData.Ck||void 0)};
uS=function(a,b){a.X("internalvideodatachange",void 0===b?"dataupdated":b,a,a.videoData)};
rNa=function(a){for(var b=g.r("loadstart loadeddata loadedmetadata play playing progress pause ended suspend seeking seeked timeupdate durationchange ratechange error waiting resize".split(" ")),c=b.next();!c.done;c=b.next())a.mw.P(a.mediaElement,c.value,a.FI,a);a.U.ql&&a.mediaElement.Hq()&&(a.mw.P(a.mediaElement,"webkitplaybacktargetavailabilitychanged",a.eY,a),a.mw.P(a.mediaElement,"webkitcurrentplaybacktargetiswirelesschanged",a.fY,a))};
sNa=function(a){window.clearInterval(a.SC);KS(a)||(a.SC=g.lq(function(){return KS(a)},100))};
KS=function(a){var b=a.mediaElement;b&&a.zC&&!a.videoData.kb&&!Cw("vfp",a.zb.timerName)&&2<=b.Pi()&&!b.Gg()&&0<xz(b.Eg())&&a.zb.tick("vfp");return(b=a.mediaElement)&&!a.videoData.kb&&0<b.getDuration()&&(!Cw("pbp",a.zb.timerName)&&b.Vm()&&2<=b.Pi()&&0<xz(b.Eg())&&a.zb.tick("pbp"),b=b.getCurrentTime(),xR(a.mx,b))?(WFa(a),!0):!1};
WFa=function(a){window.clearInterval(a.SC);a.Wr.stop();a.videoData.kb=!0;a.U.Bl=!0;a.U.kb=0;var b=a.Bk;if(b.videoData.B){var c=b.j.u;c.u.delete(b.videoData.B.j);c.j=!0}b.u.stop();a.U.Gj=a.videoData.Ww;a.videoData.VO=!0;tNa(a);g.V(a.playerState,8)&&a.Rb(CF(a.playerState,65));b=a.logging;b.j&&TKa(b.j);b=b.C;c=g.GN(b.j);0>b.u&&(b.u=c,b.delay.start());b.B=c;b.D=c;g.Fn(a.AF);a.X("playbackstarted");g.or()&&((a=g.La("yt.scheduler.instance.clearPriorityThreshold"))?a():pr(0))};
tNa=function(a){var b=a.getCurrentTime(),c=a.ph.fd();!Cw("pbs",a.zb.timerName)&&Uv.measure&&Uv.getEntriesByName&&(Uv.getEntriesByName("mark_nr")[0]?bsa("mark_nr"):bsa());c.videoId&&a.zb.info("docid",c.videoId);c.eventId&&a.zb.info("ei",c.eventId);c.clientPlaybackNonce&&!a.K("web_player_early_cpn")&&a.zb.info("cpn",c.clientPlaybackNonce);0<c.startSeconds&&a.zb.info("start",c.startSeconds.toString());if(a.mediaElement&&a.mediaElement.Vm())if(a.U.experiments.fb("web_csi_via_jspb")){var d=new Cp;g.E(d,
6,!0);var e=new Ep;wd(e,Cp,22,d);Bw(e,a.zb.timerName)}else a.zb.info("paused",1);a.U.experiments.fb("web_csi_via_jspb")?(d=new Cp,c.B?(e=Number(c.B.Vb()),g.E(d,1,e)):g.E(d,1,-1),e=new Ep,wd(e,Cp,22,d),Bw(e,a.zb.timerName)):c.B?a.zb.info("fmt",c.B.Vb()):a.zb.info("fmt","-1");c.Je&&(e=a.cH?2:1,a.U.experiments.fb("web_csi_via_jspb")?(d=new Cp,g.E(d,8,e),e=new Ep,wd(e,Cp,22,d),Bw(e,a.zb.timerName)):a.zb.info("yt_pre",String(a.cH?2:1)));a.isFullscreen()&&a.zb.info("yt_fs","1");nw({liveStreamMode:uNa[HD(c)]},
a.zb.timerName);a.zb.info("cmt",b.toFixed(3));if(a.Fa){b=a.Fa.timing;window&&window.performance&&window.performance.getEntriesByName&&(b.D&&(c=window.performance.getEntriesByName(b.D),c.length&&(c=c[0],b.tick("vri",c.fetchStart),b.tick("vdns",c.domainLookupEnd),b.tick("vreq",c.requestStart),b.tick("fvb",c.responseStart),b.tick("fvb_r",c.responseStart),b.tick("vrc",c.responseEnd))),b.u&&(c=window.performance.getEntriesByName(b.u),c.length&&(c=c[0],b.tick("ari",c.fetchStart),b.tick("adns",c.domainLookupEnd),
b.tick("areq",c.requestStart),b.tick("avb",c.responseStart),b.tick("fab_r",c.responseStart),b.tick("arc",c.responseEnd))));b=b.ticks;for(var f in b)b.hasOwnProperty(f)&&a.zb.tick(f,b[f])}};
vNa=function(a){a.logging.Od();if(a.videoData.isLivePlayback&&Date.now()>a.NO+6283){if(!(!a.isAtLiveHead()||a.videoData.j&&Nz(a.videoData.j))){var b=a.logging;if(b.qoe){b=b.qoe;var c=b.j.qa.MB(),d=g.GN(b.j);BKa(b,d,c);c=c.D;isNaN(c)||g.aR(b,d,"e2el",[c.toFixed(3)])}}g.UB(a.U)&&a.ra("rawlat",{l:wO(a.HJ,"rawlivelatency").toFixed(3)});a.NO=Date.now()}a.videoData.B&&hz(a.videoData.B)&&(b=QE(a))&&b.videoHeight!==a.CH&&(a.CH=b.videoHeight,ES(a,"a",jNa(a,a.videoData.eb)))};
jNa=function(a,b){if("auto"===b.j.video.quality&&hz(b.cg())&&a.videoData.qc)for(var c=g.r(a.videoData.qc),d=c.next();!d.done;d=c.next())if(d=d.value,d.getHeight()===a.CH&&"auto"!==d.j.video.quality)return d.cg();return b.cg()};
mS=function(a){if(!a.videoData.isLivePlayback)return NaN;var b=0;a.Fa&&a.videoData.j&&(b=tD(a.videoData)?a.Fa.WA.Dh()||0:a.videoData.j.oa);return Date.now()/1E3-a.getIngestionTime()-b};
wNa=function(a){!a.K("html5_ignore_airplay_events_on_new_video_killswitch")&&a.mediaElement&&a.mediaElement.eg()&&(a.hC=(0,g.R)());a.U.Zm?g.kq(function(){LS(a)},0):LS(a)};
LS=function(a){if(a.mediaElement)try{a.RC=a.mediaElement.playVideo()}catch(c){xS(a,"err."+c)}if(a.RC){var b=a.RC;b.then(void 0,function(c){if(!(g.V(a.playerState,4)||g.V(a.playerState,256)||a.RC!==b||c&&"AbortError"===c.name&&c.message&&c.message.includes("load"))){var d="promise";c&&c.name&&(d+=";m."+c.name);xS(a,d);a.FM=!0;a.videoData.dR=!0}})}};
xS=function(a,b){g.V(a.playerState,128)||(a.Rb(DF(a.playerState,1028,9)),a.ra("dompaused",{r:b}),a.X("onAutoplayBlocked"))};
oS=function(a){if(!a.mediaElement||!a.videoData.C)return!1;var b,c=null;if(null==(b=a.videoData.C)?0:b.j){c=pNa(a);var d;null==(d=a.Fa)||d.resume()}else wS(a),a.videoData.eb&&(c=a.videoData.eb.Mw());b=c;d=a.mediaElement.uA();c=!1;d&&d.equals(b)||(xNa(a,b),c=!0);g.V(a.playerState,2)||(b=a.Xc,b.D||!(0<b.C)||b.mediaElement&&0<b.mediaElement.getCurrentTime()||b.seekTo(b.C,{Ee:"playbacktimeline_resumeTime"}));a:if(b=c,g.FD(a.videoData)&&a.mediaElement)if((d=a.videoData.V)&&a.mediaElement.Hq()){var e=a.mediaElement.mf();
if(a.me)if(e!==a.me.element)MS(a);else if(b&&"fairplay"===d.flavor&&!Dq())MS(a);else break a;a.me=new NQ(e,a.videoData,a.U);a.me.subscribe("licenseerror",a.CC,a);a.me.subscribe("qualitychange",a.VY,a);a.me.subscribe("heartbeatparams",a.Wy,a);a.me.subscribe("keystatuseschange",a.aq,a);a.me.subscribe("ctmp",a.ra,a);b=g.r(a.Bv.keys);for(d=b.next();!d.done;d=b.next())d=a.Bv.get(d.value),a.me.wv(d);a.K("html5_eme_loader_sync")||MQ(a.Bv)}else a.qg("fmt.unplayable",1,"HTML5_NO_AVAILABLE_FORMATS_FALLBACK",
"drm.1");return c};
xNa=function(a,b){a.zb.tick("vta");Dw("vta",void 0,"video_to_ad");0<a.getCurrentTime()&&BLa(a.Xc,a.getCurrentTime());a.mediaElement.Ut(b);a.mediaSource&&pr(4);!a.videoData.kb&&g.FF(a.playerState)&&a.Wr.start();if(kNa(a)){var c;if(b=null==(c=a.mediaElement)?void 0:c.audioTracks())b.onchange=function(){a.X("internalaudioformatchange",a.videoData,!0)}}};
MS=function(a){a.me&&(a.me.dispose(),a.me=null)};
CN=function(a,b){b=void 0===b?!1:b;return a.videoData.isLivePlayback&&(a.isAtLiveHead()&&(a.K("html5_videoplayer_getmaxseekabletimeforux_check_pause_killswitch")||!g.V(a.playerState,4))||a.Mn()||g.KD(a.videoData))?a.getCurrentTime():a.Gd(b)};
yNa=function(a){a.mediaElement&&(a.mediaSource?(MS(a),HS(a),pNa(a)):(a.videoData.eb&&a.videoData.eb.mJ(),a.mediaElement.stopVideo()),a.playVideo())};
NS=function(a,b){a.U.K("html5_log_rebuffer_reason")&&a.ra("bufreason",{r:b,lact:xt()})};
TN=function(a,b,c,d,e,f){var h;if(null==(h=a.videoData.j)?0:h.isLive){h=2===c.playerType?c:b;var l=b.videoData.videoId,m=c.videoData.videoId;if(l&&m){var n=a.logging;if(n.qoe){n=n.qoe;var p=b.cpn,q=c.cpn,t=h.videoData.qd,u=n.j.videoData.clientPlaybackNonce,x=n.j.videoData.videoId,y=q!==u&&m!==x;u=p!==u&&l!==x;n.reportStats();n.adCpn&&n.adCpn!==p||(n.adCpn=u?p:"",n.V=u?l:"",n.adFormat=u?t:void 0,HKa(n,f?2:0,q,m,e),n.reportStats(),n.adCpn=y?q:"",n.V=y?m:"",n.adFormat=y?t:void 0,HKa(n,f?3:1,p,l,d),n.reportStats())}d=
a.logging;f=b.cpn;d.B.has(f)?(l=d.B.get(f),sR(l).send(),g.mq(l.B),l.B=NaN,d.u.U.K("watch_time_greater_than_playback_time_fix_killswitch")||f===d.u.videoData.clientPlaybackNonce||(tR(l),d.B.delete(f))):(d.Zg=d.u.videoData.clientPlaybackNonce,d.Zg&&d.j&&d.B.set(d.Zg,d.j));d=a.logging;f=c.cpn;h=h.videoData;l=e-a.En();if(d.B.has(f)){var z;null!=(z=d.B.get(f))&&z.C&&isNaN(z.B)&&qR(z,!1)}else z=cLa(d,d.u,h,l),d.B.set(f,z),TKa(z);d.Zg=f;z=a.videoData.clientPlaybackNonce;a=c.videoData;b=(b.cpn===z?"video":
"ad")+"_to_"+(c.cpn===z?"video":"ad");z={};!a.K("web_player_csi_ctt_killswitch")&&a.J&&(z.cttAuthInfo={token:a.J,videoId:a.videoId});z.startTime=e;ow(b,z);nw({targetVideoId:a.videoId,targetCpn:c.cpn},b);mw("pbs",e,b)}}};
zNa=function(a,b){if(dC(a.U)){var c=g.eA(a.U.experiments,"html5_log_rebuffer_events");if(c&&a.mediaElement){var d=a.mediaElement.Nb();d.rt=(1E3*g.GN(a.logging.u)).toFixed();d.e=b.substr(0,3);a.TC[a.wQ++%c]=d}}};
ANa=function(a){if(dC(a.U)){a.TC.sort(function(d,e){return+d.rt-+e.rt});
for(var b=g.r(a.TC),c=b.next();!c.done;c=b.next())c=c.value,a.ra("vpe",Object.assign({t:c.rt},c));a.TC=[];a.wQ=0}};
BNa=function(a){if(Aq("cobalt")&&Aq("nintendo switch")){var b=!window.matchMedia("screen and (max-height: 720px) and (min-resolution: 200dpi)").matches;a.ra("nxdock",{d:b})}};
VFa=function(a,b,c,d,e){a.ra("xvt",{m:b,g:1,tt:c?1:0,np:d?1:0,c:e})};
IS=function(a,b){var c;null==(c=a.Fa)||qQ(c,b||oNa(a))};
oNa=function(a){var b=a.K("disable_prefetch_when_ad_pending_for_living_room")&&g.oB(a.U),c=a.K("disable_prefetch_when_ad_pending_for_web");return(b||c)&&g.Xb(a.Tj,"ad")};
g.QS=function(a,b,c){g.I.call(this);var d=this;this.logger=new g.qO("App");this.Ky=this.Ah=!1;this.Ws={};this.Xt=new BCa;this.aD={};this.Nv=[];this.uO=!1;this.rH=null;this.yO=!1;this.Or=!0;this.zJ=!1;this.QO=this.EH=null;this.XO=!0;this.mediaElement=this.tb=null;this.cz=!1;this.eR=this.mz=this.Db=this.playlist=null;this.Gz=void 0;this.rq=0;this.zd=this.pw=this.nk=null;this.useLivingRoomPoToken=!1;this.config=pqa(b||{});this.webPlayerContextConfig=c;boa();b=this.config.args||{};this.U=new qB(b,c,c?
c.canaryState:this.config.assets.player_canary_state);g.J(this,this.U);this.yF();this.U.isMobile&&!CNa&&(window.addEventListener(UA?"touchstart":"click",PFa,{capture:!0,passive:!0}),CNa=!0);this.useLivingRoomPoToken=!(null==c||!c.useLivingRoomPoToken);this.K("html5_generate_session_po_token")&&!this.useLivingRoomPoToken&&(this.K("html5_webpo_idle_priority_job")?g.lr(g.nr(),function(){DNa(d)}):DNa(this));
this.K("html5_onesie")&&(this.us=new pN(this.U),g.J(this,this.us));this.qR=Qq($A(this.U)&&!0,b.enablesizebutton);this.xH=Qq(!1,b.player_wide);this.visibility=new JN;g.J(this,this.visibility);this.setIsExternalPlaylist(b.external_list);this.events=new g.kz(this);g.J(this,this.events);this.Zn=new sO;g.J(this,this.Zn);this.An=new sO;g.J(this,this.An);this.Jp=new VGa;this.Oa=new g.BI(this);g.J(this,this.Oa);this.template=new AO(this);g.J(this,this.template);this.appState=1;this.lh=this.U.storeUserVolume?
Lua():{volume:100,muted:this.U.mute};this.G=this.U.B?new AI(this,1):new uI(this,1);g.J(this,this.G);c={};this.xF=(c.internalvideodatachange=this.iY,c.playbackready=this.kY,c.playbackstarted=this.lY,c.statechange=this.mY,c);this.ZV=new OCa(this.Oa);g.J(this,this.ZV);this.yc=ENa(this);this.AX=new g.kz(this);g.J(this,this.AX);this.K("html5_enable_web_assembly")&&this.yc&&kDa(this.yc).then(function(e){d.U.vk=e});
this.zb=new NI(this.U,this.yc);this.rb=FNa(this);c={};this.zQ=(c.airplayactivechange=this.onAirPlayActiveChange,c.airplayavailabilitychange=this.onAirPlayAvailabilityChange,c.beginseeking=this.gI,c.endseeking=this.lI,c.internalAbandon=this.qI,c.internalaudioformatchange=this.Sy,c.internalvideodatachange=this.onVideoDataChange,c.internalvideoformatchange=this.bz,c.liveviewshift=this.XY,c.playbackstalledatstart=this.m_,c.progresssync=this.EZ,c.onLoadProgress=this.onLoadProgress,c.SEEK_COMPLETE=this.HC,
c.SEEK_TO=this.b_,c.onVideoProgress=this.onVideoProgress,c.onLoadedMetadata=this.onLoadedMetadata,c.onAutoplayBlocked=this.onAutoplayBlocked,c.playbackready=this.uZ,c.statechange=this.nQ,c.connectionissue=this.Uy,c.newelementrequired=this.UP,c.heartbeatparams=this.Wy,c.videoelementevent=this.FI,c.drmoutputrestricted=this.onDrmOutputRestricted,c.signatureexpired=this.h_,c.nonfatalerror=this.lZ,c);this.Qp=new g.kz(this);g.J(this,this.Qp);c=10;g.oB(this.U)&&(c=3);TB(this.U)&&(c=g.eA(this.U.experiments,
"tvhtml5_unplugged_preload_cache_size"));this.tv=new rO;g.J(this,this.tv);this.iz=new oO(c,function(e){e!==g.KI(d,e.getPlayerType())&&e.dispose()});
g.J(this,this.iz);this.pG=this.oB=-1;this.nD=new g.K(this.template.resize,16,this.template);g.J(this,this.nD);GNa(this);this.jd=new dO(this.Oa,this.U,this.rb);this.nw=new DN(this);g.J(this,this.nw);KGa(this.U.deviceParams.c);this.events.P(this.Oa,g.Cv("appapi"),this.gY);this.events.P(this.Oa,g.Dv("appapi"),this.hY);this.events.P(this.Oa,g.Cv("appad"),this.AP);this.events.P(this.Oa,g.Dv("appad"),this.AP);this.events.P(this.Oa,g.Cv("appprogressboundary"),this.DZ);this.events.P(this.Oa,g.Dv("applooprange"),
this.pD);this.events.P(this.Oa,"presentingplayerstatechange",this.hh);this.events.P(this.Oa,"resize",this.PZ);this.template.xa(Sca(a));this.events.P(this.Oa,"offlineslatestatechange",this.nZ);this.pK=HNa(this,this.template.element);g.J(this,this.pK);this.yc.G.S().Vg&&fJ(this.yc,"offline");this.U.Hc&&g.VI("ux",g.nN);this.AM=new g.K(this.f0,g.eA(this.U.experiments,"html5_defer_fetch_att_ms"),this);g.J(this,this.AM);this.fd().isValid()&&(g.bv()&&this.fd().oa.push("remote"),OS(this),!this.U.K("html5_delay_initial_loading")&&
PS(this)&&(this.U.zi||this.U.Ze)&&g.FN(this.rb));this.zb.tick("fs");INa(this);this.Id=null;this.U.Hc&&hDa(this.yc);g.iB(this.yc.G.S())&&fJ(this.yc,"music");g.YA(this.yc.G.S())&&fJ(this.yc,"embed");this.K("web_player_sentinel_is_uniplayer")||g.Bu(new g.Ar("Player experiment flags missing","web_player_sentinel_is_uniplayer"));a=this.K("web_player_sentinel_yt_experiments_sync");c=g.Q("web_player_sentinel_yt_experiments_sync");a!==c&&g.Bu(new g.Ar("b/195699950",{yt:a,player:c}));this.SR=JNa(this);if(a=
g.eA(this.U.experiments,"html5_block_pip_safari_delay"))this.uG=new g.K(this.MM,a,this),g.J(this,this.uG);this.U.K("embeds_enable_pem_cookie_blocking_killswitch")||(wq=this.U.Ta);a=g.eA(this.U.experiments,"html5_performance_impact_profiling_timer_ms");0<a&&(this.rQ=new g.Zg(a),g.J(this,this.rQ),this.events.P(this.rQ,"tick",function(){d.sQ&&KNa.ip(d.sQ);d.sQ=KNa.mq("apit")}))};
JNa=function(a){function b(c){c.stack&&-1!==c.stack.indexOf("player")&&(a.Db||a.rb).logging.xd("player.exception",eC({n:c.name,m:c.message}))}
Cu.subscribe("handleError",b);Up.push(b);return function(){Cu.unsubscribe("handleError",b);var c=Up.indexOf(b);-1!==c&&Up.splice(c,1)}};
FNa=function(a){var b=new g.mD(a.U,a.config.args);b=a.Yo(1,b);b.setPlaybackRate(a.U.j?1:LNa(a,Number(g.$u("yt-player-playback-rate"))||1));g.ju(b,a.xF,a);return b};
ENa=function(a){var b="",c=QGa(a);0===c.indexOf("//")&&(c=a.U.protocol+":"+c);var d=c.lastIndexOf("/base.js");-1!==d&&(b=c.substring(0,d+1));if(c=Error().stack)if(c=c.match(/\((.*?\/(debug-)?player-.*?):\d+:\d+\)/))c=c[1],c.includes(b)||g.Bu(Error("Player module URL mismatch: "+(c+" vs "+b+".")));b=new cJ(a.Oa,b);MNa(a,b);return b};
MNa=function(a,b){var c={};c=(c.destroyed=function(){a.onApiChange()},c);
b.u=c};
NNa=function(a,b){var c=a.isVideoInfoVisible();a.nk||(a.nk=new IO(a.Oa),g.J(a,a.nk),g.II(a.Oa,a.nk.element,4));g.wG(a.nk,b);RS(a)&&c!==b&&EI(a.yc).RJ();a=a.Db;b&&a&&a.ra("sfn",{},!0)};
SS=function(a){a.mediaElement=a.U.deviceIsAudioOnly?new g.pJ(g.zg("AUDIO")):wN.pop()||new g.pJ(g.zg("VIDEO"));g.J(a,a.mediaElement);a.Db&&a.Db.setMediaElement(a.mediaElement);try{a.U.qc?(a.pw&&a.events.vc(a.pw),a.pw=a.events.P(a.mediaElement,"volumechange",a.fZ)):(a.mediaElement.Qv(a.lh.muted),a.mediaElement.setVolume(a.lh.volume/100))}catch(d){a.Ef("html5.missingapi",2,"UNSUPPORTED_DEVICE","setvolume.1;emsg."+(d.message&&d.message.replace(/[;:,]/g,"_")));return}g.hu(a.Qp);ONa(a);var b=a.template;
b.Hb=a.mediaElement.mf();b.SB=!1;b.Hb.parentNode||g.Cg(b.tx,b.Hb,0);b.YC=new g.Yk(0,0,0,0);UGa(b);BO(b);g.N(b.Hb,"video-stream");g.N(b.Hb,g.zO.MAIN_VIDEO);var c=b.app.S();c.Th&&b.Hb.setAttribute("data-no-fullscreen","true");c.gk&&(b.Hb.setAttribute("webkit-playsinline",""),b.Hb.setAttribute("playsinline",""));c.Ym&&b.Hb&&b.P(b.Hb,"click",b.Hb.play,b.Hb);try{a.mediaElement.Ut()}catch(d){a.Ef("html5.missingapi",2,"UNSUPPORTED_DEVICE","activate.1;emsg."+(d.message&&d.message.replace(/[;:,]/g,"_")))}};
IN=function(a,b){if(a.Db!==b){var c=null;if(a.Db){c=a.Db.getPlayerState();hJ(a.yc,3);TS(a,"cuerangesremoved",a.Db.Ek());a.nw&&!b.isGapless()&&a.Db.isGapless()&&a.mediaElement&&a.mediaElement.stopVideo();var d;if(d=a.zd)d=a.mediaElement,d=!!d&&d===a.zd.mediaElement;d&&(a.Kh(),SS(a));a.Db&&(a.Db.Kh(),ku(a.Db,a.zQ,a),1!==a.Db.getPlayerType()&&a.Db.dispose());a.Db=null}1===b.getPlayerType()&&a.rb!==b&&(b.getVideoData().autonavState=a.rb.getVideoData().autonavState,ku(a.rb,a.xF,a),d=a.rb.getPlaybackRate(),
a.rb.dispose(),a.rb=b,a.rb.setPlaybackRate(d),g.ju(b,a.xF,a),OS(a));d=b.getPlayerType();if(b!==a.rb&&b!==a.Ws[d]){var e;null==(e=a.Ws[d])||e.dispose();a.Ws[d]=b}a.Db=b;a.mediaElement&&b.setMediaElement(a.mediaElement);g.ju(b,a.zQ,a);if(b.fC())US(a,"setPresenting",!1,!0);else{a.onVideoDataChange("newdata",b,b.getVideoData());c&&!g.EF(c,b.getPlayerState())&&a.nQ(new g.TE(b.getPlayerState(),c));if(b.Xn.isFinished())a.onVideoDataChange("dataloaded",b,b.getVideoData());(c=(c=b.getVideoData().B)&&c.video)&&
a.Oa.La("onPlaybackQualityChange",c.quality);TS(a,"cuerangesadded",a.Db.Ek());c=b.getPlayerState();g.V(c,2)?PNa(a):g.V(c,8)&&b.playVideo()}}};
PNa=function(a){if(!QNa(a)){var b=a.rb.Hd();b&&(b=b.Gx(),b instanceof Promise&&b.catch(function(){}));
VS(a,IF(a.xb()))}};
ONa=function(a){var b=a.mediaElement;qz()?a.Qp.P(b,"webkitpresentationmodechanged",a.YZ):pz()&&(a.Qp.P(b,"enterpictureinpicture",function(){a.Rv(!0)}),a.Qp.P(b,"leavepictureinpicture",function(){a.Rv(!1)}));
eB&&(a.Qp.P(b,"webkitbeginfullscreen",function(){a.dk(3)}),a.Qp.P(b,"webkitendfullscreen",function(){a.dk(0)}))};
g.KI=function(a,b){return b?1===b?a.rb:a.getVideoData().enableServerStitchedDai&&2===b?!a.K("web_player_enable_preroll_for_ssdai_killswitch")&&a.getVideoData().enablePreroll?a.Ws[2]||a.Db:a.Db:a.Ws[b]||null:a.Db};
WS=function(a,b){return a.Ce(b)?a.rb:b};
XS=function(a,b){var c=a.Db;return c&&b===a.rb&&a.Ce(b)&&a.Ce(c)?c:b};
YS=function(a){if(!RS(a)){var b=iJ(a.yc);b&&!b.created&&eJ(a.yc)&&b.create()}};
RNa=function(a){var b=a.getVideoData(),c=a.yc;gJ(c)||c.WF();fJ(c,"attribution",!1,!0);fJ(c,"embed");fJ(c,"inline_preview");fJ(c,"kids");fJ(c,"remote");fJ(c,"miniplayer");fJ(c,"music");fJ(c,"offline");fJ(c,"unplugged");fJ(c,"ypc",!1,!0);fJ(c,"ypc_clickwrap",!1,!0);fJ(c,"yto",!1,!0);fJ(c,"webgl",!1,!0);c.I?0<c.B&&c.J&&c.J.start():(fJ(c,"captions",!0),fJ(c,"endscreen"),c.XF(),fJ(c,"creatorendscreen",!0));c.fN();gDa(c);a.Oa.X("videoready",b)};
PS=function(a){a=a.fd();a.isValid();return UD(a)};
INa=function(a){a.cG();var b=a.config.args;SS(a);var c=a.fd();a.Oa.La("onVolumeChange",a.lh);if(b&&QI(b)){var d=vB(a.U);d&&!a.Ah&&(b.fetch=0);var e=g.YA(a.U);e&&!a.Ah&&(b.fetch=0);ZS(a,b);g.YA(a.U)&&a.zb.tick("ep_pr_s");if(d&&!a.Ah)$S(a);else if(e&&!a.Ah)aT(a);else if(!c.isValid())a.playlist.onReady(function(){bT(a)})}IN(a,a.rb);
g.V(a.rb.getPlayerState(),128)||(b=cua(!a.U.deviceIsAudioOnly),"fmt.noneavailable"===b?a.Ef("html5.missingapi",2,"HTML5_NO_AVAILABLE_FORMATS_FALLBACK","nocodecs.1"):"html5.missingapi"===b?a.Ef(b,2,"UNSUPPORTED_DEVICE","nocanplaymedia.1"):c&&c.isValid()&&PS(a)&&(a.U.zi||a.U.Ze)?cT(a):g.$u("yt-player-playback-on-reload")?(g.vr("embedsItpPlayedOnReload",{playedOnReload:!0,isLoggedIn:!!a.U.authUser}),Sua(!1),cT(a)):$B(a.U)||SNa(a),g.SB(a.U)||"MWEB"===mB(a.U)?(g.lr(g.nr(),function(){dT(a)}),g.lr(g.nr(),
function(){ZBa()})):(dT(a),ZBa()))};
dT=function(a){if(a.K("fetch_att_independently"))g.Fn(a.AM);else{var b=a.getVideoData().botguardData;b&&(a.getVideoData(),g.kI(b,a.U))}};
SNa=function(a){a.Oa.X("initializingmode");a.Km(2);fJ(a.yc,"remote");a.U.K("player_cued_miniplayer_module_killswitch")||fJ(a.yc,"miniplayer")};
cT=function(a){if(g.V(a.rb.getPlayerState(),128))return!1;PS(a)&&a.U.Ze&&(wN.length&&a.Ky?(wI(a,{muted:!1,volume:a.lh.volume},!1),eT(a,!1)):wN.length||a.lh.muted||(wI(a,{muted:!0,volume:a.lh.volume},!1),eT(a,!0)));var b=a.rb.getVideoData();b.xP&&wI(a,{muted:!0,volume:a.lh.volume},!1);fT(a,1,b,!1);a.Oa.X("initializingmode");IN(a,a.rb);a.Km(3);if(!(b=!a.U.zl)){if(b=a.zd)b=a.mediaElement,b=!!b&&b===a.zd.mediaElement;b=b&&a.uO}b&&(a.Kh(),SS(a),a.rb.setMediaElement(a.mediaElement));BS(a.rb);if(g.V(a.rb.getPlayerState(),
128))return!1;VS(a,3);return a.uO=!0};
DNa=function(a){var b=a.K("html5_po_token_enable_webpo_experimental")?"UE0a2bupPZ6aUyyLkkEY":"Z1elNkAKLpSR3oPOUMSN",c=a.K("html5_po_token_enable_webpo_experimental")?"bxNLZUJrsnkb8KzwCOTR":"O43z0dpjhgX20SCx4KAo";b=g.oB(a.U)?b:c;a.K("html5_placeholder_po_tokens")&&(b="2ZCPXHYZSpebQXqOYNtj");try{if(a.qw=Gfa({Qg:b,onError:function(e){g.Bu(e)}}),!a.K("html5_generate_content_po_token")){a.qw.ready().then(function(){TNa(a)});
var d=g.eA(a.U.experiments,"html5_session_po_token_interval_time_ms");0<d&&(a.rJ=g.lq(function(){TNa(a)},d))}}catch(e){e instanceof Error&&g.Bu(e)}};
TNa=function(a){var b,c,d,e;g.B(function(f){if(!a.K("html5_generate_session_po_token")||null==(b=a.qw)||!b.isReady()||a.useLivingRoomPoToken)return f.return();c=a.K("enable_web_eom_visitor_data")?g.P("EOM_VISITOR_DATA")||g.P("VISITOR_DATA"):g.P("VISITOR_DATA");d=a.U.Ql?a.U.datasyncId:c;e=a.U.livingRoomPoTokenId||d;a.U.Me=UNa(a,e);g.va(f)})};
UNa=function(a,b){var c;if(null==(c=a.qw)||!c.isReady())return"";try{var d=a.qw.uv({vx:b});return g.Cc(d,2)}catch(e){return g.Bu(e),""}};
iNa=function(a,b){return g.B(function(c){return a.qw?c.return(a.qw.ready().then(function(){return UNa(a,b)})):c.return(Promise.reject("web po not ready"))})};
RS=function(a){a=EI(a.yc);return!!a&&a.loaded};
VNa=function(a,b){if(!a.tb)return!1;var c=.001*a.tb.startTimeMs-1,d=.001*a.tb.endTimeMs;"repeatChapter"===a.tb.type&&d--;return $f(b,c)||$f(b,d)||b>=c&&b<=d};
WNa=function(a){if(!(g.V(a.rb.getPlayerState(),64)&&a.fd().isLivePlayback&&5E3>a.tb.startTimeMs)){if(a.K("web_repeating_chapters")&&"repeatChapter"===a.tb.type){var b,c=null==(b=xI(a.ib()))?void 0:b.Du(),d;b=null==(d=a.getVideoData())?void 0:d.Ag;c instanceof g.LJ&&b&&(d=b[MK(b,a.tb.startTimeMs)],c.ZI(0,d.title));isNaN(Number(a.tb.loopCount))?a.tb.loopCount=0:a.tb.loopCount++;1===a.tb.loopCount&&a.G.La("innertubeCommand",a.getVideoData().MS)}a.rb.seekTo(.001*a.tb.startTimeMs,{Ee:"application_loopRangeStart"})}};
LNa=function(a,b){var c=a.Oa.getAvailablePlaybackRates();b=Number(b.toFixed(2));a=c[0];c=c[c.length-1];b<=a?b=a:b>=c?b=c:(a=Math.floor(100*b+.001)%5,b=0===a?b:Math.floor(100*(b-.01*a)+.001)/100);return b};
hT=function(a,b,c){if(a.Ce(c)){c=c.getVideoData();if(gT(a))c=b;else{a=a.jd;for(var d=g.r(a.u),e=d.next();!e.done;e=d.next())if(e=e.value,c.Ac===e.Ac){b+=e.wc/1E3;break}d=b;a=g.r(a.u);for(e=a.next();!e.done;e=a.next()){e=e.value;if(c.Ac===e.Ac)break;var f=e.wc/1E3;if(f<b)d+=e.durationMs/1E3+f-e.Sc/1E3;else break}c=d}return c}return b};
XNa=function(a,b){if(3===a.getPresentingPlayerType())return IF(EI(a.yc).Rd);if(a.getVideoData().enableServerStitchedDai&&2===b){var c;return(null==(c=a.Id)?0:c.isAdPlaying(a.getCurrentTime()))?a.oB:-1}return 2!==b||a.Ce()?a.oB:a.pG};
OS=function(a){iT(a);a.setLoopVideo(!1);a.setLoopRange(null);a.Xt.Xt={};a.aD={};a.Nv=[];QCa(a.zb);if(a.Id){var b=a.Id,c=a.rb;c.getPlayerType();XN(b,!1);ZN(b);pGa(b);b.qa=c}b=a.jd;a=a.rb;1!==a.getPlayerType()&&eO(b,"invalidParentVideoPlayerType");jO(b,!1);lO(b);b.j=a};
$S=function(a){var b=YNa();if(b)if(!b.list)a.ju();else if(a.playlist&&a.playlist.getPlaylistId()===b.list)if(0<=b.index){var c=b.video;a.Oa.isFullscreen()&&((c=c[a.playlist.index])&&c.encrypted_id!==g.RI(a.playlist).videoId||(b.index=a.playlist.index));TI(a.playlist,b);a.mz&&jT(a,a.mz)}else a.mz=null};
aT=function(a,b){var c=(b?b:a.fd()).mS;a.zb.tick("ep_pr_r");if(null!=c&&(TI(a.playlist,c),a.zJ))a.playlist.onReady(function(){bT(a,b)})};
ZS=function(a,b){a.playlist&&(a.playlist.unsubscribe("error",a.ju,a),g.ze(a.playlist),a.playlist=null);b&&(a.Ah&&(b.fetch=0),a.playlist=new PI(a.U,b),a.playlist.subscribe("error",a.ju,a))};
bOa=function(a,b,c){if(!(c in b))return!1;b=b[c];Array.isArray(b)||(b=[b]);b=g.r(b);for(c=b.next();!c.done;c=b.next()){c=c.value;var d={CPN:a.getVideoData().clientPlaybackNonce};c=g.yn(c,d);d=void 0;d=void 0===d?!1:d;(d=tv(uv(c,ZNa),c,d,"Active View 3rd Party Integration URL"))||(d=void 0,d=void 0===d?!1:d,d=tv(uv(c,$Na),c,d,"Google/YouTube Brand Lift URL"));d||(d=void 0,d=void 0===d?!1:d,d=tv(uv(c,aOa),c,d,"Nielsen OCR URL"));g.Gs(c,void 0,d)}return!0};
VS=function(a,b){if(a.Db){var c=a.Db.getPlayerType();if(2===c&&!a.Ce()){a.pG!==b&&(a.pG=b,a.Oa.La("onAdStateChange",b));return}if(2===c&&a.Ce()||5===c||6===c||7===c)if(-1===b||0===b||5===b)return}a.K("clips_disable_end_when_looping")&&0===b&&a.tb||a.oB===b||(a.oB=b,a.Oa.La("onStateChange",b))};
fT=function(a,b,c,d){if(!f){var e=b+"_"+c.videoId+"_"+c.Ac;var f=a.iz.get(e);if(!f)return null;a.iz.remove(e);if(g.V(f.getPlayerState(),128))return f.dispose(),null}if(f===g.KI(a,b))return nw({isCacheHit:!0},a.zb.timerName),f;if((f.getVideoData().oauthToken||c.oauthToken)&&f.getVideoData().oauthToken!==c.oauthToken)return null;d||IN(a,f);nw({isCacheHit:!0},a.zb.timerName);return f};
kT=function(a,b,c){c=g.KI(a,c);b&&c===a.rb&&(c.getVideoData().zg=!0)};
lT=function(a,b,c){c=void 0===c?1:c;if(b.isValid()){var d=a.Yo(c,b);a.cancelPlayback(4,c);IN(a,d);2===c&&a.rb.Hv(b.clientPlaybackNonce,b.qd||"",b.breakType||0,b.Me);1===c&&(a.Km(1),SNa(a))}else b.dispose(),g.ze(g.KI(a,c)),!a.K("web_player_clean_up_adplayer_for_preroll_on_ssdai_killswitch")&&Wxa(a.fd())&&2===c&&delete a.Ws[2]};
cOa=function(a,b,c,d,e){b=DCa(b,c,d,e);(c=g.YA(a.U)&&!a.U.N)&&!a.Ah&&(b.fetch=0);ZS(a,b);g.YA(a.U)&&a.zb.tick("ep_a_pr_s");if(c&&!a.Ah)c=a.fd(),VCa(c,b).then(function(f){a.zJ=!0;aT(a,f)});
else a.playlist.onReady(function(){bT(a)});
g.YA(a.U)&&a.zb.tick("ep_a_pr_r")};
bT=function(a,b){var c=g.YA(a.U)&&!a.U.N,d=c&&b?b:g.RI(a.playlist);b=c&&b?b:a.getVideoData();d&&(b.Fm&&(a.U.zi||a.U.Ze)||!a.Or?(b=b.zg,d=a.Op(d,1),b&&kT(a,d)):lT(a,d,1));g.YA(a.U)&&a.zb.tick("ep_p_l");a.zJ=!1;a.Oa.La("onPlaylistUpdate")};
QNa=function(a){if(a.playlist&&g.dB(a.U)&&a.Lx()){var b=a.U.K("html5_player_autonav_logging");a.nextVideo(!1,b);return!0}return!1};
jT=function(a,b){var c=g.La(b);c?((b=YNa())&&b.list&&c(),a.mz=null):a.mz=b};
YNa=function(){var a=g.La("yt.www.watch.lists.getState");return a?a():null};
mT=function(a,b,c,d,e,f){b={id:b,namespace:"appapi"};"chapter"===f?(b.style=zv.CHAPTER_MARKER,b.visible=!0):isNaN(e)||("ad"===f?b.style=zv.AD_MARKER:(b.style=zv.TIME_MARKER,b.color=e),b.visible=!0);a.hx([new g.Av(1E3*c,1E3*d,b)],1);return!0};
dOa=function(a,b,c,d,e){e=void 0===e?!0:e;var f=a.getIngestionTime();if(!f)return e&&a.getVideoData().isLivePlayback&&a.Nv.push({id:b,A1:c,z1:d}),!1;e=f-a.getCurrentTime();return mT(a,b,c-e,d-e)};
eOa=function(a,b){a.Nv=g.cm(a.Nv,function(f){return f.id!==b});
for(var c=a.rb.Ek(),d=0;d<c.length;d++){var e=c[d];if(e.getId()===b)return a.rb.removeCueRange(e),TS(a,"cuerangesremoved",[e]),!0}return!1};
fOa=function(a){var b=(0,g.R)(),c=a.getCurrentTime();a=a.getVideoData();c=1E3*(c-a.startSeconds);a.isLivePlayback&&(c=0);return b-Math.max(c,0)};
wI=function(a,b,c){a.U.ma&&(a.lh=b,b.muted||eT(a,!1),c&&a.U.storeUserVolume&&!a.U.qc&&(c={volume:Math.floor(b.volume),muted:b.muted},c.unstorable||(g.Zu("yt-player-volume",c),g.Zu("yt-player-volume",c,2592E3))),gOa(a),c=g.oz&&a.mediaElement&&!a.mediaElement.dg(),a.U.qc&&!c||a.Oa.La("onVolumeChange",{muted:b.muted,volume:b.volume,unstorable:!a.U.storeUserVolume}))};
gOa=function(a){var b=a.getVideoData();if(!b.Sh){b=a.U.qc?1:Uxa(b);var c=a.mediaElement;c.Qv(a.lh.muted);try{c.setVolume(a.lh.volume*b/100)}catch(d){g.Bu(new g.Ar("b183742307","multiplier: "+b+", volume: "+a.lh.volume))}}};
eT=function(a,b){b!==a.Ky&&(a.Ky=b,a.Oa.La("onMutedAutoplayChange",b))};
nT=function(a){var b=cu(!0);return b&&(b===a.template.element||a.mediaElement&&b===a.mediaElement.mf())?b:null};
iOa=function(a,b){var c=window.screen&&window.screen.orientation;if((a.U.K("lock_fullscreen2")||a.U.I)&&c&&c.lock&&(!g.oz||!hOa))if(b){b=0===c.type.indexOf("portrait");var d=a.template.getVideoAspectRatio(),e=b;1>d?e=!0:1<d&&(e=!1);if(!a.cz||e!==b){c=c.lock(e?"portrait":"landscape");if(null!=c)c["catch"](function(){});
a.cz=!0}}else a.cz&&(a.cz=!1,c.unlock())};
TS=function(a,b,c){a.Oa.X(b,c);var d=g.oB(a.U)||g.fB(a.U)||g.gB(a.U);if(c&&d){switch(b){case "cuerangemarkersupdated":var e="onCueRangeMarkersUpdated";break;case "cuerangesadded":e="onCueRangesAdded";break;case "cuerangesremoved":e="onCueRangesRemoved"}e&&a.Oa.La(e,c.map(function(f){return{getId:function(){return this.id},
end:f.end,id:f.getId(),namespace:"ad"===f.namespace?"ad":"",start:f.start,style:f.style,visible:f.visible}}))}};
oT=function(a,b,c,d,e,f){c=void 0===c?!0:c;f=void 0===f?!1:f;var h=g.KI(a,e);if(!h||(2!==h.getPlayerType()||a.Ce(h)||f)&&!g.KD(h.getVideoData()))3===a.getPresentingPlayerType()?EI(a.yc).Em("control_seek",b,c):(h===a.rb&&a.tb&&!VNa(a,b)&&a.setLoopRange(null),a.seekTo(b,c,d,e))};
pT=function(a){a.Oa.La("SIZE_CLICKED",!a.xH)};
US=function(a,b,c,d){c&&(a.Kh(),SS(a));c=g.KI(a);c.xd(new fC("staleconfig",{reason:b}));var e=a.getVideoData(),f={};f.video_id=e.videoId;f.adformat=e.adFormat;e.isLivePlayback?tD(e)&&g.UB(a.U)&&(f.live_utc_start=c.getIngestionTime(),f.resume="1"):(f.start=c.getCurrentTime(),f.resume="1");e.Pa&&(f.vvt=e.Pa);e.J&&(f.vss_credentials_token=e.J,f.vss_credentials_token_type=e.qj);e.oauthToken&&(f.oauth_token=e.oauthToken);e.Xh&&(f.force_gvi=e.Xh);f.autoplay=1;f.reload_count=e.Zb+1;f.reload_reason=b;e.Xw&&
(f.unplugged_partner_opt_out=e.Xw);e.ge&&(f.ypc_is_premiere_trailer=e.ge);e.playerParams&&(f.player_params=e.playerParams);a.loadVideoByPlayerVars(f,void 0,d);"signature"===b&&a.Id&&YS(a)};
jOa=function(a,b){a.fd().autonavState=b;g.Zu("yt-player-autonavstate",b);a.Oa.X("autonavchange",b)};
kOa=function(a){var b=a.getVideoData().Sh,c=a.U.Yc,d=a.isInline()&&!a.getVideoData().dH,e=a.mediaElement;b||c||d?e.eG():(e.hG(),wI(a,a.lh))};
HNa=function(a,b){return a.U.K("html5_enable_embedded_player_visibility_signals")&&g.YA(a.U)?new yO(b):null};
iT=function(a){(a=iJ(a.ib()))&&a.created&&a.destroy()};
gT=function(a){return(a.K("html5_halftime_limit_timeline_usage_killswitch")||a.getVideoData().enableServerStitchedDai)&&!!a.Id};
lOa=function(a,b){b.bounds=a.getBoundingClientRect();for(var c=g.r(["display","opacity","visibility","zIndex"]),d=c.next();!d.done;d=c.next())d=d.value,b[d]=dl(a,d);b.hidden=!!a.hidden};
GNa=function(a){var b=a.U,c=document,d=c.requestStorageAccess&&c.hasStorageAccess;b.K("embeds_enable_request_storage_access_safari_itp")&&g.Ir&&d&&b.j?Jq()||b.Ta?(g.vr("embedsStorageAccessNotChecked",{isIosWebview:Jq(),isPemPlayer:b.Ta}),a.Gz=!1):c.hasStorageAccess().then(function(e){g.vr("embedsHasStorageAccessResult",{hasCookieAccess:e,resultedInError:!1});a.Gz=!e},function(e){g.vr("embedsHasStorageAccessResult",{hasCookieAccess:!1,
resultedInError:!0});g.Bu(Error("Embeds ITP Error: "+e));a.Gz=!1}):a.Gz=!1};
mOa=function(a,b){return g.oB(a.U)&&gq(b)&&fq(b)?g.cC(a.U,g.WD(a.getVideoData())).then(function(c){var d;c&&(d={Authorization:"Bearer "+c});return d},void 0):vq()};
qT=function(a,b){mOa(a,b).then(function(c){g.Gs(b,void 0,void 0,c)})};
rT=function(a,b){b.forEach(function(c){qT(a,c)})};
QGa=function(a){return a.webPlayerContextConfig?a.webPlayerContextConfig.jsUrl:a.config.assets&&a.config.assets.js?a.config.assets.js:""};
nOa=function(a){var b;a=null==(b=xI(a.ib()))?void 0:b.Du();if(!(a instanceof g.LJ))return null;var c;return(null==(c=a.VN())?void 0:c.V)||null};
oOa=function(a,b,c,d){var e=1E3*a.getCurrentTime()<c?1:-1;b.ZI(e,d);oT(a,c/1E3)};
sT=function(a){var b=new Map;a.forEach(function(c){b.set(c.getType(),c)});
this.j=b};
jv=function(a,b){return a.j.has(b)};
X=function(a,b){a=a.j.get(b);if(void 0!==a)return a.get()};
tT=function(a){return Array.from(a.j.keys())};
qOa=function(a){var b;return(null==(b=pOa.get(a))?void 0:b.Qs)||"ADS_CLIENT_EVENT_TYPE_UNSPECIFIED"};
vT=function(a,b){var c={type:b.slotType,controlFlowManagerLayer:rOa.get(b.Xa)||"CONTROL_FLOW_MANAGER_LAYER_UNSPECIFIED"};b.Lb&&(c.entryTriggerType=b.Lb.triggerType);1!==b.slotPhysicalPosition&&(c.slotPhysicalPosition=b.slotPhysicalPosition);if(a){c.debugData={slotId:b.slotId};if(a=b.Lb)c.debugData.slotEntryTriggerData=uT(a);a=b.Xb;c.debugData.fulfillmentTriggerData=[];a=g.r(a);for(var d=a.next();!d.done;d=a.next())c.debugData.fulfillmentTriggerData.push(uT(d.value));b=b.lc;c.debugData.expirationTriggerData=
[];b=g.r(b);for(a=b.next();!a.done;a=b.next())c.debugData.expirationTriggerData.push(uT(a.value))}return c};
sOa=function(a,b){var c={type:b.layoutType,controlFlowManagerLayer:rOa.get(b.Xa)||"CONTROL_FLOW_MANAGER_LAYER_UNSPECIFIED"};a&&(c.debugData={layoutId:b.layoutId});return c};
uT=function(a,b){var c={type:a.triggerType};null!=b&&(c.category=b);null!=a.Sg&&(c.triggerSourceData||(c.triggerSourceData={}),c.triggerSourceData.associatedSlotId=a.Sg);null!=a.wf&&(c.triggerSourceData||(c.triggerSourceData={}),c.triggerSourceData.associatedLayoutId=a.wf);return c};
tOa=function(a,b,c,d){b={opportunityType:b};a&&(d||c)&&(d=g.kk(d||[],function(e){return vT(a,e)}),b.debugData=Object.assign({},c&&0<c.length?{associatedSlotId:c}:{},0<d.length?{slots:d}:{}));
return b};
yT=function(a,b){return function(c){return wT(xT(a),b.slotId,b.slotType,b.slotPhysicalPosition,b.Xa,b.Lb,b.Xb,b.lc,c.layoutId,c.layoutType,c.Xa)}};
wT=function(a,b,c,d,e,f,h,l,m,n,p){return{adClientDataEntry:{slotData:vT(a,{slotId:b,slotType:c,slotPhysicalPosition:d,Xa:e,Lb:f,Xb:h,lc:l,Aa:new sT([])}),layoutData:sOa(a,{layoutId:m,layoutType:n,Xa:p,wd:[],Pc:[],Lc:[],Qc:[],Tc:[],Qb:new Map,Aa:new sT([]),xc:{}})}}};
uOa=function(){return!0};
zT=function(a){this.u=uOa;this.Ja=a;a=Math.random();var b=this.Ja.get();b=g.eA(b.G.S().experiments,"html5_debug_data_log_probability");b=Number.isFinite(b)&&0<=b&&1>=b?b:0;this.j=a<b};
xT=function(a){var b;(b=a.j)||(a=a.Ja.get(),b=a.G.S().K("html5_force_debug_data_for_client_tmp_logs")||a.G.S().K("html5_force_debug_data_for_client_tmp_logs_live_infra"));return b};
vOa=function(a,b){var c={slotId:ov(b,"SLOT_TYPE_IN_PLAYER"),slotType:"SLOT_TYPE_IN_PLAYER",slotPhysicalPosition:1,Lb:void 0,Xb:[],lc:[],Xa:"surface",Aa:new sT([])},d=Object,e=d.assign;b=pv(b,"LAYOUT_TYPE_TEXT_BANNER_OVERLAY",c.slotId);b={layoutId:b,layoutType:"LAYOUT_TYPE_TEXT_BANNER_OVERLAY",Qb:new Map,wd:[],Pc:[],Lc:[],Qc:[],Tc:[],Xa:"surface",Aa:new sT([]),xc:wT(!1,c.slotId,c.slotType,c.slotPhysicalPosition,c.Xa,c.Lb,c.Xb,c.lc,b,"LAYOUT_TYPE_TEXT_BANNER_OVERLAY","surface")};return e.call(d,{},
a,{ZW:!0,slot:c,layout:b})};
AT=function(a){this.controller=a};
BT=function(a){this.TF=a};
CT=function(a,b,c){this.TF=a;this.Bi=b;this.Kj=c};
wOa=function(a,b,c){var d=a.TF();switch(b.type){case "SKIP":pAa(d,a.Bi,a.Kj,c)}};
DT=function(){};
ET=function(){};
FT=function(a,b){this.Zk=a;this.U_=b};
GT=function(a,b){this.Qq=a;this.Na=b};
HT=function(a){this.G=a};
IT=function(a,b){this.Uj=a;this.Na=b};
yOa=function(a){g.I.call(this);this.j=a;this.sU=xOa(this)};
xOa=function(a){var b=new lG(a.j.Vc);g.J(a,b);a=g.r([new AT(a.j.fV),new GT(a.j.Qq,a.j.Na),new HT(a.j.G),new IT(a.j.Uj,a.j.Na),new CT(a.j.LX,a.j.Bi,a.j.Kj),new BT(a.j.wV),new ET,new FT(a.j.Zk,a.j.yh),new DT]);for(var c=a.next();!c.done;c=a.next())c=c.value,hAa(b,c),iAa(b,c);a=g.r(["adInfoDialogEndpoint","adFeedbackEndpoint"]);for(c=a.next();!c.done;c=a.next())jG(b,c.value,function(){});
return b};
JT=function(a){this.value=a};
KT=function(a){this.value=a};
LT=function(a){this.value=a};
MT=function(a){this.value=a};
NT=function(a){this.value=a};
OT=function(){JT.apply(this,arguments)};
PT=function(a){this.value=a};
QT=function(a){this.value=a};
RT=function(a){this.value=a};
ST=function(a){this.value=a};
TT=function(a){this.value=a};
UT=function(a){this.value=a};
VT=function(a){this.value=a};
WT=function(a){this.value=a};
XT=function(){JT.apply(this,arguments)};
ZT=function(){JT.apply(this,arguments)};
$T=function(a){this.value=a};
aU=function(a){this.value=a};
bU=function(a){this.value=a};
cU=function(a){this.value=a};
dU=function(a){this.value=a};
eU=function(a){this.value=a};
fU=function(a){this.value=a};
gU=function(a){this.value=a};
hU=function(a){this.value=a};
iU=function(a){this.value=a};
jU=function(a){this.value=a};
kU=function(a){this.value=a};
lU=function(a){this.value=a};
mU=function(a){this.value=a};
nU=function(a){this.value=a};
oU=function(a){this.value=a};
pU=function(a){this.value=a};
qU=function(a){this.value=a};
rU=function(a){this.value=a};
sU=function(a){this.value=a};
tU=function(a){this.value=a};
uU=function(a){this.value=a};
vU=function(a){this.value=a};
wU=function(a){this.value=a};
xU=function(a){this.value=a};
yU=function(a){this.value=a};
zU=function(a){this.value=a};
AU=function(a){this.value=a};
BU=function(a){this.value=a};
CU=function(a){this.value=a};
DU=function(a){this.value=a};
EU=function(a){this.value=a};
FU=function(a){this.value=a};
GU=function(){JT.apply(this,arguments)};
HU=function(a){this.value=a};
IU=function(){JT.apply(this,arguments)};
JU=function(){JT.apply(this,arguments)};
KU=function(){JT.apply(this,arguments)};
LU=function(){JT.apply(this,arguments)};
MU=function(){JT.apply(this,arguments)};
zOa=function(a,b){switch(a){case "TRIGGER_CATEGORY_LAYOUT_EXIT_NORMAL":return 0;case "TRIGGER_CATEGORY_LAYOUT_EXIT_USER_SKIPPED":return 1;case "TRIGGER_CATEGORY_LAYOUT_EXIT_USER_MUTED":return 2;case "TRIGGER_CATEGORY_SLOT_EXPIRATION":return 3;case "TRIGGER_CATEGORY_SLOT_FULFILLMENT":return 4;case "TRIGGER_CATEGORY_SLOT_ENTRY":return 5;case "TRIGGER_CATEGORY_LAYOUT_EXIT_USER_INPUT_SUBMITTED":return 6;case "TRIGGER_CATEGORY_LAYOUT_EXIT_USER_CANCELLED":return 7;default:return b(a),8}};
NU=function(a,b,c,d){g.I.call(this);this.je=b;this.Tb=c;this.Ja=d;this.j=a(this,this,this,this,this);g.J(this,this.j);a=g.r(b);for(b=a.next();!b.done;b=a.next())g.J(this,b.value)};
OU=function(a,b){a.je.add(b);a.Ja.get().G.S().K("html5_not_register_disposables_when_core_listens")||g.J(a,b)};
Lya=function(a,b){jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_SLOT_RECEIVED",b)};
Mya=function(a,b){jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_SLOT_SCHEDULED",b);a=g.r(a.je);for(var c=a.next();!c.done;c=a.next())c.value.Hi(b)};
Nya=function(a,b){jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_SLOT_ENTERED",b);a=g.r(a.je);for(var c=a.next();!c.done;c=a.next())c.value.Sf(b)};
Eya=function(a,b){jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_SLOT_EXITED",b);a=g.r(a.je);for(var c=a.next();!c.done;c=a.next())c.value.Tf(b)};
QU=function(a,b,c){T(c,b,void 0,void 0,c.Rq);PU(a,b,!0)};
COa=function(a,b,c){if(RU(a.j,b))if(SU(a.j,b).C=c?"filled":"not_filled",null===c){TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_SLOT_FULFILLED_EMPTY",b);c=g.r(a.je);for(var d=c.next();!d.done;d=c.next())d.value.Xk(b);PU(a,b,!1)}else{TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_SLOT_FULFILLED_NON_EMPTY",b,c);TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_LAYOUT_RECEIVED",b,c);if(d=X(c.Aa,"metadata_type_sub_layouts")){d=g.r(d);for(var e=d.next();!e.done;e=d.next())TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_LAYOUT_RECEIVED",b,e.value)}e=g.r(a.je);for(d=e.next();!d.done;d=
e.next())d.value.Yk(b);if(RU(a.j,b))if(SU(a.j,b).D)PU(a,b,!1);else{TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_SCHEDULE_LAYOUT_REQUESTED",b,c);try{var f=a.j;if(!SU(f,b))throw new UU("Unknown slotState for onLayout");if(!f.ue.Qn.get(b.slotType))throw new UU("No LayoutRenderingAdapterFactory registered for slot of type: "+b.slotType);if(g.Yb(c.wd)&&g.Yb(c.Pc)&&g.Yb(c.Lc)&&g.Yb(c.Qc)&&g.Yb(c.Tc))throw new UU("Layout has no exit triggers.");VU(f,"TRIGGER_CATEGORY_LAYOUT_EXIT_NORMAL",c.wd);VU(f,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_SKIPPED",
c.Pc);VU(f,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_MUTED",c.Lc);VU(f,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_INPUT_SUBMITTED",c.Qc);VU(f,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_CANCELLED",c.Tc)}catch(n){a.Ig(b,c,n);PU(a,b,!0);return}SU(a.j,b).I=!0;try{var h=a.j,l=SU(h,b),m=h.ue.Qn.get(b.slotType).get().Pe(h.C,h.u,b,c);m.init();l.layout=c;if(l.B)throw new UU("Already had LayoutRenderingAdapter registered for slot");l.B=m;WU(h,l,"TRIGGER_CATEGORY_LAYOUT_EXIT_NORMAL",c.wd);WU(h,l,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_SKIPPED",
c.Pc);WU(h,l,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_MUTED",c.Lc);WU(h,l,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_INPUT_SUBMITTED",c.Qc);WU(h,l,"TRIGGER_CATEGORY_LAYOUT_EXIT_USER_CANCELLED",c.Tc)}catch(n){XU(a,b);PU(a,b,!0);a.Ig(b,c,n);return}TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_LAYOUT_SCHEDULED",b,c);f=g.r(a.je);for(d=f.next();!d.done;d=f.next())d.value.Oj(b,c);XU(a,b);AOa(a,b)}else BOa(a.Ja.get())&&T("slot is unscheduled after been fulfilled.",b,c)}};
YU=function(a,b,c){"core"!==b.Xa&&TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_LAYOUT_RECEIVED",b,c)};
ZU=function(a,b,c){TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_LAYOUT_SCHEDULED",b,c);a=g.r(a.je);for(var d=a.next();!d.done;d=a.next())d.value.Oj(b,c)};
kF=function(a,b,c){a=g.r(a.je);for(var d=a.next();!d.done;d=a.next())d.value.Pj(b,c)};
$U=function(a,b,c){TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_LAYOUT_ENTERED",b,c);a=g.r(a.je);for(var d=a.next();!d.done;d=a.next())d.value.Rc(b,c)};
fF=function(a,b,c,d){TU(a.Tb,qOa(d),b,c);a=g.r(a.je);for(var e=a.next();!e.done;e=a.next())e.value.hd(b,c,d)};
XU=function(a,b){if(RU(a.j,b)){SU(a.j,b).I=!1;var c=aV;b=SU(a.j,b);var d=[].concat(g.v(b.N));Zb(b.N);c(a,d)}};
aV=function(a,b){b.sort(function(f,h){function l(m){T("TriggerCategoryOrder enum does not contain trigger category: "+m)}
return f.category===h.category?f.trigger.triggerId.localeCompare(h.trigger.triggerId):zOa(f.category,l)-zOa(h.category,l)});
var c=new Map;b=g.r(b);for(var d=b.next();!d.done;d=b.next())if(d=d.value,RU(a.j,d.slot))if(SU(a.j,d.slot).I)SU(a.j,d.slot).N.push(d);else{DOa(a.Tb,d.slot,d,d.layout);var e=c.get(d.category);e||(e=[]);e.push(d);c.set(d.category,e)}b=g.r(EOa);for(d=b.next();!d.done;d=b.next())e=g.r(d.value),d=e.next().value,e=e.next().value,(d=c.get(d))&&FOa(a,d,e);(b=c.get("TRIGGER_CATEGORY_SLOT_EXPIRATION"))&&GOa(a,b);(b=c.get("TRIGGER_CATEGORY_SLOT_FULFILLMENT"))&&HOa(a,b);(c=c.get("TRIGGER_CATEGORY_SLOT_ENTRY"))&&
IOa(a,c)};
FOa=function(a,b,c){b=g.r(b);for(var d=b.next();!d.done;d=b.next())d=d.value,d.layout&&bV(a.j,d.slot)&&JOa(a,d.slot,d.layout,c)};
GOa=function(a,b){b=g.r(b);for(var c=b.next();!c.done;c=b.next())PU(a,c.value.slot,!1)};
HOa=function(a,b){b=g.r(b);for(var c=b.next();!c.done;c=b.next()){c=c.value;a:switch(SU(a.j,c.slot).C){case "not_filled":var d=!0;break a;default:d=!1}d&&(jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_FULFILL_SLOT_REQUESTED",c.slot),a.j.Jx(c.slot))}};
IOa=function(a,b){b=g.r(b);for(var c=b.next();!c.done;c=b.next()){c=c.value;jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_ENTER_SLOT_REQUESTED",c.slot);for(var d=g.r(a.je),e=d.next();!e.done;e=d.next())e.value.Rj(c.slot);try{var f=a.j,h=c.slot,l=SU(f,h);if(!l)throw new Jv("Got enter request for unknown slot");if(!l.u)throw new Jv("Tried to enter slot with no assigned slotAdapter");if("scheduled"!==l.j)throw new Jv("Tried to enter a slot from stage: "+l.j);if(cV(l))throw new Jv("Got enter request for already active slot");
for(var m=g.r(dV(f,h.slotType+"_"+h.slotPhysicalPosition).values()),n=m.next();!n.done;n=m.next()){var p=n.value;if(l!==p&&cV(p))throw new Jv("Trying to enter a slot when a slot of same type is already active.",{activeSlotStatus:p.j});}}catch(q){T(q,c.slot,eV(a.j,c.slot),void 0,q.Rq);PU(a,c.slot,!0);continue}c=SU(a.j,c.slot);"scheduled"!==c.j&&fV(c.slot,c.j,"enterSlot");c.j="enter_requested";c.u.lB()}};
AOa=function(a,b){if(RU(a.j,b)&&cV(SU(a.j,b))&&eV(a.j,b)&&!bV(a.j,b)){var c;TU(a.Tb,"ADS_CLIENT_EVENT_TYPE_ENTER_LAYOUT_REQUESTED",b,null!=(c=eV(a.j,b))?c:void 0);a=SU(a.j,b);"entered"!==a.j&&fV(a.slot,a.j,"enterLayoutForSlot");a.j="rendering";a.B.startRendering(a.layout)}};
JOa=function(a,b,c,d){if(RU(a.j,b)){var e=a.Tb,f;var h=(null==(f=pOa.get(d))?void 0:f.Gs)||"ADS_CLIENT_EVENT_TYPE_UNSPECIFIED";TU(e,h,b,c);a=SU(a.j,b);"rendering"!==a.j&&fV(a.slot,a.j,"exitLayout");a.j="rendering_stop_requested";a.B.Pf(c,d)}};
PU=function(a,b,c){if(RU(a.j,b)){a:switch(SU(a.j,b).j){case "exit_requested":var d=!0;break a;default:d=!1}if(!d)a:switch(SU(a.j,b).j){case "rendering_stop_requested":d=!0;break a;default:d=!1}if(d&&(SU(a.j,b).D=!0,!c))return;if(cV(SU(a.j,b)))SU(a.j,b).D=!0,KOa(a,b,c);else{a:switch(SU(a.j,b).C){case "fill_requested":c=!0;break a;default:c=!1}if(c)SU(a.j,b).D=!0,RU(a.j,b)&&(jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_CANCEL_SLOT_FULFILLMENT_REQUESTED",b),b=SU(a.j,b),b.C="fill_cancel_requested",b.J.IF());else{c=
eV(a.j,b);jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_UNSCHEDULE_SLOT_REQUESTED",b);d=SU(a.j,b);var e=b.Lb,f=d.oa.get(e.triggerId);f&&(f.hk(e),d.oa.delete(e.triggerId));e=g.r(b.Xb);for(f=e.next();!f.done;f=e.next()){f=f.value;var h=d.W.get(f.triggerId);h&&(h.hk(f),d.W.delete(f.triggerId))}e=g.r(b.lc);for(f=e.next();!f.done;f=e.next())if(f=f.value,h=d.V.get(f.triggerId))h.hk(f),d.V.delete(f.triggerId);null!=d.layout&&(e=d.layout,gV(d,e.wd),gV(d,e.Pc),gV(d,e.Lc),gV(d,e.Qc),gV(d,e.Tc));d.J=void 0;null!=d.u&&(d.u.release(),
d.u=void 0);null!=d.B&&(d.B.release(),d.B=void 0);d=a.j;SU(d,b)&&(d=dV(d,b.slotType+"_"+b.slotPhysicalPosition))&&d.delete(b.slotId);jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_SLOT_UNSCHEDULED",b);a=g.r(a.je);for(d=a.next();!d.done;d=a.next())d=d.value,d.Sj(b),c&&d.Pj(b,c)}}}};
KOa=function(a,b,c){if(RU(a.j,b)&&cV(SU(a.j,b))){var d=eV(a.j,b);if(d&&bV(a.j,b))JOa(a,b,d,c?"error":"abandoned");else{jF(a.Tb,"ADS_CLIENT_EVENT_TYPE_EXIT_SLOT_REQUESTED",b);try{var e=SU(a.j,b);if(!e)throw new Jv("Cannot exit slot it is unregistered");"enter_requested"!==e.j&&"entered"!==e.j&&"rendering"!==e.j&&fV(e.slot,e.j,"exitSlot");e.j="exit_requested";if(void 0===e.u)throw e.j="scheduled",new Jv("Cannot exit slot because adapter is not defined");e.u.nB()}catch(f){T(f,b,void 0,void 0,f.Rq)}}}};
LOa=function(a){this.slot=a;this.oa=new Map;this.W=new Map;this.V=new Map;this.Y=new Map;this.B=this.layout=this.u=this.J=void 0;this.I=this.D=!1;this.N=[];this.j="not_scheduled";this.C="not_filled"};
cV=function(a){return"enter_requested"===a.j||a.isActive()};
UU=function(a,b,c){c=void 0===c?!1:c;Za.call(this,a);this.Rq=c;this.args=[];b&&this.args.push(b)};
hV=function(a,b,c,d,e,f){g.I.call(this);this.ue=a;this.B=b;this.D=c;this.C=d;this.u=e;this.Ja=f;this.j=new Map};
dV=function(a,b){return(a=a.j.get(b))?a:new Map};
SU=function(a,b){return dV(a,b.slotType+"_"+b.slotPhysicalPosition).get(b.slotId)};
MOa=function(a){var b=[];a.j.forEach(function(c){c=g.r(c.values());for(var d=c.next();!d.done;d=c.next())b.push(d.value.slot)});
return b};
RU=function(a,b){return null!=SU(a,b)};
bV=function(a,b){a=SU(a,b);if(b=null!=a.layout)a:switch(a.j){case "rendering":case "rendering_stop_requested":b=!0;break a;default:b=!1}return b};
eV=function(a,b){(a=SU(a,b))?null!=a.layout&&!a.layout&&T("Unexpected empty layout",b):T("Unexpected undefined slotState",b);return(null==a?void 0:a.layout)||null};
iV=function(a,b,c){if(g.Yb(c))throw new Jv("No "+NOa.get(b)+" triggers found for slot.");c=g.r(c);for(var d=c.next();!d.done;d=c.next())if(d=d.value,!a.ue.nj.get(d.triggerType))throw new Jv("No trigger adapter registered for "+b+" trigger of type: "+d.triggerType);};
VU=function(a,b,c){c=g.r(c);for(var d=c.next();!d.done;d=c.next())if(d=d.value,!a.ue.nj.get(d.triggerType))throw new UU("No trigger adapter registered for "+NOa.get(b)+" trigger of type: "+d.triggerType);};
WU=function(a,b,c,d){d=g.r(d);for(var e=d.next();!e.done;e=d.next()){e=e.value;var f=a.ue.nj.get(e.triggerType);f.Yj(c,e,b.slot,b.layout?b.layout:null);b.Y.set(e.triggerId,f)}};
gV=function(a,b){b=g.r(b);for(var c=b.next();!c.done;c=b.next()){c=c.value;var d=a.Y.get(c.triggerId);d&&(d.hk(c),a.Y.delete(c.triggerId))}};
fV=function(a,b,c){T("Slot stage was "+b+" when calling method "+c,a)};
OOa=function(a){return jV(a.ws).concat(jV(a.nj)).concat(jV(a.Bn)).concat(jV(a.Ao)).concat(jV(a.Qn))};
jV=function(a){var b=[];a=g.r(a.values());for(var c=a.next();!c.done;c=a.next())c=c.value,c.Ej&&b.push(c);return b};
kV=function(a){g.I.call(this);this.j=a;this.u=POa(this)};
POa=function(a){var b=new NU(function(c,d,e,f){return new hV(a.j.ue,c,d,e,f,a.j.Ja)},new Set(OOa(a.j.ue).concat(a.j.listeners)),a.j.Tb,a.j.Ja);
g.J(a,b);return b};
lV=function(a){g.I.call(this);var b=this;this.u=a;this.j=null;g.Be(this,function(){g.ze(b.j);b.j=null})};
Y=function(a){return new lV(a)};
mV=function(a){this.j=a};
ZG=function(a,b,c,d){(a=a.j())||T("Could not initiate a command router instance.");a.executeCommand(b,c,d)};
nV=function(a,b,c,d){(a=a.j())||T("Could not initiate a command router instance.");mG(a,b,c,d)};
oV=function(a){return null!=(null==a?void 0:a.layoutId)&&null!=(null==a?void 0:a.layoutType)};
pV=function(a){var b,c=null==(b=a.config)?void 0:b.adPlacementConfig;a=a.renderer;return!(!c||null==c.kind||!a)};
QOa=function(a){return null!=a.linearAds&&oV(a.adLayoutMetadata)};
ROa=function(a){return null!=a.linearAd&&null!=a.adVideoStart};
TOa=function(a,b,c,d,e,f,h){b=Hra(b,f,Number(d.prefetchMilliseconds)||0,h);a=b instanceof Jv?b:SOa(a,d,e,b,c);return a instanceof Jv?a:[a]};
UOa=function(a){var b,c;return void 0!==(null==(b=a.renderer)?void 0:null==(c=b.adBreakServiceRenderer)?void 0:c.getAdBreakUrl)};
YOa=function(a,b,c,d,e){b=g.r(b);for(var f=b.next();!f.done;f=b.next())f=f.value,qV(a,f.renderer,f.config.adPlacementConfig.kind);a=Array.from(a.values()).filter(function(p){return VOa(p)});
b=[];f={};for(var h=g.r(a),l=h.next();!l.done;f={Al:f.Al},l=h.next()){f.Al=l.value;l={};for(var m=g.r(f.Al.sF),n=m.next();!n.done;l={xg:l.xg},n=m.next())l.xg=n.value,n=function(p,q){return function(t){return p.xg.YF(t,q.Al.instreamVideoAdRenderer.elementId,p.xg.rF)}}(l,f),l.xg.shouldRemoveCommandTriggeredCompanions?l.xg.isContentVideoCompanion?b.push(WOa(c,d,e,f.Al.instreamVideoAdRenderer.elementId,l.xg.associatedCompositePlayerBytesLayoutId,l.xg.adSlotLoggingData,n)):1<a.length?b.push(rV(c,d,e,f.Al.instreamVideoAdRenderer.elementId,
l.xg.adSlotLoggingData,function(p,q){return function(t){return p.xg.YF(t,q.Al.instreamVideoAdRenderer.elementId,p.xg.rF,p.xg.associatedCompositePlayerBytesLayoutId)}}(l,f))):b.push(rV(c,d,e,f.Al.instreamVideoAdRenderer.elementId,l.xg.adSlotLoggingData,n)):"AD_PLACEMENT_KIND_COMMAND_TRIGGERED"===l.xg.Vt?b.push(XOa(c,d,l.xg.wM,e,f.Al.instreamVideoAdRenderer.elementId,l.xg.adSlotLoggingData,n)):b.push(rV(c,d,e,f.Al.instreamVideoAdRenderer.elementId,l.xg.adSlotLoggingData,n))}return b};
qV=function(a,b,c){if(b=ZOa(b)){b=g.r(b);for(var d=b.next();!d.done;d=b.next())if((d=d.value)&&d.externalVideoId){var e=$Oa(a,d.externalVideoId);e.instreamVideoAdRenderer||(e.instreamVideoAdRenderer=d,e.XB=c)}else T("InstreamVideoAdRenderer without externalVideoId")}};
ZOa=function(a){var b=[],c=a.sandwichedLinearAdRenderer&&a.sandwichedLinearAdRenderer.linearAd&&a.sandwichedLinearAdRenderer.linearAd.instreamVideoAdRenderer;if(c)return b.push(c),b;if(a.instreamVideoAdRenderer)return b.push(a.instreamVideoAdRenderer),b;if(a.linearAdSequenceRenderer&&a.linearAdSequenceRenderer.linearAds){a=g.r(a.linearAdSequenceRenderer.linearAds);for(c=a.next();!c.done;c=a.next())c=c.value,c.instreamVideoAdRenderer&&b.push(c.instreamVideoAdRenderer);return b}return null};
VOa=function(a){if(void 0===a.instreamVideoAdRenderer)return T("AdPlacementSupportedRenderers without matching InstreamVideoAdRenderer"),!1;for(var b=g.r(a.sF),c=b.next();!c.done;c=b.next()){c=c.value;if(void 0===c.YF)return!1;if(void 0===c.rF)return T("AdPlacementConfig for AdPlacementSupportedRenderers that matches an InstreamVideoAdRenderer is undefined"),!1;if(void 0===a.XB||void 0===c.Vt||a.XB!==c.Vt&&"AD_PLACEMENT_KIND_COMMAND_TRIGGERED"!==c.Vt)return!1;if(void 0===a.instreamVideoAdRenderer.elementId)return T("InstreamVideoAdRenderer has no elementId",
void 0,void 0,{kind:a.XB,"matching APSR kind":c.Vt}),!1;if("AD_PLACEMENT_KIND_COMMAND_TRIGGERED"===c.Vt&&void 0===c.wM)return T("Command Triggered AdPlacementSupportedRenderer's AdPlacementRenderer does not have an element ID"),!1}return!0};
$Oa=function(a,b){a.has(b)||a.set(b,{instreamVideoAdRenderer:void 0,XB:void 0,adVideoId:b,sF:[]});return a.get(b)};
sV=function(a,b,c,d,e,f,h,l,m,n){f?$Oa(a,f).sF.push({wM:b,Vt:c,shouldRemoveCommandTriggeredCompanions:d,isCon/*
 * This file was automatically generated.
 * DO NOT MODIFY BY HAND.
 * Run `yarn special-lint-fix` to update
 */

import { Buffer } from "buffer";
import {
	ArrayExpression,
	ArrayPattern,
	ArrowFunctionExpression,
	AssignmentExpression,
	AssignmentPattern,
	AssignmentProperty,
	AwaitExpression,
	BigIntLiteral,
	BinaryExpression,
	BlockStatement,
	BreakStatement,
	CatchClause,
	ChainExpression,
	ClassBody,
	ClassDeclaration,
	ClassExpression,
	Comment,
	ConditionalExpression,
	ContinueStatement,
	DebuggerStatement,
	DoWhileStatement,
	EmptyStatement,
	ExportAllDeclaration,
	ExportDefaultDeclaration,
	ExportNamedDeclaration,
	ExportSpecifier,
	ExpressionStatement,
	ForInStatement,
	ForOfStatement,
	ForStatement,
	FunctionDeclaration,
	FunctionExpression,
	Identifier,
	IfStatement,
	ImportDeclaration,
	ImportDefaultSpecifier,
	ImportExpression,
	ImportNamespaceSpecifier,
	ImportSpecifier,
	LabeledStatement,
	LogicalExpression,
	MemberExpression,
	MetaProperty,
	MethodDefinition,
	NewExpression,
	ObjectExpression,
	ObjectPattern,
	PrivateIdentifier,
	Program,
	Property,
	PropertyDefinition,
	RegExpLiteral,
	RestElement,
	ReturnStatement,
	SequenceExpression,
	SimpleCallExpression,
	SimpleLiteral,
	SpreadElement,
	StaticBlock,
	Super,
	SwitchCase,
	SwitchStatement,
	TaggedTemplateExpression,
	TemplateElement,
	TemplateLiteral,
	ThisExpression,
	ThrowStatement,
	TryStatement,
	UnaryExpression,
	UpdateExpression,
	VariableDeclaration,
	VariableDeclarator,
	WhileStatement,
	WithStatement,
	YieldExpression
} from "estree";
import { ServerOptions as ServerOptionsImport } from "http";
import { ListenOptions, Server } from "net";
import { validate as validateFunction } from "schema-utils";
import { default as ValidationError } from "schema-utils/declarations/ValidationError";
import { ValidationErrorConfiguration } from "schema-utils/declarations/validate";
import {
	AsArray,
	AsyncParallelHook,
	AsyncSeriesBailHook,
	AsyncSeriesHook,
	AsyncSeriesWaterfallHook,
	HookMap,
	MultiHook,
	SyncBailHook,
	SyncHook,
	SyncWaterfallHook
} from "tapable";
import { SecureContextOptions, TlsOptions } from "tls";

declare class AbstractLibraryPlugin<T> {
	constructor(__0: {
		/**
		 * name of the plugin
		 */
		pluginName: string;
		/**
		 * used library type
		 */
		type: string;
	});

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	parseOptions(library: LibraryOptions): false | T;
	finishEntryModule(
		module: Module,
		entryName: string,
		libraryContext: LibraryContext<T>
	): void;
	embedInRuntimeBailout(
		module: Module,
		renderContext: RenderContext,
		libraryContext: LibraryContext<T>
	): undefined | string;
	strictRuntimeBailout(
		renderContext: RenderContext,
		libraryContext: LibraryContext<T>
	): undefined | string;
	runtimeRequirements(
		chunk: Chunk,
		set: Set<string>,
		libraryContext: LibraryContext<T>
	): void;
	render(
		source: Source,
		renderContext: RenderContext,
		libraryContext: LibraryContext<T>
	): Source;
	renderStartup(
		source: Source,
		module: Module,
		renderContext: StartupRenderContext,
		libraryContext: LibraryContext<T>
	): Source;
	chunkHash(
		chunk: Chunk,
		hash: Hash,
		chunkHashContext: ChunkHashContext,
		libraryContext: LibraryContext<T>
	): void;
	static COMMON_LIBRARY_NAME_MESSAGE: string;
}
declare interface AdditionalData {
	[index: string]: any;
	webpackAST: object;
}
declare class AggressiveMergingPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class AggressiveSplittingPlugin {
	constructor(options?: AggressiveSplittingPluginOptions);
	options: AggressiveSplittingPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static wasChunkRecorded(chunk: Chunk): boolean;
}
declare interface AggressiveSplittingPluginOptions {
	/**
	 * Extra cost for each chunk (Default: 9.8kiB).
	 */
	chunkOverhead?: number;

	/**
	 * Extra cost multiplicator for entry chunks (Default: 10).
	 */
	entryChunkMultiplicator?: number;

	/**
	 * Byte, max size of per file (Default: 50kiB).
	 */
	maxSize?: number;

	/**
	 * Byte, split point. (Default: 30kiB).
	 */
	minSize?: number;
}
declare interface AliasOption {
	alias: string | false | string[];
	name: string;
	onlyModule?: boolean;
}
type AliasOptionNewRequest = string | false | string[];
declare interface AliasOptions {
	[index: string]: AliasOptionNewRequest;
}
declare interface Argument {
	description: string;
	simpleType: "string" | "number" | "boolean";
	multiple: boolean;
	configs: ArgumentConfig[];
}
declare interface ArgumentConfig {
	description: string;
	negatedDescription?: string;
	path: string;
	multiple: boolean;
	type: "string" | "number" | "boolean" | "path" | "enum" | "RegExp" | "reset";
	values?: any[];
}
declare interface Asset {
	/**
	 * the filename of the asset
	 */
	name: string;

	/**
	 * source of the asset
	 */
	source: Source;

	/**
	 * info about the asset
	 */
	info: AssetInfo;
}
declare interface AssetEmittedInfo {
	content: Buffer;
	source: Source;
	compilation: Compilation;
	outputPath: string;
	targetPath: string;
}
type AssetFilterItemTypes =
	| string
	| RegExp
	| ((name: string, asset: StatsAsset) => boolean);

/**
 * Options object for data url generation.
 */
declare interface AssetGeneratorDataUrlOptions {
	/**
	 * Asset encoding (defaults to base64).
	 */
	encoding?: false | "base64";

	/**
	 * Asset mimetype (getting from file extension by default).
	 */
	mimetype?: string;
}
type AssetGeneratorOptions = AssetInlineGeneratorOptions &
	AssetResourceGeneratorOptions;
type AssetInfo = KnownAssetInfo & Record<string, any>;

/**
 * Generator options for asset/inline modules.
 */
declare interface AssetInlineGeneratorOptions {
	/**
	 * The options for data url generator.
	 */
	dataUrl?:
		| AssetGeneratorDataUrlOptions
		| ((
				source: string | Buffer,
				context: { filename: string; module: Module }
		  ) => string);
}

/**
 * Options object for DataUrl condition.
 */
declare interface AssetParserDataUrlOptions {
	/**
	 * Maximum size of asset that should be inline as modules. Default: 8kb.
	 */
	maxSize?: number;
}

/**
 * Parser options for asset modules.
 */
declare interface AssetParserOptions {
	/**
	 * The condition for inlining the asset as DataUrl.
	 */
	dataUrlCondition?:
		| AssetParserDataUrlOptions
		| ((
				source: string | Buffer,
				context: { filename: string; module: Module }
		  ) => boolean);
}

/**
 * Generator options for asset/resource modules.
 */
declare interface AssetResourceGeneratorOptions {
	/**
	 * Emit an output asset from this asset module. This can be set to 'false' to omit emitting e. g. for SSR.
	 */
	emit?: boolean;

	/**
	 * Specifies the filename template of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Emit the asset in the specified folder relative to 'output.path'. This should only be needed when custom 'publicPath' is specified to match the folder structure there.
	 */
	outputPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);
}
declare class AsyncDependenciesBlock extends DependenciesBlock {
	constructor(
		groupOptions: RawChunkGroupOptions & { name?: string } & {
			entryOptions?: EntryOptions;
		},
		loc?: SyntheticDependencyLocation | RealDependencyLocation,
		request?: string
	);
	groupOptions: RawChunkGroupOptions & { name?: string } & {
		entryOptions?: EntryOptions;
	};
	loc?: SyntheticDependencyLocation | RealDependencyLocation;
	request?: string;
	chunkName: string;
	module: any;
}
declare abstract class AsyncQueue<T, K, R> {
	hooks: {
		beforeAdd: AsyncSeriesHook<[T]>;
		added: SyncHook<[T]>;
		beforeStart: AsyncSeriesHook<[T]>;
		started: SyncHook<[T]>;
		result: SyncHook<[T, Error, R]>;
	};
	add(item: T, callback: CallbackAsyncQueue<R>): void;
	invalidate(item: T): void;

	/**
	 * Waits for an already started item
	 */
	waitFor(item: T, callback: CallbackAsyncQueue<R>): void;
	stop(): void;
	increaseParallelism(): void;
	decreaseParallelism(): void;
	isProcessing(item: T): boolean;
	isQueued(item: T): boolean;
	isDone(item: T): boolean;
	clear(): void;
}
declare class AsyncWebAssemblyModulesPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	renderModule(module?: any, renderContext?: any, hooks?: any): any;
	static getCompilationHooks(
		compilation: Compilation
	): CompilationHooksAsyncWebAssemblyModulesPlugin;
}
declare class AutomaticPrefetchPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type AuxiliaryComment = string | LibraryCustomUmdCommentObject;
declare interface BackendApi {
	dispose: (arg0?: Error) => void;
	module: (arg0: Module) => { client: string; data: string; active: boolean };
}
declare class BannerPlugin {
	constructor(options: BannerPluginArgument);
	options: BannerPluginOptions;
	banner: (data: { hash: string; chunk: Chunk; filename: string }) => string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type BannerPluginArgument =
	| string
	| BannerPluginOptions
	| ((data: { hash: string; chunk: Chunk; filename: string }) => string);
declare interface BannerPluginOptions {
	/**
	 * Specifies the banner.
	 */
	banner:
		| string
		| ((data: { hash: string; chunk: Chunk; filename: string }) => string);

	/**
	 * If true, the banner will only be added to the entry chunks.
	 */
	entryOnly?: boolean;

	/**
	 * Exclude all modules matching any of these conditions.
	 */
	exclude?: string | RegExp | Rule[];

	/**
	 * Include all modules matching any of these conditions.
	 */
	include?: string | RegExp | Rule[];

	/**
	 * If true, banner will not be wrapped in a comment.
	 */
	raw?: boolean;

	/**
	 * Include all modules that pass test assertion.
	 */
	test?: string | RegExp | Rule[];
}
declare interface BaseResolveRequest {
	path: string | false;
	descriptionFilePath?: string;
	descriptionFileRoot?: string;
	descriptionFileData?: object;
	relativePath?: string;
	ignoreSymlinks?: boolean;
	fullySpecified?: boolean;
}
declare abstract class BasicEvaluatedExpression {
	type: number;
	range: [number, number];
	falsy: boolean;
	truthy: boolean;
	nullish?: boolean;
	sideEffects: boolean;
	bool?: boolean;
	number?: number;
	bigint?: bigint;
	regExp?: RegExp;
	string?: string;
	quasis?: BasicEvaluatedExpression[];
	parts?: BasicEvaluatedExpression[];
	array?: any[];
	items?: BasicEvaluatedExpression[];
	options?: BasicEvaluatedExpression[];
	prefix?: BasicEvaluatedExpression;
	postfix?: BasicEvaluatedExpression;
	wrappedInnerExpressions: any;
	identifier?: string;
	rootInfo: VariableInfoInterface;
	getMembers: () => string[];
	expression: NodeEstreeIndex;
	isUnknown(): boolean;
	isNull(): boolean;
	isUndefined(): boolean;
	isString(): boolean;
	isNumber(): boolean;
	isBigInt(): boolean;
	isBoolean(): boolean;
	isRegExp(): boolean;
	isConditional(): boolean;
	isArray(): boolean;
	isConstArray(): boolean;
	isIdentifier(): boolean;
	isWrapped(): boolean;
	isTemplateString(): boolean;

	/**
	 * Is expression a primitive or an object type value?
	 */
	isPrimitiveType(): undefined | boolean;

	/**
	 * Is expression a runtime or compile-time value?
	 */
	isCompileTimeValue(): boolean;

	/**
	 * Gets the compile-time value of the expression
	 */
	asCompileTimeValue(): any;
	isTruthy(): boolean;
	isFalsy(): boolean;
	isNullish(): undefined | boolean;

	/**
	 * Can this expression have side effects?
	 */
	couldHaveSideEffects(): boolean;
	asBool(): any;
	asNullish(): undefined | boolean;
	asString(): any;
	setString(string?: any): BasicEvaluatedExpression;
	setUndefined(): BasicEvaluatedExpression;
	setNull(): BasicEvaluatedExpression;
	setNumber(number?: any): BasicEvaluatedExpression;
	setBigInt(bigint?: any): BasicEvaluatedExpression;
	setBoolean(bool?: any): BasicEvaluatedExpression;
	setRegExp(regExp?: any): BasicEvaluatedExpression;
	setIdentifier(
		identifier?: any,
		rootInfo?: any,
		getMembers?: any
	): BasicEvaluatedExpression;
	setWrapped(
		prefix?: any,
		postfix?: any,
		innerExpressions?: any
	): BasicEvaluatedExpression;
	setOptions(options?: any): BasicEvaluatedExpression;
	addOptions(options?: any): BasicEvaluatedExpression;
	setItems(items?: any): BasicEvaluatedExpression;
	setArray(array?: any): BasicEvaluatedExpression;
	setTemplateString(
		quasis?: any,
		parts?: any,
		kind?: any
	): BasicEvaluatedExpression;
	templateStringKind: any;
	setTruthy(): BasicEvaluatedExpression;
	setFalsy(): BasicEvaluatedExpression;
	setNullish(value?: any): BasicEvaluatedExpression;
	setRange(range?: any): BasicEvaluatedExpression;
	setSideEffects(sideEffects?: boolean): BasicEvaluatedExpression;
	setExpression(expression?: any): BasicEvaluatedExpression;
}
type BuildMeta = KnownBuildMeta & Record<string, any>;
declare abstract class ByTypeGenerator extends Generator {
	map: any;
}
declare const CIRCULAR_CONNECTION: unique symbol;
declare class Cache {
	constructor();
	hooks: {
		get: AsyncSeriesBailHook<
			[
				string,
				null | Etag,
				((result: any, callback: (arg0?: Error) => void) => void)[]
			],
			any
		>;
		store: AsyncParallelHook<[string, null | Etag, any]>;
		storeBuildDependencies: AsyncParallelHook<[Iterable<string>]>;
		beginIdle: SyncHook<[]>;
		endIdle: AsyncParallelHook<[]>;
		shutdown: AsyncParallelHook<[]>;
	};
	get<T>(
		identifier: string,
		etag: null | Etag,
		callback: CallbackCache<T>
	): void;
	store<T>(
		identifier: string,
		etag: null | Etag,
		data: T,
		callback: CallbackCache<void>
	): void;

	/**
	 * After this method has succeeded the cache can only be restored when build dependencies are
	 */
	storeBuildDependencies(
		dependencies: Iterable<string>,
		callback: CallbackCache<void>
	): void;
	beginIdle(): void;
	endIdle(callback: CallbackCache<void>): void;
	shutdown(callback: CallbackCache<void>): void;
	static STAGE_MEMORY: number;
	static STAGE_DEFAULT: number;
	static STAGE_DISK: number;
	static STAGE_NETWORK: number;
}
declare abstract class CacheFacade {
	getChildCache(name: string): CacheFacade;
	getItemCache(identifier: string, etag: null | Etag): ItemCacheFacade;
	getLazyHashedEtag(obj: HashableObject): Etag;
	mergeEtags(a: Etag, b: Etag): Etag;
	get<T>(
		identifier: string,
		etag: null | Etag,
		callback: CallbackCache<T>
	): void;
	getPromise<T>(identifier: string, etag: null | Etag): Promise<T>;
	store<T>(
		identifier: string,
		etag: null | Etag,
		data: T,
		callback: CallbackCache<void>
	): void;
	storePromise<T>(
		identifier: string,
		etag: null | Etag,
		data: T
	): Promise<void>;
	provide<T>(
		identifier: string,
		etag: null | Etag,
		computer: (arg0: CallbackNormalErrorCache<T>) => void,
		callback: CallbackNormalErrorCache<T>
	): void;
	providePromise<T>(
		identifier: string,
		etag: null | Etag,
		computer: () => T | Promise<T>
	): Promise<T>;
}
declare interface CacheGroupSource {
	key?: string;
	priority?: number;
	getName?: (
		module?: Module,
		chunks?: Chunk[],
		key?: string
	) => undefined | string;
	chunksFilter?: (chunk: Chunk) => boolean;
	enforce?: boolean;
	minSize: SplitChunksSizes;
	minSizeReduction: SplitChunksSizes;
	minRemainingSize: SplitChunksSizes;
	enforceSizeThreshold: SplitChunksSizes;
	maxAsyncSize: SplitChunksSizes;
	maxInitialSize: SplitChunksSizes;
	minChunks?: number;
	maxAsyncRequests?: number;
	maxInitialRequests?: number;
	filename?: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	idHint?: string;
	automaticNameDelimiter: string;
	reuseExistingChunk?: boolean;
	usedExports?: boolean;
}
declare interface CacheGroupsContext {
	moduleGraph: ModuleGraph;
	chunkGraph: ChunkGraph;
}
type CacheOptionsNormalized = false | FileCacheOptions | MemoryCacheOptions;
declare class CachedSource extends Source {
	constructor(source: Source);
	constructor(source: Source | (() => Source), cachedData?: any);
	original(): Source;
	originalLazy(): Source | (() => Source);
	getCachedData(): any;
}
type CallExpression = SimpleCallExpression | NewExpression;
declare interface CallExpressionInfo {
	type: "call";
	call: CallExpression;
	calleeName: string;
	rootInfo: string | VariableInfo;
	getCalleeMembers: () => string[];
	name: string;
	getMembers: () => string[];
}
declare interface CallbackAsyncQueue<T> {
	(err?: null | WebpackError, result?: T): any;
}
declare interface CallbackCache<T> {
	(err?: null | WebpackError, result?: T): void;
}
declare interface CallbackFunction<T> {
	(err?: null | Error, result?: T): any;
}
declare interface CallbackNormalErrorCache<T> {
	(err?: null | Error, result?: T): void;
}
declare interface CallbackWebpack<T> {
	(err?: Error, stats?: T): void;
}
type Cell<T> = undefined | T;
declare class Chunk {
	constructor(name?: string, backCompat?: boolean);
	id: null | string | number;
	ids: null | (string | number)[];
	debugId: number;
	name: string;
	idNameHints: SortableSet<string>;
	preventIntegration: boolean;
	filenameTemplate:
		| null
		| string
		| ((arg0: PathData, arg1?: AssetInfo) => string);
	cssFilenameTemplate:
		| null
		| string
		| ((arg0: PathData, arg1?: AssetInfo) => string);
	runtime: RuntimeSpec;
	files: Set<string>;
	auxiliaryFiles: Set<string>;
	rendered: boolean;
	hash?: string;
	contentHash: Record<string, string>;
	renderedHash?: string;
	chunkReason?: string;
	extraAsync: boolean;
	readonly entryModule?: Module;
	hasEntryModule(): boolean;
	addModule(module: Module): boolean;
	removeModule(module: Module): void;
	getNumberOfModules(): number;
	readonly modulesIterable: Iterable<Module>;
	compareTo(otherChunk: Chunk): 0 | 1 | -1;
	containsModule(module: Module): boolean;
	getModules(): Module[];
	remove(): void;
	moveModule(module: Module, otherChunk: Chunk): void;
	integrate(otherChunk: Chunk): boolean;
	canBeIntegrated(otherChunk: Chunk): boolean;
	isEmpty(): boolean;
	modulesSize(): number;
	size(options?: ChunkSizeOptions): number;
	integratedSize(otherChunk: Chunk, options: ChunkSizeOptions): number;
	getChunkModuleMaps(filterFn: (m: Module) => boolean): ChunkModuleMaps;
	hasModuleInGraph(
		filterFn: (m: Module) => boolean,
		filterChunkFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): boolean;
	getChunkMaps(realHash: boolean): ChunkMaps;
	hasRuntime(): boolean;
	canBeInitial(): boolean;
	isOnlyInitial(): boolean;
	getEntryOptions(): undefined | EntryOptions;
	addGroup(chunkGroup: ChunkGroup): void;
	removeGroup(chunkGroup: ChunkGroup): void;
	isInGroup(chunkGroup: ChunkGroup): boolean;
	getNumberOfGroups(): number;
	readonly groupsIterable: Iterable<ChunkGroup>;
	disconnectFromGroups(): void;
	split(newChunk: Chunk): void;
	updateHash(hash: Hash, chunkGraph: ChunkGraph): void;
	getAllAsyncChunks(): Set<Chunk>;
	getAllInitialChunks(): Set<Chunk>;
	getAllReferencedChunks(): Set<Chunk>;
	getAllReferencedAsyncEntrypoints(): Set<Entrypoint>;
	hasAsyncChunks(): boolean;
	getChildIdsByOrders(
		chunkGraph: ChunkGraph,
		filterFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): Record<string, (string | number)[]>;
	getChildrenOfTypeInOrder(
		chunkGraph: ChunkGraph,
		type: string
	): { onChunks: Chunk[]; chunks: Set<Chunk> }[];
	getChildIdsByOrdersMap(
		chunkGraph: ChunkGraph,
		includeDirectChildren?: boolean,
		filterFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): Record<string | number, Record<string, (string | number)[]>>;
}
declare class ChunkGraph {
	constructor(moduleGraph: ModuleGraph, hashFunction?: string | typeof Hash);
	moduleGraph: ModuleGraph;
	connectChunkAndModule(chunk: Chunk, module: Module): void;
	disconnectChunkAndModule(chunk: Chunk, module: Module): void;
	disconnectChunk(chunk: Chunk): void;
	attachModules(chunk: Chunk, modules: Iterable<Module>): void;
	attachRuntimeModules(chunk: Chunk, modules: Iterable<RuntimeModule>): void;
	attachFullHashModules(chunk: Chunk, modules: Iterable<RuntimeModule>): void;
	attachDependentHashModules(
		chunk: Chunk,
		modules: Iterable<RuntimeModule>
	): void;
	replaceModule(oldModule: Module, newModule: Module): void;
	isModuleInChunk(module: Module, chunk: Chunk): boolean;
	isModuleInChunkGroup(module: Module, chunkGroup: ChunkGroup): boolean;
	isEntryModule(module: Module): boolean;
	getModuleChunksIterable(module: Module): Iterable<Chunk>;
	getOrderedModuleChunksIterable(
		module: Module,
		sortFn: (arg0: Chunk, arg1: Chunk) => 0 | 1 | -1
	): Iterable<Chunk>;
	getModuleChunks(module: Module): Chunk[];
	getNumberOfModuleChunks(module: Module): number;
	getModuleRuntimes(module: Module): RuntimeSpecSet;
	getNumberOfChunkModules(chunk: Chunk): number;
	getNumberOfChunkFullHashModules(chunk: Chunk): number;
	getChunkModulesIterable(chunk: Chunk): Iterable<Module>;
	getChunkModulesIterableBySourceType(
		chunk: Chunk,
		sourceType: string
	): undefined | Iterable<Module>;
	getOrderedChunkModulesIterable(
		chunk: Chunk,
		comparator: (arg0: Module, arg1: Module) => 0 | 1 | -1
	): Iterable<Module>;
	getOrderedChunkModulesIterableBySourceType(
		chunk: Chunk,
		sourceType: string,
		comparator: (arg0: Module, arg1: Module) => 0 | 1 | -1
	): undefined | Iterable<Module>;
	getChunkModules(chunk: Chunk): Module[];
	getOrderedChunkModules(
		chunk: Chunk,
		comparator: (arg0: Module, arg1: Module) => 0 | 1 | -1
	): Module[];
	getChunkModuleIdMap(
		chunk: Chunk,
		filterFn: (m: Module) => boolean,
		includeAllChunks?: boolean
	): Record<string | number, (string | number)[]>;
	getChunkModuleRenderedHashMap(
		chunk: Chunk,
		filterFn: (m: Module) => boolean,
		hashLength?: number,
		includeAllChunks?: boolean
	): Record<string | number, Record<string | number, string>>;
	getChunkConditionMap(
		chunk: Chunk,
		filterFn: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): Record<string | number, boolean>;
	hasModuleInGraph(
		chunk: Chunk,
		filterFn: (m: Module) => boolean,
		filterChunkFn?: (c: Chunk, chunkGraph: ChunkGraph) => boolean
	): boolean;
	compareChunks(chunkA: Chunk, chunkB: Chunk): 0 | 1 | -1;
	getChunkModulesSize(chunk: Chunk): number;
	getChunkModulesSizes(chunk: Chunk): Record<string, number>;
	getChunkRootModules(chunk: Chunk): Module[];
	getChunkSize(chunk: Chunk, options?: ChunkSizeOptions): number;
	getIntegratedChunksSize(
		chunkA: Chunk,
		chunkB: Chunk,
		options?: ChunkSizeOptions
	): number;
	canChunksBeIntegrated(chunkA: Chunk, chunkB: Chunk): boolean;
	integrateChunks(chunkA: Chunk, chunkB: Chunk): void;
	upgradeDependentToFullHashModules(chunk: Chunk): void;
	isEntryModuleInChunk(module: Module, chunk: Chunk): boolean;
	connectChunkAndEntryModule(
		chunk: Chunk,
		module: Module,
		entrypoint?: Entrypoint
	): void;
	connectChunkAndRuntimeModule(chunk: Chunk, module: RuntimeModule): void;
	addFullHashModuleToChunk(chunk: Chunk, module: RuntimeModule): void;
	addDependentHashModuleToChunk(chunk: Chunk, module: RuntimeModule): void;
	disconnectChunkAndEntryModule(chunk: Chunk, module: Module): void;
	disconnectChunkAndRuntimeModule(chunk: Chunk, module: RuntimeModule): void;
	disconnectEntryModule(module: Module): void;
	disconnectEntries(chunk: Chunk): void;
	getNumberOfEntryModules(chunk: Chunk): number;
	getNumberOfRuntimeModules(chunk: Chunk): number;
	getChunkEntryModulesIterable(chunk: Chunk): Iterable<Module>;
	getChunkEntryDependentChunksIterable(chunk: Chunk): Iterable<Chunk>;
	hasChunkEntryDependentChunks(chunk: Chunk): boolean;
	getChunkRuntimeModulesIterable(chunk: Chunk): Iterable<RuntimeModule>;
	getChunkRuntimeModulesInOrder(chunk: Chunk): RuntimeModule[];
	getChunkFullHashModulesIterable(
		chunk: Chunk
	): undefined | Iterable<RuntimeModule>;
	getChunkFullHashModulesSet(
		chunk: Chunk
	): undefined | ReadonlySet<RuntimeModule>;
	getChunkDependentHashModulesIterable(
		chunk: Chunk
	): undefined | Iterable<RuntimeModule>;
	getChunkEntryModulesWithChunkGroupIterable(
		chunk: Chunk
	): Iterable<[Module, undefined | Entrypoint]>;
	getBlockChunkGroup(depBlock: AsyncDependenciesBlock): ChunkGroup;
	connectBlockAndChunkGroup(
		depBlock: AsyncDependenciesBlock,
		chunkGroup: ChunkGroup
	): void;
	disconnectChunkGroup(chunkGroup: ChunkGroup): void;
	getModuleId(module: Module): string | number;
	setModuleId(module: Module, id: string | number): void;
	getRuntimeId(runtime: string): string | number;
	setRuntimeId(runtime: string, id: string | number): void;
	hasModuleHashes(module: Module, runtime: RuntimeSpec): boolean;
	getModuleHash(module: Module, runtime: RuntimeSpec): string;
	getRenderedModuleHash(module: Module, runtime: RuntimeSpec): string;
	setModuleHashes(
		module: Module,
		runtime: RuntimeSpec,
		hash: string,
		renderedHash: string
	): void;
	addModuleRuntimeRequirements(
		module: Module,
		runtime: RuntimeSpec,
		items: Set<string>,
		transferOwnership?: boolean
	): void;
	addChunkRuntimeRequirements(chunk: Chunk, items: Set<string>): void;
	addTreeRuntimeRequirements(chunk: Chunk, items: Iterable<string>): void;
	getModuleRuntimeRequirements(
		module: Module,
		runtime: RuntimeSpec
	): ReadonlySet<string>;
	getChunkRuntimeRequirements(chunk: Chunk): ReadonlySet<string>;
	getModuleGraphHash(
		module: Module,
		runtime: RuntimeSpec,
		withConnections?: boolean
	): string;
	getModuleGraphHashBigInt(
		module: Module,
		runtime: RuntimeSpec,
		withConnections?: boolean
	): bigint;
	getTreeRuntimeRequirements(chunk: Chunk): ReadonlySet<string>;
	static getChunkGraphForModule(
		module: Module,
		deprecateMessage: string,
		deprecationCode: string
	): ChunkGraph;
	static setChunkGraphForModule(module: Module, chunkGraph: ChunkGraph): void;
	static clearChunkGraphForModule(module: Module): void;
	static getChunkGraphForChunk(
		chunk: Chunk,
		deprecateMessage: string,
		deprecationCode: string
	): ChunkGraph;
	static setChunkGraphForChunk(chunk: Chunk, chunkGraph: ChunkGraph): void;
	static clearChunkGraphForChunk(chunk: Chunk): void;
}
declare abstract class ChunkGroup {
	groupDebugId: number;
	options: ChunkGroupOptions;
	chunks: Chunk[];
	origins: OriginRecord[];
	index: number;

	/**
	 * when a new chunk is added to a chunkGroup, addingOptions will occur.
	 */
	addOptions(options: ChunkGroupOptions): void;

	/**
	 * returns the name of current ChunkGroup
	 * sets a new name for current ChunkGroup
	 */
	name?: string;

	/**
	 * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's
	 */
	readonly debugId: string;

	/**
	 * get a unique id for ChunkGroup, made up of its member Chunk id's
	 */
	readonly id: string;

	/**
	 * Performs an unshift of a specific chunk
	 */
	unshiftChunk(chunk: Chunk): boolean;

	/**
	 * inserts a chunk before another existing chunk in group
	 */
	insertChunk(chunk: Chunk, before: Chunk): boolean;

	/**
	 * add a chunk into ChunkGroup. Is pushed on or prepended
	 */
	pushChunk(chunk: Chunk): boolean;
	replaceChunk(oldChunk: Chunk, newChunk: Chunk): boolean;
	removeChunk(chunk: Chunk): boolean;
	isInitial(): boolean;
	addChild(group: ChunkGroup): boolean;
	getChildren(): ChunkGroup[];
	getNumberOfChildren(): number;
	readonly childrenIterable: SortableSet<ChunkGroup>;
	removeChild(group: ChunkGroup): boolean;
	addParent(parentChunk: ChunkGroup): boolean;
	getParents(): ChunkGroup[];
	getNumberOfParents(): number;
	hasParent(parent: ChunkGroup): boolean;
	readonly parentsIterable: SortableSet<ChunkGroup>;
	removeParent(chunkGroup: ChunkGroup): boolean;
	addAsyncEntrypoint(entrypoint: Entrypoint): boolean;
	readonly asyncEntrypointsIterable: SortableSet<ChunkGroup>;
	getBlocks(): any[];
	getNumberOfBlocks(): number;
	hasBlock(block?: any): boolean;
	readonly blocksIterable: Iterable<AsyncDependenciesBlock>;
	addBlock(block: AsyncDependenciesBlock): boolean;
	addOrigin(module: Module, loc: DependencyLocation, request: string): void;
	getFiles(): string[];
	remove(): void;
	sortItems(): void;

	/**
	 * Sorting predicate which allows current ChunkGroup to be compared against another.
	 * Sorting values are based off of number of chunks in ChunkGroup.
	 */
	compareTo(chunkGraph: ChunkGraph, otherGroup: ChunkGroup): 0 | 1 | -1;
	getChildrenByOrders(
		moduleGraph: ModuleGraph,
		chunkGraph: ChunkGraph
	): Record<string, ChunkGroup[]>;

	/**
	 * Sets the top-down index of a module in this ChunkGroup
	 */
	setModulePreOrderIndex(module: Module, index: number): void;

	/**
	 * Gets the top-down index of a module in this ChunkGroup
	 */
	getModulePreOrderIndex(module: Module): number;

	/**
	 * Sets the bottom-up index of a module in this ChunkGroup
	 */
	setModulePostOrderIndex(module: Module, index: number): void;

	/**
	 * Gets the bottom-up index of a module in this ChunkGroup
	 */
	getModulePostOrderIndex(module: Module): number;
	checkConstraints(): void;
	getModuleIndex: (module: Module) => number;
	getModuleIndex2: (module: Module) => number;
}
type ChunkGroupOptions = RawChunkGroupOptions & { name?: string };
declare interface ChunkHashContext {
	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;
}
declare interface ChunkMaps {
	hash: Record<string | number, string>;
	contentHash: Record<string | number, Record<string, string>>;
	name: Record<string | number, string>;
}
declare class ChunkModuleIdRangePlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ChunkModuleMaps {
	id: Record<string | number, (string | number)[]>;
	hash: Record<string | number, string>;
}
declare interface ChunkPathData {
	id: string | number;
	name?: string;
	hash: string;
	hashWithLength?: (arg0: number) => string;
	contentHash?: Record<string, string>;
	contentHashWithLength?: Record<string, (length: number) => string>;
}
declare class ChunkPrefetchPreloadPlugin {
	constructor();
	apply(compiler: Compiler): void;
}
declare interface ChunkRenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * init fragments for the chunk
	 */
	chunkInitFragments: InitFragment<ChunkRenderContext>[];

	/**
	 * rendering in strict context
	 */
	strictMode: boolean;
}
declare interface ChunkSizeOptions {
	/**
	 * constant overhead for a chunk
	 */
	chunkOverhead?: number;

	/**
	 * multiplicator for initial chunks
	 */
	entryChunkMultiplicator?: number;
}
declare abstract class ChunkTemplate {
	hooks: Readonly<{
		renderManifest: { tap: (options?: any, fn?: any) => void };
		modules: { tap: (options?: any, fn?: any) => void };
		render: { tap: (options?: any, fn?: any) => void };
		renderWithEntry: { tap: (options?: any, fn?: any) => void };
		hash: { tap: (options?: any, fn?: any) => void };
		hashForChunk: { tap: (options?: any, fn?: any) => void };
	}>;
	readonly outputOptions: Output;
}

/**
 * Advanced options for cleaning assets.
 */
declare interface CleanOptions {
	/**
	 * Log the assets that should be removed instead of deleting them.
	 */
	dry?: boolean;

	/**
	 * Keep these assets.
	 */
	keep?: string | RegExp | ((filename: string) => boolean);
}
declare class CleanPlugin {
	constructor(options?: CleanOptions);
	options: {
		/**
		 * Log the assets that should be removed instead of deleting them.
		 */
		dry: boolean;
		/**
		 * Keep these assets.
		 */
		keep?: string | RegExp | ((filename: string) => boolean);
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getCompilationHooks(
		compilation: Compilation
	): CleanPluginCompilationHooks;
}
declare interface CleanPluginCompilationHooks {
	/**
	 * when returning true the file/directory will be kept during cleaning, returning false will clean it and ignore the following plugins and config
	 */
	keep: SyncBailHook<[string], boolean>;
}
declare interface CodeGenerationContext {
	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the runtimes code should be generated for
	 */
	runtime: RuntimeSpec;

	/**
	 * when in concatenated module, information about other concatenated modules
	 */
	concatenationScope?: ConcatenationScope;

	/**
	 * code generation results of other modules (need to have a codeGenerationDependency to use that)
	 */
	codeGenerationResults: CodeGenerationResults;
}
declare interface CodeGenerationResult {
	/**
	 * the resulting sources for all source types
	 */
	sources: Map<string, Source>;

	/**
	 * the resulting data for all source types
	 */
	data?: Map<string, any>;

	/**
	 * the runtime requirements
	 */
	runtimeRequirements: ReadonlySet<string>;

	/**
	 * a hash of the code generation result (will be automatically calculated from sources and runtimeRequirements if not provided)
	 */
	hash?: string;
}
declare abstract class CodeGenerationResults {
	map: Map<Module, RuntimeSpecMap<CodeGenerationResult>>;
	get(module: Module, runtime: RuntimeSpec): CodeGenerationResult;
	has(module: Module, runtime: RuntimeSpec): boolean;
	getSource(module: Module, runtime: RuntimeSpec, sourceType: string): Source;
	getRuntimeRequirements(
		module: Module,
		runtime: RuntimeSpec
	): ReadonlySet<string>;
	getData(module: Module, runtime: RuntimeSpec, key: string): any;
	getHash(module: Module, runtime: RuntimeSpec): any;
	add(module: Module, runtime: RuntimeSpec, result: CodeGenerationResult): void;
}
type CodeValue =
	| undefined
	| null
	| string
	| number
	| bigint
	| boolean
	| Function
	| RegExp
	| RuntimeValue
	| {
			[index: string]: RecursiveArrayOrRecord<
				| undefined
				| null
				| string
				| number
				| bigint
				| boolean
				| Function
				| RegExp
				| RuntimeValue
			>;
	  }
	| RecursiveArrayOrRecord<
			| undefined
			| null
			| string
			| number
			| bigint
			| boolean
			| Function
			| RegExp
			| RuntimeValue
	  >[];
type CodeValuePrimitive =
	| undefined
	| null
	| string
	| number
	| bigint
	| boolean
	| Function
	| RegExp;
declare interface Comparator<T> {
	(arg0: T, arg1: T): 0 | 1 | -1;
}
declare class CompatSource extends Source {
	constructor(sourceLike: SourceLike);
	static from(sourceLike: SourceLike): Source;
}
declare class Compilation {
	/**
	 * Creates an instance of Compilation.
	 */
	constructor(compiler: Compiler, params: CompilationParams);
	hooks: Readonly<{
		buildModule: SyncHook<[Module]>;
		rebuildModule: SyncHook<[Module]>;
		failedModule: SyncHook<[Module, WebpackError]>;
		succeedModule: SyncHook<[Module]>;
		stillValidModule: SyncHook<[Module]>;
		addEntry: SyncHook<[Dependency, EntryOptions]>;
		failedEntry: SyncHook<[Dependency, EntryOptions, Error]>;
		succeedEntry: SyncHook<[Dependency, EntryOptions, Module]>;
		dependencyReferencedExports: SyncWaterfallHook<
			[(string[] | ReferencedExport)[], Dependency, RuntimeSpec]
		>;
		executeModule: SyncHook<[ExecuteModuleArgument, ExecuteModuleContext]>;
		prepareModuleExecution: AsyncParallelHook<
			[ExecuteModuleArgument, ExecuteModuleContext]
		>;
		finishModules: AsyncSeriesHook<[Iterable<Module>]>;
		finishRebuildingModule: AsyncSeriesHook<[Module]>;
		unseal: SyncHook<[]>;
		seal: SyncHook<[]>;
		beforeChunks: SyncHook<[]>;
		afterChunks: SyncHook<[Iterable<Chunk>]>;
		optimizeDependencies: SyncBailHook<[Iterable<Module>], any>;
		afterOptimizeDependencies: SyncHook<[Iterable<Module>]>;
		optimize: SyncHook<[]>;
		optimizeModules: SyncBailHook<[Iterable<Module>], any>;
		afterOptimizeModules: SyncHook<[Iterable<Module>]>;
		optimizeChunks: SyncBailHook<[Iterable<Chunk>, ChunkGroup[]], any>;
		afterOptimizeChunks: SyncHook<[Iterable<Chunk>, ChunkGroup[]]>;
		optimizeTree: AsyncSeriesHook<[Iterable<Chunk>, Iterable<Module>]>;
		afterOptimizeTree: SyncHook<[Iterable<Chunk>, Iterable<Module>]>;
		optimizeChunkModules: AsyncSeriesBailHook<
			[Iterable<Chunk>, Iterable<Module>],
			any
		>;
		afterOptimizeChunkModules: SyncHook<[Iterable<Chunk>, Iterable<Module>]>;
		shouldRecord: SyncBailHook<[], boolean>;
		additionalChunkRuntimeRequirements: SyncHook<
			[Chunk, Set<string>, RuntimeRequirementsContext]
		>;
		runtimeRequirementInChunk: HookMap<
			SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext], any>
		>;
		additionalModuleRuntimeRequirements: SyncHook<
			[Module, Set<string>, RuntimeRequirementsContext]
		>;
		runtimeRequirementInModule: HookMap<
			SyncBailHook<[Module, Set<string>, RuntimeRequirementsContext], any>
		>;
		additionalTreeRuntimeRequirements: SyncHook<
			[Chunk, Set<string>, RuntimeRequirementsContext]
		>;
		runtimeRequirementInTree: HookMap<
			SyncBailHook<[Chunk, Set<string>, RuntimeRequirementsContext], any>
		>;
		runtimeModule: SyncHook<[RuntimeModule, Chunk]>;
		reviveModules: SyncHook<[Iterable<Module>, any]>;
		beforeModuleIds: SyncHook<[Iterable<Module>]>;
		moduleIds: SyncHook<[Iterable<Module>]>;
		optimizeModuleIds: SyncHook<[Iterable<Module>]>;
		afterOptimizeModuleIds: SyncHook<[Iterable<Module>]>;
		reviveChunks: SyncHook<[Iterable<Chunk>, any]>;
		beforeChunkIds: SyncHook<[Iterable<Chunk>]>;
		chunkIds: SyncHook<[Iterable<Chunk>]>;
		optimizeChunkIds: SyncHook<[Iterable<Chunk>]>;
		afterOptimizeChunkIds: SyncHook<[Iterable<Chunk>]>;
		recordModules: SyncHook<[Iterable<Module>, any]>;
		recordChunks: SyncHook<[Iterable<Chunk>, any]>;
		optimizeCodeGeneration: SyncHook<[Iterable<Module>]>;
		beforeModuleHash: SyncHook<[]>;
		afterModuleHash: SyncHook<[]>;
		beforeCodeGeneration: SyncHook<[]>;
		afterCodeGeneration: SyncHook<[]>;
		beforeRuntimeRequirements: SyncHook<[]>;
		afterRuntimeRequirements: SyncHook<[]>;
		beforeHash: SyncHook<[]>;
		contentHash: SyncHook<[Chunk]>;
		afterHash: SyncHook<[]>;
		recordHash: SyncHook<[any]>;
		record: SyncHook<[Compilation, any]>;
		beforeModuleAssets: SyncHook<[]>;
		shouldGenerateChunkAssets: SyncBailHook<[], boolean>;
		beforeChunkAssets: SyncHook<[]>;
		additionalChunkAssets: FakeHook<
			Pick<
				AsyncSeriesHook<[Set<Chunk>]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		additionalAssets: FakeHook<
			Pick<AsyncSeriesHook<[]>, "name" | "tap" | "tapAsync" | "tapPromise">
		>;
		optimizeChunkAssets: FakeHook<
			Pick<
				AsyncSeriesHook<[Set<Chunk>]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		afterOptimizeChunkAssets: FakeHook<
			Pick<
				AsyncSeriesHook<[Set<Chunk>]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		optimizeAssets: AsyncSeriesHook<
			[CompilationAssets],
			ProcessAssetsAdditionalOptions
		>;
		afterOptimizeAssets: SyncHook<[CompilationAssets]>;
		processAssets: AsyncSeriesHook<
			[CompilationAssets],
			ProcessAssetsAdditionalOptions
		>;
		afterProcessAssets: SyncHook<[CompilationAssets]>;
		processAdditionalAssets: AsyncSeriesHook<[CompilationAssets]>;
		needAdditionalSeal: SyncBailHook<[], boolean>;
		afterSeal: AsyncSeriesHook<[]>;
		renderManifest: SyncWaterfallHook<
			[RenderManifestEntry[], RenderManifestOptions]
		>;
		fullHash: SyncHook<[Hash]>;
		chunkHash: SyncHook<[Chunk, Hash, ChunkHashContext]>;
		moduleAsset: SyncHook<[Module, string]>;
		chunkAsset: SyncHook<[Chunk, string]>;
		assetPath: SyncWaterfallHook<[string, object, AssetInfo]>;
		needAdditionalPass: SyncBailHook<[], boolean>;
		childCompiler: SyncHook<[Compiler, string, number]>;
		log: SyncBailHook<[string, LogEntry], true>;
		processWarnings: SyncWaterfallHook<[WebpackError[]]>;
		processErrors: SyncWaterfallHook<[WebpackError[]]>;
		statsPreset: HookMap<
			SyncHook<[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]>
		>;
		statsNormalize: SyncHook<
			[Partial<NormalizedStatsOptions>, CreateStatsOptionsContext]
		>;
		statsFactory: SyncHook<[StatsFactory, NormalizedStatsOptions]>;
		statsPrinter: SyncHook<[StatsPrinter, NormalizedStatsOptions]>;
		readonly normalModuleLoader: SyncHook<[object, NormalModule]>;
	}>;
	name?: string;
	startTime: any;
	endTime: any;
	compiler: Compiler;
	resolverFactory: ResolverFactory;
	inputFileSystem: InputFileSystem;
	fileSystemInfo: FileSystemInfo;
	valueCacheVersions: Map<string, string | Set<string>>;
	requestShortener: RequestShortener;
	compilerPath: string;
	logger: WebpackLogger;
	options: WebpackOptionsNormalized;
	outputOptions: OutputNormalized;
	bail: boolean;
	profile: boolean;
	params: CompilationParams;
	mainTemplate: MainTemplate;
	chunkTemplate: ChunkTemplate;
	runtimeTemplate: RuntimeTemplate;
	moduleTemplates: { javascript: ModuleTemplate };
	moduleMemCaches?: Map<Module, WeakTupleMap<any, any>>;
	moduleMemCaches2?: Map<Module, WeakTupleMap<any, any>>;
	moduleGraph: ModuleGraph;
	chunkGraph: ChunkGraph;
	codeGenerationResults: CodeGenerationResults;
	processDependenciesQueue: AsyncQueue<Module, Module, Module>;
	addModuleQueue: AsyncQueue<Module, string, Module>;
	factorizeQueue: AsyncQueue<
		FactorizeModuleOptions,
		string,
		Module | ModuleFactoryResult
	>;
	buildQueue: AsyncQueue<Module, Module, Module>;
	rebuildQueue: AsyncQueue<Module, Module, Module>;

	/**
	 * Modules in value are building during the build of Module in key.
	 * Means value blocking key from finishing.
	 * Needed to detect build cycles.
	 */
	creatingModuleDuringBuild: WeakMap<Module, Set<Module>>;
	entries: Map<string, EntryData>;
	globalEntry: EntryData;
	entrypoints: Map<string, Entrypoint>;
	asyncEntrypoints: Entrypoint[];
	chunks: Set<Chunk>;
	chunkGroups: ChunkGroup[];
	namedChunkGroups: Map<string, ChunkGroup>;
	namedChunks: Map<string, Chunk>;
	modules: Set<Module>;
	records: any;
	additionalChunkAssets: string[];
	assets: CompilationAssets;
	assetsInfo: Map<string, AssetInfo>;
	errors: WebpackError[];
	warnings: WebpackError[];
	children: Compilation[];
	logging: Map<string, LogEntry[]>;
	dependencyFactories: Map<DepConstructor, ModuleFactory>;
	dependencyTemplates: DependencyTemplates;
	childrenCounters: object;
	usedChunkIds: Set<string | number>;
	usedModuleIds: Set<number>;
	needAdditionalPass: boolean;
	builtModules: WeakSet<Module>;
	codeGeneratedModules: WeakSet<Module>;
	buildTimeExecutedModules: WeakSet<Module>;
	emittedAssets: Set<string>;
	comparedForEmitAssets: Set<string>;
	fileDependencies: LazySet<string>;
	contextDependencies: LazySet<string>;
	missingDependencies: LazySet<string>;
	buildDependencies: LazySet<string>;
	compilationDependencies: { add: (item?: any) => LazySet<string> };
	getStats(): Stats;
	createStatsOptions(
		optionsOrPreset: string | StatsOptions,
		context?: CreateStatsOptionsContext
	): NormalizedStatsOptions;
	createStatsFactory(options?: any): StatsFactory;
	createStatsPrinter(options?: any): StatsPrinter;
	getCache(name: string): CacheFacade;
	getLogger(name: string | (() => string)): WebpackLogger;
	addModule(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;

	/**
	 * Fetches a module from a compilation by its identifier
	 */
	getModule(module: Module): Module;

	/**
	 * Attempts to search for a module by its identifier
	 */
	findModule(identifier: string): undefined | Module;

	/**
	 * Schedules a build of the module object
	 */
	buildModule(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	processModuleDependencies(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	processModuleDependenciesNonRecursive(module: Module): void;
	handleModuleCreation(
		__0: HandleModuleCreationOptions,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addModuleChain(
		context: string,
		dependency: Dependency,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addModuleTree(
		__0: {
			/**
			 * context string path
			 */
			context: string;
			/**
			 * dependency used to create Module chain
			 */
			dependency: Dependency;
			/**
			 * additional context info for the root module
			 */
			contextInfo?: Partial<ModuleFactoryCreateDataContextInfo>;
		},
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addEntry(
		context: string,
		entry: Dependency,
		optionsOrName: string | EntryOptions,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	addInclude(
		context: string,
		dependency: Dependency,
		options: EntryOptions,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	rebuildModule(
		module: Module,
		callback: (err?: null | WebpackError, result?: Module) => void
	): void;
	finish(callback?: any): void;
	unseal(): void;
	seal(callback: (err?: null | WebpackError) => void): void;
	reportDependencyErrorsAndWarnings(
		module: Module,
		blocks: DependenciesBlock[]
	): boolean;
	codeGeneration(callback?: any): void;
	processRuntimeRequirements(__0?: {
		/**
		 * the chunk graph
		 */
		chunkGraph?: ChunkGraph;
		/**
		 * modules
		 */
		modules?: Iterable<Module>;
		/**
		 * chunks
		 */
		chunks?: Iterable<Chunk>;
		/**
		 * codeGenerationResults
		 */
		codeGenerationResults?: CodeGenerationResults;
		/**
		 * chunkGraphEntries
		 */
		chunkGraphEntries?: Iterable<Chunk>;
	}): void;
	addRuntimeModule(
		chunk: Chunk,
		module: RuntimeModule,
		chunkGraph?: ChunkGraph
	): void;

	/**
	 * If `module` is passed, `loc` and `request` must also be passed.
	 */
	addChunkInGroup(
		groupOptions: string | ChunkGroupOptions,
		module?: Module,
		loc?: SyntheticDependencyLocation | RealDependencyLocation,
		request?: string
	): ChunkGroup;
	addAsyncEntrypoint(
		options: EntryOptions,
		module: Module,
		loc: DependencyLocation,
		request: string
	): Entrypoint;

	/**
	 * This method first looks to see if a name is provided for a new chunk,
	 * and first looks to see if any named chunks already exist and reuse that chunk instead.
	 */
	addChunk(name?: string): Chunk;
	assignDepth(module: Module): void;
	assignDepths(modules: Set<Module>): void;
	getDependencyReferencedExports(
		dependency: Dependency,
		runtime: RuntimeSpec
	): (string[] | ReferencedExport)[];
	removeReasonsOfDependencyBlock(
		module: Module,
		block: DependenciesBlockLike
	): void;
	patchChunksAfterReasonRemoval(module: Module, chunk: Chunk): void;
	removeChunkFromDependencies(block: DependenciesBlock, chunk: Chunk): void;
	assignRuntimeIds(): void;
	sortItemsWithChunkIds(): void;
	summarizeDependencies(): void;
	createModuleHashes(): void;
	createHash(): {
		module: Module;
		hash: string;
		runtime: RuntimeSpec;
		runtimes: RuntimeSpec[];
	}[];
	fullHash?: string;
	hash?: string;
	emitAsset(file: string, source: Source, assetInfo?: AssetInfo): void;
	updateAsset(
		file: string,
		newSourceOrFunction: Source | ((arg0: Source) => Source),
		assetInfoUpdateOrFunction?: AssetInfo | ((arg0?: AssetInfo) => AssetInfo)
	): void;
	renameAsset(file?: any, newFile?: any): void;
	deleteAsset(file: string): void;
	getAssets(): Readonly<Asset>[];
	getAsset(name: string): undefined | Readonly<Asset>;
	clearAssets(): void;
	createModuleAssets(): void;
	getRenderManifest(options: RenderManifestOptions): RenderManifestEntry[];
	createChunkAssets(callback: (err?: null | WebpackError) => void): void;
	getPath(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data?: PathData
	): string;
	getPathWithInfo(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data?: PathData
	): { path: string; info: AssetInfo };
	getAssetPath(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data: PathData
	): string;
	getAssetPathWithInfo(
		filename: string | ((arg0: PathData, arg1?: AssetInfo) => string),
		data: PathData
	): { path: string; info: AssetInfo };
	getWarnings(): WebpackError[];
	getErrors(): WebpackError[];

	/**
	 * This function allows you to run another instance of webpack inside of webpack however as
	 * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins
	 * from parent (or top level compiler) and creates a child Compilation
	 */
	createChildCompiler(
		name: string,
		outputOptions?: OutputNormalized,
		plugins?: (
			| ((this: Compiler, compiler: Compiler) => void)
			| WebpackPluginInstance
		)[]
	): Compiler;
	executeModule(
		module: Module,
		options: ExecuteModuleOptions,
		callback: (err?: null | WebpackError, result?: ExecuteModuleResult) => void
	): void;
	checkConstraints(): void;
	factorizeModule: {
		(
			options: FactorizeModuleOptions & { factoryResult?: false },
			callback: (err?: null | WebpackError, result?: Module) => void
		): void;
		(
			options: FactorizeModuleOptions & { factoryResult: true },
			callback: (
				err?: null | WebpackError,
				result?: ModuleFactoryResult
			) => void
		): void;
	};

	/**
	 * Add additional assets to the compilation.
	 */
	static PROCESS_ASSETS_STAGE_ADDITIONAL: number;

	/**
	 * Basic preprocessing of assets.
	 */
	static PROCESS_ASSETS_STAGE_PRE_PROCESS: number;

	/**
	 * Derive new assets from existing assets.
	 * Existing assets should not be treated as complete.
	 */
	static PROCESS_ASSETS_STAGE_DERIVED: number;

	/**
	 * Add additional sections to existing assets, like a banner or initialization code.
	 */
	static PROCESS_ASSETS_STAGE_ADDITIONS: number;

	/**
	 * Optimize existing assets in a general way.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE: number;

	/**
	 * Optimize the count of existing assets, e. g. by merging them.
	 * Only assets of the same type should be merged.
	 * For assets of different types see PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT: number;

	/**
	 * Optimize the compatibility of existing assets, e. g. add polyfills or vendor-prefixes.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY: number;

	/**
	 * Optimize the size of existing assets, e. g. by minimizing or omitting whitespace.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE: number;

	/**
	 * Add development tooling to assets, e. g. by extracting a SourceMap.
	 */
	static PROCESS_ASSETS_STAGE_DEV_TOOLING: number;

	/**
	 * Optimize the count of existing assets, e. g. by inlining assets of into other assets.
	 * Only assets of different types should be inlined.
	 * For assets of the same type see PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE: number;

	/**
	 * Summarize the list of existing assets
	 * e. g. creating an assets manifest of Service Workers.
	 */
	static PROCESS_ASSETS_STAGE_SUMMARIZE: number;

	/**
	 * Optimize the hashes of the assets, e. g. by generating real hashes of the asset content.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_HASH: number;

	/**
	 * Optimize the transfer of existing assets, e. g. by preparing a compressed (gzip) file as separate asset.
	 */
	static PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER: number;

	/**
	 * Analyse existing assets.
	 */
	static PROCESS_ASSETS_STAGE_ANALYSE: number;

	/**
	 * Creating assets for reporting purposes.
	 */
	static PROCESS_ASSETS_STAGE_REPORT: number;
}
declare interface CompilationAssets {
	[index: string]: Source;
}
declare interface CompilationHooksAsyncWebAssemblyModulesPlugin {
	renderModuleContent: SyncWaterfallHook<
		[Source, Module, WebAssemblyRenderContext]
	>;
}
declare interface CompilationHooksJavascriptModulesPlugin {
	renderModuleContent: SyncWaterfallHook<[Source, Module, ChunkRenderContext]>;
	renderModuleContainer: SyncWaterfallHook<
		[Source, Module, ChunkRenderContext]
	>;
	renderModulePackage: SyncWaterfallHook<[Source, Module, ChunkRenderContext]>;
	renderChunk: SyncWaterfallHook<[Source, RenderContext]>;
	renderMain: SyncWaterfallHook<[Source, RenderContext]>;
	renderContent: SyncWaterfallHook<[Source, RenderContext]>;
	render: SyncWaterfallHook<[Source, RenderContext]>;
	renderStartup: SyncWaterfallHook<[Source, Module, StartupRenderContext]>;
	renderRequire: SyncWaterfallHook<[string, RenderBootstrapContext]>;
	inlineInRuntimeBailout: SyncBailHook<
		[Module, RenderBootstrapContext],
		string
	>;
	embedInRuntimeBailout: SyncBailHook<[Module, RenderContext], string>;
	strictRuntimeBailout: SyncBailHook<[RenderContext], string>;
	chunkHash: SyncHook<[Chunk, Hash, ChunkHashContext]>;
	useSourceMap: SyncBailHook<[Chunk, RenderContext], boolean>;
}
declare interface CompilationHooksRealContentHashPlugin {
	updateHash: SyncBailHook<[Buffer[], string], string>;
}
declare interface CompilationParams {
	normalModuleFactory: NormalModuleFactory;
	contextModuleFactory: ContextModuleFactory;
}
declare class Compiler {
	constructor(context: string, options?: WebpackOptionsNormalized);
	hooks: Readonly<{
		initialize: SyncHook<[]>;
		shouldEmit: SyncBailHook<[Compilation], boolean>;
		done: AsyncSeriesHook<[Stats]>;
		afterDone: SyncHook<[Stats]>;
		additionalPass: AsyncSeriesHook<[]>;
		beforeRun: AsyncSeriesHook<[Compiler]>;
		run: AsyncSeriesHook<[Compiler]>;
		emit: AsyncSeriesHook<[Compilation]>;
		assetEmitted: AsyncSeriesHook<[string, AssetEmittedInfo]>;
		afterEmit: AsyncSeriesHook<[Compilation]>;
		thisCompilation: SyncHook<[Compilation, CompilationParams]>;
		compilation: SyncHook<[Compilation, CompilationParams]>;
		normalModuleFactory: SyncHook<[NormalModuleFactory]>;
		contextModuleFactory: SyncHook<[ContextModuleFactory]>;
		beforeCompile: AsyncSeriesHook<[CompilationParams]>;
		compile: SyncHook<[CompilationParams]>;
		make: AsyncParallelHook<[Compilation]>;
		finishMake: AsyncParallelHook<[Compilation]>;
		afterCompile: AsyncSeriesHook<[Compilation]>;
		readRecords: AsyncSeriesHook<[]>;
		emitRecords: AsyncSeriesHook<[]>;
		watchRun: AsyncSeriesHook<[Compiler]>;
		failed: SyncHook<[Error]>;
		invalid: SyncHook<[null | string, number]>;
		watchClose: SyncHook<[]>;
		shutdown: AsyncSeriesHook<[]>;
		infrastructureLog: SyncBailHook<[string, string, any[]], true>;
		environment: SyncHook<[]>;
		afterEnvironment: SyncHook<[]>;
		afterPlugins: SyncHook<[Compiler]>;
		afterResolvers: SyncHook<[Compiler]>;
		entryOption: SyncBailHook<[string, EntryNormalized], boolean>;
	}>;
	webpack: typeof exports;
	name?: string;
	parentCompilation?: Compilation;
	root: Compiler;
	outputPath: string;
	watching: Watching;
	outputFileSystem: OutputFileSystem;
	intermediateFileSystem: IntermediateFileSystem;
	inputFileSystem: InputFileSystem;
	watchFileSystem: WatchFileSystem;
	recordsInputPath: null | string;
	recordsOutputPath: null | string;
	records: object;
	managedPaths: Set<string | RegExp>;
	immutablePaths: Set<string | RegExp>;
	modifiedFiles: ReadonlySet<string>;
	removedFiles: ReadonlySet<string>;
	fileTimestamps: ReadonlyMap<string, null | FileSystemInfoEntry | "ignore">;
	contextTimestamps: ReadonlyMap<string, null | FileSystemInfoEntry | "ignore">;
	fsStartTime: number;
	resolverFactory: ResolverFactory;
	infrastructureLogger: any;
	options: WebpackOptionsNormalized;
	context: string;
	requestShortener: RequestShortener;
	cache: Cache;
	moduleMemCaches?: Map<
		Module,
		{
			buildInfo: object;
			references: WeakMap<Dependency, Module>;
			memCache: WeakTupleMap<any, any>;
		}
	>;
	compilerPath: string;
	running: boolean;
	idle: boolean;
	watchMode: boolean;
	getCache(name: string): CacheFacade;
	getInfrastructureLogger(name: string | (() => string)): WebpackLogger;
	watch(watchOptions: WatchOptions, handler: CallbackFunction<Stats>): Watching;
	run(callback: CallbackFunction<Stats>): void;
	runAsChild(
		callback: (
			err?: null | Error,
			entries?: Chunk[],
			compilation?: Compilation
		) => any
	): void;
	purgeInputFileSystem(): void;
	emitAssets(compilation: Compilation, callback: CallbackFunction<void>): void;
	emitRecords(callback: CallbackFunction<void>): void;
	readRecords(callback: CallbackFunction<void>): void;
	createChildCompiler(
		compilation: Compilation,
		compilerName: string,
		compilerIndex: number,
		outputOptions?: OutputNormalized,
		plugins?: WebpackPluginInstance[]
	): Compiler;
	isChild(): boolean;
	createCompilation(params?: any): Compilation;
	newCompilation(params: CompilationParams): Compilation;
	createNormalModuleFactory(): NormalModuleFactory;
	createContextModuleFactory(): ContextModuleFactory;
	newCompilationParams(): {
		normalModuleFactory: NormalModuleFactory;
		contextModuleFactory: ContextModuleFactory;
	};
	compile(callback: CallbackFunction<Compilation>): void;
	close(callback: CallbackFunction<void>): void;
}
declare class ConcatSource extends Source {
	constructor(...args: (string | Source)[]);
	getChildren(): Source[];
	add(item: string | Source): void;
	addAllSkipOptimizing(items: Source[]): void;
}
declare interface ConcatenatedModuleInfo {
	index: number;
	module: Module;

	/**
	 * mapping from export name to symbol
	 */
	exportMap: Map<string, string>;

	/**
	 * mapping from export name to symbol
	 */
	rawExportMap: Map<string, string>;
	namespaceExportSymbol?: string;
}
declare interface ConcatenationBailoutReasonContext {
	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;
}
declare class ConcatenationScope {
	constructor(
		modulesMap: ModuleInfo[] | Map<Module, ModuleInfo>,
		currentModule: ConcatenatedModuleInfo
	);
	isModuleInScope(module: Module): boolean;
	registerExport(exportName: string, symbol: string): void;
	registerRawExport(exportName: string, expression: string): void;
	registerNamespaceExport(symbol: string): void;
	createModuleReference(
		module: Module,
		__1: Partial<ModuleReferenceOptions>
	): string;
	static isModuleReference(name: string): boolean;
	static matchModuleReference(
		name: string
	): ModuleReferenceOptions & { index: number };
	static DEFAULT_EXPORT: string;
	static NAMESPACE_OBJECT_EXPORT: string;
}

/**
 * Options object as provided by the user.
 */
declare interface Configuration {
	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: false | { [index: string]: any };

	/**
	 * Report the first error as a hard error instead of tolerating it.
	 */
	bail?: boolean;

	/**
	 * Cache generated modules and chunks to improve performance for multiple incremental builds.
	 */
	cache?: boolean | FileCacheOptions | MemoryCacheOptions;

	/**
	 * The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.
	 */
	context?: string;

	/**
	 * References to other configurations to depend on.
	 */
	dependencies?: string[];

	/**
	 * A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
	 */
	devtool?: string | false;

	/**
	 * The entry point(s) of the compilation.
	 */
	entry?:
		| string
		| (() => string | EntryObject | string[] | Promise<EntryStatic>)
		| EntryObject
		| string[];

	/**
	 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
	 */
	experiments?: Experiments;

	/**
	 * Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
	 */
	externals?:
		| string
		| RegExp
		| ExternalItem[]
		| (ExternalItemObjectKnown & ExternalItemObjectUnknown)
		| ((
				data: ExternalItemFunctionData,
				callback: (
					err?: Error,
					result?: string | boolean | string[] | { [index: string]: any }
				) => void
		  ) => void)
		| ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>);

	/**
	 * Enable presets of externals for specific targets.
	 */
	externalsPresets?: ExternalsPresets;

	/**
	 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
	 */
	externalsType?:
		| "import"
		| "var"
		| "module"
		| "assign"
		| "this"
		| "window"
		| "self"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "commonjs-static"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system"
		| "promise"
		| "script"
		| "node-commonjs";

	/**
	 * Ignore specific warnings.
	 */
	ignoreWarnings?: (
		| RegExp
		| {
				/**
				 * A RegExp to select the origin file for the warning.
				 */
				file?: RegExp;
				/**
				 * A RegExp to select the warning message.
				 */
				message?: RegExp;
				/**
				 * A RegExp to select the origin module for the warning.
				 */
				module?: RegExp;
		  }
		| ((warning: WebpackError, compilation: Compilation) => boolean)
	)[];

	/**
	 * Options for infrastructure level logging.
	 */
	infrastructureLogging?: InfrastructureLogging;

	/**
	 * Custom values available in the loader context.
	 */
	loader?: Loader;

	/**
	 * Enable production optimizations or development hints.
	 */
	mode?: "none" | "development" | "production";

	/**
	 * Options affecting the normal modules (`NormalModuleFactory`).
	 */
	module?: ModuleOptions;

	/**
	 * Name of the configuration. Used when loading multiple configurations.
	 */
	name?: string;

	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node?: false | NodeOptions;

	/**
	 * Enables/Disables integrated optimizations.
	 */
	optimization?: Optimization;

	/**
	 * Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
	 */
	output?: Output;

	/**
	 * The number of parallel processed modules in the compilation.
	 */
	parallelism?: number;

	/**
	 * Configuration for web performance recommendations.
	 */
	performance?: false | PerformanceOptions;

	/**
	 * Add additional plugins to the compiler.
	 */
	plugins?: (
		| ((this: Compiler, compiler: Compiler) => void)
		| WebpackPluginInstance
	)[];

	/**
	 * Capture timing information for each module.
	 */
	profile?: boolean;

	/**
	 * Store compiler state to a json file.
	 */
	recordsInputPath?: string | false;

	/**
	 * Load compiler state from a json file.
	 */
	recordsOutputPath?: string | false;

	/**
	 * Store/Load compiler state from/to a json file. This will result in persistent ids of modules and chunks. An absolute path is expected. `recordsPath` is used for `recordsInputPath` and `recordsOutputPath` if they left undefined.
	 */
	recordsPath?: string | false;

	/**
	 * Options for the resolver.
	 */
	resolve?: ResolveOptionsWebpackOptions;

	/**
	 * Options for the resolver when resolving loaders.
	 */
	resolveLoader?: ResolveOptionsWebpackOptions;

	/**
	 * Options affecting how file system snapshots are created and validated.
	 */
	snapshot?: SnapshotOptions;

	/**
	 * Stats options object or preset name.
	 */
	stats?:
		| boolean
		| StatsOptions
		| "none"
		| "verbose"
		| "summary"
		| "errors-only"
		| "errors-warnings"
		| "minimal"
		| "normal"
		| "detailed";

	/**
	 * Environment to build for. An array of environments to build for all of them when possible.
	 */
	target?: string | false | string[];

	/**
	 * Enter watch mode, which rebuilds on file change.
	 */
	watch?: boolean;

	/**
	 * Options for the watcher.
	 */
	watchOptions?: WatchOptions;
}
type ConnectionState =
	| boolean
	| typeof TRANSITIVE_ONLY
	| typeof CIRCULAR_CONNECTION;
declare class ConstDependency extends NullDependency {
	constructor(
		expression: string,
		range: number | [number, number],
		runtimeRequirements?: string[]
	);
	expression: string;
	range: number | [number, number];
	runtimeRequirements: null | Set<string>;
	static Template: typeof ConstDependencyTemplate;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare class ConstDependencyTemplate extends NullDependencyTemplate {
	constructor();
}
declare interface Constructor {
	new (...params: any[]): any;
}
declare class ConsumeSharedPlugin {
	constructor(options: ConsumeSharedPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Options for consuming shared modules.
 */
declare interface ConsumeSharedPluginOptions {
	/**
	 * Modules that should be consumed from share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	consumes: Consumes;

	/**
	 * Share scope name used for all consumed modules (defaults to 'default').
	 */
	shareScope?: string;
}
type Consumes = (string | ConsumesObject)[] | ConsumesObject;

/**
 * Advanced configuration for modules that should be consumed from share scope.
 */
declare interface ConsumesConfig {
	/**
	 * Include the fallback module directly instead behind an async request. This allows to use fallback module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;

	/**
	 * Fallback module if no shared module is found in share scope. Defaults to the property name.
	 */
	import?: string | false;

	/**
	 * Package name to determine required version from description file. This is only needed when package name can't be automatically determined from request.
	 */
	packageName?: string;

	/**
	 * Version requirement from module in share scope.
	 */
	requiredVersion?: string | false;

	/**
	 * Module is looked up under this key from the share scope.
	 */
	shareKey?: string;

	/**
	 * Share scope name.
	 */
	shareScope?: string;

	/**
	 * Allow only a single version of the shared module in share scope (disabled by default).
	 */
	singleton?: boolean;

	/**
	 * Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).
	 */
	strictVersion?: boolean;
}

/**
 * Modules that should be consumed from share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.
 */
declare interface ConsumesObject {
	[index: string]: string | ConsumesConfig;
}
type ContainerOptionsFormat<T> =
	| Record<string, string | string[] | T>
	| (string | Record<string, string | string[] | T>)[];
declare class ContainerPlugin {
	constructor(options: ContainerPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ContainerPluginOptions {
	/**
	 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
	 */
	exposes: Exposes;

	/**
	 * The filename for this container relative path inside the `output.path` directory.
	 */
	filename?: string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The name for this container.
	 */
	name: string;

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * The name of the share scope which is shared with the host (defaults to 'default').
	 */
	shareScope?: string;
}
declare class ContainerReferencePlugin {
	constructor(options: ContainerReferencePluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ContainerReferencePluginOptions {
	/**
	 * The external type of the remote containers.
	 */
	remoteType: ExternalsType;

	/**
	 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
	 */
	remotes: Remotes;

	/**
	 * The name of the share scope shared with all remotes (defaults to 'default').
	 */
	shareScope?: string;
}
declare abstract class ContextElementDependency extends ModuleDependency {
	referencedExports: any;
}
declare class ContextExclusionPlugin {
	constructor(negativeMatcher: RegExp);
	negativeMatcher: RegExp;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ContextFileSystemInfoEntry {
	safeTime: number;
	timestampHash?: string;
	resolved?: ResolvedContextFileSystemInfoEntry;
	symlinks?: Set<string>;
}
declare interface ContextHash {
	hash: string;
	resolved?: string;
	symlinks?: Set<string>;
}
type ContextMode =
	| "weak"
	| "sync"
	| "eager"
	| "async-weak"
	| "lazy"
	| "lazy-once";
declare abstract class ContextModuleFactory extends ModuleFactory {
	hooks: Readonly<{
		beforeResolve: AsyncSeriesWaterfallHook<[any]>;
		afterResolve: AsyncSeriesWaterfallHook<[any]>;
		contextModuleFiles: SyncWaterfallHook<[string[]]>;
		alternatives: FakeHook<
			Pick<
				AsyncSeriesWaterfallHook<[any[]]>,
				"name" | "tap" | "tapAsync" | "tapPromise"
			>
		>;
		alternativeRequests: AsyncSeriesWaterfallHook<
			[any[], ContextModuleOptions]
		>;
	}>;
	resolverFactory: ResolverFactory;
	resolveDependencies(
		fs: InputFileSystem,
		options: ContextModuleOptions,
		callback: (
			err?: null | Error,
			dependencies?: ContextElementDependency[]
		) => any
	): void;
}

declare interface ContextModuleOptions {
	mode: ContextMode;
	recursive: boolean;
	regExp: RegExp;
	namespaceObject?: boolean | "strict";
	addon?: string;
	chunkName?: string;
	include?: RegExp;
	exclude?: RegExp;
	groupOptions?: RawChunkGroupOptions;
	typePrefix?: string;
	category?: string;

	/**
	 * exports referenced from modules (won't be mangled)
	 */
	referencedExports?: string[][];
	resource: string | false | string[];
	resourceQuery?: string;
	resourceFragment?: string;
	resolveOptions: any;
}
declare class ContextReplacementPlugin {
	constructor(
		resourceRegExp?: any,
		newContentResource?: any,
		newContentRecursive?: any,
		newContentRegExp?: any
	);
	resourceRegExp: any;
	newContentCallback: any;
	newContentResource: any;
	newContentCreateContextMap: any;
	newContentRecursive: any;
	newContentRegExp: any;
	apply(compiler?: any): void;
}
declare interface ContextTimestampAndHash {
	safeTime: number;
	timestampHash?: string;
	hash: string;
	resolved?: ResolvedContextTimestampAndHash;
	symlinks?: Set<string>;
}
type CreateStatsOptionsContext = KnownCreateStatsOptionsContext &
	Record<string, any>;

/**
 * Options for css handling.
 */
declare interface CssExperimentOptions {
	/**
	 * Avoid generating and loading a stylesheet and only embed exports from css into output javascript files.
	 */
	exportsOnly?: boolean;
}
type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration;
declare class DefinePlugin {
	/**
	 * Create a new define plugin
	 */
	constructor(definitions: Record<string, CodeValue>);
	definitions: Record<string, CodeValue>;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static runtimeValue(
		fn: (arg0: {
			module: NormalModule;
			key: string;
			readonly version?: string;
		}) => CodeValuePrimitive,
		options?: true | string[] | RuntimeValueOptions
	): RuntimeValue;
}
declare class DelegatedPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface DepConstructor {
	new (...args: any[]): Dependency;
}
declare abstract class DependenciesBlock {
	dependencies: Dependency[];
	blocks: AsyncDependenciesBlock[];
	parent: DependenciesBlock;
	getRootBlock(): DependenciesBlock;

	/**
	 * Adds a DependencyBlock to DependencyBlock relationship.
	 * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)
	 */
	addBlock(block: AsyncDependenciesBlock): void;
	addDependency(dependency: Dependency): void;
	removeDependency(dependency: Dependency): void;

	/**
	 * Removes all dependencies and blocks
	 */
	clearDependenciesAndBlocks(): void;
	updateHash(hash: Hash, context: UpdateHashContextDependency): void;
	serialize(__0: { write: any }): void;
	deserialize(__0: { read: any }): void;
}
declare interface DependenciesBlockLike {
	dependencies: Dependency[];
	blocks: AsyncDependenciesBlock[];
}
declare class Dependency {
	constructor();
	weak: boolean;
	optional: boolean;
	readonly type: string;
	readonly category: string;
	loc: DependencyLocation;
	setLoc(
		startLine?: any,
		startColumn?: any,
		endLine?: any,
		endColumn?: any
	): void;
	getResourceIdentifier(): null | string;
	couldAffectReferencingModule(): boolean | typeof TRANSITIVE;

	/**
	 * Returns the referenced module and export
	 */
	getReference(moduleGraph: ModuleGraph): never;

	/**
	 * Returns list of exports referenced by this dependency
	 */
	getReferencedExports(
		moduleGraph: ModuleGraph,
		runtime: RuntimeSpec
	): (string[] | ReferencedExport)[];
	getCondition(
		moduleGraph: ModuleGraph
	):
		| null
		| false
		| ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState);

	/**
	 * Returns the exported names
	 */
	getExports(moduleGraph: ModuleGraph): undefined | ExportsSpec;

	/**
	 * Returns warnings
	 */
	getWarnings(moduleGraph: ModuleGraph): WebpackError[];

	/**
	 * Returns errors
	 */
	getErrors(moduleGraph: ModuleGraph): WebpackError[];

	/**
	 * Update the hash
	 */
	updateHash(hash: Hash, context: UpdateHashContextDependency): void;

	/**
	 * implement this method to allow the occurrence order plugin to count correctly
	 */
	getNumberOfIdOccurrences(): number;
	getModuleEvaluationSideEffectsState(
		moduleGraph: ModuleGraph
	): ConnectionState;
	createIgnoredModule(context: string): Module;
	serialize(__0: { write: any }): void;
	deserialize(__0: { read: any }): void;
	module: any;
	readonly disconnect: any;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare interface DependencyConstructor {
	new (...args: any[]): Dependency;
}
type DependencyLocation = SyntheticDependencyLocation | RealDependencyLocation;
declare class DependencyTemplate {
	constructor();
	apply(
		dependency: Dependency,
		source: ReplaceSource,
		templateContext: DependencyTemplateContext
	): void;
}
declare interface DependencyTemplateContext {
	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the requirements for runtime
	 */
	runtimeRequirements: Set<string>;

	/**
	 * current module
	 */
	module: Module;

	/**
	 * current runtimes, for which code is generated
	 */
	runtime: RuntimeSpec;

	/**
	 * mutable array of init fragments for the current module
	 */
	initFragments: InitFragment<GenerateContext>[];

	/**
	 * when in a concatenated module, information about other concatenated modules
	 */
	concatenationScope?: ConcatenationScope;

	/**
	 * the code generation results
	 */
	codeGenerationResults: CodeGenerationResults;
}
declare abstract class DependencyTemplates {
	get(dependency: DependencyConstructor): DependencyTemplate;
	set(
		dependency: DependencyConstructor,
		dependencyTemplate: DependencyTemplate
	): void;
	updateHash(part: string): void;
	getHash(): string;
	clone(): DependencyTemplates;
}
declare class DeterministicChunkIdsPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class DeterministicModuleIdsPlugin {
	constructor(options?: {
		/**
		 * context relative to which module identifiers are computed
		 */
		context?: string;
		/**
		 * selector function for modules
		 */
		test?: (arg0: Module) => boolean;
		/**
		 * maximum id length in digits (used as starting point)
		 */
		maxLength?: number;
		/**
		 * hash salt for ids
		 */
		salt?: number;
		/**
		 * do not increase the maxLength to find an optimal id space size
		 */
		fixedLength?: boolean;
		/**
		 * throw an error when id conflicts occur (instead of rehashing)
		 */
		failOnConflict?: boolean;
	});
	options: {
		/**
		 * context relative to which module identifiers are computed
		 */
		context?: string;
		/**
		 * selector function for modules
		 */
		test?: (arg0: Module) => boolean;
		/**
		 * maximum id length in digits (used as starting point)
		 */
		maxLength?: number;
		/**
		 * hash salt for ids
		 */
		salt?: number;
		/**
		 * do not increase the maxLength to find an optimal id space size
		 */
		fixedLength?: boolean;
		/**
		 * throw an error when id conflicts occur (instead of rehashing)
		 */
		failOnConflict?: boolean;
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Options for the webpack-dev-server.
 */
declare interface DevServer {
	[index: string]: any;
}
declare class DllPlugin {
	constructor(options: DllPluginOptions);
	options: {
		entryOnly: boolean;
		/**
		 * Context of requests in the manifest file (defaults to the webpack context).
		 */
		context?: string;
		/**
		 * If true, manifest json file (output) will be formatted.
		 */
		format?: boolean;
		/**
		 * Name of the exposed dll function (external name, use value of 'output.library').
		 */
		name?: string;
		/**
		 * Absolute path to the manifest json file (output).
		 */
		path: string;
		/**
		 * Type of the dll bundle (external type, use value of 'output.libraryTarget').
		 */
		type?: string;
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface DllPluginOptions {
	/**
	 * Context of requests in the manifest file (defaults to the webpack context).
	 */
	context?: string;

	/**
	 * If true, only entry points will be exposed (default: true).
	 */
	entryOnly?: boolean;

	/**
	 * If true, manifest json file (output) will be formatted.
	 */
	format?: boolean;

	/**
	 * Name of the exposed dll function (external name, use value of 'output.library').
	 */
	name?: string;

	/**
	 * Absolute path to the manifest json file (output).
	 */
	path: string;

	/**
	 * Type of the dll bundle (external type, use value of 'output.libraryTarget').
	 */
	type?: string;
}
declare class DllReferencePlugin {
	constructor(options: DllReferencePluginOptions);
	options: DllReferencePluginOptions;
	apply(compiler?: any): void;
}
type DllReferencePluginOptions =
	| {
			/**
			 * Context of requests in the manifest (or content property) as absolute path.
			 */
			context?: string;
			/**
			 * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
			 */
			extensions?: string[];
			/**
			 * An object containing content and name or a string to the absolute path of the JSON manifest to be loaded upon compilation.
			 */
			manifest: string | DllReferencePluginOptionsManifest;
			/**
			 * The name where the dll is exposed (external name, defaults to manifest.name).
			 */
			name?: string;
			/**
			 * Prefix which is used for accessing the content of the dll.
			 */
			scope?: string;
			/**
			 * How the dll is exposed (libraryTarget, defaults to manifest.type).
			 */
			sourceType?:
				| "var"
				| "assign"
				| "this"
				| "window"
				| "global"
				| "commonjs"
				| "commonjs2"
				| "commonjs-module"
				| "amd"
				| "amd-require"
				| "umd"
				| "umd2"
				| "jsonp"
				| "system";
			/**
			 * The way how the export of the dll bundle is used.
			 */
			type?: "object" | "require";
	  }
	| {
			/**
			 * The mappings from request to module info.
			 */
			content: DllReferencePluginOptionsContent;
			/**
			 * Context of requests in the manifest (or content property) as absolute path.
			 */
			context?: string;
			/**
			 * Extensions used to resolve modules in the dll bundle (only used when using 'scope').
			 */
			extensions?: string[];
			/**
			 * The name where the dll is exposed (external name).
			 */
			name: string;
			/**
			 * Prefix which is used for accessing the content of the dll.
			 */
			scope?: string;
			/**
			 * How the dll is exposed (libraryTarget).
			 */
			sourceType?:
				| "var"
				| "assign"
				| "this"
				| "window"
				| "global"
				| "commonjs"
				| "commonjs2"
				| "commonjs-module"
				| "amd"
				| "amd-require"
				| "umd"
				| "umd2"
				| "jsonp"
				| "system";
			/**
			 * The way how the export of the dll bundle is used.
			 */
			type?: "object" | "require";
	  };

/**
 * The mappings from request to module info.
 */
declare interface DllReferencePluginOptionsContent {
	[index: string]: {
		/**
		 * Meta information about the module.
		 */
		buildMeta?: { [index: string]: any };
		/**
		 * Information about the provided exports of the module.
		 */
		exports?: true | string[];
		/**
		 * Module ID.
		 */
		id: string | number;
	};
}

/**
 * An object containing content, name and type.
 */
declare interface DllReferencePluginOptionsManifest {
	/**
	 * The mappings from request to module info.
	 */
	content: DllReferencePluginOptionsContent;

	/**
	 * The name where the dll is exposed (external name).
	 */
	name?: string;

	/**
	 * The type how the dll is exposed (external type).
	 */
	type?:
		| "var"
		| "assign"
		| "this"
		| "window"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system";
}
declare class DynamicEntryPlugin {
	constructor(context: string, entry: () => Promise<EntryStaticNormalized>);
	context: string;
	entry: () => Promise<EntryStaticNormalized>;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface Effect {
	type: string;
	value: any;
}
declare class ElectronTargetPlugin {
	constructor(context?: "main" | "preload" | "renderer");

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * No generator options are supported for this module type.
 */
declare interface EmptyGeneratorOptions {}

/**
 * No parser options are supported for this module type.
 */
declare interface EmptyParserOptions {}
declare class EnableChunkLoadingPlugin {
	constructor(type: string);
	type: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static setEnabled(compiler: Compiler, type: string): void;
	static checkEnabled(compiler: Compiler, type: string): void;
}
declare class EnableLibraryPlugin {
	constructor(type: string);
	type: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static setEnabled(compiler: Compiler, type: string): void;
	static checkEnabled(compiler: Compiler, type: string): void;
}
type Entry =
	| string
	| (() => string | EntryObject | string[] | Promise<EntryStatic>)
	| EntryObject
	| string[];
declare interface EntryData {
	/**
	 * dependencies of the entrypoint that should be evaluated at startup
	 */
	dependencies: Dependency[];

	/**
	 * dependencies of the entrypoint that should be included but not evaluated
	 */
	includeDependencies: Dependency[];

	/**
	 * options of the entrypoint
	 */
	options: EntryOptions;
}
declare abstract class EntryDependency extends ModuleDependency {}

/**
 * An object with entry point description.
 */
declare interface EntryDescription {
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Base uri for this entry.
	 */
	baseUri?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.
	 */
	dependOn?: string | string[];

	/**
	 * Specifies the filename of the output file on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Module(s) that are loaded upon startup.
	 */
	import: EntryItem;

	/**
	 * Specifies the layer in which modules of this entrypoint are placed.
	 */
	layer?: null | string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;
}

/**
 * An object with entry point description.
 */
declare interface EntryDescriptionNormalized {
	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Base uri for this entry.
	 */
	baseUri?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The entrypoints that the current entrypoint depend on. They must be loaded when this entrypoint is loaded.
	 */
	dependOn?: string[];

	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Module(s) that are loaded upon startup. The last one is exported.
	 */
	import?: string[];

	/**
	 * Specifies the layer in which modules of this entrypoint are placed.
	 */
	layer?: null | string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;
}
type EntryItem = string | string[];
type EntryNormalized =
	| (() => Promise<EntryStaticNormalized>)
	| EntryStaticNormalized;

/**
 * Multiple entry bundles are created. The key is the entry name. The value can be a string, an array or an entry description object.
 */
declare interface EntryObject {
	[index: string]: string | string[] | EntryDescription;
}
declare class EntryOptionPlugin {
	constructor();
	apply(compiler: Compiler): void;
	static applyEntryOption(
		compiler: Compiler,
		context: string,
		entry: EntryNormalized
	): void;
	static entryDescriptionToOptions(
		compiler: Compiler,
		name: string,
		desc: EntryDescriptionNormalized
	): EntryOptions;
}
type EntryOptions = { name?: string } & Omit<
	EntryDescriptionNormalized,
	"import"
>;
declare class EntryPlugin {
	/**
	 * An entry plugin which will handle
	 * creation of the EntryDependency
	 */
	constructor(context: string, entry: string, options?: string | EntryOptions);
	context: string;
	entry: string;
	options: string | EntryOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static createDependency(
		entry: string,
		options: string | EntryOptions
	): EntryDependency;
}
type EntryStatic = string | EntryObject | string[];

/**
 * Multiple entry bundles are created. The key is the entry name. The value is an entry description object.
 */
declare interface EntryStaticNormalized {
	[index: string]: EntryDescriptionNormalized;
}
declare abstract class Entrypoint extends ChunkGroup {
	/**
	 * Sets the runtimeChunk for an entrypoint.
	 */
	setRuntimeChunk(chunk: Chunk): void;

	/**
	 * Fetches the chunk reference containing the webpack bootstrap code
	 */
	getRuntimeChunk(): null | Chunk;

	/**
	 * Sets the chunk with the entrypoint modules for an entrypoint.
	 */
	setEntrypointChunk(chunk: Chunk): void;

	/**
	 * Returns the chunk which contains the entrypoint modules
	 * (or at least the execution of them)
	 */
	getEntrypointChunk(): Chunk;
}

/**
 * The abilities of the environment where the webpack generated code should run.
 */
declare interface Environment {
	/**
	 * The environment supports arrow functions ('() => { ... }').
	 */
	arrowFunction?: boolean;

	/**
	 * The environment supports BigInt as literal (123n).
	 */
	bigIntLiteral?: boolean;

	/**
	 * The environment supports const and let for variable declarations.
	 */
	const?: boolean;

	/**
	 * The environment supports destructuring ('{ a, b } = obj').
	 */
	destructuring?: boolean;

	/**
	 * The environment supports an async import() function to import EcmaScript modules.
	 */
	dynamicImport?: boolean;

	/**
	 * The environment supports 'for of' iteration ('for (const x of array) { ... }').
	 */
	forOf?: boolean;

	/**
	 * The environment supports EcmaScript Module syntax to import EcmaScript modules (import ... from '...').
	 */
	module?: boolean;

	/**
	 * The environment supports optional chaining ('obj?.a' or 'obj?.()').
	 */
	optionalChaining?: boolean;

	/**
	 * The environment supports template literals.
	 */
	templateLiteral?: boolean;
}
declare class EnvironmentPlugin {
	constructor(...keys: any[]);
	keys: any[];
	defaultValues: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface Etag {
	toString: () => string;
}
declare class EvalDevToolModulePlugin {
	constructor(options?: any);
	namespace: any;
	sourceUrlComment: any;
	moduleFilenameTemplate: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class EvalSourceMapDevToolPlugin {
	constructor(inputOptions: string | SourceMapDevToolPluginOptions);
	sourceMapComment: string;
	moduleFilenameTemplate: string | Function;
	namespace: string;
	options: SourceMapDevToolPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ExecuteModuleArgument {
	module: Module;
	moduleObject?: { id: string; exports: any; loaded: boolean };
	preparedInfo: any;
	codeGenerationResult: CodeGenerationResult;
}
declare interface ExecuteModuleContext {
	assets: Map<string, { source: Source; info: AssetInfo }>;
	chunk: Chunk;
	chunkGraph: ChunkGraph;
	__webpack_require__?: (arg0: string) => any;
}
declare interface ExecuteModuleOptions {
	entryOptions?: EntryOptions;
}
declare interface ExecuteModuleResult {
	exports: any;
	cacheable: boolean;
	assets: Map<string, { source: Source; info: AssetInfo }>;
	fileDependencies: LazySet<string>;
	contextDependencies: LazySet<string>;
	missingDependencies: LazySet<string>;
	buildDependencies: LazySet<string>;
}
type Experiments = ExperimentsCommon & ExperimentsExtra;

/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
declare interface ExperimentsCommon {
	/**
	 * Support WebAssembly as asynchronous EcmaScript Module.
	 */
	asyncWebAssembly?: boolean;

	/**
	 * Enable backward-compat layer with deprecation warnings for many webpack 4 APIs.
	 */
	backCompat?: boolean;

	/**
	 * Enable additional in memory caching of modules that are unchanged and reference only unchanged modules.
	 */
	cacheUnaffected?: boolean;

	/**
	 * Apply defaults of next major version.
	 */
	futureDefaults?: boolean;

	/**
	 * Enable module layers.
	 */
	layers?: boolean;

	/**
	 * Allow output javascript files as module source type.
	 */
	outputModule?: boolean;

	/**
	 * Support WebAssembly as synchronous EcmaScript Module (outdated).
	 */
	syncWebAssembly?: boolean;

	/**
	 * Allow using top-level-await in EcmaScript Modules.
	 */
	topLevelAwait?: boolean;
}

/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
declare interface ExperimentsExtra {
	/**
	 * Build http(s): urls using a lockfile and resource content cache.
	 */
	buildHttp?: HttpUriOptions | (string | RegExp | ((uri: string) => boolean))[];

	/**
	 * Enable css support.
	 */
	css?: boolean | CssExperimentOptions;

	/**
	 * Compile entrypoints and import()s only when they are accessed.
	 */
	lazyCompilation?: boolean | LazyCompilationOptions;
}
type ExperimentsNormalized = ExperimentsCommon & ExperimentsNormalizedExtra;

/**
 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
 */
declare interface ExperimentsNormalizedExtra {
	/**
	 * Build http(s): urls using a lockfile and resource content cache.
	 */
	buildHttp?: HttpUriOptions;

	/**
	 * Enable css support.
	 */
	css?: CssExperimentOptions;

	/**
	 * Compile entrypoints and import()s only when they are accessed.
	 */
	lazyCompilation?: LazyCompilationOptions;
}
declare abstract class ExportInfo {
	name: string;

	/**
	 * true: it is provided
	 * false: it is not provided
	 * null: only the runtime knows if it is provided
	 * undefined: it was not determined if it is provided
	 */
	provided?: null | boolean;

	/**
	 * is the export a terminal binding that should be checked for export star conflicts
	 */
	terminalBinding: boolean;

	/**
	 * true: it can be mangled
	 * false: is can not be mangled
	 * undefined: it was not determined if it can be mangled
	 */
	canMangleProvide?: boolean;

	/**
	 * true: it can be mangled
	 * false: is can not be mangled
	 * undefined: it was not determined if it can be mangled
	 */
	canMangleUse?: boolean;
	exportsInfoOwned: boolean;
	exportsInfo?: ExportsInfo;
	readonly canMangle?: boolean;
	setUsedInUnknownWay(runtime: RuntimeSpec): boolean;
	setUsedWithoutInfo(runtime: RuntimeSpec): boolean;
	setHasUseInfo(): void;
	setUsedConditionally(
		condition: (arg0: UsageStateType) => boolean,
		newValue: UsageStateType,
		runtime: RuntimeSpec
	): boolean;
	setUsed(newValue: UsageStateType, runtime: RuntimeSpec): boolean;
	unsetTarget(key?: any): boolean;
	setTarget(
		key: any,
		connection: ModuleGraphConnection,
		exportName?: string[],
		priority?: number
	): boolean;
	getUsed(runtime: RuntimeSpec): UsageStateType;

	/**
	 * get used name
	 */
	getUsedName(
		fallbackName: undefined | string,
		runtime: RuntimeSpec
	): string | false;
	hasUsedName(): boolean;

	/**
	 * Sets the mangled name of this export
	 */
	setUsedName(name: string): void;
	getTerminalBinding(
		moduleGraph: ModuleGraph,
		resolveTargetFilter?: (arg0: {
			module: Module;
			export?: string[];
		}) => boolean
	): undefined | ExportsInfo | ExportInfo;
	isReexport(): undefined | boolean;
	findTarget(
		moduleGraph: ModuleGraph,
		validTargetModuleFilter: (arg0: Module) => boolean
	): undefined | false | { module: Module; export?: string[] };
	getTarget(
		moduleGraph: ModuleGraph,
		resolveTargetFilter?: (arg0: {
			module: Module;
			export?: string[];
		}) => boolean
	): undefined | { module: Module; export?: string[] };

	/**
	 * Move the target forward as long resolveTargetFilter is fulfilled
	 */
	moveTarget(
		moduleGraph: ModuleGraph,
		resolveTargetFilter: (arg0: {
			module: Module;
			export?: string[];
		}) => boolean,
		updateOriginalConnection?: (arg0: {
			module: Module;
			export?: string[];
		}) => ModuleGraphConnection
	): undefined | { module: Module; export?: string[] };
	createNestedExportsInfo(): undefined | ExportsInfo;
	getNestedExportsInfo(): undefined | ExportsInfo;
	hasInfo(baseInfo?: any, runtime?: any): boolean;
	updateHash(hash?: any, runtime?: any): void;
	getUsedInfo(): string;
	getProvidedInfo():
		| "no provided info"
		| "maybe provided (runtime-defined)"
		| "provided"
		| "not provided";
	getRenameInfo(): string;
}
declare interface ExportSpec {
	/**
	 * the name of the export
	 */
	name: string;

	/**
	 * can the export be renamed (defaults to true)
	 */
	canMangle?: boolean;

	/**
	 * is the export a terminal binding that should be checked for export star conflicts
	 */
	terminalBinding?: boolean;

	/**
	 * nested exports
	 */
	exports?: (string | ExportSpec)[];

	/**
	 * when reexported: from which module
	 */
	from?: ModuleGraphConnection;

	/**
	 * when reexported: from which export
	 */
	export?: null | string[];

	/**
	 * when reexported: with which priority
	 */
	priority?: number;

	/**
	 * export is not visible, because another export blends over it
	 */
	hidden?: boolean;
}
type ExportedVariableInfo = string | ScopeInfo | VariableInfo;
declare abstract class ExportsInfo {
	readonly ownedExports: Iterable<ExportInfo>;
	readonly orderedOwnedExports: Iterable<ExportInfo>;
	readonly exports: Iterable<ExportInfo>;
	readonly orderedExports: Iterable<ExportInfo>;
	readonly otherExportsInfo: ExportInfo;
	setRedirectNamedTo(exportsInfo?: any): boolean;
	setHasProvideInfo(): void;
	setHasUseInfo(): void;
	getOwnExportInfo(name: string): ExportInfo;
	getExportInfo(name: string): ExportInfo;
	getReadOnlyExportInfo(name: string): ExportInfo;
	getReadOnlyExportInfoRecursive(name: string[]): undefined | ExportInfo;
	getNestedExportsInfo(name?: string[]): undefined | ExportsInfo;
	setUnknownExportsProvided(
		canMangle?: boolean,
		excludeExports?: Set<string>,
		targetKey?: any,
		targetModule?: ModuleGraphConnection,
		priority?: number
	): boolean;
	setUsedInUnknownWay(runtime: RuntimeSpec): boolean;
	setUsedWithoutInfo(runtime: RuntimeSpec): boolean;
	setAllKnownExportsUsed(runtime: RuntimeSpec): boolean;
	setUsedForSideEffectsOnly(runtime: RuntimeSpec): boolean;
	isUsed(runtime: RuntimeSpec): boolean;
	isModuleUsed(runtime: RuntimeSpec): boolean;
	getUsedExports(runtime: RuntimeSpec): null | boolean | SortableSet<string>;
	getProvidedExports(): null | true | string[];
	getRelevantExports(runtime: RuntimeSpec): ExportInfo[];
	isExportProvided(name: string | string[]): undefined | null | boolean;
	getUsageKey(runtime: RuntimeSpec): string;
	isEquallyUsed(runtimeA: RuntimeSpec, runtimeB: RuntimeSpec): boolean;
	getUsed(name: string | string[], runtime: RuntimeSpec): UsageStateType;
	getUsedName(
		name: string | string[],
		runtime: RuntimeSpec
	): string | false | string[];
	updateHash(hash: Hash, runtime: RuntimeSpec): void;
	getRestoreProvidedData(): any;
	restoreProvided(__0: {
		otherProvided: any;
		otherCanMangleProvide: any;
		otherTerminalBinding: any;
		exports: any;
	}): void;
}
declare interface ExportsSpec {
	/**
	 * exported names, true for unknown exports or null for no exports
	 */
	exports: null | true | (string | ExportSpec)[];

	/**
	 * when exports = true, list of unaffected exports
	 */
	excludeExports?: Set<string>;

	/**
	 * list of maybe prior exposed, but now hidden exports
	 */
	hideExports?: Set<string>;

	/**
	 * when reexported: from which module
	 */
	from?: ModuleGraphConnection;

	/**
	 * when reexported: with which priority
	 */
	priority?: number;

	/**
	 * can the export be renamed (defaults to true)
	 */
	canMangle?: boolean;

	/**
	 * are the exports terminal bindings that should be checked for export star conflicts
	 */
	terminalBinding?: boolean;

	/**
	 * module on which the result depends on
	 */
	dependencies?: Module[];
}
type Exposes = (string | ExposesObject)[] | ExposesObject;

/**
 * Advanced configuration for modules that should be exposed by this container.
 */
declare interface ExposesConfig {
	/**
	 * Request to a module that should be exposed by this container.
	 */
	import: string | string[];

	/**
	 * Custom chunk name for the exposed module.
	 */
	name?: string;
}

/**
 * Modules that should be exposed by this container. Property names are used as public paths.
 */
declare interface ExposesObject {
	[index: string]: string | ExposesConfig | string[];
}
type Expression =
	| UnaryExpression
	| ThisExpression
	| ArrayExpression
	| ObjectExpression
	| FunctionExpression
	| ArrowFunctionExpression
	| YieldExpression
	| SimpleLiteral
	| RegExpLiteral
	| BigIntLiteral
	| UpdateExpression
	| BinaryExpression
	| AssignmentExpression
	| LogicalExpression
	| MemberExpression
	| ConditionalExpression
	| SimpleCallExpression
	| NewExpression
	| SequenceExpression
	| TemplateLiteral
	| TaggedTemplateExpression
	| ClassExpression
	| MetaProperty
	| Identifier
	| AwaitExpression
	| ImportExpression
	| ChainExpression;
declare interface ExpressionExpressionInfo {
	type: "expression";
	rootInfo: string | VariableInfo;
	name: string;
	getMembers: () => string[];
}
type ExternalItem =
	| string
	| RegExp
	| (ExternalItemObjectKnown & ExternalItemObjectUnknown)
	| ((
			data: ExternalItemFunctionData,
			callback: (
				err?: Error,
				result?: string | boolean | string[] | { [index: string]: any }
			) => void
	  ) => void)
	| ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>);

/**
 * Data object passed as argument when a function is set for 'externals'.
 */
declare interface ExternalItemFunctionData {
	/**
	 * The directory in which the request is placed.
	 */
	context?: string;

	/**
	 * Contextual information.
	 */
	contextInfo?: ModuleFactoryCreateDataContextInfo;

	/**
	 * The category of the referencing dependencies.
	 */
	dependencyType?: string;

	/**
	 * Get a resolve function with the current resolver options.
	 */
	getResolve?: (
		options?: ResolveOptionsWebpackOptions
	) =>
		| ((
				context: string,
				request: string,
				callback: (err?: Error, result?: string) => void
		  ) => void)
		| ((context: string, request: string) => Promise<string>);

	/**
	 * The request as written by the user in the require/import expression/statement.
	 */
	request?: string;
}

/**
 * If an dependency matches exactly a property of the object, the property value is used as dependency.
 */
declare interface ExternalItemObjectKnown {
	/**
	 * Specify externals depending on the layer.
	 */
	byLayer?:
		| { [index: string]: ExternalItem }
		| ((layer: null | string) => ExternalItem);
}

/**
 * If an dependency matches exactly a property of the object, the property value is used as dependency.
 */
declare interface ExternalItemObjectUnknown {
	[index: string]: ExternalItemValue;
}
type ExternalItemValue = string | boolean | string[] | { [index: string]: any };
declare class ExternalModule extends Module {
	constructor(request?: any, type?: any, userRequest?: any);
	request: string | string[] | Record<string, string | string[]>;
	externalType: string;
	userRequest: string;
	restoreFromUnsafeCache(
		unsafeCacheData?: any,
		normalModuleFactory?: any
	): void;
}
declare interface ExternalModuleInfo {
	index: number;
	module: Module;
}
type Externals =
	| string
	| RegExp
	| ExternalItem[]
	| (ExternalItemObjectKnown & ExternalItemObjectUnknown)
	| ((
			data: ExternalItemFunctionData,
			callback: (
				err?: Error,
				result?: string | boolean | string[] | { [index: string]: any }
			) => void
	  ) => void)
	| ((data: ExternalItemFunctionData) => Promise<ExternalItemValue>);
declare class ExternalsPlugin {
	constructor(type: undefined | string, externals: Externals);
	type?: string;
	externals: Externals;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Enable presets of externals for specific targets.
 */
declare interface ExternalsPresets {
	/**
	 * Treat common electron built-in modules in main and preload context like 'electron', 'ipc' or 'shell' as external and load them via require() when used.
	 */
	electron?: boolean;

	/**
	 * Treat electron built-in modules in the main context like 'app', 'ipc-main' or 'shell' as external and load them via require() when used.
	 */
	electronMain?: boolean;

	/**
	 * Treat electron built-in modules in the preload context like 'web-frame', 'ipc-renderer' or 'shell' as external and load them via require() when used.
	 */
	electronPreload?: boolean;

	/**
	 * Treat electron built-in modules in the renderer context like 'web-frame', 'ipc-renderer' or 'shell' as external and load them via require() when used.
	 */
	electronRenderer?: boolean;

	/**
	 * Treat node.js built-in modules like fs, path or vm as external and load them via require() when used.
	 */
	node?: boolean;

	/**
	 * Treat NW.js legacy nw.gui module as external and load it via require() when used.
	 */
	nwjs?: boolean;

	/**
	 * Treat references to 'http(s)://...' and 'std:...' as external and load them via import when used (Note that this changes execution order as externals are executed before any other code in the chunk).
	 */
	web?: boolean;

	/**
	 * Treat references to 'http(s)://...' and 'std:...' as external and load them via async import() when used (Note that this external type is an async module, which has various effects on the execution).
	 */
	webAsync?: boolean;
}
type ExternalsType =
	| "import"
	| "var"
	| "module"
	| "assign"
	| "this"
	| "window"
	| "self"
	| "global"
	| "commonjs"
	| "commonjs2"
	| "commonjs-module"
	| "commonjs-static"
	| "amd"
	| "amd-require"
	| "umd"
	| "umd2"
	| "jsonp"
	| "system"
	| "promise"
	| "script"
	| "node-commonjs";
declare interface FactorizeModuleOptions {
	currentProfile: ModuleProfile;
	factory: ModuleFactory;
	dependencies: Dependency[];

	/**
	 * return full ModuleFactoryResult instead of only module
	 */
	factoryResult?: boolean;
	originModule: null | Module;
	contextInfo?: Partial<ModuleFactoryCreateDataContextInfo>;
	context?: string;
}
type FakeHook<T> = T & FakeHookMarker;
declare interface FakeHookMarker {}
declare interface FallbackCacheGroup {
	chunksFilter: (chunk: Chunk) => boolean;
	minSize: SplitChunksSizes;
	maxAsyncSize: SplitChunksSizes;
	maxInitialSize: SplitChunksSizes;
	automaticNameDelimiter: string;
}
declare class FetchCompileAsyncWasmPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class FetchCompileWasmPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Options object for persistent file-based caching.
 */
declare interface FileCacheOptions {
	/**
	 * Allows to collect unused memory allocated during deserialization. This requires copying data into smaller buffers and has a performance cost.
	 */
	allowCollectingMemory?: boolean;

	/**
	 * Dependencies the build depends on (in multiple categories, default categories: 'defaultWebpack').
	 */
	buildDependencies?: { [index: string]: string[] };

	/**
	 * Base directory for the cache (defaults to node_modules/.cache/webpack).
	 */
	cacheDirectory?: string;

	/**
	 * Locations for the cache (defaults to cacheDirectory / name).
	 */
	cacheLocation?: string;

	/**
	 * Compression type used for the cache files.
	 */
	compression?: false | "gzip" | "brotli";

	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashAlgorithm?: string;

	/**
	 * Time in ms after which idle period the cache storing should happen.
	 */
	idleTimeout?: number;

	/**
	 * Time in ms after which idle period the cache storing should happen when larger changes has been detected (cumulative build time > 2 x avg cache store time).
	 */
	idleTimeoutAfterLargeChanges?: number;

	/**
	 * Time in ms after which idle period the initial cache storing should happen.
	 */
	idleTimeoutForInitialStore?: number;

	/**
	 * List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.
	 */
	immutablePaths?: (string | RegExp)[];

	/**
	 * List of paths that are managed by a package manager and can be trusted to not be modified otherwise.
	 */
	managedPaths?: (string | RegExp)[];

	/**
	 * Time for which unused cache entries stay in the filesystem cache at minimum (in milliseconds).
	 */
	maxAge?: number;

	/**
	 * Number of generations unused cache entries stay in memory cache at minimum (0 = no memory cache used, 1 = may be removed after unused for a single compilation, ..., Infinity: kept forever). Cache entries will be deserialized from disk when removed from memory cache.
	 */
	maxMemoryGenerations?: number;

	/**
	 * Additionally cache computation of modules that are unchanged and reference only unchanged modules in memory.
	 */
	memoryCacheUnaffected?: boolean;

	/**
	 * Name for the cache. Different names will lead to different coexisting caches.
	 */
	name?: string;

	/**
	 * Track and log detailed timing information for individual cache items.
	 */
	profile?: boolean;

	/**
	 * When to store data to the filesystem. (pack: Store data when compiler is idle in a single file).
	 */
	store?: "pack";

	/**
	 * Filesystem caching.
	 */
	type: "filesystem";

	/**
	 * Version of the cache data. Different versions won't allow to reuse the cache and override existing content. Update the version when config changed in a way which doesn't allow to reuse cache. This will invalidate the cache.
	 */
	version?: string;
}
declare interface FileSystem {
	readFile: {
		(arg0: string, arg1: FileSystemCallback<string | Buffer>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
	readdir: {
		(
			arg0: string,
			arg1: FileSystemCallback<(string | Buffer)[] | FileSystemDirent[]>
		): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<(string | Buffer)[] | FileSystemDirent[]>
		): void;
	};
	readJson?: {
		(arg0: string, arg1: FileSystemCallback<object>): void;
		(arg0: string, arg1: object, arg2: FileSystemCallback<object>): void;
	};
	readlink: {
		(arg0: string, arg1: FileSystemCallback<string | Buffer>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
	lstat?: {
		(arg0: string, arg1: FileSystemCallback<FileSystemStats>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
	stat: {
		(arg0: string, arg1: FileSystemCallback<FileSystemStats>): void;
		(
			arg0: string,
			arg1: object,
			arg2: FileSystemCallback<string | Buffer>
		): void;
	};
}
declare interface FileSystemCallback<T> {
	(err?: null | (PossibleFileSystemError & Error), result?: T): any;
}
declare interface FileSystemDirent {
	name: string | Buffer;
	isDirectory: () => boolean;
	isFile: () => boolean;
}
declare abstract class FileSystemInfo {
	fs: InputFileSystem;
	logger?: WebpackLogger;
	fileTimestampQueue: AsyncQueue<string, string, null | FileSystemInfoEntry>;
	fileHashQueue: AsyncQueue<string, string, null | string>;
	contextTimestampQueue: AsyncQueue<
		string,
		string,
		null | ContextFileSystemInfoEntry
	>;
	contextHashQueue: AsyncQueue<string, string, null | ContextHash>;
	contextTshQueue: AsyncQueue<string, string, null | ContextTimestampAndHash>;
	managedItemQueue: AsyncQueue<string, string, null | string>;
	managedItemDirectoryQueue: AsyncQueue<string, string, Set<string>>;
	managedPaths: (string | RegExp)[];
	managedPathsWithSlash: string[];
	managedPathsRegExps: RegExp[];
	immutablePaths: (string | RegExp)[];
	immutablePathsWithSlash: string[];
	immutablePathsRegExps: RegExp[];
	logStatistics(): void;
	clear(): void;
	addFileTimestamps(
		map: ReadonlyMap<string, null | FileSystemInfoEntry | "ignore">,
		immutable?: boolean
	): void;
	addContextTimestamps(
		map: ReadonlyMap<string, null | FileSystemInfoEntry | "ignore">,
		immutable?: boolean
	): void;
	getFileTimestamp(
		path: string,
		callback: (
			arg0?: null | WebpackError,
			arg1?: null | FileSystemInfoEntry | "ignore"
		) => void
	): void;
	getContextTimestamp(
		path: string,
		callback: (
			arg0?: null | WebpackError,
			arg1?: null | "ignore" | ResolvedContextFileSystemInfoEntry
		) => void
	): void;
	getFileHash(
		path: string,
		callback: (arg0?: null | WebpackError, arg1?: string) => void
	): void;
	getContextHash(
		path: string,
		callback: (arg0?: null | WebpackError, arg1?: string) => void
	): void;
	getContextTsh(
		path: string,
		callback: (
			arg0?: null | WebpackError,
			arg1?: ResolvedContextTimestampAndHash
		) => void
	): void;
	resolveBuildDependencies(
		context: string,
		deps: Iterable<string>,
		callback: (
			arg0?: null | Error,
			arg1?: ResolveBuildDependenciesResult
		) => void
	): void;
	checkResolveResultsValid(
		resolveResults: Map<string, string | false>,
		callback: (arg0?: null | Error, arg1?: boolean) => void
	): void;
	createSnapshot(
		startTime: number,
		files: Iterable<string>,
		directories: Iterable<string>,
		missing: Iterable<string>,
		options: {
			/**
			 * Use hashes of the content of the files/directories to determine invalidation.
			 */
			hash?: boolean;
			/**
			 * Use timestamps of the files/directories to determine invalidation.
			 */
			timestamp?: boolean;
		},
		callback: (arg0?: null | WebpackError, arg1?: null | Snapshot) => void
	): void;
	mergeSnapshots(snapshot1: Snapshot, snapshot2: Snapshot): Snapshot;
	checkSnapshotValid(
		snapshot: Snapshot,
		callback: (arg0?: null | WebpackError, arg1?: boolean) => void
	): void;
	getDeprecatedFileTimestamps(): Map<any, any>;
	getDeprecatedContextTimestamps(): Map<any, any>;
}
declare interface FileSystemInfoEntry {
	safeTime: number;
	timestamp?: number;
}
declare interface FileSystemStats {
	isDirectory: () => boolean;
	isFile: () => boolean;
}
type FilterItemTypes = string | RegExp | ((value: string) => boolean);
declare interface GenerateContext {
	/**
	 * mapping from dependencies to templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the requirements for runtime
	 */
	runtimeRequirements: Set<string>;

	/**
	 * the runtime
	 */
	runtime: RuntimeSpec;

	/**
	 * when in concatenated module, information about other concatenated modules
	 */
	concatenationScope?: ConcatenationScope;

	/**
	 * code generation results of other modules (need to have a codeGenerationDependency to use that)
	 */
	codeGenerationResults?: CodeGenerationResults;

	/**
	 * which kind of code should be generated
	 */
	type: string;

	/**
	 * get access to the code generation data
	 */
	getData?: () => Map<string, any>;
}
declare class Generator {
	constructor();
	getTypes(module: NormalModule): Set<string>;
	getSize(module: NormalModule, type?: string): number;
	generate(module: NormalModule, __1: GenerateContext): Source;
	getConcatenationBailoutReason(
		module: NormalModule,
		context: ConcatenationBailoutReasonContext
	): undefined | string;
	updateHash(hash: Hash, __1: UpdateHashContextGenerator): void;
	static byType(map?: any): ByTypeGenerator;
}
type GeneratorOptionsByModuleType = GeneratorOptionsByModuleTypeKnown &
	GeneratorOptionsByModuleTypeUnknown;

/**
 * Specify options for each generator.
 */
declare interface GeneratorOptionsByModuleTypeKnown {
	/**
	 * Generator options for asset modules.
	 */
	asset?: AssetGeneratorOptions;

	/**
	 * Generator options for asset/inline modules.
	 */
	"asset/inline"?: AssetInlineGeneratorOptions;

	/**
	 * Generator options for asset/resource modules.
	 */
	"asset/resource"?: AssetResourceGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	javascript?: EmptyGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/auto"?: EmptyGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/dynamic"?: EmptyGeneratorOptions;

	/**
	 * No generator options are supported for this module type.
	 */
	"javascript/esm"?: EmptyGeneratorOptions;
}

/**
 * Specify options for each generator.
 */
declare interface GeneratorOptionsByModuleTypeUnknown {
	[index: string]: { [index: string]: any };
}
declare class GetChunkFilenameRuntimeModule extends RuntimeModule {
	constructor(
		contentType: string,
		name: string,
		global: string,
		getFilenameForChunk: (
			arg0: Chunk
		) => string | ((arg0: PathData, arg1?: AssetInfo) => string),
		allChunks: boolean
	);
	contentType: string;
	global: string;
	getFilenameForChunk: (
		arg0: Chunk
	) => string | ((arg0: PathData, arg1?: AssetInfo) => string);
	allChunks: boolean;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}
declare interface GroupConfig {
	getKeys: (arg0?: any) => string[];
	createGroup: (arg0: string, arg1: any[], arg2: any[]) => object;
	getOptions?: (arg0: string, arg1: any[]) => GroupOptions;
}
declare interface GroupOptions {
	groupChildren?: boolean;
	force?: boolean;
	targetGroupCount?: number;
}
declare interface HMRJavascriptParserHooks {
	hotAcceptCallback: SyncBailHook<[any, string[]], void>;
	hotAcceptWithoutCallback: SyncBailHook<[any, string[]], void>;
}
declare interface HandleModuleCreationOptions {
	factory: ModuleFactory;
	dependencies: Dependency[];
	originModule: null | Module;
	contextInfo?: Partial<ModuleFactoryCreateDataContextInfo>;
	context?: string;

	/**
	 * recurse into dependencies of the created module
	 */
	recursive?: boolean;

	/**
	 * connect the resolved module with the origin module
	 */
	connectOrigin?: boolean;
}
declare class Hash {
	constructor();

	/**
	 * Update hash {@link https ://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
	 */
	update(data: string | Buffer, inputEncoding?: string): Hash;

	/**
	 * Calculates the digest {@link https ://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
	 */
	digest(encoding?: string): string | Buffer;
}
declare interface HashableObject {
	updateHash: (arg0: Hash) => void;
}
declare class HashedModuleIdsPlugin {
	constructor(options?: HashedModuleIdsPluginOptions);
	options: HashedModuleIdsPluginOptions;
	apply(compiler?: any): void;
}
declare interface HashedModuleIdsPluginOptions {
	/**
	 * The context directory for creating names.
	 */
	context?: string;

	/**
	 * The encoding to use when generating the hash, defaults to 'base64'. All encodings from Node.JS' hash.digest are supported.
	 */
	hashDigest?: "latin1" | "hex" | "base64";

	/**
	 * The prefix length of the hash digest to use, defaults to 4.
	 */
	hashDigestLength?: number;

	/**
	 * The hashing algorithm to use, defaults to 'md4'. All functions from Node.JS' crypto.createHash are supported.
	 */
	hashFunction?: string | typeof Hash;
}
declare abstract class HelperRuntimeModule extends RuntimeModule {}
declare class HotModuleReplacementPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getParserHooks(parser: JavascriptParser): HMRJavascriptParserHooks;
}

/**
 * These properties are added by the HotModuleReplacementPlugin
 */
declare interface HotModuleReplacementPluginLoaderContext {
	hot?: boolean;
}
declare class HotUpdateChunk extends Chunk {
	constructor();
}

/**
 * Options for building http resources.
 */
declare interface HttpUriOptions {
	/**
	 * List of allowed URIs (resp. the beginning of them).
	 */
	allowedUris: (string | RegExp | ((uri: string) => boolean))[];

	/**
	 * Location where resource content is stored for lockfile entries. It's also possible to disable storing by passing false.
	 */
	cacheLocation?: string | false;

	/**
	 * When set, anything that would lead to a modification of the lockfile or any resource content, will result in an error.
	 */
	frozen?: boolean;

	/**
	 * Location of the lockfile.
	 */
	lockfileLocation?: string;

	/**
	 * Proxy configuration, which can be used to specify a proxy server to use for HTTP requests.
	 */
	proxy?: string;

	/**
	 * When set, resources of existing lockfile entries will be fetched and entries will be upgraded when resource content has changed.
	 */
	upgrade?: boolean;
}
declare class HttpUriPlugin {
	constructor(options: HttpUriOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface IDirent {
	isFile: () => boolean;
	isDirectory: () => boolean;
	isBlockDevice: () => boolean;
	isCharacterDevice: () => boolean;
	isSymbolicLink: () => boolean;
	isFIFO: () => boolean;
	isSocket: () => boolean;
	name: string | Buffer;
}
declare interface IStats {
	isFile: () => boolean;
	isDirectory: () => boolean;
	isBlockDevice: () => boolean;
	isCharacterDevice: () => boolean;
	isSymbolicLink: () => boolean;
	isFIFO: () => boolean;
	isSocket: () => boolean;
	dev: number | bigint;
	ino: number | bigint;
	mode: number | bigint;
	nlink: number | bigint;
	uid: number | bigint;
	gid: number | bigint;
	rdev: number | bigint;
	size: number | bigint;
	blksize: number | bigint;
	blocks: number | bigint;
	atimeMs: number | bigint;
	mtimeMs: number | bigint;
	ctimeMs: number | bigint;
	birthtimeMs: number | bigint;
	atime: Date;
	mtime: Date;
	ctime: Date;
	birthtime: Date;
}
declare class IgnorePlugin {
	constructor(options: IgnorePluginOptions);
	options: IgnorePluginOptions;

	/**
	 * Note that if "contextRegExp" is given, both the "resourceRegExp"
	 * and "contextRegExp" have to match.
	 */
	checkIgnore(resolveData: ResolveData): undefined | false;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type IgnorePluginOptions =
	| {
			/**
			 * A RegExp to test the context (directory) against.
			 */
			contextRegExp?: RegExp;
			/**
			 * A RegExp to test the request against.
			 */
			resourceRegExp: RegExp;
	  }
	| {
			/**
			 * A filter function for resource and context.
			 */
			checkResource: (resource: string, context: string) => boolean;
	  };
declare interface ImportModuleOptions {
	/**
	 * the target layer
	 */
	layer?: string;

	/**
	 * the target public path
	 */
	publicPath?: string;

	/**
	 * target base uri
	 */
	baseUri?: string;
}
type ImportSource =
	| undefined
	| null
	| string
	| SimpleLiteral
	| RegExpLiteral
	| BigIntLiteral;

/**
 * Options for infrastructure level logging.
 */
declare interface InfrastructureLogging {
	/**
	 * Only appends lines to the output. Avoids updating existing output e. g. for status messages. This option is only used when no custom console is provided.
	 */
	appendOnly?: boolean;

	/**
	 * Enables/Disables colorful output. This option is only used when no custom console is provided.
	 */
	colors?: boolean;

	/**
	 * Custom console used for logging.
	 */
	console?: Console;

	/**
	 * Enable debug logging for specific loggers.
	 */
	debug?:
		| string
		| boolean
		| RegExp
		| FilterItemTypes[]
		| ((value: string) => boolean);

	/**
	 * Log level.
	 */
	level?: "none" | "error" | "warn" | "info" | "log" | "verbose";

	/**
	 * Stream used for logging output. Defaults to process.stderr. This option is only used when no custom console is provided.
	 */
	stream?: NodeJS.WritableStream;
}
declare abstract class InitFragment<Context> {
	content: string | Source;
	stage: number;
	position: number;
	key?: string;
	endContent?: string | Source;
	getContent(context: Context): string | Source;
	getEndContent(context: Context): undefined | string | Source;
	serialize(context?: any): void;
	deserialize(context?: any): void;
	merge: any;
}
declare interface InputFileSystem {
	readFile: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	readJson?: (
		arg0: string,
		arg1: (arg0?: null | Error | NodeJS.ErrnoException, arg1?: any) => void
	) => void;
	readlink: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	readdir: (
		arg0: string,
		arg1: (
			arg0?: null | NodeJS.ErrnoException,
			arg1?: (string | Buffer)[] | IDirent[]
		) => void
	) => void;
	stat: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	lstat?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	realpath?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	purge?: (arg0?: string) => void;
	join?: (arg0: string, arg1: string) => string;
	relative?: (arg0: string, arg1: string) => string;
	dirname?: (arg0: string) => string;
}
type IntermediateFileSystem = InputFileSystem &
	OutputFileSystem &
	IntermediateFileSystemExtras;
declare interface IntermediateFileSystemExtras {
	mkdirSync: (arg0: string) => void;
	createWriteStream: (arg0: string) => NodeJS.WritableStream;
	open: (
		arg0: string,
		arg1: string,
		arg2: (arg0?: null | NodeJS.ErrnoException, arg1?: number) => void
	) => void;
	read: (
		arg0: number,
		arg1: Buffer,
		arg2: number,
		arg3: number,
		arg4: number,
		arg5: (arg0?: null | NodeJS.ErrnoException, arg1?: number) => void
	) => void;
	close: (
		arg0: number,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	rename: (
		arg0: string,
		arg1: string,
		arg2: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
}
type InternalCell<T> = T | typeof TOMBSTONE | typeof UNDEFINED_MARKER;
declare abstract class ItemCacheFacade {
	get<T>(callback: CallbackCache<T>): void;
	getPromise<T>(): Promise<T>;
	store<T>(data: T, callback: CallbackCache<void>): void;
	storePromise<T>(data: T): Promise<void>;
	provide<T>(
		computer: (arg0: CallbackNormalErrorCache<T>) => void,
		callback: CallbackNormalErrorCache<T>
	): void;
	providePromise<T>(computer: () => T | Promise<T>): Promise<T>;
}
declare class JavascriptModulesPlugin {
	constructor(options?: object);
	options: object;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	renderModule(
		module: Module,
		renderContext: ChunkRenderContext,
		hooks: CompilationHooksJavascriptModulesPlugin,
		factory: boolean
	): Source;
	renderChunk(
		renderContext: RenderContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): Source;
	renderMain(
		renderContext: MainRenderContext,
		hooks: CompilationHooksJavascriptModulesPlugin,
		compilation: Compilation
	): Source;
	updateHashWithBootstrap(
		hash: Hash,
		renderContext: RenderBootstrapContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): void;
	renderBootstrap(
		renderContext: RenderBootstrapContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): {
		header: string[];
		beforeStartup: string[];
		startup: string[];
		afterStartup: string[];
		allowInlineStartup: boolean;
	};
	renderRequire(
		renderContext: RenderBootstrapContext,
		hooks: CompilationHooksJavascriptModulesPlugin
	): string;
	static getCompilationHooks(
		compilation: Compilation
	): CompilationHooksJavascriptModulesPlugin;
	static getChunkFilenameTemplate(chunk?: any, outputOptions?: any): any;
	static chunkHasJs: (chunk: Chunk, chunkGraph: ChunkGraph) => boolean;
}
declare class JavascriptParser extends Parser {
	constructor(sourceType?: "module" | "auto" | "script");
	hooks: Readonly<{
		evaluateTypeof: HookMap<
			SyncBailHook<
				[UnaryExpression],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		evaluate: HookMap<
			SyncBailHook<[Expression], undefined | null | BasicEvaluatedExpression>
		>;
		evaluateIdentifier: HookMap<
			SyncBailHook<
				[ThisExpression | MemberExpression | MetaProperty | Identifier],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		evaluateDefinedIdentifier: HookMap<
			SyncBailHook<
				[ThisExpression | MemberExpression | Identifier],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		evaluateCallExpressionMember: HookMap<
			SyncBailHook<
				[CallExpression, undefined | BasicEvaluatedExpression],
				undefined | null | BasicEvaluatedExpression
			>
		>;
		isPure: HookMap<
			SyncBailHook<
				[
					(
						| UnaryExpression
						| ThisExpression
						| ArrayExpression
						| ObjectExpression
						| FunctionExpression
						| ArrowFunctionExpression
						| YieldExpression
						| SimpleLiteral
						| RegExpLiteral
						| BigIntLiteral
						| UpdateExpression
						| BinaryExpression
						| AssignmentExpression
						| LogicalExpression
						| MemberExpression
						| ConditionalExpression
						| SimpleCallExpression
						| NewExpression
						| SequenceExpression
						| TemplateLiteral
						| TaggedTemplateExpression
						| ClassExpression
						| MetaProperty
						| Identifier
						| AwaitExpression
						| ImportExpression
						| ChainExpression
						| FunctionDeclaration
						| VariableDeclaration
						| ClassDeclaration
						| PrivateIdentifier
					),
					number
				],
				boolean | void
			>
		>;
		preStatement: SyncBailHook<
			[
				| FunctionDeclaration
				| VariableDeclaration
				| ClassDeclaration
				| ExpressionStatement
				| BlockStatement
				| StaticBlock
				| EmptyStatement
				| DebuggerStatement
				| WithStatement
				| ReturnStatement
				| LabeledStatement
				| BreakStatement
				| ContinueStatement
				| IfStatement
				| SwitchStatement
				| ThrowStatement
				| TryStatement
				| WhileStatement
				| DoWhileStatement
				| ForStatement
				| ForInStatement
				| ForOfStatement
				| ImportDeclaration
				| ExportNamedDeclaration
				| ExportDefaultDeclaration
				| ExportAllDeclaration
			],
			boolean | void
		>;
		blockPreStatement: SyncBailHook<
			[
				| FunctionDeclaration
				| VariableDeclaration
				| ClassDeclaration
				| ExpressionStatement
				| BlockStatement
				| StaticBlock
				| EmptyStatement
				| DebuggerStatement
				| WithStatement
				| ReturnStatement
				| LabeledStatement
				| BreakStatement
				| ContinueStatement
				| IfStatement
				| SwitchStatement
				| ThrowStatement
				| TryStatement
				| WhileStatement
				| DoWhileStatement
				| ForStatement
				| ForInStatement
				| ForOfStatement
				| ImportDeclaration
				| ExportNamedDeclaration
				| ExportDefaultDeclaration
				| ExportAllDeclaration
			],
			boolean | void
		>;
		statement: SyncBailHook<
			[
				| FunctionDeclaration
				| VariableDeclaration
				| ClassDeclaration
				| ExpressionStatement
				| BlockStatement
				| StaticBlock
				| EmptyStatement
				| DebuggerStatement
				| WithStatement
				| ReturnStatement
				| LabeledStatement
				| BreakStatement
				| ContinueStatement
				| IfStatement
				| SwitchStatement
				| ThrowStatement
				| TryStatement
				| WhileStatement
				| DoWhileStatement
				| ForStatement
				| ForInStatement
				| ForOfStatement
				| ImportDeclaration
				| ExportNamedDeclaration
				| ExportDefaultDeclaration
				| ExportAllDeclaration
			],
			boolean | void
		>;
		statementIf: SyncBailHook<[IfStatement], boolean | void>;
		classExtendsExpression: SyncBailHook<
			[Expression, ClassExpression | ClassDeclaration],
			boolean | void
		>;
		classBodyElement: SyncBailHook<
			[
				MethodDefinition | PropertyDefinition,
				ClassExpression | ClassDeclaration
			],
			boolean | void
		>;
		classBodyValue: SyncBailHook<
			[
				Expression,
				MethodDefinition | PropertyDefinition,
				ClassExpression | ClassDeclaration
			],
			boolean | void
		>;
		label: HookMap<SyncBailHook<[LabeledStatement], boolean | void>>;
		import: SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>;
		importSpecifier: SyncBailHook<
			[ImportDeclaration, ImportSource, string, string],
			boolean | void
		>;
		export: SyncBailHook<
			[ExportNamedDeclaration | ExportAllDeclaration],
			boolean | void
		>;
		exportImport: SyncBailHook<
			[ExportNamedDeclaration | ExportAllDeclaration, ImportSource],
			boolean | void
		>;
		exportDeclaration: SyncBailHook<
			[ExportNamedDeclaration | ExportAllDeclaration, Declaration],
			boolean | void
		>;
		exportExpression: SyncBailHook<
			[ExportDefaultDeclaration, Declaration],
			boolean | void
		>;
		exportSpecifier: SyncBailHook<
			[
				ExportNamedDeclaration | ExportAllDeclaration,
				string,
				string,
				undefined | number
			],
			boolean | void
		>;
		exportImportSpecifier: SyncBailHook<
			[
				ExportNamedDeclaration | ExportAllDeclaration,
				ImportSource,
				string,
				string,
				undefined | number
			],
			boolean | void
		>;
		preDeclarator: SyncBailHook<
			[VariableDeclarator, Statement],
			boolean | void
		>;
		declarator: SyncBailHook<[VariableDeclarator, Statement], boolean | void>;
		varDeclaration: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		varDeclarationLet: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		varDeclarationConst: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		varDeclarationVar: HookMap<SyncBailHook<[Declaration], boolean | void>>;
		pattern: HookMap<SyncBailHook<[Identifier], boolean | void>>;
		canRename: HookMap<SyncBailHook<[Expression], boolean | void>>;
		rename: HookMap<SyncBailHook<[Expression], boolean | void>>;
		assign: HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>;
		assignMemberChain: HookMap<
			SyncBailHook<[AssignmentExpression, string[]], boolean | void>
		>;
		typeof: HookMap<SyncBailHook<[Expression], boolean | void>>;
		importCall: SyncBailHook<[Expression], boolean | void>;
		topLevelAwait: SyncBailHook<[Expression], boolean | void>;
		call: HookMap<SyncBailHook<[Expression], boolean | void>>;
		callMemberChain: HookMap<
			SyncBailHook<[CallExpression, string[]], boolean | void>
		>;
		memberChainOfCallMemberChain: HookMap<
			SyncBailHook<
				[Expression, string[], CallExpression, string[]],
				boolean | void
			>
		>;
		callMemberChainOfCallMemberChain: HookMap<
			SyncBailHook<
				[Expression, string[], CallExpression, string[]],
				boolean | void
			>
		>;
		optionalChaining: SyncBailHook<[ChainExpression], boolean | void>;
		new: HookMap<SyncBailHook<[NewExpression], boolean | void>>;
		expression: HookMap<SyncBailHook<[Expression], boolean | void>>;
		expressionMemberChain: HookMap<
			SyncBailHook<[Expression, string[]], boolean | void>
		>;
		unhandledExpressionMemberChain: HookMap<
			SyncBailHook<[Expression, string[]], boolean | void>
		>;
		expressionConditionalOperator: SyncBailHook<[Expression], boolean | void>;
		expressionLogicalOperator: SyncBailHook<[Expression], boolean | void>;
		program: SyncBailHook<[Program, Comment[]], boolean | void>;
		finish: SyncBailHook<[Program, Comment[]], boolean | void>;
	}>;
	sourceType: "module" | "auto" | "script";
	scope: ScopeInfo;
	state: ParserState;
	comments: any;
	semicolons: any;
	statementPath: (
		| UnaryExpression
		| ThisExpression
		| ArrayExpression
		| ObjectExpression
		| FunctionExpression
		| ArrowFunctionExpression
		| YieldExpression
		| SimpleLiteral
		| RegExpLiteral
		| BigIntLiteral
		| UpdateExpression
		| BinaryExpression
		| AssignmentExpression
		| LogicalExpression
		| MemberExpression
		| ConditionalExpression
		| SimpleCallExpression
		| NewExpression
		| SequenceExpression
		| TemplateLiteral
		| TaggedTemplateExpression
		| ClassExpression
		| MetaProperty
		| Identifier
		| AwaitExpression
		| ImportExpression
		| ChainExpression
		| FunctionDeclaration
		| VariableDeclaration
		| ClassDeclaration
		| ExpressionStatement
		| BlockStatement
		| StaticBlock
		| EmptyStatement
		| DebuggerStatement
		| WithStatement
		| ReturnStatement
		| LabeledStatement
		| BreakStatement
		| ContinueStatement
		| IfStatement
		| SwitchStatement
		| ThrowStatement
		| TryStatement
		| WhileStatement
		| DoWhileStatement
		| ForStatement
		| ForInStatement
		| ForOfStatement
	)[];
	prevStatement: any;
	currentTagData: any;
	getRenameIdentifier(expr?: any): undefined | string;
	walkClass(classy: ClassExpression | ClassDeclaration): void;
	preWalkStatements(statements?: any): void;
	blockPreWalkStatements(statements?: any): void;
	walkStatements(statements?: any): void;
	preWalkStatement(statement?: any): void;
	blockPreWalkStatement(statement?: any): void;
	walkStatement(statement?: any): void;

	/**
	 * Walks a statements that is nested within a parent statement
	 * and can potentially be a non-block statement.
	 * This enforces the nested statement to never be in ASI position.
	 */
	walkNestedStatement(statement: Statement): void;
	preWalkBlockStatement(statement?: any): void;
	walkBlockStatement(statement?: any): void;
	walkExpressionStatement(statement?: any): void;
	preWalkIfStatement(statement?: any): void;
	walkIfStatement(statement?: any): void;
	preWalkLabeledStatement(statement?: any): void;
	walkLabeledStatement(statement?: any): void;
	preWalkWithStatement(statement?: any): void;
	walkWithStatement(statement?: any): void;
	preWalkSwitchStatement(statement?: any): void;
	walkSwitchStatement(statement?: any): void;
	walkTerminatingStatement(statement?: any): void;
	walkReturnStatement(statement?: any): void;
	walkThrowStatement(statement?: any): void;
	preWalkTryStatement(statement?: any): void;
	walkTryStatement(statement?: any): void;
	preWalkWhileStatement(statement?: any): void;
	walkWhileStatement(statement?: any): void;
	preWalkDoWhileStatement(statement?: any): void;
	walkDoWhileStatement(statement?: any): void;
	preWalkForStatement(statement?: any): void;
	walkForStatement(statement?: any): void;
	preWalkForInStatement(statement?: any): void;
	walkForInStatement(statement?: any): void;
	preWalkForOfStatement(statement?: any): void;
	walkForOfStatement(statement?: any): void;
	preWalkFunctionDeclaration(statement?: any): void;
	walkFunctionDeclaration(statement?: any): void;
	blockPreWalkImportDeclaration(statement?: any): void;
	enterDeclaration(declaration?: any, onIdent?: any): void;
	blockPreWalkExportNamedDeclaration(statement?: any): void;
	walkExportNamedDeclaration(statement?: any): void;
	blockPreWalkExportDefaultDeclaration(statement?: any): void;
	walkExportDefaultDeclaration(statement?: any): void;
	blockPreWalkExportAllDeclaration(statement?: any): void;
	preWalkVariableDeclaration(statement?: any): void;
	blockPreWalkVariableDeclaration(statement?: any): void;
	walkVariableDeclaration(statement?: any): void;
	blockPreWalkClassDeclaration(statement?: any): void;
	walkClassDeclaration(statement?: any): void;
	preWalkSwitchCases(switchCases?: any): void;
	walkSwitchCases(switchCases?: any): void;
	preWalkCatchClause(catchClause?: any): void;
	walkCatchClause(catchClause?: any): void;
	walkPattern(pattern?: any): void;
	walkAssignmentPattern(pattern?: any): void;
	walkObjectPattern(pattern?: any): void;
	walkArrayPattern(pattern?: any): void;
	walkRestElement(pattern?: any): void;
	walkExpressions(expressions?: any): void;
	walkExpression(expression?: any): void;
	walkAwaitExpression(expression?: any): void;
	walkArrayExpression(expression?: any): void;
	walkSpreadElement(expression?: any): void;
	walkObjectExpression(expression?: any): void;
	walkProperty(prop?: any): void;
	walkFunctionExpression(expression?: any): void;
	walkArrowFunctionExpression(expression?: any): void;
	walkSequenceExpression(expression: SequenceExpression): void;
	walkUpdateExpression(expression?: any): void;
	walkUnaryExpression(expression?: any): void;
	walkLeftRightExpression(expression?: any): void;
	walkBinaryExpression(expression?: any): void;
	walkLogicalExpression(expression?: any): void;
	walkAssignmentExpression(expression?: any): void;
	walkConditionalExpression(expression?: any): void;
	walkNewExpression(expression?: any): void;
	walkYieldExpression(expression?: any): void;
	walkTemplateLiteral(expression?: any): void;
	walkTaggedTemplateExpression(expression?: any): void;
	walkClassExpression(expression?: any): void;
	walkChainExpression(expression: ChainExpression): void;
	walkImportExpression(expression?: any): void;
	walkCallExpression(expression?: any): void;
	walkMemberExpression(expression?: any): void;
	walkMemberExpressionWithExpressionName(
		expression?: any,
		name?: any,
		rootInfo?: any,
		members?: any,
		onUnhandled?: any
	): void;
	walkThisExpression(expression?: any): void;
	walkIdentifier(expression?: any): void;
	walkMetaProperty(metaProperty: MetaProperty): void;
	callHooksForExpression(hookMap: any, expr: any, ...args: any[]): any;
	callHooksForExpressionWithFallback<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		expr: MemberExpression,
		fallback: (
			arg0: string,
			arg1: string | ScopeInfo | VariableInfo,
			arg2: () => string[]
		) => any,
		defined: (arg0: string) => any,
		...args: AsArray<T>
	): R;
	callHooksForName<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		name: string,
		...args: AsArray<T>
	): R;
	callHooksForInfo<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		info: ExportedVariableInfo,
		...args: AsArray<T>
	): R;
	callHooksForInfoWithFallback<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		info: ExportedVariableInfo,
		fallback: (arg0: string) => any,
		defined: () => any,
		...args: AsArray<T>
	): R;
	callHooksForNameWithFallback<T, R>(
		hookMap: HookMap<SyncBailHook<T, R>>,
		name: string,
		fallback: (arg0: string) => any,
		defined: () => any,
		...args: AsArray<T>
	): R;
	inScope(params: any, fn: () => void): void;
	inFunctionScope(hasThis?: any, params?: any, fn?: any): void;
	inBlockScope(fn?: any): void;
	detectMode(statements?: any): void;
	enterPatterns(patterns?: any, onIdent?: any): void;
	enterPattern(pattern?: any, onIdent?: any): void;
	enterIdentifier(pattern?: any, onIdent?: any): void;
	enterObjectPattern(pattern?: any, onIdent?: any): void;
	enterArrayPattern(pattern?: any, onIdent?: any): void;
	enterRestElement(pattern?: any, onIdent?: any): void;
	enterAssignmentPattern(pattern?: any, onIdent?: any): void;
	evaluateExpression(
		expression: Expression
	): undefined | BasicEvaluatedExpression;
	parseString(expression?: any): any;
	parseCalculatedString(expression?: any): any;
	evaluate(source?: any): undefined | BasicEvaluatedExpression;
	isPure(
		expr:
			| undefined
			| null
			| UnaryExpression
			| ThisExpression
			| ArrayExpression
			| ObjectExpression
			| FunctionExpression
			| ArrowFunctionExpression
			| YieldExpression
			| SimpleLiteral
			| RegExpLiteral
			| BigIntLiteral
			| UpdateExpression
			| BinaryExpression
			| AssignmentExpression
			| LogicalExpression
			| MemberExpression
			| ConditionalExpression
			| SimpleCallExpression
			| NewExpression
			| SequenceExpression
			| TemplateLiteral
			| TaggedTemplateExpression
			| ClassExpression
			| MetaProperty
			| Identifier
			| AwaitExpression
			| ImportExpression
			| ChainExpression
			| FunctionDeclaration
			| VariableDeclaration
			| ClassDeclaration
			| PrivateIdentifier,
		commentsStartPos: number
	): boolean;
	getComments(range?: any): any[];
	isAsiPosition(pos: number): boolean;
	unsetAsiPosition(pos: number): void;
	isStatementLevelExpression(expr?: any): boolean;
	getTagData(name?: any, tag?: any): any;
	tagVariable(name?: any, tag?: any, data?: any): void;
	defineVariable(name?: any): void;
	undefineVariable(name?: any): void;
	isVariableDefined(name?: any): boolean;
	getVariableInfo(name: string): ExportedVariableInfo;
	setVariable(name: string, variableInfo: ExportedVariableInfo): void;
	parseCommentOptions(
		range?: any
	): { options: null; errors: null } | { options: object; errors: unknown[] };
	extractMemberExpressionChain(expression: MemberExpression): {
		members: string[];
		object:
			| UnaryExpression
			| ThisExpression
			| ArrayExpression
			| ObjectExpression
			| FunctionExpression
			| ArrowFunctionExpression
			| YieldExpression
			| SimpleLiteral
			| RegExpLiteral
			| BigIntLiteral
			| UpdateExpression
			| BinaryExpression
			| AssignmentExpression
			| LogicalExpression
			| MemberExpression
			| ConditionalExpression
			| SimpleCallExpression
			| NewExpression
			| SequenceExpression
			| TemplateLiteral
			| TaggedTemplateExpression
			| ClassExpression
			| MetaProperty
			| Identifier
			| AwaitExpression
			| ImportExpression
			| ChainExpression
			| Super;
	};
	getFreeInfoFromVariable(varName: string): {
		name: string;
		info: string | VariableInfo;
	};
	getMemberExpressionInfo(
		expression: MemberExpression,
		allowedTypes: number
	): undefined | CallExpressionInfo | ExpressionExpressionInfo;
	getNameForExpression(expression: MemberExpression): {
		name: string;
		rootInfo: ExportedVariableInfo;
		getMembers: () => string[];
	};
	static ALLOWED_MEMBER_TYPES_ALL: 3;
	static ALLOWED_MEMBER_TYPES_EXPRESSION: 2;
	static ALLOWED_MEMBER_TYPES_CALL_EXPRESSION: 1;
}

/**
 * Parser options for javascript modules.
 */
declare interface JavascriptParserOptions {
	[index: string]: any;

	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: false | { [index: string]: any };

	/**
	 * Enable/disable special handling for browserify bundles.
	 */
	browserify?: boolean;

	/**
	 * Enable/disable parsing of CommonJs syntax.
	 */
	commonjs?: boolean;

	/**
	 * Enable/disable parsing of magic comments in CommonJs syntax.
	 */
	commonjsMagicComments?: boolean;

	/**
	 * Specifies the behavior of invalid export names in "import ... from ..." and "export ... from ...".
	 */
	exportsPresence?: false | "auto" | "error" | "warn";

	/**
	 * Enable warnings for full dynamic dependencies.
	 */
	exprContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for full dynamic dependencies.
	 */
	exprContextRecursive?: boolean;

	/**
	 * Sets the default regular expression for full dynamic dependencies.
	 */
	exprContextRegExp?: boolean | RegExp;

	/**
	 * Set the default request for full dynamic dependencies.
	 */
	exprContextRequest?: string;

	/**
	 * Enable/disable parsing of EcmaScript Modules syntax.
	 */
	harmony?: boolean;

	/**
	 * Enable/disable parsing of import() syntax.
	 */
	import?: boolean;

	/**
	 * Specifies the behavior of invalid export names in "import ... from ...".
	 */
	importExportsPresence?: false | "auto" | "error" | "warn";

	/**
	 * Enable/disable evaluating import.meta.
	 */
	importMeta?: boolean;

	/**
	 * Enable/disable evaluating import.meta.webpackContext.
	 */
	importMetaContext?: boolean;

	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node?: false | NodeOptions;

	/**
	 * Specifies the behavior of invalid export names in "export ... from ...". This might be useful to disable during the migration from "export ... from ..." to "export type ... from ..." when reexporting types in TypeScript.
	 */
	reexportExportsPresence?: false | "auto" | "error" | "warn";

	/**
	 * Enable/disable parsing of require.context syntax.
	 */
	requireContext?: boolean;

	/**
	 * Enable/disable parsing of require.ensure syntax.
	 */
	requireEnsure?: boolean;

	/**
	 * Enable/disable parsing of require.include syntax.
	 */
	requireInclude?: boolean;

	/**
	 * Enable/disable parsing of require.js special syntax like require.config, requirejs.config, require.version and requirejs.onError.
	 */
	requireJs?: boolean;

	/**
	 * Deprecated in favor of "exportsPresence". Emit errors instead of warnings when imported names don't exist in imported module.
	 */
	strictExportPresence?: boolean;

	/**
	 * Handle the this context correctly according to the spec for namespace objects.
	 */
	strictThisContextOnImports?: boolean;

	/**
	 * Enable/disable parsing of System.js special syntax like System.import, System.get, System.set and System.register.
	 */
	system?: boolean;

	/**
	 * Enable warnings when using the require function in a not statically analyse-able way.
	 */
	unknownContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup when using the require function in a not statically analyse-able way.
	 */
	unknownContextRecursive?: boolean;

	/**
	 * Sets the regular expression when using the require function in a not statically analyse-able way.
	 */
	unknownContextRegExp?: boolean | RegExp;

	/**
	 * Sets the request when using the require function in a not statically analyse-able way.
	 */
	unknownContextRequest?: string;

	/**
	 * Enable/disable parsing of new URL() syntax.
	 */
	url?: boolean | "relative";

	/**
	 * Disable or configure parsing of WebWorker syntax like new Worker() or navigator.serviceWorker.register().
	 */
	worker?: boolean | string[];

	/**
	 * Enable warnings for partial dynamic dependencies.
	 */
	wrappedContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for partial dynamic dependencies.
	 */
	wrappedContextRecursive?: boolean;

	/**
	 * Set the inner regular expression for partial dynamic dependencies.
	 */
	wrappedContextRegExp?: RegExp;
}
declare class JsonpChunkLoadingRuntimeModule extends RuntimeModule {
	constructor(runtimeRequirements?: any);
	static getCompilationHooks(
		compilation: Compilation
	): JsonpCompilationPluginHooks;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}
declare interface JsonpCompilationPluginHooks {
	linkPreload: SyncWaterfallHook<[string, Chunk]>;
	linkPrefetch: SyncWaterfallHook<[string, Chunk]>;
}
declare class JsonpTemplatePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getCompilationHooks(
		compilation: Compilation
	): JsonpCompilationPluginHooks;
}
declare interface KnownAssetInfo {
	/**
	 * true, if the asset can be long term cached forever (contains a hash)
	 */
	immutable?: boolean;

	/**
	 * whether the asset is minimized
	 */
	minimized?: boolean;

	/**
	 * the value(s) of the full hash used for this asset
	 */
	fullhash?: string | string[];

	/**
	 * the value(s) of the chunk hash used for this asset
	 */
	chunkhash?: string | string[];

	/**
	 * the value(s) of the module hash used for this asset
	 */
	modulehash?: string | string[];

	/**
	 * the value(s) of the content hash used for this asset
	 */
	contenthash?: string | string[];

	/**
	 * when asset was created from a source file (potentially transformed), the original filename relative to compilation context
	 */
	sourceFilename?: string;

	/**
	 * size in bytes, only set after asset has been emitted
	 */
	size?: number;

	/**
	 * true, when asset is only used for development and doesn't count towards user-facing assets
	 */
	development?: boolean;

	/**
	 * true, when asset ships data for updating an existing application (HMR)
	 */
	hotModuleReplacement?: boolean;

	/**
	 * true, when asset is javascript and an ESM
	 */
	javascriptModule?: boolean;

	/**
	 * object of pointers to other assets, keyed by type of relation (only points from parent to child)
	 */
	related?: Record<string, string | string[]>;
}
declare interface KnownBuildMeta {
	moduleArgument?: string;
	exportsArgument?: string;
	strict?: boolean;
	moduleConcatenationBailout?: string;
	exportsType?: "namespace" | "dynamic" | "default" | "flagged";
	defaultObject?: false | "redirect" | "redirect-warn";
	strictHarmonyModule?: boolean;
	async?: boolean;
	sideEffectFree?: boolean;
}
declare interface KnownCreateStatsOptionsContext {
	forToString?: boolean;
}
declare interface KnownNormalizedStatsOptions {
	context: string;
	requestShortener: RequestShortener;
	chunksSort: string;
	modulesSort: string;
	chunkModulesSort: string;
	nestedModulesSort: string;
	assetsSort: string;
	ids: boolean;
	cachedAssets: boolean;
	groupAssetsByEmitStatus: boolean;
	groupAssetsByPath: boolean;
	groupAssetsByExtension: boolean;
	assetsSpace: number;
	excludeAssets: ((value: string, asset: StatsAsset) => boolean)[];
	excludeModules: ((
		name: string,
		module: StatsModule,
		type: "module" | "chunk" | "root-of-chunk" | "nested"
	) => boolean)[];
	warningsFilter: ((warning: StatsError, textValue: string) => boolean)[];
	cachedModules: boolean;
	orphanModules: boolean;
	dependentModules: boolean;
	runtimeModules: boolean;
	groupModulesByCacheStatus: boolean;
	groupModulesByLayer: boolean;
	groupModulesByAttributes: boolean;
	groupModulesByPath: boolean;
	groupModulesByExtension: boolean;
	groupModulesByType: boolean;
	entrypoints: boolean | "auto";
	chunkGroups: boolean;
	chunkGroupAuxiliary: boolean;
	chunkGroupChildren: boolean;
	chunkGroupMaxAssets: number;
	modulesSpace: number;
	chunkModulesSpace: number;
	nestedModulesSpace: number;
	logging: false | "none" | "error" | "warn" | "info" | "log" | "verbose";
	loggingDebug: ((value: string) => boolean)[];
	loggingTrace: boolean;
}
declare interface KnownStatsAsset {
	type: string;
	name: string;
	info: AssetInfo;
	size: number;
	emitted: boolean;
	comparedForEmit: boolean;
	cached: boolean;
	related?: StatsAsset[];
	chunkNames?: (string | number)[];
	chunkIdHints?: (string | number)[];
	chunks?: (string | number)[];
	auxiliaryChunkNames?: (string | number)[];
	auxiliaryChunks?: (string | number)[];
	auxiliaryChunkIdHints?: (string | number)[];
	filteredRelated?: number;
	isOverSizeLimit?: boolean;
}
declare interface KnownStatsChunk {
	rendered: boolean;
	initial: boolean;
	entry: boolean;
	recorded: boolean;
	reason?: string;
	size: number;
	sizes?: Record<string, number>;
	names?: string[];
	idHints?: string[];
	runtime?: string[];
	files?: string[];
	auxiliaryFiles?: string[];
	hash: string;
	childrenByOrder?: Record<string, (string | number)[]>;
	id?: string | number;
	siblings?: (string | number)[];
	parents?: (string | number)[];
	children?: (string | number)[];
	modules?: StatsModule[];
	filteredModules?: number;
	origins?: StatsChunkOrigin[];
}
declare interface KnownStatsChunkGroup {
	name?: string;
	chunks?: (string | number)[];
	assets?: { name: string; size?: number }[];
	filteredAssets?: number;
	assetsSize?: number;
	auxiliaryAssets?: { name: string; size?: number }[];
	filteredAuxiliaryAssets?: number;
	auxiliaryAssetsSize?: number;
	children?: { [index: string]: StatsChunkGroup[] };
	childAssets?: { [index: string]: string[] };
	isOverSizeLimit?: boolean;
}
declare interface KnownStatsChunkOrigin {
	module?: string;
	moduleIdentifier?: string;
	moduleName?: string;
	loc?: string;
	request?: string;
	moduleId?: string | number;
}
declare interface KnownStatsCompilation {
	env?: any;
	name?: string;
	hash?: string;
	version?: string;
	time?: number;
	builtAt?: number;
	needAdditionalPass?: boolean;
	publicPath?: string;
	outputPath?: string;
	assetsByChunkName?: Record<string, string[]>;
	assets?: StatsAsset[];
	filteredAssets?: number;
	chunks?: StatsChunk[];
	modules?: StatsModule[];
	filteredModules?: number;
	entrypoints?: Record<string, StatsChunkGroup>;
	namedChunkGroups?: Record<string, StatsChunkGroup>;
	errors?: StatsError[];
	errorsCount?: number;
	warnings?: StatsError[];
	warningsCount?: number;
	children?: StatsCompilation[];
	logging?: Record<string, StatsLogging>;
}
declare interface KnownStatsError {
	message: string;
	chunkName?: string;
	chunkEntry?: boolean;
	chunkInitial?: boolean;
	file?: string;
	moduleIdentifier?: string;
	moduleName?: string;
	loc?: string;
	chunkId?: string | number;
	moduleId?: string | number;
	moduleTrace?: StatsModuleTraceItem[];
	details?: any;
	stack?: string;
}
declare interface KnownStatsFactoryContext {
	type: string;
	makePathsRelative?: (arg0: string) => string;
	compilation?: Compilation;
	rootModules?: Set<Module>;
	compilationFileToChunks?: Map<string, Chunk[]>;
	compilationAuxiliaryFileToChunks?: Map<string, Chunk[]>;
	runtime?: RuntimeSpec;
	cachedGetErrors?: (arg0: Compilation) => WebpackError[];
	cachedGetWarnings?: (arg0: Compilation) => WebpackError[];
}
declare interface KnownStatsLogging {
	entries: StatsLoggingEntry[];
	filteredEntries: number;
	debug: boolean;
}
declare interface KnownStatsLoggingEntry {
	type: string;
	message: string;
	trace?: string[];
	children?: StatsLoggingEntry[];
	args?: any[];
	time?: number;
}
declare interface KnownStatsModule {
	type?: string;
	moduleType?: string;
	layer?: string;
	identifier?: string;
	name?: string;
	nameForCondition?: string;
	index?: number;
	preOrderIndex?: number;
	index2?: number;
	postOrderIndex?: number;
	size?: number;
	sizes?: { [index: string]: number };
	cacheable?: boolean;
	built?: boolean;
	codeGenerated?: boolean;
	buildTimeExecuted?: boolean;
	cached?: boolean;
	optional?: boolean;
	orphan?: boolean;
	id?: string | number;
	issuerId?: string | number;
	chunks?: (string | number)[];
	assets?: (string | number)[];
	dependent?: boolean;
	issuer?: string;
	issuerName?: string;
	issuerPath?: StatsModuleIssuer[];
	failed?: boolean;
	errors?: number;
	warnings?: number;
	profile?: StatsProfile;
	reasons?: StatsModuleReason[];
	usedExports?: boolean | string[];
	providedExports?: string[];
	optimizationBailout?: string[];
	depth?: number;
	modules?: StatsModule[];
	filteredModules?: number;
	source?: string | Buffer;
}
declare interface KnownStatsModuleIssuer {
	identifier?: string;
	name?: string;
	id?: string | number;
	profile?: StatsProfile;
}
declare interface KnownStatsModuleReason {
	moduleIdentifier?: string;
	module?: string;
	moduleName?: string;
	resolvedModuleIdentifier?: string;
	resolvedModule?: string;
	type?: string;
	active: boolean;
	explanation?: string;
	userRequest?: string;
	loc?: string;
	moduleId?: string | number;
	resolvedModuleId?: string | number;
}
declare interface KnownStatsModuleTraceDependency {
	loc?: string;
}
declare interface KnownStatsModuleTraceItem {
	originIdentifier?: string;
	originName?: string;
	moduleIdentifier?: string;
	moduleName?: string;
	dependencies?: StatsModuleTraceDependency[];
	originId?: string | number;
	moduleId?: string | number;
}
declare interface KnownStatsPrinterContext {
	type?: string;
	compilation?: StatsCompilation;
	chunkGroup?: StatsChunkGroup;
	asset?: StatsAsset;
	module?: StatsModule;
	chunk?: StatsChunk;
	moduleReason?: StatsModuleReason;
	bold?: (str: string) => string;
	yellow?: (str: string) => string;
	red?: (str: string) => string;
	green?: (str: string) => string;
	magenta?: (str: string) => string;
	cyan?: (str: string) => string;
	formatFilename?: (file: string, oversize?: boolean) => string;
	formatModuleId?: (id: string) => string;
	formatChunkId?: (
		id: string,
		direction?: "parent" | "child" | "sibling"
	) => string;
	formatSize?: (size: number) => string;
	formatDateTime?: (dateTime: number) => string;
	formatFlag?: (flag: string) => string;
	formatTime?: (time: number, boldQuantity?: boolean) => string;
	chunkGroupKind?: string;
}
declare interface KnownStatsProfile {
	total: number;
	resolving: number;
	restoring: number;
	building: number;
	integration: number;
	storing: number;
	additionalResolving: number;
	additionalIntegration: number;
	factory: number;
	dependencies: number;
}

/**
 * Options for the default backend.
 */
declare interface LazyCompilationDefaultBackendOptions {
	/**
	 * A custom client.
	 */
	client?: string;

	/**
	 * Specifies where to listen to from the server.
	 */
	listen?: number | ListenOptions | ((server: typeof Server) => void);

	/**
	 * Specifies the protocol the client should use to connect to the server.
	 */
	protocol?: "http" | "https";

	/**
	 * Specifies how to create the server handling the EventSource requests.
	 */
	server?: ServerOptionsImport | ServerOptionsHttps | (() => typeof Server);
}

/**
 * Options for compiling entrypoints and import()s only when they are accessed.
 */
declare interface LazyCompilationOptions {
	/**
	 * Specifies the backend that should be used for handling client keep alive.
	 */
	backend?:
		| ((
				compiler: Compiler,
				callback: (err?: Error, api?: BackendApi) => void
		  ) => void)
		| ((compiler: Compiler) => Promise<BackendApi>)
		| LazyCompilationDefaultBackendOptions;

	/**
	 * Enable/disable lazy compilation for entries.
	 */
	entries?: boolean;

	/**
	 * Enable/disable lazy compilation for import() modules.
	 */
	imports?: boolean;

	/**
	 * Specify which entrypoints or import()ed modules should be lazily compiled. This is matched with the imported module and not the entrypoint name.
	 */
	test?: string | RegExp | ((module: Module) => boolean);
}
declare class LazySet<T> {
	constructor(iterable?: Iterable<T>);
	readonly size: number;
	add(item: T): LazySet<T>;
	addAll(iterable: LazySet<T> | Iterable<T>): LazySet<T>;
	clear(): void;
	delete(value: T): boolean;
	entries(): IterableIterator<[T, T]>;
	forEach(
		callbackFn: (arg0: T, arg1: T, arg2: Set<T>) => void,
		thisArg?: any
	): void;
	has(item: T): boolean;
	keys(): IterableIterator<T>;
	values(): IterableIterator<T>;
	serialize(__0: { write: any }): void;
	[Symbol.iterator](): IterableIterator<T>;
	static deserialize(__0: { read: any }): LazySet<any>;
}
declare interface LibIdentOptions {
	/**
	 * absolute context path to which lib ident is relative to
	 */
	context: string;

	/**
	 * object for caching
	 */
	associatedObjectForCache?: Object;
}
declare class LibManifestPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface LibraryContext<T> {
	compilation: Compilation;
	chunkGraph: ChunkGraph;
	options: T;
}

/**
 * Set explicit comments for `commonjs`, `commonjs2`, `amd`, and `root`.
 */
declare interface LibraryCustomUmdCommentObject {
	/**
	 * Set comment for `amd` section in UMD.
	 */
	amd?: string;

	/**
	 * Set comment for `commonjs` (exports) section in UMD.
	 */
	commonjs?: string;

	/**
	 * Set comment for `commonjs2` (module.exports) section in UMD.
	 */
	commonjs2?: string;

	/**
	 * Set comment for `root` (global variable) section in UMD.
	 */
	root?: string;
}

/**
 * Description object for all UMD variants of the library name.
 */
declare interface LibraryCustomUmdObject {
	/**
	 * Name of the exposed AMD library in the UMD.
	 */
	amd?: string;

	/**
	 * Name of the exposed commonjs export in the UMD.
	 */
	commonjs?: string;

	/**
	 * Name of the property exposed globally by a UMD library.
	 */
	root?: string | string[];
}
type LibraryExport = string | string[];
type LibraryName = string | string[] | LibraryCustomUmdObject;

/**
 * Options for library.
 */
declare interface LibraryOptions {
	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: string | LibraryCustomUmdCommentObject;

	/**
	 * Specify which export should be exposed as library.
	 */
	export?: string | string[];

	/**
	 * The name of the library (some types allow unnamed libraries too).
	 */
	name?: string | string[] | LibraryCustomUmdObject;

	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	type: string;

	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: boolean;
}
declare class LibraryTemplatePlugin {
	constructor(
		name: LibraryName,
		target: string,
		umdNamedDefine: boolean,
		auxiliaryComment: AuxiliaryComment,
		exportProperty: LibraryExport
	);
	library: {
		type: string;
		name: LibraryName;
		umdNamedDefine: boolean;
		auxiliaryComment: AuxiliaryComment;
		export: LibraryExport;
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class LimitChunkCountPlugin {
	constructor(options?: LimitChunkCountPluginOptions);
	options?: LimitChunkCountPluginOptions;
	apply(compiler: Compiler): void;
}
declare interface LimitChunkCountPluginOptions {
	/**
	 * Constant overhead for a chunk.
	 */
	chunkOverhead?: number;

	/**
	 * Multiplicator for initial chunks.
	 */
	entryChunkMultiplicator?: number;

	/**
	 * Limit the maximum number of chunks using a value greater greater than or equal to 1.
	 */
	maxChunks: number;
}
declare interface LoadScriptCompilationHooks {
	createScript: SyncWaterfallHook<[string, Chunk]>;
}
declare class LoadScriptRuntimeModule extends HelperRuntimeModule {
	constructor(withCreateScriptUrl?: boolean);
	static getCompilationHooks(
		compilation: Compilation
	): LoadScriptCompilationHooks;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}

/**
 * Custom values available in the loader context.
 */
declare interface Loader {
	[index: string]: any;
}
type LoaderContext<OptionsType> = NormalModuleLoaderContext<OptionsType> &
	LoaderRunnerLoaderContext<OptionsType> &
	LoaderPluginLoaderContext &
	HotModuleReplacementPluginLoaderContext;
type LoaderDefinition<
	OptionsType = {},
	ContextAdditions = {}
> = LoaderDefinitionFunction<OptionsType, ContextAdditions> & {
	raw?: false;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
};
declare interface LoaderDefinitionFunction<
	OptionsType = {},
	ContextAdditions = {}
> {
	(
		this: NormalModuleLoaderContext<OptionsType> &
			LoaderRunnerLoaderContext<OptionsType> &
			LoaderPluginLoaderContext &
			HotModuleReplacementPluginLoaderContext &
			ContextAdditions,
		content: string,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	): string | void | Buffer | Promise<string | Buffer>;
}
declare interface LoaderItem {
	loader: string;
	options: any;
	ident: null | string;
	type: null | string;
}
declare interface LoaderModule<OptionsType = {}, ContextAdditions = {}> {
	default?:
		| RawLoaderDefinitionFunction<OptionsType, ContextAdditions>
		| LoaderDefinitionFunction<OptionsType, ContextAdditions>;
	raw?: false;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
}
declare class LoaderOptionsPlugin {
	constructor(options?: LoaderOptionsPluginOptions);
	options: LoaderOptionsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface LoaderOptionsPluginOptions {
	[index: string]: any;

	/**
	 * Whether loaders should be in debug mode or not. debug will be removed as of webpack 3.
	 */
	debug?: boolean;

	/**
	 * Where loaders can be switched to minimize mode.
	 */
	minimize?: boolean;

	/**
	 * A configuration object that can be used to configure older loaders.
	 */
	options?: {
		[index: string]: any;
		/**
		 * The context that can be used to configure older loaders.
		 */
		context?: string;
	};
}

/**
 * These properties are added by the LoaderPlugin
 */
declare interface LoaderPluginLoaderContext {
	/**
	 * Resolves the given request to a module, applies all configured loaders and calls
	 * back with the generated source, the sourceMap and the module instance (usually an
	 * instance of NormalModule). Use this function if you need to know the source code
	 * of another module to generate the result.
	 */
	loadModule(
		request: string,
		callback: (
			err: null | Error,
			source: string,
			sourceMap: any,
			module: NormalModule
		) => void
	): void;
	importModule(
		request: string,
		options: ImportModuleOptions,
		callback: (err?: null | Error, exports?: any) => any
	): void;
	importModule(request: string, options?: ImportModuleOptions): Promise<any>;
}

/**
 * The properties are added by https://github.com/webpack/loader-runner
 */
declare interface LoaderRunnerLoaderContext<OptionsType> {
	/**
	 * Add a directory as dependency of the loader result.
	 */
	addContextDependency(context: string): void;

	/**
	 * Adds a file as dependency of the loader result in order to make them watchable.
	 * For example, html-loader uses this technique as it finds src and src-set attributes.
	 * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
	 */
	addDependency(file: string): void;
	addMissingDependency(context: string): void;

	/**
	 * Make this loader async.
	 */
	async(): (
		err?: null | Error,
		content?: string | Buffer,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	) => void;

	/**
	 * Make this loader result cacheable. By default it's cacheable.
	 * A cacheable loader must have a deterministic result, when inputs and dependencies haven't changed.
	 * This means the loader shouldn't have other dependencies than specified with this.addDependency.
	 * Most loaders are deterministic and cacheable.
	 */
	cacheable(flag?: boolean): void;
	callback: (
		err?: null | Error,
		content?: string | Buffer,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	) => void;

	/**
	 * Remove all dependencies of the loader result. Even initial dependencies and these of other loaders.
	 */
	clearDependencies(): void;

	/**
	 * The directory of the module. Can be used as context for resolving other stuff.
	 * eg '/workspaces/ts-loader/examples/vanilla/src'
	 */
	context: string;
	readonly currentRequest: string;
	readonly data: any;

	/**
	 * alias of addDependency
	 * Adds a file as dependency of the loader result in order to make them watchable.
	 * For example, html-loader uses this technique as it finds src and src-set attributes.
	 * Then, it sets the url's for those attributes as dependencies of the html file that is parsed.
	 */
	dependency(file: string): void;
	getContextDependencies(): string[];
	getDependencies(): string[];
	getMissingDependencies(): string[];

	/**
	 * The index in the loaders array of the current loader.
	 * In the example: in loader1: 0, in loader2: 1
	 */
	loaderIndex: number;
	readonly previousRequest: string;
	readonly query: string | OptionsType;
	readonly remainingRequest: string;
	readonly request: string;

	/**
	 * An array of all the loaders. It is writeable in the pitch phase.
	 * loaders = [{request: string, path: string, query: string, module: function}]
	 * In the example:
	 * [
	 *   { request: "/abc/loader1.js?xyz",
	 *     path: "/abc/loader1.js",
	 *     query: "?xyz",
	 *     module: [Function]
	 *   },
	 *   { request: "/abc/node_modules/loader2/index.js",
	 *     path: "/abc/node_modules/loader2/index.js",
	 *     query: "",
	 *     module: [Function]
	 *   }
	 * ]
	 */
	loaders: {
		request: string;
		path: string;
		query: string;
		fragment: string;
		options?: string | object;
		ident: string;
		normal?: Function;
		pitch?: Function;
		raw?: boolean;
		data?: object;
		pitchExecuted: boolean;
		normalExecuted: boolean;
	}[];

	/**
	 * The resource path.
	 * In the example: "/abc/resource.js"
	 */
	resourcePath: string;

	/**
	 * The resource query string.
	 * Example: "?query"
	 */
	resourceQuery: string;

	/**
	 * The resource fragment.
	 * Example: "#frag"
	 */
	resourceFragment: string;

	/**
	 * The resource inclusive query and fragment.
	 * Example: "/abc/resource.js?query#frag"
	 */
	resource: string;
}
declare class LoaderTargetPlugin {
	constructor(target: string);
	target: string;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface LogEntry {
	type: string;
	args: any[];
	time: number;
	trace?: string[];
}
declare const MEASURE_END_OPERATION: unique symbol;
declare const MEASURE_START_OPERATION: unique symbol;
declare interface MainRenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * hash to be used for render call
	 */
	hash: string;

	/**
	 * rendering in strict context
	 */
	strictMode: boolean;
}
declare abstract class MainTemplate {
	hooks: Readonly<{
		renderManifest: { tap: (options?: any, fn?: any) => void };
		modules: { tap: () => never };
		moduleObj: { tap: () => never };
		require: { tap: (options?: any, fn?: any) => void };
		beforeStartup: { tap: () => never };
		startup: { tap: () => never };
		afterStartup: { tap: () => never };
		render: { tap: (options?: any, fn?: any) => void };
		renderWithEntry: { tap: (options?: any, fn?: any) => void };
		assetPath: {
			tap: (options?: any, fn?: any) => void;
			call: (filename?: any, options?: any) => string;
		};
		hash: { tap: (options?: any, fn?: any) => void };
		hashForChunk: { tap: (options?: any, fn?: any) => void };
		globalHashPaths: { tap: () => void };
		globalHash: { tap: () => void };
		hotBootstrap: { tap: () => never };
		bootstrap: SyncWaterfallHook<
			[string, Chunk, string, ModuleTemplate, DependencyTemplates]
		>;
		localVars: SyncWaterfallHook<[string, Chunk, string]>;
		requireExtensions: SyncWaterfallHook<[string, Chunk, string]>;
		requireEnsure: SyncWaterfallHook<[string, Chunk, string, string]>;
		readonly jsonpScript: SyncWaterfallHook<[string, Chunk]>;
		readonly linkPrefetch: SyncWaterfallHook<[string, Chunk]>;
		readonly linkPreload: SyncWaterfallHook<[string, Chunk]>;
	}>;
	renderCurrentHashCode: (hash: string, length?: number) => string;
	getPublicPath: (options: object) => string;
	getAssetPath: (path?: any, options?: any) => string;
	getAssetPathWithInfo: (
		path?: any,
		options?: any
	) => { path: string; info: AssetInfo };
	readonly requireFn: "__webpack_require__";
	readonly outputOptions: Output;
}
declare interface MapOptions {
	columns?: boolean;
	module?: boolean;
}

/**
 * Options object for in-memory caching.
 */
declare interface MemoryCacheOptions {
	/**
	 * Additionally cache computation of modules that are unchanged and reference only unchanged modules.
	 */
	cacheUnaffected?: boolean;

	/**
	 * Number of generations unused cache entries stay in memory cache at minimum (1 = may be removed after unused for a single compilation, ..., Infinity: kept forever).
	 */
	maxGenerations?: number;

	/**
	 * In memory caching.
	 */
	type: "memory";
}
declare class MemoryCachePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class MinChunkSizePlugin {
	constructor(options: MinChunkSizePluginOptions);
	options: MinChunkSizePluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface MinChunkSizePluginOptions {
	/**
	 * Constant overhead for a chunk.
	 */
	chunkOverhead?: number;

	/**
	 * Multiplicator for initial chunks.
	 */
	entryChunkMultiplicator?: number;

	/**
	 * Minimum number of characters.
	 */
	minChunkSize: number;
}
declare class Module extends DependenciesBlock {
	constructor(type: string, context?: string, layer?: string);
	type: string;
	context: null | string;
	layer: null | string;
	needId: boolean;
	debugId: number;
	resolveOptions: ResolveOptionsWebpackOptions;
	factoryMeta?: object;
	useSourceMap: boolean;
	useSimpleSourceMap: boolean;
	buildMeta: BuildMeta;
	buildInfo: Record<string, any>;
	presentationalDependencies?: Dependency[];
	codeGenerationDependencies?: Dependency[];
	id: string | number;
	readonly hash: string;
	readonly renderedHash: string;
	profile: null | ModuleProfile;
	index: number;
	index2: number;
	depth: number;
	issuer: null | Module;
	readonly usedExports: null | boolean | SortableSet<string>;
	readonly optimizationBailout: (
		| string
		| ((requestShortener: RequestShortener) => string)
	)[];
	readonly optional: boolean;
	addChunk(chunk?: any): boolean;
	removeChunk(chunk?: any): void;
	isInChunk(chunk?: any): boolean;
	isEntryModule(): boolean;
	getChunks(): Chunk[];
	getNumberOfChunks(): number;
	readonly chunksIterable: Iterable<Chunk>;
	isProvided(exportName: string): null | boolean;
	readonly exportsArgument: string;
	readonly moduleArgument: string;
	getExportsType(
		moduleGraph: ModuleGraph,
		strict: boolean
	): "namespace" | "default-only" | "default-with-named" | "dynamic";
	addPresentationalDependency(presentationalDependency: Dependency): void;
	addCodeGenerationDependency(codeGenerationDependency: Dependency): void;
	addWarning(warning: WebpackError): void;
	getWarnings(): undefined | Iterable<WebpackError>;
	getNumberOfWarnings(): number;
	addError(error: WebpackError): void;
	getErrors(): undefined | Iterable<WebpackError>;
	getNumberOfErrors(): number;

	/**
	 * removes all warnings and errors
	 */
	clearWarningsAndErrors(): void;
	isOptional(moduleGraph: ModuleGraph): boolean;
	isAccessibleInChunk(
		chunkGraph: ChunkGraph,
		chunk: Chunk,
		ignoreChunk?: Chunk
	): boolean;
	isAccessibleInChunkGroup(
		chunkGraph: ChunkGraph,
		chunkGroup: ChunkGroup,
		ignoreChunk?: Chunk
	): boolean;
	hasReasonForChunk(
		chunk: Chunk,
		moduleGraph: ModuleGraph,
		chunkGraph: ChunkGraph
	): boolean;
	hasReasons(moduleGraph: ModuleGraph, runtime: RuntimeSpec): boolean;
	needBuild(
		context: NeedBuildContext,
		callback: (arg0?: null | WebpackError, arg1?: boolean) => void
	): void;
	needRebuild(
		fileTimestamps: Map<string, null | number>,
		contextTimestamps: Map<string, null | number>
	): boolean;
	invalidateBuild(): void;
	identifier(): string;
	readableIdentifier(requestShortener: RequestShortener): string;
	build(
		options: WebpackOptionsNormalized,
		compilation: Compilation,
		resolver: ResolverWithOptions,
		fs: InputFileSystem,
		callback: (arg0?: WebpackError) => void
	): void;
	getSourceTypes(): Set<string>;
	source(
		dependencyTemplates: DependencyTemplates,
		runtimeTemplate: RuntimeTemplate,
		type?: string
	): Source;
	size(type?: string): number;
	libIdent(options: LibIdentOptions): null | string;
	nameForCondition(): null | string;
	getConcatenationBailoutReason(
		context: ConcatenationBailoutReasonContext
	): undefined | string;
	getSideEffectsConnectionState(moduleGraph: ModuleGraph): ConnectionState;
	codeGeneration(context: CodeGenerationContext): CodeGenerationResult;
	chunkCondition(chunk: Chunk, compilation: Compilation): boolean;
	hasChunkCondition(): boolean;

	/**
	 * Assuming this module is in the cache. Update the (cached) module with
	 * the fresh module from the factory. Usually updates internal references
	 * and properties.
	 */
	updateCacheModule(module: Module): void;

	/**
	 * Module should be unsafe cached. Get data that's needed for that.
	 * This data will be passed to restoreFromUnsafeCache later.
	 */
	getUnsafeCacheData(): object;

	/**
	 * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
	 */
	cleanupForCache(): void;
	originalSource(): null | Source;
	addCacheDependencies(
		fileDependencies: LazySet<string>,
		contextDependencies: LazySet<string>,
		missingDependencies: LazySet<string>,
		buildDependencies: LazySet<string>
	): void;
	readonly hasEqualsChunks: any;
	readonly isUsed: any;
	readonly errors: any;
	readonly warnings: any;
	used: any;
}
declare class ModuleConcatenationPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class ModuleDependency extends Dependency {
	constructor(request: string);
	request: string;
	userRequest: string;
	range: any;
	assertions?: Record<string, any>;
	static Template: typeof DependencyTemplate;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare abstract class ModuleFactory {
	create(
		data: ModuleFactoryCreateData,
		callback: (arg0?: Error, arg1?: ModuleFactoryResult) => void
	): void;
}
declare interface ModuleFactoryCreateData {
	contextInfo: ModuleFactoryCreateDataContextInfo;
	resolveOptions?: ResolveOptionsWebpackOptions;
	context: string;
	dependencies: Dependency[];
}
declare interface ModuleFactoryCreateDataContextInfo {
	issuer: string;
	issuerLayer?: null | string;
	compiler: string;
}
declare interface ModuleFactoryResult {
	/**
	 * the created module or unset if no module was created
	 */
	module?: Module;
	fileDependencies?: Set<string>;
	contextDependencies?: Set<string>;
	missingDependencies?: Set<string>;

	/**
	 * allow to use the unsafe cache
	 */
	cacheable?: boolean;
}
declare class ModuleFederationPlugin {
	constructor(options: ModuleFederationPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ModuleFederationPluginOptions {
	/**
	 * Modules that should be exposed by this container. When provided, property name is used as public name, otherwise public name is automatically inferred from request.
	 */
	exposes?: (string | ExposesObject)[] | ExposesObject;

	/**
	 * The filename of the container as relative path inside the `output.path` directory.
	 */
	filename?: string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * The name of the container.
	 */
	name?: string;

	/**
	 * The external type of the remote containers.
	 */
	remoteType?:
		| "import"
		| "var"
		| "module"
		| "assign"
		| "this"
		| "window"
		| "self"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "commonjs-static"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system"
		| "promise"
		| "script"
		| "node-commonjs";

	/**
	 * Container locations and request scopes from which modules should be resolved and loaded at runtime. When provided, property name is used as request scope, otherwise request scope is automatically inferred from container location.
	 */
	remotes?: (string | RemotesObject)[] | RemotesObject;

	/**
	 * The name of the runtime chunk. If set a runtime chunk with this name is created or an existing entrypoint is used as runtime.
	 */
	runtime?: string | false;

	/**
	 * Share scope name used for all shared modules (defaults to 'default').
	 */
	shareScope?: string;

	/**
	 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	shared?: (string | SharedObject)[] | SharedObject;
}
type ModuleFilterItemTypes =
	| string
	| RegExp
	| ((
			name: string,
			module: StatsModule,
			type: "module" | "chunk" | "root-of-chunk" | "nested"
	  ) => boolean);
declare class ModuleGraph {
	constructor();
	setParents(
		dependency: Dependency,
		block: DependenciesBlock,
		module: Module,
		indexInBlock?: number
	): void;
	getParentModule(dependency: Dependency): Module;
	getParentBlock(dependency: Dependency): DependenciesBlock;
	getParentBlockIndex(dependency: Dependency): number;
	setResolvedModule(
		originModule: Module,
		dependency: Dependency,
		module: Module
	): void;
	updateModule(dependency: Dependency, module: Module): void;
	removeConnection(dependency: Dependency): void;
	addExplanation(dependency: Dependency, explanation: string): void;
	cloneModuleAttributes(sourceModule: Module, targetModule: Module): void;
	removeModuleAttributes(module: Module): void;
	removeAllModuleAttributes(): void;
	moveModuleConnections(
		oldModule: Module,
		newModule: Module,
		filterConnection: (arg0: ModuleGraphConnection) => boolean
	): void;
	copyOutgoingModuleConnections(
		oldModule: Module,
		newModule: Module,
		filterConnection: (arg0: ModuleGraphConnection) => boolean
	): void;
	addExtraReason(module: Module, explanation: string): void;
	getResolvedModule(dependency: Dependency): Module;
	getConnection(dependency: Dependency): undefined | ModuleGraphConnection;
	getModule(dependency: Dependency): Module;
	getOrigin(dependency: Dependency): Module;
	getResolvedOrigin(dependency: Dependency): Module;
	getIncomingConnections(module: Module): Iterable<ModuleGraphConnection>;
	getOutgoingConnections(module: Module): Iterable<ModuleGraphConnection>;
	getIncomingConnectionsByOriginModule(
		module: Module
	): Map<undefined | Module, ReadonlyArray<ModuleGraphConnection>>;
	getOutgoingConnectionsByModule(
		module: Module
	): undefined | Map<undefined | Module, ReadonlyArray<ModuleGraphConnection>>;
	getProfile(module: Module): null | ModuleProfile;
	setProfile(module: Module, profile: null | ModuleProfile): void;
	getIssuer(module: Module): null | Module;
	setIssuer(module: Module, issuer: null | Module): void;
	setIssuerIfUnset(module: Module, issuer: null | Module): void;
	getOptimizationBailout(
		module: Module
	): (string | ((requestShortener: RequestShortener) => string))[];
	getProvidedExports(module: Module): null | true | string[];
	isExportProvided(
		module: Module,
		exportName: string | string[]
	): null | boolean;
	getExportsInfo(module: Module): ExportsInfo;
	getExportInfo(module: Module, exportName: string): ExportInfo;
	getReadOnlyExportInfo(module: Module, exportName: string): ExportInfo;
	getUsedExports(
		module: Module,
		runtime: RuntimeSpec
	): null | boolean | SortableSet<string>;
	getPreOrderIndex(module: Module): number;
	getPostOrderIndex(module: Module): number;
	setPreOrderIndex(module: Module, index: number): void;
	setPreOrderIndexIfUnset(module: Module, index: number): boolean;
	setPostOrderIndex(module: Module, index: number): void;
	setPostOrderIndexIfUnset(module: Module, index: number): boolean;
	getDepth(module: Module): number;
	setDepth(module: Module, depth: number): void;
	setDepthIfLower(module: Module, depth: number): boolean;
	isAsync(module: Module): boolean;
	setAsync(module: Module): void;
	getMeta(thing?: any): Object;
	getMetaIfExisting(thing?: any): Object;
	freeze(cacheStage?: string): void;
	unfreeze(): void;
	cached<T extends any[], V>(
		fn: (moduleGraph: ModuleGraph, ...args: T) => V,
		...args: T
	): V;
	setModuleMemCaches(
		moduleMemCaches: Map<Module, WeakTupleMap<any, any>>
	): void;
	dependencyCacheProvide(dependency: Dependency, ...args: any[]): any;
	static getModuleGraphForModule(
		module: Module,
		deprecateMessage: string,
		deprecationCode: string
	): ModuleGraph;
	static setModuleGraphForModule(
		module: Module,
		moduleGraph: ModuleGraph
	): void;
	static clearModuleGraphForModule(module: Module): void;
	static ModuleGraphConnection: typeof ModuleGraphConnection;
}
declare class ModuleGraphConnection {
	constructor(
		originModule: null | Module,
		dependency: null | Dependency,
		module: Module,
		explanation?: string,
		weak?: boolean,
		condition?:
			| false
			| ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState)
	);
	originModule: null | Module;
	resolvedOriginModule: null | Module;
	dependency: null | Dependency;
	resolvedModule: Module;
	module: Module;
	weak: boolean;
	conditional: boolean;
	condition: (
		arg0: ModuleGraphConnection,
		arg1: RuntimeSpec
	) => ConnectionState;
	explanations: Set<string>;
	clone(): ModuleGraphConnection;
	addCondition(
		condition: (
			arg0: ModuleGraphConnection,
			arg1: RuntimeSpec
		) => ConnectionState
	): void;
	addExplanation(explanation: string): void;
	readonly explanation: string;
	active: void;
	isActive(runtime: RuntimeSpec): boolean;
	isTargetActive(runtime: RuntimeSpec): boolean;
	getActiveState(runtime: RuntimeSpec): ConnectionState;
	setActive(value: boolean): void;
	static addConnectionStates: (
		a: ConnectionState,
		b: ConnectionState
	) => ConnectionState;
	static TRANSITIVE_ONLY: typeof TRANSITIVE_ONLY;
	static CIRCULAR_CONNECTION: typeof CIRCULAR_CONNECTION;
}
type ModuleInfo = ConcatenatedModuleInfo | ExternalModuleInfo;

/**
 * Options affecting the normal modules (`NormalModuleFactory`).
 */
declare interface ModuleOptions {
	/**
	 * An array of rules applied by default for modules.
	 */
	defaultRules?: (RuleSetRule | "...")[];

	/**
	 * Enable warnings for full dynamic dependencies.
	 */
	exprContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRecursive'.
	 */
	exprContextRecursive?: boolean;

	/**
	 * Sets the default regular expression for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRegExp'.
	 */
	exprContextRegExp?: boolean | RegExp;

	/**
	 * Set the default request for full dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.exprContextRequest'.
	 */
	exprContextRequest?: string;

	/**
	 * Specify options for each generator.
	 */
	generator?: GeneratorOptionsByModuleType;

	/**
	 * Don't parse files matching. It's matched against the full resolved request.
	 */
	noParse?: string | Function | RegExp | (string | Function | RegExp)[];

	/**
	 * Specify options for each parser.
	 */
	parser?: ParserOptionsByModuleType;

	/**
	 * An array of rules applied for modules.
	 */
	rules?: (RuleSetRule | "...")[];

	/**
	 * Emit errors instead of warnings when imported names don't exist in imported module. Deprecated: This option has moved to 'module.parser.javascript.strictExportPresence'.
	 */
	strictExportPresence?: boolean;

	/**
	 * Handle the this context correctly according to the spec for namespace objects. Deprecated: This option has moved to 'module.parser.javascript.strictThisContextOnImports'.
	 */
	strictThisContextOnImports?: boolean;

	/**
	 * Enable warnings when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextCritical'.
	 */
	unknownContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRecursive'.
	 */
	unknownContextRecursive?: boolean;

	/**
	 * Sets the regular expression when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRegExp'.
	 */
	unknownContextRegExp?: boolean | RegExp;

	/**
	 * Sets the request when using the require function in a not statically analyse-able way. Deprecated: This option has moved to 'module.parser.javascript.unknownContextRequest'.
	 */
	unknownContextRequest?: string;

	/**
	 * Cache the resolving of module requests.
	 */
	unsafeCache?: boolean | Function;

	/**
	 * Enable warnings for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextCritical'.
	 */
	wrappedContextCritical?: boolean;

	/**
	 * Enable recursive directory lookup for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextRecursive'.
	 */
	wrappedContextRecursive?: boolean;

	/**
	 * Set the inner regular expression for partial dynamic dependencies. Deprecated: This option has moved to 'module.parser.javascript.wrappedContextRegExp'.
	 */
	wrappedContextRegExp?: RegExp;
}

/**
 * Options affecting the normal modules (`NormalModuleFactory`).
 */
declare interface ModuleOptionsNormalized {
	/**
	 * An array of rules applied by default for modules.
	 */
	defaultRules: (RuleSetRule | "...")[];

	/**
	 * Specify options for each generator.
	 */
	generator: GeneratorOptionsByModuleType;

	/**
	 * Don't parse files matching. It's matched against the full resolved request.
	 */
	noParse?: string | Function | RegExp | (string | Function | RegExp)[];

	/**
	 * Specify options for each parser.
	 */
	parser: ParserOptionsByModuleType;

	/**
	 * An array of rules applied for modules.
	 */
	rules: (RuleSetRule | "...")[];

	/**
	 * Cache the resolving of module requests.
	 */
	unsafeCache?: boolean | Function;
}
declare interface ModulePathData {
	id: string | number;
	hash: string;
	hashWithLength?: (arg0: number) => string;
}
declare abstract class ModuleProfile {
	startTime: number;
	factoryStartTime: number;
	factoryEndTime: number;
	factory: number;
	factoryParallelismFactor: number;
	restoringStartTime: number;
	restoringEndTime: number;
	restoring: number;
	restoringParallelismFactor: number;
	integrationStartTime: number;
	integrationEndTime: number;
	integration: number;
	integrationParallelismFactor: number;
	buildingStartTime: number;
	buildingEndTime: number;
	building: number;
	buildingParallelismFactor: number;
	storingStartTime: number;
	storingEndTime: number;
	storing: number;
	storingParallelismFactor: number;
	additionalFactoryTimes: any;
	additionalFactories: number;
	additionalFactoriesParallelismFactor: number;
	additionalIntegration: number;
	markFactoryStart(): void;
	markFactoryEnd(): void;
	markRestoringStart(): void;
	markRestoringEnd(): void;
	markIntegrationStart(): void;
	markIntegrationEnd(): void;
	markBuildingStart(): void;
	markBuildingEnd(): void;
	markStoringStart(): void;
	markStoringEnd(): void;

	/**
	 * Merge this profile into another one
	 */
	mergeInto(realProfile: ModuleProfile): void;
}
declare interface ModuleReferenceOptions {
	/**
	 * the properties/exports of the module
	 */
	ids: string[];

	/**
	 * true, when this referenced export is called
	 */
	call: boolean;

	/**
	 * true, when this referenced export is directly imported (not via property access)
	 */
	directImport: boolean;

	/**
	 * if the position is ASI safe or unknown
	 */
	asiSafe?: boolean;
}
declare interface ModuleSettings {
	/**
	 * Specifies the layer in which the module should be placed in.
	 */
	layer?: string;

	/**
	 * Module type to use for the module.
	 */
	type?: string;

	/**
	 * Options for the resolver.
	 */
	resolve?: ResolveOptionsWebpackOptions;

	/**
	 * Options for parsing.
	 */
	parser?: { [index: string]: any };

	/**
	 * The options for the module generator.
	 */
	generator?: { [index: string]: any };

	/**
	 * Flags a module as with or without side effects.
	 */
	sideEffects?: boolean;
}
declare abstract class ModuleTemplate {
	type: string;
	hooks: Readonly<{
		content: { tap: (options?: any, fn?: any) => void };
		module: { tap: (options?: any, fn?: any) => void };
		render: { tap: (options?: any, fn?: any) => void };
		package: { tap: (options?: any, fn?: any) => void };
		hash: { tap: (options?: any, fn?: any) => void };
	}>;
	readonly runtimeTemplate: any;
}
declare class MultiCompiler {
	constructor(
		compilers: Compiler[] | Record<string, Compiler>,
		options: MultiCompilerOptions
	);
	hooks: Readonly<{
		done: SyncHook<[MultiStats]>;
		invalid: MultiHook<SyncHook<[null | string, number]>>;
		run: MultiHook<AsyncSeriesHook<[Compiler]>>;
		watchClose: SyncHook<[]>;
		watchRun: MultiHook<AsyncSeriesHook<[Compiler]>>;
		infrastructureLog: MultiHook<SyncBailHook<[string, string, any[]], true>>;
	}>;
	compilers: Compiler[];
	dependencies: WeakMap<Compiler, string[]>;
	running: boolean;
	readonly options: WebpackOptionsNormalized[] & MultiCompilerOptions;
	readonly outputPath: string;
	inputFileSystem: InputFileSystem;
	outputFileSystem: OutputFileSystem;
	watchFileSystem: WatchFileSystem;
	intermediateFileSystem: IntermediateFileSystem;
	getInfrastructureLogger(name?: any): WebpackLogger;
	setDependencies(compiler: Compiler, dependencies: string[]): void;
	validateDependencies(callback: CallbackFunction<MultiStats>): boolean;
	runWithDependencies(
		compilers: Compiler[],
		fn: (compiler: Compiler, callback: CallbackFunction<MultiStats>) => any,
		callback: CallbackFunction<MultiStats>
	): void;
	watch(
		watchOptions: WatchOptions | WatchOptions[],
		handler: CallbackFunction<MultiStats>
	): MultiWatching;
	run(callback: CallbackFunction<MultiStats>): void;
	purgeInputFileSystem(): void;
	close(callback: CallbackFunction<void>): void;
}
declare interface MultiCompilerOptions {
	/**
	 * how many Compilers are allows to run at the same time in parallel
	 */
	parallelism?: number;
}
declare abstract class MultiStats {
	stats: Stats[];
	readonly hash: string;
	hasErrors(): boolean;
	hasWarnings(): boolean;
	toJson(options?: any): StatsCompilation;
	toString(options?: any): string;
}
declare abstract class MultiWatching {
	watchings: Watching[];
	compiler: MultiCompiler;
	invalidate(callback?: any): void;
	suspend(): void;
	resume(): void;
	close(callback: CallbackFunction<void>): void;
}
declare class NamedChunkIdsPlugin {
	constructor(options?: any);
	delimiter: any;
	context: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class NamedModuleIdsPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class NaturalModuleIdsPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface NeedBuildContext {
	compilation: Compilation;
	fileSystemInfo: FileSystemInfo;
	valueCacheVersions: Map<string, string | Set<string>>;
}
declare class NoEmitOnErrorsPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class NodeEnvironmentPlugin {
	constructor(options: {
		/**
		 * infrastructure logging options
		 */
		infrastructureLogging: InfrastructureLogging;
	});
	options: {
		/**
		 * infrastructure logging options
		 */
		infrastructureLogging: InfrastructureLogging;
	};

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type NodeEstreeIndex =
	| UnaryExpression
	| ThisExpression
	| ArrayExpression
	| ObjectExpression
	| FunctionExpression
	| ArrowFunctionExpression
	| YieldExpression
	| SimpleLiteral
	| RegExpLiteral
	| BigIntLiteral
	| UpdateExpression
	| BinaryExpression
	| AssignmentExpression
	| LogicalExpression
	| MemberExpression
	| ConditionalExpression
	| SimpleCallExpression
	| NewExpression
	| SequenceExpression
	| TemplateLiteral
	| TaggedTemplateExpression
	| ClassExpression
	| MetaProperty
	| Identifier
	| AwaitExpression
	| ImportExpression
	| ChainExpression
	| FunctionDeclaration
	| VariableDeclaration
	| ClassDeclaration
	| PrivateIdentifier
	| ExpressionStatement
	| BlockStatement
	| StaticBlock
	| EmptyStatement
	| DebuggerStatement
	| WithStatement
	| ReturnStatement
	| LabeledStatement
	| BreakStatement
	| ContinueStatement
	| IfStatement
	| SwitchStatement
	| ThrowStatement
	| TryStatement
	| WhileStatement
	| DoWhileStatement
	| ForStatement
	| ForInStatement
	| ForOfStatement
	| ImportDeclaration
	| ExportNamedDeclaration
	| ExportDefaultDeclaration
	| ExportAllDeclaration
	| MethodDefinition
	| PropertyDefinition
	| VariableDeclarator
	| Program
	| Super
	| SwitchCase
	| CatchClause
	| Property
	| AssignmentProperty
	| TemplateElement
	| SpreadElement
	| ObjectPattern
	| ArrayPattern
	| RestElement
	| AssignmentPattern
	| ClassBody
	| ImportSpecifier
	| ImportDefaultSpecifier
	| ImportNamespaceSpecifier
	| ExportSpecifier;

/**
 * Options object for node compatibility features.
 */
declare interface NodeOptions {
	/**
	 * Include a polyfill for the '__dirname' variable.
	 */
	__dirname?: boolean | "warn-mock" | "mock" | "eval-only";

	/**
	 * Include a polyfill for the '__filename' variable.
	 */
	__filename?: boolean | "warn-mock" | "mock" | "eval-only";

	/**
	 * Include a polyfill for the 'global' variable.
	 */
	global?: boolean | "warn";
}
declare class NodeSourcePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class NodeTargetPlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class NodeTemplatePlugin {
	constructor(options?: any);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type NodeWebpackOptions = false | NodeOptions;
declare class NormalModule extends Module {
	constructor(__0: NormalModuleCreateData);
	request: string;
	userRequest: string;
	rawRequest: string;
	binary: boolean;
	parser: Parser;
	parserOptions?: Record<string, any>;
	generator: Generator;
	generatorOptions?: Record<string, any>;
	resource: string;
	resourceResolveData?: Record<string, any>;
	matchResource?: string;
	loaders: LoaderItem[];
	error?: null | WebpackError;
	restoreFromUnsafeCache(
		unsafeCacheData?: any,
		normalModuleFactory?: any
	): void;
	createSourceForAsset(
		context: string,
		name: string,
		content: string,
		sourceMap?: any,
		associatedObjectForCache?: Object
	): Source;
	getCurrentLoader(loaderContext?: any, index?: any): null | LoaderItem;
	createSource(
		context: string,
		content: string | Buffer,
		sourceMap?: any,
		associatedObjectForCache?: Object
	): Source;
	markModuleAsErrored(error: WebpackError): void;
	applyNoParseRule(rule?: any, content?: any): any;
	shouldPreventParsing(noParseRule?: any, request?: any): any;
	static getCompilationHooks(
		compilation: Compilation
	): NormalModuleCompilationHooks;
	static deserialize(context?: any): NormalModule;
}
declare interface NormalModuleCompilationHooks {
	loader: SyncHook<[object, NormalModule]>;
	beforeLoaders: SyncHook<[LoaderItem[], NormalModule, object]>;
	beforeParse: SyncHook<[NormalModule]>;
	beforeSnapshot: SyncHook<[NormalModule]>;
	readResourceForScheme: HookMap<
		AsyncSeriesBailHook<[string, NormalModule], string | Buffer>
	>;
	readResource: HookMap<AsyncSeriesBailHook<[object], string | Buffer>>;
	needBuild: AsyncSeriesBailHook<[NormalModule, NeedBuildContext], boolean>;
}
declare interface NormalModuleCreateData {
	/**
	 * an optional layer in which the module is
	 */
	layer?: string;

	/**
	 * module type
	 */
	type: string;

	/**
	 * request string
	 */
	request: string;

	/**
	 * request intended by user (without loaders from config)
	 */
	userRequest: string;

	/**
	 * request without resolving
	 */
	rawRequest: string;

	/**
	 * list of loaders
	 */
	loaders: LoaderItem[];

	/**
	 * path + query of the real resource
	 */
	resource: string;

	/**
	 * resource resolve data
	 */
	resourceResolveData?: Record<string, any>;

	/**
	 * context directory for resolving
	 */
	context: string;

	/**
	 * path + query of the matched resource (virtual)
	 */
	matchResource?: string;

	/**
	 * the parser used
	 */
	parser: Parser;

	/**
	 * the options of the parser used
	 */
	parserOptions?: Record<string, any>;

	/**
	 * the generator used
	 */
	generator: Generator;

	/**
	 * the options of the generator used
	 */
	generatorOptions?: Record<string, any>;

	/**
	 * options used for resolving requests from this module
	 */
	resolveOptions?: ResolveOptionsWebpackOptions;
}
declare abstract class NormalModuleFactory extends ModuleFactory {
	hooks: Readonly<{
		resolve: AsyncSeriesBailHook<[ResolveData], false | void | Module>;
		resolveForScheme: HookMap<
			AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>
		>;
		resolveInScheme: HookMap<
			AsyncSeriesBailHook<[ResourceDataWithData, ResolveData], true | void>
		>;
		factorize: AsyncSeriesBailHook<[ResolveData], Module>;
		beforeResolve: AsyncSeriesBailHook<[ResolveData], false | void>;
		afterResolve: AsyncSeriesBailHook<[ResolveData], false | void>;
		createModule: AsyncSeriesBailHook<
			[
				Partial<NormalModuleCreateData & { settings: ModuleSettings }>,
				ResolveData
			],
			void | Module
		>;
		module: SyncWaterfallHook<
			[
				Module,
				Partial<NormalModuleCreateData & { settings: ModuleSettings }>,
				ResolveData
			],
			Module
		>;
		createParser: HookMap<SyncBailHook<any, any>>;
		parser: HookMap<SyncHook<any>>;
		createGenerator: HookMap<SyncBailHook<any, any>>;
		generator: HookMap<SyncHook<any>>;
	}>;
	resolverFactory: ResolverFactory;
	ruleSet: RuleSet;
	context: string;
	fs: InputFileSystem;
	parserCache: Map<string, WeakMap<Object, any>>;
	generatorCache: Map<string, WeakMap<Object, Generator>>;
	cleanupForCache(): void;
	resolveResource(
		contextInfo?: any,
		context?: any,
		unresolvedResource?: any,
		resolver?: any,
		resolveContext?: any,
		callback?: any
	): void;
	resolveRequestArray(
		contextInfo?: any,
		context?: any,
		array?: any,
		resolver?: any,
		resolveContext?: any,
		callback?: any
	): any;
	getParser(type?: any, parserOptions?: object): any;
	createParser(type: string, parserOptions?: { [index: string]: any }): Parser;
	getGenerator(type?: any, generatorOptions?: object): undefined | Generator;
	createGenerator(type?: any, generatorOptions?: object): any;
	getResolver(type?: any, resolveOptions?: any): ResolverWithOptions;
}

/**
 * These properties are added by the NormalModule
 */
declare interface NormalModuleLoaderContext<OptionsType> {
	version: number;
	getOptions(): OptionsType;
	getOptions(schema: Parameters<typeof validateFunction>[0]): OptionsType;
	emitWarning(warning: Error): void;
	emitError(error: Error): void;
	getLogger(name?: string): WebpackLogger;
	resolve(
		context: string,
		request: string,
		callback: (
			arg0: null | Error,
			arg1?: string | false,
			arg2?: ResolveRequest
		) => void
	): any;
	getResolve(options?: ResolveOptionsWithDependencyType): {
		(
			context: string,
			request: string,
			callback: (
				arg0: null | Error,
				arg1?: string | false,
				arg2?: ResolveRequest
			) => void
		): void;
		(context: string, request: string): Promise<string>;
	};
	emitFile(
		name: string,
		content: string | Buffer,
		sourceMap?: string,
		assetInfo?: AssetInfo
	): void;
	addBuildDependency(dep: string): void;
	utils: {
		absolutify: (context: string, request: string) => string;
		contextify: (context: string, request: string) => string;
		createHash: (algorithm?: string) => Hash;
	};
	rootContext: string;
	fs: InputFileSystem;
	sourceMap?: boolean;
	mode: "none" | "development" | "production";
	webpack?: boolean;
	_module?: NormalModule;
	_compilation?: Compilation;
	_compiler?: Compiler;
}
declare class NormalModuleReplacementPlugin {
	/**
	 * Create an instance of the plugin
	 */
	constructor(
		resourceRegExp: RegExp,
		newResource: string | ((arg0?: any) => void)
	);
	resourceRegExp: RegExp;
	newResource: string | ((arg0?: any) => void);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type NormalizedStatsOptions = KnownNormalizedStatsOptions &
	Omit<
		StatsOptions,
		| "context"
		| "chunkGroups"
		| "requestShortener"
		| "chunksSort"
		| "modulesSort"
		| "chunkModulesSort"
		| "nestedModulesSort"
		| "assetsSort"
		| "ids"
		| "cachedAssets"
		| "groupAssetsByEmitStatus"
		| "groupAssetsByPath"
		| "groupAssetsByExtension"
		| "assetsSpace"
		| "excludeAssets"
		| "excludeModules"
		| "warningsFilter"
		| "cachedModules"
		| "orphanModules"
		| "dependentModules"
		| "runtimeModules"
		| "groupModulesByCacheStatus"
		| "groupModulesByLayer"
		| "groupModulesByAttributes"
		| "groupModulesByPath"
		| "groupModulesByExtension"
		| "groupModulesByType"
		| "entrypoints"
		| "chunkGroupAuxiliary"
		| "chunkGroupChildren"
		| "chunkGroupMaxAssets"
		| "modulesSpace"
		| "chunkModulesSpace"
		| "nestedModulesSpace"
		| "logging"
		| "loggingDebug"
		| "loggingTrace"
		| "_env"
	> &
	Record<string, any>;
declare class NullDependency extends Dependency {
	constructor();
	static Template: typeof NullDependencyTemplate;
	static NO_EXPORTS_REFERENCED: string[][];
	static EXPORTS_OBJECT_REFERENCED: string[][];
	static TRANSITIVE: typeof TRANSITIVE;
}
declare class NullDependencyTemplate extends DependencyTemplate {
	constructor();
}
declare interface ObjectDeserializerContext {
	read: () => any;
}
declare interface ObjectSerializer {
	serialize: (arg0: any, arg1: ObjectSerializerContext) => void;
	deserialize: (arg0: ObjectDeserializerContext) => any;
}
declare interface ObjectSerializerContext {
	write: (arg0?: any) => void;
}
declare class OccurrenceChunkIdsPlugin {
	constructor(options?: OccurrenceChunkIdsPluginOptions);
	options: OccurrenceChunkIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface OccurrenceChunkIdsPluginOptions {
	/**
	 * Prioritise initial size over total size.
	 */
	prioritiseInitial?: boolean;
}
declare class OccurrenceModuleIdsPlugin {
	constructor(options?: OccurrenceModuleIdsPluginOptions);
	options: OccurrenceModuleIdsPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface OccurrenceModuleIdsPluginOptions {
	/**
	 * Prioritise initial size over total size.
	 */
	prioritiseInitial?: boolean;
}

/**
 * Enables/Disables integrated optimizations.
 */
declare interface Optimization {
	/**
	 * Check for incompatible wasm types when importing/exporting from/to ESM.
	 */
	checkWasmTypes?: boolean;

	/**
	 * Define the algorithm to choose chunk ids (named: readable ids for better debugging, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, total-size: numeric ids focused on minimal total download size, false: no algorithm used, as custom one can be provided via plugin).
	 */
	chunkIds?:
		| false
		| "natural"
		| "named"
		| "deterministic"
		| "size"
		| "total-size";

	/**
	 * Concatenate modules when possible to generate less modules, more efficient code and enable more optimizations by the minimizer.
	 */
	concatenateModules?: boolean;

	/**
	 * Emit assets even when errors occur. Critical errors are emitted into the generated code and will cause errors at runtime.
	 */
	emitOnErrors?: boolean;

	/**
	 * Also flag chunks as loaded which contain a subset of the modules.
	 */
	flagIncludedChunks?: boolean;

	/**
	 * Creates a module-internal dependency graph for top level symbols, exports and imports, to improve unused exports detection.
	 */
	innerGraph?: boolean;

	/**
	 * Rename exports when possible to generate shorter code (depends on optimization.usedExports and optimization.providedExports, true/"deterministic": generate short deterministic names optimized for caching, "size": generate the shortest possible names).
	 */
	mangleExports?: boolean | "deterministic" | "size";

	/**
	 * Reduce size of WASM by changing imports to shorter strings.
	 */
	mangleWasmImports?: boolean;

	/**
	 * Merge chunks which contain the same modules.
	 */
	mergeDuplicateChunks?: boolean;

	/**
	 * Enable minimizing the output. Uses optimization.minimizer.
	 */
	minimize?: boolean;

	/**
	 * Minimizer(s) to use for minimizing the output.
	 */
	minimizer?: (
		| ((this: Compiler, compiler: Compiler) => void)
		| WebpackPluginInstance
		| "..."
	)[];

	/**
	 * Define the algorithm to choose module ids (natural: numeric ids in order of usage, named: readable ids for better debugging, hashed: (deprecated) short hashes as ids for better long term caching, deterministic: numeric hash ids for better long term caching, size: numeric ids focused on minimal initial download size, false: no algorithm used, as custom one can be provided via plugin).
	 */
	moduleIds?: false | "natural" | "named" | "deterministic" | "size" | "hashed";

	/**
	 * Avoid emitting assets when errors occur (deprecated: use 'emitOnErrors' instead).
	 */
	noEmitOnErrors?: boolean;

	/**
	 * Set process.env.NODE_ENV to a specific value.
	 */
	nodeEnv?: string | false;

	/**
	 * Generate records with relative paths to be able to move the context folder.
	 */
	portableRecords?: boolean;

	/**
	 * Figure out which exports are provided by modules to generate more efficient code.
	 */
	providedExports?: boolean;

	/**
	 * Use real [contenthash] based on final content of the assets.
	 */
	realContentHash?: boolean;

	/**
	 * Removes modules from chunks when these modules are already included in all parents.
	 */
	removeAvailableModules?: boolean;

	/**
	 * Remove chunks which are empty.
	 */
	removeEmptyChunks?: boolean;

	/**
	 * Create an additional chunk which contains only the webpack runtime and chunk hash maps.
	 */
	runtimeChunk?:
		| boolean
		| "single"
		| "multiple"
		| {
				/**
				 * The name or name factory for the runtime chunks.
				 */
				name?: string | Function;
		  };

	/**
	 * Skip over modules which contain no side effects when exports are not used (false: disabled, 'flag': only use manually placed side effects flag, true: also analyse source code for side effects).
	 */
	sideEffects?: boolean | "flag";

	/**
	 * Optimize duplication and caching by splitting chunks by shared modules and cache group.
	 */
	splitChunks?: false | OptimizationSplitChunksOptions;

	/**
	 * Figure out which exports are used by modules to mangle export names, omit unused exports and generate more efficient code (true: analyse used exports for each runtime, "global": analyse exports globally for all runtimes combined).
	 */
	usedExports?: boolean | "global";
}

/**
 * Options object for describing behavior of a cache group selecting modules that should be cached together.
 */
declare interface OptimizationSplitChunksCacheGroup {
	/**
	 * Sets the name delimiter for created chunks.
	 */
	automaticNameDelimiter?: string;

	/**
	 * Select chunks for determining cache group content (defaults to "initial", "initial" and "all" requires adding these chunks to the HTML).
	 */
	chunks?: "all" | "initial" | "async" | ((chunk: Chunk) => boolean);

	/**
	 * Ignore minimum size, minimum chunks and maximum requests and always create chunks for this cache group.
	 */
	enforce?: boolean;

	/**
	 * Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.
	 */
	enforceSizeThreshold?: number | { [index: string]: number };

	/**
	 * Sets the template for the filename for created chunks.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Sets the hint for chunk id.
	 */
	idHint?: string;

	/**
	 * Assign modules to a cache group by module layer.
	 */
	layer?: string | Function | RegExp;

	/**
	 * Maximum number of requests which are accepted for on-demand loading.
	 */
	maxAsyncRequests?: number;

	/**
	 * Maximal size hint for the on-demand chunks.
	 */
	maxAsyncSize?: number | { [index: string]: number };

	/**
	 * Maximum number of initial chunks which are accepted for an entry point.
	 */
	maxInitialRequests?: number;

	/**
	 * Maximal size hint for the initial chunks.
	 */
	maxInitialSize?: number | { [index: string]: number };

	/**
	 * Maximal size hint for the created chunks.
	 */
	maxSize?: number | { [index: string]: number };

	/**
	 * Minimum number of times a module has to be duplicated until it's considered for splitting.
	 */
	minChunks?: number;

	/**
	 * Minimal size for the chunks the stay after moving the modules to a new chunk.
	 */
	minRemainingSize?: number | { [index: string]: number };

	/**
	 * Minimal size for the created chunk.
	 */
	minSize?: number | { [index: string]: number };

	/**
	 * Minimum size reduction due to the created chunk.
	 */
	minSizeReduction?: number | { [index: string]: number };

	/**
	 * Give chunks for this cache group a name (chunks with equal name are merged).
	 */
	name?: string | false | Function;

	/**
	 * Priority of this cache group.
	 */
	priority?: number;

	/**
	 * Try to reuse existing chunk (with name) when it has matching modules.
	 */
	reuseExistingChunk?: boolean;

	/**
	 * Assign modules to a cache group by module name.
	 */
	test?: string | Function | RegExp;

	/**
	 * Assign modules to a cache group by module type.
	 */
	type?: string | Function | RegExp;

	/**
	 * Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.
	 */
	usedExports?: boolean;
}

/**
 * Options object for splitting chunks into smaller chunks.
 */
declare interface OptimizationSplitChunksOptions {
	/**
	 * Sets the name delimiter for created chunks.
	 */
	automaticNameDelimiter?: string;

	/**
	 * Assign modules to a cache group (modules from different cache groups are tried to keep in separate chunks, default categories: 'default', 'defaultVendors').
	 */
	cacheGroups?: {
		[index: string]:
			| string
			| false
			| Function
			| RegExp
			| OptimizationSplitChunksCacheGroup;
	};

	/**
	 * Select chunks for determining shared modules (defaults to "async", "initial" and "all" requires adding these chunks to the HTML).
	 */
	chunks?: "all" | "initial" | "async" | ((chunk: Chunk) => boolean);

	/**
	 * Sets the size types which are used when a number is used for sizes.
	 */
	defaultSizeTypes?: string[];

	/**
	 * Size threshold at which splitting is enforced and other restrictions (minRemainingSize, maxAsyncRequests, maxInitialRequests) are ignored.
	 */
	enforceSizeThreshold?: number | { [index: string]: number };

	/**
	 * Options for modules not selected by any other cache group.
	 */
	fallbackCacheGroup?: {
		/**
		 * Sets the name delimiter for created chunks.
		 */
		automaticNameDelimiter?: string;
		/**
		 * Select chunks for determining shared modules (defaults to "async", "initial" and "all" requires adding these chunks to the HTML).
		 */
		chunks?: "all" | "initial" | "async" | ((chunk: Chunk) => boolean);
		/**
		 * Maximal size hint for the on-demand chunks.
		 */
		maxAsyncSize?: number | { [index: string]: number };
		/**
		 * Maximal size hint for the initial chunks.
		 */
		maxInitialSize?: number | { [index: string]: number };
		/**
		 * Maximal size hint for the created chunks.
		 */
		maxSize?: number | { [index: string]: number };
		/**
		 * Minimal size for the created chunk.
		 */
		minSize?: number | { [index: string]: number };
		/**
		 * Minimum size reduction due to the created chunk.
		 */
		minSizeReduction?: number | { [index: string]: number };
	};

	/**
	 * Sets the template for the filename for created chunks.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Prevents exposing path info when creating names for parts splitted by maxSize.
	 */
	hidePathInfo?: boolean;

	/**
	 * Maximum number of requests which are accepted for on-demand loading.
	 */
	maxAsyncRequests?: number;

	/**
	 * Maximal size hint for the on-demand chunks.
	 */
	maxAsyncSize?: number | { [index: string]: number };

	/**
	 * Maximum number of initial chunks which are accepted for an entry point.
	 */
	maxInitialRequests?: number;

	/**
	 * Maximal size hint for the initial chunks.
	 */
	maxInitialSize?: number | { [index: string]: number };

	/**
	 * Maximal size hint for the created chunks.
	 */
	maxSize?: number | { [index: string]: number };

	/**
	 * Minimum number of times a module has to be duplicated until it's considered for splitting.
	 */
	minChunks?: number;

	/**
	 * Minimal size for the chunks the stay after moving the modules to a new chunk.
	 */
	minRemainingSize?: number | { [index: string]: number };

	/**
	 * Minimal size for the created chunks.
	 */
	minSize?: number | { [index: string]: number };

	/**
	 * Minimum size reduction due to the created chunk.
	 */
	minSizeReduction?: number | { [index: string]: number };

	/**
	 * Give chunks created a name (chunks with equal name are merged).
	 */
	name?: string | false | Function;

	/**
	 * Compare used exports when checking common modules. Modules will only be put in the same chunk when exports are equal.
	 */
	usedExports?: boolean;
}
declare abstract class OptionsApply {
	process(options?: any, compiler?: any): void;
}
declare interface OriginRecord {
	module: Module;
	loc: DependencyLocation;
	request: string;
}
declare class OriginalSource extends Source {
	constructor(source: string | Buffer, name: string);
	getName(): string;
}

/**
 * Options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
 */
declare interface Output {
	/**
	 * The filename of asset modules as relative path inside the 'output.path' directory.
	 */
	assetModuleFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Add a comment in the UMD wrapper.
	 */
	auxiliaryComment?: string | LibraryCustomUmdCommentObject;

	/**
	 * Add charset attribute for script tag.
	 */
	charset?: boolean;

	/**
	 * Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	chunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The format of chunks (formats included by default are 'array-push' (web/WebWorker), 'commonjs' (node.js), 'module' (ESM), but others might be added by plugins).
	 */
	chunkFormat?: string | false;

	/**
	 * Number of milliseconds before chunk request expires.
	 */
	chunkLoadTimeout?: number;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The global variable used by webpack for loading of chunks.
	 */
	chunkLoadingGlobal?: string;

	/**
	 * Clean the output directory before emit.
	 */
	clean?: boolean | CleanOptions;

	/**
	 * Check if to be emitted file already exists and have the same content before writing to output filesystem.
	 */
	compareBeforeEmit?: boolean;

	/**
	 * This option enables cross-origin loading of chunks.
	 */
	crossOriginLoading?: false | "anonymous" | "use-credentials";

	/**
	 * Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssChunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.
	 */
	devtoolFallbackModuleFilenameTemplate?: string | Function;

	/**
	 * Filename template string of function for the sources array in a generated SourceMap.
	 */
	devtoolModuleFilenameTemplate?: string | Function;

	/**
	 * Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.
	 */
	devtoolNamespace?: string;

	/**
	 * List of chunk loading types enabled for use by entry points.
	 */
	enabledChunkLoadingTypes?: string[];

	/**
	 * List of library types enabled for use by entry points.
	 */
	enabledLibraryTypes?: string[];

	/**
	 * List of wasm loading types enabled for use by entry points.
	 */
	enabledWasmLoadingTypes?: string[];

	/**
	 * The abilities of the environment where the webpack generated code should run.
	 */
	environment?: Environment;

	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * An expression which is used to address the global object/scope in runtime code.
	 */
	globalObject?: string;

	/**
	 * Digest type used for the hash.
	 */
	hashDigest?: string;

	/**
	 * Number of chars which are used for the hash.
	 */
	hashDigestLength?: number;

	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashFunction?: string | typeof Hash;

	/**
	 * Any string which is added to the hash to salt it.
	 */
	hashSalt?: string;

	/**
	 * The filename of the Hot Update Chunks. They are inside the output.path directory.
	 */
	hotUpdateChunkFilename?: string;

	/**
	 * The global variable used by webpack for loading of hot update chunks.
	 */
	hotUpdateGlobal?: string;

	/**
	 * The filename of the Hot Update Main File. It is inside the 'output.path' directory.
	 */
	hotUpdateMainFilename?: string;

	/**
	 * Wrap javascript code into IIFE's to avoid leaking into global scope.
	 */
	iife?: boolean;

	/**
	 * The name of the native import() function (can be exchanged for a polyfill).
	 */
	importFunctionName?: string;

	/**
	 * The name of the native import.meta object (can be exchanged for a polyfill).
	 */
	importMetaName?: string;

	/**
	 * Make the output files a library, exporting the exports of the entry point.
	 */
	library?: string | string[] | LibraryOptions | LibraryCustomUmdObject;

	/**
	 * Specify which export should be exposed as library.
	 */
	libraryExport?: string | string[];

	/**
	 * Type of library (types included by default are 'var', 'module', 'assign', 'assign-properties', 'this', 'window', 'self', 'global', 'commonjs', 'commonjs2', 'commonjs-module', 'commonjs-static', 'amd', 'amd-require', 'umd', 'umd2', 'jsonp', 'system', but others might be added by plugins).
	 */
	libraryTarget?: string;

	/**
	 * Output javascript files as module source type.
	 */
	module?: boolean;

	/**
	 * The output directory as **absolute path** (required).
	 */
	path?: string;

	/**
	 * Include comments with information about the modules.
	 */
	pathinfo?: boolean | "verbose";

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * This option enables loading async chunks via a custom script type, such as script type="module".
	 */
	scriptType?: false | "module" | "text/javascript";

	/**
	 * The filename of the SourceMaps for the JavaScript files. They are inside the 'output.path' directory.
	 */
	sourceMapFilename?: string;

	/**
	 * Prefixes every line of the source in the bundle with this string.
	 */
	sourcePrefix?: string;

	/**
	 * Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.
	 */
	strictModuleErrorHandling?: boolean;

	/**
	 * Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.
	 */
	strictModuleExceptionHandling?: boolean;

	/**
	 * Use a Trusted Types policy to create urls for chunks. 'output.uniqueName' is used a default policy name. Passing a string sets a custom policy name.
	 */
	trustedTypes?: string | true | TrustedTypes;

	/**
	 * If `output.libraryTarget` is set to umd and `output.library` is set, setting this to true will name the AMD module.
	 */
	umdNamedDefine?: boolean;

	/**
	 * A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.
	 */
	uniqueName?: string;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;

	/**
	 * The filename of WebAssembly modules as relative path inside the 'output.path' directory.
	 */
	webassemblyModuleFilename?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	workerChunkLoading?: string | false;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	workerWasmLoading?: string | false;
}
declare interface OutputFileSystem {
	writeFile: (
		arg0: string,
		arg1: string | Buffer,
		arg2: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	mkdir: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	readdir?: (
		arg0: string,
		arg1: (
			arg0?: null | NodeJS.ErrnoException,
			arg1?: (string | Buffer)[] | IDirent[]
		) => void
	) => void;
	rmdir?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	unlink?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException) => void
	) => void;
	stat: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	lstat?: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: IStats) => void
	) => void;
	readFile: (
		arg0: string,
		arg1: (arg0?: null | NodeJS.ErrnoException, arg1?: string | Buffer) => void
	) => void;
	join?: (arg0: string, arg1: string) => string;
	relative?: (arg0: string, arg1: string) => string;
	dirname?: (arg0: string) => string;
}

/**
 * Normalized options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
 */
declare interface OutputNormalized {
	/**
	 * The filename of asset modules as relative path inside the 'output.path' directory.
	 */
	assetModuleFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Enable/disable creating async chunks that are loaded on demand.
	 */
	asyncChunks?: boolean;

	/**
	 * Add charset attribute for script tag.
	 */
	charset?: boolean;

	/**
	 * Specifies the filename template of output files of non-initial chunks on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	chunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * The format of chunks (formats included by default are 'array-push' (web/WebWorker), 'commonjs' (node.js), 'module' (ESM), but others might be added by plugins).
	 */
	chunkFormat?: string | false;

	/**
	 * Number of milliseconds before chunk request expires.
	 */
	chunkLoadTimeout?: number;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	chunkLoading?: string | false;

	/**
	 * The global variable used by webpack for loading of chunks.
	 */
	chunkLoadingGlobal?: string;

	/**
	 * Clean the output directory before emit.
	 */
	clean?: boolean | CleanOptions;

	/**
	 * Check if to be emitted file already exists and have the same content before writing to output filesystem.
	 */
	compareBeforeEmit?: boolean;

	/**
	 * This option enables cross-origin loading of chunks.
	 */
	crossOriginLoading?: false | "anonymous" | "use-credentials";

	/**
	 * Specifies the filename template of non-initial output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssChunkFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Specifies the filename template of output css files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	cssFilename?:
		| string
		| ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * Similar to `output.devtoolModuleFilenameTemplate`, but used in the case of duplicate module identifiers.
	 */
	devtoolFallbackModuleFilenameTemplate?: string | Function;

	/**
	 * Filename template string of function for the sources array in a generated SourceMap.
	 */
	devtoolModuleFilenameTemplate?: string | Function;

	/**
	 * Module namespace to use when interpolating filename template string for the sources array in a generated SourceMap. Defaults to `output.library` if not set. It's useful for avoiding runtime collisions in sourcemaps from multiple webpack projects built as libraries.
	 */
	devtoolNamespace?: string;

	/**
	 * List of chunk loading types enabled for use by entry points.
	 */
	enabledChunkLoadingTypes?: string[];

	/**
	 * List of library types enabled for use by entry points.
	 */
	enabledLibraryTypes?: string[];

	/**
	 * List of wasm loading types enabled for use by entry points.
	 */
	enabledWasmLoadingTypes?: string[];

	/**
	 * The abilities of the environment where the webpack generated code should run.
	 */
	environment?: Environment;

	/**
	 * Specifies the filename of output files on disk. You must **not** specify an absolute path here, but the path may contain folders separated by '/'! The specified path is joined with the value of the 'output.path' option to determine the location on disk.
	 */
	filename?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * An expression which is used to address the global object/scope in runtime code.
	 */
	globalObject?: string;

	/**
	 * Digest type used for the hash.
	 */
	hashDigest?: string;

	/**
	 * Number of chars which are used for the hash.
	 */
	hashDigestLength?: number;

	/**
	 * Algorithm used for generation the hash (see node.js crypto package).
	 */
	hashFunction?: string | typeof Hash;

	/**
	 * Any string which is added to the hash to salt it.
	 */
	hashSalt?: string;

	/**
	 * The filename of the Hot Update Chunks. They are inside the output.path directory.
	 */
	hotUpdateChunkFilename?: string;

	/**
	 * The global variable used by webpack for loading of hot update chunks.
	 */
	hotUpdateGlobal?: string;

	/**
	 * The filename of the Hot Update Main File. It is inside the 'output.path' directory.
	 */
	hotUpdateMainFilename?: string;

	/**
	 * Wrap javascript code into IIFE's to avoid leaking into global scope.
	 */
	iife?: boolean;

	/**
	 * The name of the native import() function (can be exchanged for a polyfill).
	 */
	importFunctionName?: string;

	/**
	 * The name of the native import.meta object (can be exchanged for a polyfill).
	 */
	importMetaName?: string;

	/**
	 * Options for library.
	 */
	library?: LibraryOptions;

	/**
	 * Output javascript files as module source type.
	 */
	module?: boolean;

	/**
	 * The output directory as **absolute path** (required).
	 */
	path?: string;

	/**
	 * Include comments with information about the modules.
	 */
	pathinfo?: boolean | "verbose";

	/**
	 * The 'publicPath' specifies the public URL address of the output files when referenced in a browser.
	 */
	publicPath?: string | ((pathData: PathData, assetInfo?: AssetInfo) => string);

	/**
	 * This option enables loading async chunks via a custom script type, such as script type="module".
	 */
	scriptType?: false | "module" | "text/javascript";

	/**
	 * The filename of the SourceMaps for the JavaScript files. They are inside the 'output.path' directory.
	 */
	sourceMapFilename?: string;

	/**
	 * Prefixes every line of the source in the bundle with this string.
	 */
	sourcePrefix?: string;

	/**
	 * Handles error in module loading correctly at a performance cost. This will handle module error compatible with the EcmaScript Modules spec.
	 */
	strictModuleErrorHandling?: boolean;

	/**
	 * Handles exceptions in module loading correctly at a performance cost (Deprecated). This will handle module error compatible with the Node.js CommonJS way.
	 */
	strictModuleExceptionHandling?: boolean;

	/**
	 * Use a Trusted Types policy to create urls for chunks.
	 */
	trustedTypes?: TrustedTypes;

	/**
	 * A unique name of the webpack build to avoid multiple webpack runtimes to conflict when using globals.
	 */
	uniqueName?: string;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	wasmLoading?: string | false;

	/**
	 * The filename of WebAssembly modules as relative path inside the 'output.path' directory.
	 */
	webassemblyModuleFilename?: string;

	/**
	 * The method of loading chunks (methods included by default are 'jsonp' (web), 'import' (ESM), 'importScripts' (WebWorker), 'require' (sync node.js), 'async-node' (async node.js), but others might be added by plugins).
	 */
	workerChunkLoading?: string | false;

	/**
	 * The method of loading WebAssembly Modules (methods included by default are 'fetch' (web/WebWorker), 'async-node' (node.js), but others might be added by plugins).
	 */
	workerWasmLoading?: string | false;
}
declare interface ParameterizedComparator<TArg, T> {
	(arg0: TArg): Comparator<T>;
}
declare interface ParsedIdentifier {
	request: string;
	query: string;
	fragment: string;
	directory: boolean;
	module: boolean;
	file: boolean;
	internal: boolean;
}
declare class Parser {
	constructor();
	parse(
		source: string | Buffer | PreparsedAst,
		state: ParserState
	): ParserState;
}
type ParserOptionsByModuleType = ParserOptionsByModuleTypeKnown &
	ParserOptionsByModuleTypeUnknown;

/**
 * Specify options for each parser.
 */
declare interface ParserOptionsByModuleTypeKnown {
	/**
	 * Parser options for asset modules.
	 */
	asset?: AssetParserOptions;

	/**
	 * No parser options are supported for this module type.
	 */
	"asset/inline"?: EmptyParserOptions;

	/**
	 * No parser options are supported for this module type.
	 */
	"asset/resource"?: EmptyParserOptions;

	/**
	 * No parser options are supported for this module type.
	 */
	"asset/source"?: EmptyParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	javascript?: JavascriptParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	"javascript/auto"?: JavascriptParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	"javascript/dynamic"?: JavascriptParserOptions;

	/**
	 * Parser options for javascript modules.
	 */
	"javascript/esm"?: JavascriptParserOptions;
}

/**
 * Specify options for each parser.
 */
declare interface ParserOptionsByModuleTypeUnknown {
	[index: string]: { [index: string]: any };
}
type ParserState = Record<string, any> & ParserStateBase;
declare interface ParserStateBase {
	source: string | Buffer;
	current: NormalModule;
	module: NormalModule;
	compilation: Compilation;
	options: { [index: string]: any };
}
declare interface PathData {
	chunkGraph?: ChunkGraph;
	hash?: string;
	hashWithLength?: (arg0: number) => string;
	chunk?: Chunk | ChunkPathData;
	module?: Module | ModulePathData;
	runtime?: RuntimeSpec;
	filename?: string;
	basename?: string;
	query?: string;
	contentHashType?: string;
	contentHash?: string;
	contentHashWithLength?: (arg0: number) => string;
	noChunkHash?: boolean;
	url?: string;
}

/**
 * Configuration object for web performance recommendations.
 */
declare interface PerformanceOptions {
	/**
	 * Filter function to select assets that are checked.
	 */
	assetFilter?: Function;

	/**
	 * Sets the format of the hints: warnings, errors or nothing at all.
	 */
	hints?: false | "error" | "warning";

	/**
	 * File size limit (in bytes) when exceeded, that webpack will provide performance hints.
	 */
	maxAssetSize?: number;

	/**
	 * Total size of an entry point (in bytes).
	 */
	maxEntrypointSize?: number;
}
declare interface PitchLoaderDefinitionFunction<
	OptionsType = {},
	ContextAdditions = {}
> {
	(
		this: NormalModuleLoaderContext<OptionsType> &
			LoaderRunnerLoaderContext<OptionsType> &
			LoaderPluginLoaderContext &
			HotModuleReplacementPluginLoaderContext &
			ContextAdditions,
		remainingRequest: string,
		previousRequest: string,
		data: object
	): string | void | Buffer | Promise<string | Buffer>;
}
type Plugin =
	| { apply: (arg0: Resolver) => void }
	| ((this: Resolver, arg1: Resolver) => void);
declare interface PnpApiImpl {
	resolveToUnqualified: (arg0: string, arg1: string, arg2: object) => string;
}
declare interface PossibleFileSystemError {
	code?: string;
	errno?: number;
	path?: string;
	syscall?: string;
}
declare class PrefetchPlugin {
	constructor(context?: any, request?: any);
	context: any;
	request: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class PrefixSource extends Source {
	constructor(prefix: string, source: string | Source);
	original(): Source;
	getPrefix(): string;
}
declare interface PreparsedAst {
	[index: string]: any;
}
declare interface PrintedElement {
	element: string;
	content: string;
}
declare interface Problem {
	type: ProblemType;
	path: string;
	argument: string;
	value?: any;
	index?: number;
	expected?: string;
}
type ProblemType =
	| "unknown-argument"
	| "unexpected-non-array-in-path"
	| "unexpected-non-object-in-path"
	| "multiple-values-unexpected"
	| "invalid-value";
declare interface ProcessAssetsAdditionalOptions {
	additionalAssets?: true | Function;
}
declare class Profiler {
	constructor(inspector?: any);
	session: any;
	inspector: any;
	hasSession(): boolean;
	startProfiling(): Promise<void> | Promise<[any, any, any]>;
	sendCommand(method?: any, params?: any): Promise<any>;
	destroy(): Promise<void>;
	stopProfiling(): Promise<{ profile: any }>;
}
declare class ProfilingPlugin {
	constructor(options?: ProfilingPluginOptions);
	outputPath: string;
	apply(compiler?: any): void;
	static Profiler: typeof Profiler;
}
declare interface ProfilingPluginOptions {
	/**
	 * Path to the output file e.g. `path.resolve(__dirname, 'profiling/events.json')`. Defaults to `events.json`.
	 */
	outputPath?: string;
}
declare class ProgressPlugin {
	constructor(options?: ProgressPluginArgument);
	profile?: null | boolean;
	handler?: (percentage: number, msg: string, ...args: string[]) => void;
	modulesCount?: number;
	dependenciesCount?: number;
	showEntries?: boolean;
	showModules?: boolean;
	showDependencies?: boolean;
	showActiveModules?: boolean;
	percentBy?: null | "modules" | "dependencies" | "entries";
	apply(compiler: Compiler | MultiCompiler): void;
	static getReporter(
		compiler: Compiler
	): (p: number, ...args: string[]) => void;
	static defaultOptions: {
		profile: boolean;
		modulesCount: number;
		dependenciesCount: number;
		modules: boolean;
		dependencies: boolean;
		activeModules: boolean;
		entries: boolean;
	};
}
type ProgressPluginArgument =
	| ProgressPluginOptions
	| ((percentage: number, msg: string, ...args: string[]) => void);

/**
 * Options object for the ProgressPlugin.
 */
declare interface ProgressPluginOptions {
	/**
	 * Show active modules count and one active module in progress message.
	 */
	activeModules?: boolean;

	/**
	 * Show dependencies count in progress message.
	 */
	dependencies?: boolean;

	/**
	 * Minimum dependencies count to start with. For better progress calculation. Default: 10000.
	 */
	dependenciesCount?: number;

	/**
	 * Show entries count in progress message.
	 */
	entries?: boolean;

	/**
	 * Function that executes for every progress step.
	 */
	handler?: (percentage: number, msg: string, ...args: string[]) => void;

	/**
	 * Show modules count in progress message.
	 */
	modules?: boolean;

	/**
	 * Minimum modules count to start with. For better progress calculation. Default: 5000.
	 */
	modulesCount?: number;

	/**
	 * Collect percent algorithm. By default it calculates by a median from modules, entries and dependencies percent.
	 */
	percentBy?: null | "modules" | "dependencies" | "entries";

	/**
	 * Collect profile data for progress steps. Default: false.
	 */
	profile?: null | boolean;
}
declare class ProvidePlugin {
	constructor(definitions: Record<string, string | string[]>);
	definitions: Record<string, string | string[]>;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class ProvideSharedPlugin {
	constructor(options: ProvideSharedPluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface ProvideSharedPluginOptions {
	/**
	 * Modules that should be provided as shared modules to the share scope. When provided, property name is used to match modules, otherwise this is automatically inferred from share key.
	 */
	provides: Provides;

	/**
	 * Share scope name used for all provided modules (defaults to 'default').
	 */
	shareScope?: string;
}
type Provides = (string | ProvidesObject)[] | ProvidesObject;

/**
 * Advanced configuration for modules that should be provided as shared modules to the share scope.
 */
declare interface ProvidesConfig {
	/**
	 * Include the provided module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;

	/**
	 * Key in the share scope under which the shared modules should be stored.
	 */
	shareKey?: string;

	/**
	 * Share scope name.
	 */
	shareScope?: string;

	/**
	 * Version of the provided module. Will replace lower matching versions, but not higher.
	 */
	version?: string | false;
}

/**
 * Modules that should be provided as shared modules to the share scope. Property names are used as share keys.
 */
declare interface ProvidesObject {
	[index: string]: string | ProvidesConfig;
}
declare interface RawChunkGroupOptions {
	preloadOrder?: number;
	prefetchOrder?: number;
}
type RawLoaderDefinition<
	OptionsType = {},
	ContextAdditions = {}
> = RawLoaderDefinitionFunction<OptionsType, ContextAdditions> & {
	raw: true;
	pitch?: PitchLoaderDefinitionFunction<OptionsType, ContextAdditions>;
};
declare interface RawLoaderDefinitionFunction<
	OptionsType = {},
	ContextAdditions = {}
> {
	(
		this: NormalModuleLoaderContext<OptionsType> &
			LoaderRunnerLoaderContext<OptionsType> &
			LoaderPluginLoaderContext &
			HotModuleReplacementPluginLoaderContext &
			ContextAdditions,
		content: Buffer,
		sourceMap?: string | SourceMap,
		additionalData?: AdditionalData
	): string | void | Buffer | Promise<string | Buffer>;
}
declare class RawSource extends Source {
	constructor(source: string | Buffer, convertToString?: boolean);
	isBuffer(): boolean;
}
declare class ReadFileCompileWasmPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class RealContentHashPlugin {
	constructor(__0: { hashFunction: any; hashDigest: any });

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static getCompilationHooks(
		compilation: Compilation
	): CompilationHooksRealContentHashPlugin;
}
declare interface RealDependencyLocation {
	start: SourcePosition;
	end?: SourcePosition;
	index?: number;
}
type RecursiveArrayOrRecord<T> =
	| { [index: string]: RecursiveArrayOrRecord<T> }
	| RecursiveArrayOrRecord<T>[]
	| T;
declare interface ReferencedExport {
	/**
	 * name of the referenced export
	 */
	name: string[];

	/**
	 * when false, referenced export can not be mangled, defaults to true
	 */
	canMangle?: boolean;
}
type Remotes = (string | RemotesObject)[] | RemotesObject;

/**
 * Advanced configuration for container locations from which modules should be resolved and loaded at runtime.
 */
declare interface RemotesConfig {
	/**
	 * Container locations from which modules should be resolved and loaded at runtime.
	 */
	external: string | string[];

	/**
	 * The name of the share scope shared with this remote.
	 */
	shareScope?: string;
}

/**
 * Container locations from which modules should be resolved and loaded at runtime. Property names are used as request scopes.
 */
declare interface RemotesObject {
	[index: string]: string | RemotesConfig | string[];
}
declare interface RenderBootstrapContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * hash to be used for render call
	 */
	hash: string;
}
declare interface RenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;

	/**
	 * rendering in strict context
	 */
	strictMode: boolean;
}
type RenderManifestEntry =
	| RenderManifestEntryTemplated
	| RenderManifestEntryStatic;
declare interface RenderManifestEntryStatic {
	render: () => Source;
	filename: string;
	info: AssetInfo;
	identifier: string;
	hash?: string;
	auxiliary?: boolean;
}
declare interface RenderManifestEntryTemplated {
	render: () => Source;
	filenameTemplate: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	pathOptions?: PathData;
	info?: AssetInfo;
	identifier: string;
	hash?: string;
	auxiliary?: boolean;
}
declare interface RenderManifestOptions {
	/**
	 * the chunk used to render
	 */
	chunk: Chunk;
	hash: string;
	fullHash: string;
	outputOptions: Output;
	codeGenerationResults: CodeGenerationResults;
	moduleTemplates: { javascript: ModuleTemplate };
	dependencyTemplates: DependencyTemplates;
	runtimeTemplate: RuntimeTemplate;
	moduleGraph: ModuleGraph;
	chunkGraph: ChunkGraph;
}
declare class ReplaceSource extends Source {
	constructor(source: Source, name?: string);
	replace(start: number, end: number, newValue: string, name?: string): void;
	insert(pos: number, newValue: string, name?: string): void;
	getName(): string;
	original(): string;
	getReplacements(): {
		start: number;
		end: number;
		content: string;
		insertIndex: number;
		name: string;
	}[];
}
declare abstract class RequestShortener {
	contextify: (arg0: string) => string;
	shorten(request?: null | string): undefined | null | string;
}
declare interface ResolveBuildDependenciesResult {
	/**
	 * list of files
	 */
	files: Set<string>;

	/**
	 * list of directories
	 */
	directories: Set<string>;

	/**
	 * list of missing entries
	 */
	missing: Set<string>;

	/**
	 * stored resolve results
	 */
	resolveResults: Map<string, string | false>;

	/**
	 * dependencies of the resolving
	 */
	resolveDependencies: {
		/**
		 * list of files
		 */
		files: Set<string>;
		/**
		 * list of directories
		 */
		directories: Set<string>;
		/**
		 * list of missing entries
		 */
		missing: Set<string>;
	};
}

/**
 * Resolve context
 */
declare interface ResolveContext {
	contextDependencies?: WriteOnlySet<string>;

	/**
	 * files that was found on file system
	 */
	fileDependencies?: WriteOnlySet<string>;

	/**
	 * dependencies that was not found on file system
	 */
	missingDependencies?: WriteOnlySet<string>;

	/**
	 * set of hooks' calls. For instance, `resolve  parsedResolve  describedResolve`,
	 */
	stack?: Set<string>;

	/**
	 * log function
	 */
	log?: (arg0: string) => void;

	/**
	 * yield result, if provided plugins can return several results
	 */
	yield?: (arg0: ResolveRequest) => void;
}
declare interface ResolveData {
	contextInfo: ModuleFactoryCreateDataContextInfo;
	resolveOptions?: ResolveOptionsWebpackOptions;
	context: string;
	request: string;
	assertions?: Record<string, any>;
	dependencies: ModuleDependency[];
	dependencyType: string;
	createData: Partial<NormalModuleCreateData & { settings: ModuleSettings }>;
	fileDependencies: LazySet<string>;
	missingDependencies: LazySet<string>;
	contextDependencies: LazySet<string>;

	/**
	 * allow to use the unsafe cache
	 */
	cacheable: boolean;
}
declare interface ResolveOptionsTypes {
	alias: AliasOption[];
	fallback: AliasOption[];
	aliasFields: Set<string | string[]>;
	cachePredicate: (arg0: ResolveRequest) => boolean;
	cacheWithContext: boolean;

	/**
	 * A list of exports field condition names.
	 */
	conditionNames: Set<string>;
	descriptionFiles: string[];
	enforceExtension: boolean;
	exportsFields: Set<string | string[]>;
	importsFields: Set<string | string[]>;
	extensions: Set<string>;
	fileSystem: FileSystem;
	unsafeCache: false | object;
	symlinks: boolean;
	resolver?: Resolver;
	modules: (string | string[])[];
	mainFields: { name: string[]; forceRelative: boolean }[];
	mainFiles: Set<string>;
	plugins: Plugin[];
	pnpApi: null | PnpApiImpl;
	roots: Set<string>;
	fullySpecified: boolean;
	resolveToContext: boolean;
	restrictions: Set<string | RegExp>;
	preferRelative: boolean;
	preferAbsolute: boolean;
}

/**
 * Options object for resolving requests.
 */
declare interface ResolveOptionsWebpackOptions {
	/**
	 * Redirect module requests.
	 */
	alias?:
		| {
				/**
				 * New request.
				 */
				alias: string | false | string[];
				/**
				 * Request to be redirected.
				 */
				name: string;
				/**
				 * Redirect only exact matching request.
				 */
				onlyModule?: boolean;
		  }[]
		| { [index: string]: string | false | string[] };

	/**
	 * Fields in the description file (usually package.json) which are used to redirect requests inside the module.
	 */
	aliasFields?: (string | string[])[];

	/**
	 * Extra resolve options per dependency category. Typical categories are "commonjs", "amd", "esm".
	 */
	byDependency?: { [index: string]: ResolveOptionsWebpackOptions };

	/**
	 * Enable caching of successfully resolved requests (cache entries are revalidated).
	 */
	cache?: boolean;

	/**
	 * Predicate function to decide which requests should be cached.
	 */
	cachePredicate?: (request: ResolveRequest) => boolean;

	/**
	 * Include the context information in the cache identifier when caching.
	 */
	cacheWithContext?: boolean;

	/**
	 * Condition names for exports field entry point.
	 */
	conditionNames?: string[];

	/**
	 * Filenames used to find a description file (like a package.json).
	 */
	descriptionFiles?: string[];

	/**
	 * Enforce the resolver to use one of the extensions from the extensions option (User must specify requests without extension).
	 */
	enforceExtension?: boolean;

	/**
	 * Field names from the description file (usually package.json) which are used to provide entry points of a package.
	 */
	exportsFields?: string[];

	/**
	 * Extensions added to the request when trying to find the file.
	 */
	extensions?: string[];

	/**
	 * Redirect module requests when normal resolving fails.
	 */
	fallback?:
		| {
				/**
				 * New request.
				 */
				alias: string | false | string[];
				/**
				 * Request to be redirected.
				 */
				name: string;
				/**
				 * Redirect only exact matching request.
				 */
				onlyModule?: boolean;
		  }[]
		| { [index: string]: string | false | string[] };

	/**
	 * Filesystem for the resolver.
	 */
	fileSystem?: InputFileSystem;

	/**
	 * Treats the request specified by the user as fully specified, meaning no extensions are added and the mainFiles in directories are not resolved (This doesn't affect requests from mainFields, aliasFields or aliases).
	 */
	fullySpecified?: boolean;

	/**
	 * Field names from the description file (usually package.json) which are used to provide internal request of a package (requests starting with # are considered as internal).
	 */
	importsFields?: string[];

	/**
	 * Field names from the description file (package.json) which are used to find the default entry point.
	 */
	mainFields?: (string | string[])[];

	/**
	 * Filenames used to find the default entry point if there is no description file or main field.
	 */
	mainFiles?: string[];

	/**
	 * Folder names or directory paths where to find modules.
	 */
	modules?: string[];

	/**
	 * Plugins for the resolver.
	 */
	plugins?: (ResolvePluginInstance | "...")[];

	/**
	 * Prefer to resolve server-relative URLs (starting with '/') as absolute paths before falling back to resolve in 'resolve.roots'.
	 */
	preferAbsolute?: boolean;

	/**
	 * Prefer to resolve module requests as relative request and fallback to resolving as module.
	 */
	preferRelative?: boolean;

	/**
	 * Custom resolver.
	 */
	resolver?: Resolver;

	/**
	 * A list of resolve restrictions. Resolve results must fulfill all of these restrictions to resolve successfully. Other resolve paths are taken when restrictions are not met.
	 */
	restrictions?: (string | RegExp)[];

	/**
	 * A list of directories in which requests that are server-relative URLs (starting with '/') are resolved.
	 */
	roots?: string[];

	/**
	 * Enable resolving symlinks to the original location.
	 */
	symlinks?: boolean;

	/**
	 * Enable caching of successfully resolved requests (cache entries are not revalidated).
	 */
	unsafeCache?: boolean | { [index: string]: any };

	/**
	 * Use synchronous filesystem calls for the resolver.
	 */
	useSyncFileSystemCalls?: boolean;
}
type ResolveOptionsWithDependencyType = ResolveOptionsWebpackOptions & {
	dependencyType?: string;
	resolveToContext?: boolean;
};

/**
 * Plugin instance.
 */
declare interface ResolvePluginInstance {
	[index: string]: any;

	/**
	 * The run point of the plugin, required method.
	 */
	apply: (resolver: Resolver) => void;
}
type ResolveRequest = BaseResolveRequest & Partial<ParsedIdentifier>;
declare interface ResolvedContextFileSystemInfoEntry {
	safeTime: number;
	timestampHash?: string;
}
declare interface ResolvedContextTimestampAndHash {
	safeTime: number;
	timestampHash?: string;
	hash: string;
}
declare abstract class Resolver {
	fileSystem: FileSystem;
	options: ResolveOptionsTypes;
	hooks: {
		resolveStep: SyncHook<
			[
				AsyncSeriesBailHook<
					[ResolveRequest, ResolveContext],
					null | ResolveRequest
				>,
				ResolveRequest
			]
		>;
		noResolve: SyncHook<[ResolveRequest, Error]>;
		resolve: AsyncSeriesBailHook<
			[ResolveRequest, ResolveContext],
			null | ResolveRequest
		>;
		result: AsyncSeriesHook<[ResolveRequest, ResolveContext]>;
	};
	ensureHook(
		name:
			| string
			| AsyncSeriesBailHook<
					[ResolveRequest, ResolveContext],
					null | ResolveRequest
			  >
	): AsyncSeriesBailHook<
		[ResolveRequest, ResolveContext],
		null | ResolveRequest
	>;
	getHook(
		name:
			| string
			| AsyncSeriesBailHook<
					[ResolveRequest, ResolveContext],
					null | ResolveRequest
			  >
	): AsyncSeriesBailHook<
		[ResolveRequest, ResolveContext],
		null | ResolveRequest
	>;
	resolveSync(context: object, path: string, request: string): string | false;
	resolve(
		context: object,
		path: string,
		request: string,
		resolveContext: ResolveContext,
		callback: (
			arg0: null | Error,
			arg1?: string | false,
			arg2?: ResolveRequest
		) => void
	): void;
	doResolve(
		hook?: any,
		request?: any,
		message?: any,
		resolveContext?: any,
		callback?: any
	): any;
	parse(identifier: string): ParsedIdentifier;
	isModule(path?: any): boolean;
	isPrivate(path?: any): boolean;
	isDirectory(path: string): boolean;
	join(path?: any, request?: any): string;
	normalize(path?: any): string;
}
declare interface ResolverCache {
	direct: WeakMap<Object, ResolverWithOptions>;
	stringified: Map<string, ResolverWithOptions>;
}
declare abstract class ResolverFactory {
	hooks: Readonly<{
		resolveOptions: HookMap<
			SyncWaterfallHook<[ResolveOptionsWithDependencyType]>
		>;
		resolver: HookMap<
			SyncHook<[Resolver, UserResolveOptions, ResolveOptionsWithDependencyType]>
		>;
	}>;
	cache: Map<string, ResolverCache>;
	get(
		type: string,
		resolveOptions?: ResolveOptionsWithDependencyType
	): ResolverWithOptions;
}
type ResolverWithOptions = Resolver & WithOptions;

declare interface ResourceDataWithData {
	resource: string;
	path: string;
	query: string;
	fragment: string;
	context?: string;
	data: Record<string, any>;
}
type Rule = string | RegExp;
declare interface RuleSet {
	/**
	 * map of references in the rule set (may grow over time)
	 */
	references: Map<string, any>;

	/**
	 * execute the rule set
	 */
	exec: (arg0: object) => Effect[];
}
type RuleSetCondition =
	| string
	| RegExp
	| ((value: string) => boolean)
	| RuleSetLogicalConditions
	| RuleSetCondition[];
type RuleSetConditionAbsolute =
	| string
	| RegExp
	| ((value: string) => boolean)
	| RuleSetLogicalConditionsAbsolute
	| RuleSetConditionAbsolute[];
type RuleSetConditionOrConditions =
	| string
	| RegExp
	| ((value: string) => boolean)
	| RuleSetLogicalConditions
	| RuleSetCondition[];

/**
 * Logic operators used in a condition matcher.
 */
declare interface RuleSetLogicalConditions {
	/**
	 * Logical AND.
	 */
	and?: RuleSetCondition[];

	/**
	 * Logical NOT.
	 */
	not?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Logical OR.
	 */
	or?: RuleSetCondition[];
}

/**
 * Logic operators used in a condition matcher.
 */
declare interface RuleSetLogicalConditionsAbsolute {
	/**
	 * Logical AND.
	 */
	and?: RuleSetConditionAbsolute[];

	/**
	 * Logical NOT.
	 */
	not?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Logical OR.
	 */
	or?: RuleSetConditionAbsolute[];
}

/**
 * A rule description with conditions and effects for modules.
 */
declare interface RuleSetRule {
	/**
	 * Match on import assertions of the dependency.
	 */
	assert?: { [index: string]: RuleSetConditionOrConditions };

	/**
	 * Match the child compiler name.
	 */
	compiler?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match dependency type.
	 */
	dependency?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match values of properties in the description file (usually package.json).
	 */
	descriptionData?: { [index: string]: RuleSetConditionOrConditions };

	/**
	 * Enforce this rule as pre or post step.
	 */
	enforce?: "pre" | "post";

	/**
	 * Shortcut for resource.exclude.
	 */
	exclude?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * The options for the module generator.
	 */
	generator?: { [index: string]: any };

	/**
	 * Shortcut for resource.include.
	 */
	include?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Match the issuer of the module (The module pointing to this module).
	 */
	issuer?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Match layer of the issuer of this module (The module pointing to this module).
	 */
	issuerLayer?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Specifies the layer in which the module should be placed in.
	 */
	layer?: string;

	/**
	 * Shortcut for use.loader.
	 */
	loader?: string;

	/**
	 * Match module mimetype when load from Data URI.
	 */
	mimetype?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Only execute the first matching rule in this array.
	 */
	oneOf?: RuleSetRule[];

	/**
	 * Shortcut for use.options.
	 */
	options?: string | { [index: string]: any };

	/**
	 * Options for parsing.
	 */
	parser?: { [index: string]: any };

	/**
	 * Match the real resource path of the module.
	 */
	realResource?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Options for the resolver.
	 */
	resolve?: ResolveOptionsWebpackOptions;

	/**
	 * Match the resource path of the module.
	 */
	resource?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Match the resource fragment of the module.
	 */
	resourceFragment?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match the resource query of the module.
	 */
	resourceQuery?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Match and execute these rules when this rule is matched.
	 */
	rules?: RuleSetRule[];

	/**
	 * Match module scheme.
	 */
	scheme?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditions
		| RuleSetCondition[];

	/**
	 * Flags a module as with or without side effects.
	 */
	sideEffects?: boolean;

	/**
	 * Shortcut for resource.test.
	 */
	test?:
		| string
		| RegExp
		| ((value: string) => boolean)
		| RuleSetLogicalConditionsAbsolute
		| RuleSetConditionAbsolute[];

	/**
	 * Module type to use for the module.
	 */
	type?: string;

	/**
	 * Modifiers applied to the module when rule is matched.
	 */
	use?:
		| string
		| RuleSetUseItem[]
		| ((data: {
				resource: string;
				realResource: string;
				resourceQuery: string;
				issuer: string;
				compiler: string;
		  }) => RuleSetUseItem[])
		| {
				/**
				 * Unique loader options identifier.
				 */
				ident?: string;
				/**
				 * Loader name.
				 */
				loader?: string;
				/**
				 * Loader options.
				 */
				options?: string | { [index: string]: any };
		  }
		| ((data: object) =>
				| string
				| {
						/**
						 * Unique loader options identifier.
						 */
						ident?: string;
						/**
						 * Loader name.
						 */
						loader?: string;
						/**
						 * Loader options.
						 */
						options?: string | { [index: string]: any };
				  }
				| __TypeWebpackOptions
				| RuleSetUseItem[]);
}
type RuleSetUse =
	| string
	| RuleSetUseItem[]
	| ((data: {
			resource: string;
			realResource: string;
			resourceQuery: string;
			issuer: string;
			compiler: string;
	  }) => RuleSetUseItem[])
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: string;
			/**
			 * Loader options.
			 */
			options?: string | { [index: string]: any };
	  }
	| __TypeWebpackOptions;
type RuleSetUseItem =
	| string
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: string;
			/**
			 * Loader options.
			 */
			options?: string | { [index: string]: any };
	  }
	| __TypeWebpackOptions;
declare class RuntimeChunkPlugin {
	constructor(options?: any);
	options: any;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
type RuntimeCondition = undefined | string | boolean | SortableSet<string>;
declare class RuntimeModule extends Module {
	constructor(name: string, stage?: number);
	name: string;
	stage: number;
	compilation: Compilation;
	chunk: Chunk;
	chunkGraph: ChunkGraph;
	fullHash: boolean;
	dependentHash: boolean;
	attach(compilation: Compilation, chunk: Chunk, chunkGraph?: ChunkGraph): void;
	generate(): string;
	getGeneratedCode(): string;
	shouldIsolate(): boolean;

	/**
	 * Runtime modules without any dependencies to other runtime modules
	 */
	static STAGE_NORMAL: number;

	/**
	 * Runtime modules with simple dependencies on other runtime modules
	 */
	static STAGE_BASIC: number;

	/**
	 * Runtime modules which attach to handlers of other runtime modules
	 */
	static STAGE_ATTACH: number;

	/**
	 * Runtime modules which trigger actions on bootstrap
	 */
	static STAGE_TRIGGER: number;
}
declare interface RuntimeRequirementsContext {
	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * the code generation results
	 */
	codeGenerationResults: CodeGenerationResults;
}
type RuntimeSpec = undefined | string | SortableSet<string>;
declare class RuntimeSpecMap<T> {
	constructor(clone?: RuntimeSpecMap<T>);
	get(runtime: RuntimeSpec): T;
	has(runtime: RuntimeSpec): boolean;
	set(runtime?: any, value?: any): void;
	provide(runtime?: any, computer?: any): any;
	delete(runtime?: any): void;
	update(runtime?: any, fn?: any): void;
	keys(): RuntimeSpec[];
	values(): IterableIterator<T>;
	readonly size?: number;
}
declare class RuntimeSpecSet {
	constructor(iterable?: any);
	add(runtime?: any): void;
	has(runtime?: any): boolean;
	readonly size: number;
	[Symbol.iterator](): IterableIterator<RuntimeSpec>;
}
declare abstract class RuntimeTemplate {
	compilation: Compilation;
	outputOptions: OutputNormalized;
	requestShortener: RequestShortener;
	globalObject: string;
	contentHashReplacement: string;
	isIIFE(): undefined | boolean;
	isModule(): undefined | boolean;
	supportsConst(): undefined | boolean;
	supportsArrowFunction(): undefined | boolean;
	supportsOptionalChaining(): undefined | boolean;
	supportsForOf(): undefined | boolean;
	supportsDestructuring(): undefined | boolean;
	supportsBigIntLiteral(): undefined | boolean;
	supportsDynamicImport(): undefined | boolean;
	supportsEcmaScriptModuleSyntax(): undefined | boolean;
	supportTemplateLiteral(): undefined | boolean;
	returningFunction(returnValue?: any, args?: string): string;
	basicFunction(args?: any, body?: any): string;
	concatenation(...args: (string | { expr: string })[]): string;
	expressionFunction(expression?: any, args?: string): string;
	emptyFunction(): "x => {}" | "function() {}";
	destructureArray(items?: any, value?: any): string;
	destructureObject(items?: any, value?: any): string;
	iife(args?: any, body?: any): string;
	forEach(variable?: any, array?: any, body?: any): string;

	/**
	 * Add a comment
	 */
	comment(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
		/**
		 * name of the chunk referenced
		 */
		chunkName?: string;
		/**
		 * reason information of the chunk
		 */
		chunkReason?: string;
		/**
		 * additional message
		 */
		message?: string;
		/**
		 * name of the export
		 */
		exportName?: string;
	}): string;
	throwMissingModuleErrorBlock(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	throwMissingModuleErrorFunction(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	missingModule(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	missingModuleStatement(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	missingModulePromise(__0: {
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	weakError(__0: {
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * expression to use as id expression
		 */
		idExpr?: string;
		/**
		 * which kind of code should be returned
		 */
		type: "promise" | "expression" | "statements";
	}): string;
	moduleId(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
	}): string;
	moduleRaw(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	moduleExports(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	moduleNamespace(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * if the current module is in strict esm mode
		 */
		strict?: boolean;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	moduleNamespacePromise(__0: {
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the current dependencies block
		 */
		block?: AsyncDependenciesBlock;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * a message for the comment
		 */
		message: string;
		/**
		 * if the current module is in strict esm mode
		 */
		strict?: boolean;
		/**
		 * if the dependency is weak (will create a nice error message)
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	runtimeConditionExpression(__0: {
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * runtime for which this code will be generated
		 */
		runtime?: RuntimeSpec;
		/**
		 * only execute the statement in some runtimes
		 */
		runtimeCondition?: string | boolean | SortableSet<string>;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	importStatement(__0: {
		/**
		 * whether a new variable should be created or the existing one updated
		 */
		update?: boolean;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * the request that should be printed as comment
		 */
		request: string;
		/**
		 * name of the import variable
		 */
		importVar: string;
		/**
		 * module in which the statement is emitted
		 */
		originModule: Module;
		/**
		 * true, if this is a weak dependency
		 */
		weak?: boolean;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): [string, string];
	exportFromImport(__0: {
		/**
		 * the module graph
		 */
		moduleGraph: ModuleGraph;
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the request
		 */
		request: string;
		/**
		 * the export name
		 */
		exportName: string | string[];
		/**
		 * the origin module
		 */
		originModule: Module;
		/**
		 * true, if location is safe for ASI, a bracket can be emitted
		 */
		asiSafe?: boolean;
		/**
		 * true, if expression will be called
		 */
		isCall: boolean;
		/**
		 * when false, call context will not be preserved
		 */
		callContext: boolean;
		/**
		 * when true and accessing the default exports, interop code will be generated
		 */
		defaultInterop: boolean;
		/**
		 * the identifier name of the import variable
		 */
		importVar: string;
		/**
		 * init fragments will be added here
		 */
		initFragments: InitFragment<any>[];
		/**
		 * runtime for which this code will be generated
		 */
		runtime: RuntimeSpec;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	blockPromise(__0: {
		/**
		 * the async block
		 */
		block: AsyncDependenciesBlock;
		/**
		 * the message
		 */
		message: string;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	asyncModuleFactory(__0: {
		/**
		 * the async block
		 */
		block: AsyncDependenciesBlock;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	syncModuleFactory(__0: {
		/**
		 * the dependency
		 */
		dependency: Dependency;
		/**
		 * the chunk graph
		 */
		chunkGraph: ChunkGraph;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
		/**
		 * request string used originally
		 */
		request?: string;
	}): string;
	defineEsModuleFlagStatement(__0: {
		/**
		 * the name of the exports object
		 */
		exportsArgument: string;
		/**
		 * if set, will be filled with runtime requirements
		 */
		runtimeRequirements: Set<string>;
	}): string;
	assetUrl(__0: {
		/**
		 * the module
		 */
		module: Module;
		/**
		 * the public path
		 */
		publicPath: string;
		/**
		 * runtime
		 */
		runtime?: RuntimeSpec;
		/**
		 * the code generation results
		 */
		codeGenerationResults: CodeGenerationResults;
	}): string;
}
declare abstract class RuntimeValue {
	fn: (arg0: {
		module: NormalModule;
		key: string;
		readonly version?: string;
	}) => CodeValuePrimitive;
	options: true | RuntimeValueOptions;
	readonly fileDependencies?: true | string[];
	exec(
		parser: JavascriptParser,
		valueCacheVersions: Map<string, string | Set<string>>,
		key: string
	): CodeValuePrimitive;
	getCacheVersion(): undefined | string;
}
declare interface RuntimeValueOptions {
	fileDependencies?: string[];
	contextDependencies?: string[];
	missingDependencies?: string[];
	buildDependencies?: string[];
	version?: string | (() => string);
}
declare interface ScopeInfo {
	definitions: StackedMap<string, ScopeInfo | VariableInfo>;
	topLevelScope: boolean | "arrow";
	inShorthand: boolean;
	isStrict: boolean;
	isAsmJs: boolean;
	inTry: boolean;
}
declare interface Selector<A, B> {
	(input: A): B;
}
declare abstract class Serializer {
	serializeMiddlewares: any;
	deserializeMiddlewares: any;
	context: any;
	serialize(obj?: any, context?: any): any;
	deserialize(value?: any, context?: any): any;
}
type ServerOptionsHttps = SecureContextOptions &
	TlsOptions &
	ServerOptionsImport;
declare class SharePlugin {
	constructor(options: SharePluginOptions);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}

/**
 * Options for shared modules.
 */
declare interface SharePluginOptions {
	/**
	 * Share scope name used for all shared modules (defaults to 'default').
	 */
	shareScope?: string;

	/**
	 * Modules that should be shared in the share scope. When provided, property names are used to match requested modules in this compilation.
	 */
	shared: Shared;
}
type Shared = (string | SharedObject)[] | SharedObject;

/**
 * Advanced configuration for modules that should be shared in the share scope.
 */
declare interface SharedConfig {
	/**
	 * Include the provided and fallback module directly instead behind an async request. This allows to use this shared module in initial load too. All possible shared modules need to be eager too.
	 */
	eager?: boolean;

	/**
	 * Provided module that should be provided to share scope. Also acts as fallback module if no shared module is found in share scope or version isn't valid. Defaults to the property name.
	 */
	import?: string | false;

	/**
	 * Package name to determine required version from description file. This is only needed when package name can't be automatically determined from request.
	 */
	packageName?: string;

	/**
	 * Version requirement from module in share scope.
	 */
	requiredVersion?: string | false;

	/**
	 * Module is looked up under this key from the share scope.
	 */
	shareKey?: string;

	/**
	 * Share scope name.
	 */
	shareScope?: string;

	/**
	 * Allow only a single version of the shared module in share scope (disabled by default).
	 */
	singleton?: boolean;

	/**
	 * Do not accept shared module if version is not valid (defaults to yes, if local fallback module is available and shared module is not a singleton, otherwise no, has no effect if there is no required version specified).
	 */
	strictVersion?: boolean;

	/**
	 * Version of the provided module. Will replace lower matching versions, but not higher.
	 */
	version?: string | false;
}

/**
 * Modules that should be shared in the share scope. Property names are used to match requested modules in this compilation. Relative requests are resolved, module requests are matched unresolved, absolute paths will match resolved requests. A trailing slash will match all requests with this prefix. In this case shareKey must also have a trailing slash.
 */
declare interface SharedObject {
	[index: string]: string | SharedConfig;
}
declare class SideEffectsFlagPlugin {
	constructor(analyseSource?: boolean);

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
	static moduleHasSideEffects(
		moduleName?: any,
		flagValue?: any,
		cache?: any
	): any;
}
declare class SizeOnlySource extends Source {
	constructor(size: number);
}
declare abstract class Snapshot {
	startTime?: number;
	fileTimestamps?: Map<string, null | FileSystemInfoEntry>;
	fileHashes?: Map<string, null | string>;
	fileTshs?: Map<string, null | string | TimestampAndHash>;
	contextTimestamps?: Map<string, null | ResolvedContextFileSystemInfoEntry>;
	contextHashes?: Map<string, null | string>;
	contextTshs?: Map<string, null | ResolvedContextTimestampAndHash>;
	missingExistence?: Map<string, boolean>;
	managedItemInfo?: Map<string, string>;
	managedFiles?: Set<string>;
	managedContexts?: Set<string>;
	managedMissing?: Set<string>;
	children?: Set<Snapshot>;
	hasStartTime(): boolean;
	setStartTime(value?: any): void;
	setMergedStartTime(value?: any, snapshot?: any): void;
	hasFileTimestamps(): boolean;
	setFileTimestamps(value?: any): void;
	hasFileHashes(): boolean;
	setFileHashes(value?: any): void;
	hasFileTshs(): boolean;
	setFileTshs(value?: any): void;
	hasContextTimestamps(): boolean;
	setContextTimestamps(value?: any): void;
	hasContextHashes(): boolean;
	setContextHashes(value?: any): void;
	hasContextTshs(): boolean;
	setContextTshs(value?: any): void;
	hasMissingExistence(): boolean;
	setMissingExistence(value?: any): void;
	hasManagedItemInfo(): boolean;
	setManagedItemInfo(value?: any): void;
	hasManagedFiles(): boolean;
	setManagedFiles(value?: any): void;
	hasManagedContexts(): boolean;
	setManagedContexts(value?: any): void;
	hasManagedMissing(): boolean;
	setManagedMissing(value?: any): void;
	hasChildren(): boolean;
	setChildren(value?: any): void;
	addChild(child?: any): void;
	serialize(__0: { write: any }): void;
	deserialize(__0: { read: any }): void;
	getFileIterable(): Iterable<string>;
	getContextIterable(): Iterable<string>;
	getMissingIterable(): Iterable<string>;
}

/**
 * Options affecting how file system snapshots are created and validated.
 */
declare interface SnapshotOptions {
	/**
	 * Options for snapshotting build dependencies to determine if the whole cache need to be invalidated.
	 */
	buildDependencies?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};

	/**
	 * List of paths that are managed by a package manager and contain a version or hash in its path so all files are immutable.
	 */
	immutablePaths?: (string | RegExp)[];

	/**
	 * List of paths that are managed by a package manager and can be trusted to not be modified otherwise.
	 */
	managedPaths?: (string | RegExp)[];

	/**
	 * Options for snapshotting dependencies of modules to determine if they need to be built again.
	 */
	module?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};

	/**
	 * Options for snapshotting dependencies of request resolving to determine if requests need to be re-resolved.
	 */
	resolve?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};

	/**
	 * Options for snapshotting the resolving of build dependencies to determine if the build dependencies need to be re-resolved.
	 */
	resolveBuildDependencies?: {
		/**
		 * Use hashes of the content of the files/directories to determine invalidation.
		 */
		hash?: boolean;
		/**
		 * Use timestamps of the files/directories to determine invalidation.
		 */
		timestamp?: boolean;
	};
}
declare abstract class SortableSet<T> extends Set<T> {
	/**
	 * Sort with a comparer function
	 */
	sortWith(sortFn: (arg0: T, arg1: T) => number): void;
	sort(): SortableSet<T>;

	/**
	 * Get data from cache
	 */
	getFromCache<R>(fn: (arg0: SortableSet<T>) => R): R;

	/**
	 * Get data from cache (ignoring sorting)
	 */
	getFromUnorderedCache<R>(fn: (arg0: SortableSet<T>) => R): R;
	toJSON(): T[];

	/**
	 * Iterates over values in the set.
	 */
	[Symbol.iterator](): IterableIterator<T>;
}
declare class Source {
	constructor();
	size(): number;
	map(options?: MapOptions): Object;
	sourceAndMap(options?: MapOptions): { source: string | Buffer; map: Object };
	updateHash(hash: Hash): void;
	source(): string | Buffer;
	buffer(): Buffer;
}
declare interface SourceLike {
	source(): string | Buffer;
}
declare interface SourceMap {
	version: number;
	sources: string[];
	mappings: string;
	file?: string;
	sourceRoot?: string;
	sourcesContent?: string[];
	names?: string[];
}
declare class SourceMapDevToolPlugin {
	constructor(options?: SourceMapDevToolPluginOptions);
	sourceMapFilename: string | false;
	sourceMappingURLComment: string | false;
	moduleFilenameTemplate: string | Function;
	fallbackModuleFilenameTemplate: string | Function;
	namespace: string;
	options: SourceMapDevToolPluginOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface SourceMapDevToolPluginOptions {
	/**
	 * Appends the given value to the original asset. Usually the #sourceMappingURL comment. [url] is replaced with a URL to the source map file. false disables the appending.
	 */
	append?: null | string | false;

	/**
	 * Indicates whether column mappings should be used (defaults to true).
	 */
	columns?: boolean;

	/**
	 * Exclude modules that match the given value from source map generation.
	 */
	exclude?: string | RegExp | Rule[];

	/**
	 * Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap used only if 'moduleFilenameTemplate' would result in a conflict.
	 */
	fallbackModuleFilenameTemplate?: string | Function;

	/**
	 * Path prefix to which the [file] placeholder is relative to.
	 */
	fileContext?: string;

	/**
	 * Defines the output filename of the SourceMap (will be inlined if no value is provided).
	 */
	filename?: null | string | false;

	/**
	 * Include source maps for module paths that match the given value.
	 */
	include?: string | RegExp | Rule[];

	/**
	 * Indicates whether SourceMaps from loaders should be used (defaults to true).
	 */
	module?: boolean;

	/**
	 * Generator string or function to create identifiers of modules for the 'sources' array in the SourceMap.
	 */
	moduleFilenameTemplate?: string | Function;

	/**
	 * Namespace prefix to allow multiple webpack roots in the devtools.
	 */
	namespace?: string;

	/**
	 * Omit the 'sourceContents' array from the SourceMap.
	 */
	noSources?: boolean;

	/**
	 * Provide a custom public path for the SourceMapping comment.
	 */
	publicPath?: string;

	/**
	 * Provide a custom value for the 'sourceRoot' property in the SourceMap.
	 */
	sourceRoot?: string;

	/**
	 * Include source maps for modules based on their extension (defaults to .js and .css).
	 */
	test?: string | RegExp | Rule[];
}
declare class SourceMapSource extends Source {
	constructor(
		source: string | Buffer,
		name: string,
		sourceMap: string | Object | Buffer,
		originalSource?: string | Buffer,
		innerSourceMap?: string | Object | Buffer,
		removeOriginalSource?: boolean
	);
	getArgsAsBuffers(): [
		Buffer,
		string,
		Buffer,
		undefined | Buffer,
		undefined | Buffer,
		boolean
	];
}
declare interface SourcePosition {
	line: number;
	column?: number;
}
declare interface SplitChunksOptions {
	chunksFilter: (chunk: Chunk) => boolean;
	defaultSizeTypes: string[];
	minSize: SplitChunksSizes;
	minSizeReduction: SplitChunksSizes;
	minRemainingSize: SplitChunksSizes;
	enforceSizeThreshold: SplitChunksSizes;
	maxInitialSize: SplitChunksSizes;
	maxAsyncSize: SplitChunksSizes;
	minChunks: number;
	maxAsyncRequests: number;
	maxInitialRequests: number;
	hidePathInfo: boolean;
	filename: string | ((arg0: PathData, arg1?: AssetInfo) => string);
	automaticNameDelimiter: string;
	getCacheGroups: (
		module: Module,
		context: CacheGroupsContext
	) => CacheGroupSource[];
	getName: (
		module?: Module,
		chunks?: Chunk[],
		key?: string
	) => undefined | string;
	usedExports: boolean;
	fallbackCacheGroup: FallbackCacheGroup;
}
declare class SplitChunksPlugin {
	constructor(options?: OptimizationSplitChunksOptions);
	options: SplitChunksOptions;

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface SplitChunksSizes {
	[index: string]: number;
}
declare abstract class StackedMap<K, V> {
	map: Map<K, InternalCell<V>>;
	stack: Map<K, InternalCell<V>>[];
	set(item: K, value: V): void;
	delete(item: K): void;
	has(item: K): boolean;
	get(item: K): Cell<V>;
	asArray(): K[];
	asSet(): Set<K>;
	asPairArray(): [K, Cell<V>][];
	asMap(): Map<K, Cell<V>>;
	readonly size: number;
	createChild(): StackedMap<K, V>;
}
type StartupRenderContext = RenderContext & { inlined: boolean };
type Statement =
	| FunctionDeclaration
	| VariableDeclaration
	| ClassDeclaration
	| ExpressionStatement
	| BlockStatement
	| StaticBlock
	| EmptyStatement
	| DebuggerStatement
	| WithStatement
	| ReturnStatement
	| LabeledStatement
	| BreakStatement
	| ContinueStatement
	| IfStatement
	| SwitchStatement
	| ThrowStatement
	| TryStatement
	| WhileStatement
	| DoWhileStatement
	| ForStatement
	| ForInStatement
	| ForOfStatement;
declare class Stats {
	constructor(compilation: Compilation);
	compilation: Compilation;
	readonly hash?: string;
	readonly startTime: any;
	readonly endTime: any;
	hasWarnings(): boolean;
	hasErrors(): boolean;
	toJson(options?: string | StatsOptions): StatsCompilation;
	toString(options?: any): string;
}
type StatsAsset = KnownStatsAsset & Record<string, any>;
type StatsChunk = KnownStatsChunk & Record<string, any>;
type StatsChunkGroup = KnownStatsChunkGroup & Record<string, any>;
type StatsChunkOrigin = KnownStatsChunkOrigin & Record<string, any>;
type StatsCompilation = KnownStatsCompilation & Record<string, any>;
type StatsError = KnownStatsError & Record<string, any>;
declare abstract class StatsFactory {
	hooks: Readonly<{
		extract: HookMap<SyncBailHook<[Object, any, StatsFactoryContext], any>>;
		filter: HookMap<
			SyncBailHook<[any, StatsFactoryContext, number, number], any>
		>;
		sort: HookMap<
			SyncBailHook<
				[((arg0?: any, arg1?: any) => number)[], StatsFactoryContext],
				any
			>
		>;
		filterSorted: HookMap<
			SyncBailHook<[any, StatsFactoryContext, number, number], any>
		>;
		groupResults: HookMap<
			SyncBailHook<[GroupConfig[], StatsFactoryContext], any>
		>;
		sortResults: HookMap<
			SyncBailHook<
				[((arg0?: any, arg1?: any) => number)[], StatsFactoryContext],
				any
			>
		>;
		filterResults: HookMap<
			SyncBailHook<[any, StatsFactoryContext, number, number], any>
		>;
		merge: HookMap<SyncBailHook<[any[], StatsFactoryContext], any>>;
		result: HookMap<SyncBailHook<[any[], StatsFactoryContext], any>>;
		getItemName: HookMap<SyncBailHook<[any, StatsFactoryContext], any>>;
		getItemFactory: HookMap<SyncBailHook<[any, StatsFactoryContext], any>>;
	}>;
	create(
		type: string,
		data: any,
		baseContext: Omit<StatsFactoryContext, "type">
	): any;
}
type StatsFactoryContext = KnownStatsFactoryContext & Record<string, any>;
type StatsLogging = KnownStatsLogging & Record<string, any>;
type StatsLoggingEntry = KnownStatsLoggingEntry & Record<string, any>;
type StatsModule = KnownStatsModule & Record<string, any>;
type StatsModuleIssuer = KnownStatsModuleIssuer & Record<string, any>;
type StatsModuleReason = KnownStatsModuleReason & Record<string, any>;
type StatsModuleTraceDependency = KnownStatsModuleTraceDependency &
	Record<string, any>;
type StatsModuleTraceItem = KnownStatsModuleTraceItem & Record<string, any>;

/**
 * Stats options object.
 */
declare interface StatsOptions {
	/**
	 * Fallback value for stats options when an option is not defined (has precedence over local webpack defaults).
	 */
	all?: boolean;

	/**
	 * Add assets information.
	 */
	assets?: boolean;

	/**
	 * Sort the assets by that field.
	 */
	assetsSort?: string;

	/**
	 * Space to display assets (groups will be collapsed to fit this space).
	 */
	assetsSpace?: number;

	/**
	 * Add built at time information.
	 */
	builtAt?: boolean;

	/**
	 * Add information about cached (not built) modules (deprecated: use 'cachedModules' instead).
	 */
	cached?: boolean;

	/**
	 * Show cached assets (setting this to `false` only shows emitted files).
	 */
	cachedAssets?: boolean;

	/**
	 * Add information about cached (not built) modules.
	 */
	cachedModules?: boolean;

	/**
	 * Add children information.
	 */
	children?: boolean;

	/**
	 * Display auxiliary assets in chunk groups.
	 */
	chunkGroupAuxiliary?: boolean;

	/**
	 * Display children of chunk groups.
	 */
	chunkGroupChildren?: boolean;

	/**
	 * Limit of assets displayed in chunk groups.
	 */
	chunkGroupMaxAssets?: number;

	/**
	 * Display all chunk groups with the corresponding bundles.
	 */
	chunkGroups?: boolean;

	/**
	 * Add built modules information to chunk information.
	 */
	chunkModules?: boolean;

	/**
	 * Space to display chunk modules (groups will be collapsed to fit this space, value is in number of modules/group).
	 */
	chunkModulesSpace?: number;

	/**
	 * Add the origins of chunks and chunk merging info.
	 */
	chunkOrigins?: boolean;

	/**
	 * Add information about parent, children and sibling chunks to chunk information.
	 */
	chunkRelations?: boolean;

	/**
	 * Add chunk information.
	 */
	chunks?: boolean;

	/**
	 * Sort the chunks by that field.
	 */
	chunksSort?: string;

	/**
	 * Enables/Disables colorful output.
	 */
	colors?:
		| boolean
		| {
				/**
				 * Custom color for bold text.
				 */
				bold?: string;
				/**
				 * Custom color for cyan text.
				 */
				cyan?: string;
				/**
				 * Custom color for green text.
				 */
				green?: string;
				/**
				 * Custom color for magenta text.
				 */
				magenta?: string;
				/**
				 * Custom color for red text.
				 */
				red?: string;
				/**
				 * Custom color for yellow text.
				 */
				yellow?: string;
		  };

	/**
	 * Context directory for request shortening.
	 */
	context?: string;

	/**
	 * Show chunk modules that are dependencies of other modules of the chunk.
	 */
	dependentModules?: boolean;

	/**
	 * Add module depth in module graph.
	 */
	depth?: boolean;

	/**
	 * Display the entry points with the corresponding bundles.
	 */
	entrypoints?: boolean | "auto";

	/**
	 * Add --env information.
	 */
	env?: boolean;

	/**
	 * Add details to errors (like resolving log).
	 */
	errorDetails?: boolean | "auto";

	/**
	 * Add internal stack trace to errors.
	 */
	errorStack?: boolean;

	/**
	 * Add errors.
	 */
	errors?: boolean;

	/**
	 * Add errors count.
	 */
	errorsCount?: boolean;

	/**
	 * Please use excludeModules instead.
	 */
	exclude?:
		| string
		| boolean
		| RegExp
		| ModuleFilterItemTypes[]
		| ((
				name: string,
				module: StatsModule,
				type: "module" | "chunk" | "root-of-chunk" | "nested"
		  ) => boolean);

	/**
	 * Suppress assets that match the specified filters. Filters can be Strings, RegExps or Functions.
	 */
	excludeAssets?:
		| string
		| RegExp
		| AssetFilterItemTypes[]
		| ((name: string, asset: StatsAsset) => boolean);

	/**
	 * Suppress modules that match the specified filters. Filters can be Strings, RegExps, Booleans or Functions.
	 */
	excludeModules?:
		| string
		| boolean
		| RegExp
		| ModuleFilterItemTypes[]
		| ((
				name: string,
				module: StatsModule,
				type: "module" | "chunk" | "root-of-chunk" | "nested"
		  ) => boolean);

	/**
	 * Group assets by how their are related to chunks.
	 */
	groupAssetsByChunk?: boolean;

	/**
	 * Group assets by their status (emitted, compared for emit or cached).
	 */
	groupAssetsByEmitStatus?: boolean;

	/**
	 * Group assets by their extension.
	 */
	groupAssetsByExtension?: boolean;

	/**
	 * Group assets by their asset info (immutable, development, hotModuleReplacement, etc).
	 */
	groupAssetsByInfo?: boolean;

	/**
	 * Group assets by their path.
	 */
	groupAssetsByPath?: boolean;

	/**
	 * Group modules by their attributes (errors, warnings, assets, optional, orphan, or dependent).
	 */
	groupModulesByAttributes?: boolean;

	/**
	 * Group modules by their status (cached or built and cacheable).
	 */
	groupModulesByCacheStatus?: boolean;

	/**
	 * Group modules by their extension.
	 */
	groupModulesByExtension?: boolean;

	/**
	 * Group modules by their layer.
	 */
	groupModulesByLayer?: boolean;

	/**
	 * Group modules by their path.
	 */
	groupModulesByPath?: boolean;

	/**
	 * Group modules by their type.
	 */
	groupModulesByType?: boolean;

	/**
	 * Group reasons by their origin module.
	 */
	groupReasonsByOrigin?: boolean;

	/**
	 * Add the hash of the compilation.
	 */
	hash?: boolean;

	/**
	 * Add ids.
	 */
	ids?: boolean;

	/**
	 * Add logging output.
	 */
	logging?: boolean | "none" | "error" | "warn" | "info" | "log" | "verbose";

	/**
	 * Include debug logging of specified loggers (i. e. for plugins or loaders). Filters can be Strings, RegExps or Functions.
	 */
	loggingDebug?:
		| string
		| boolean
		| RegExp
		| FilterItemTypes[]
		| ((value: string) => boolean);

	/**
	 * Add stack traces to logging output.
	 */
	loggingTrace?: boolean;

	/**
	 * Add information about assets inside modules.
	 */
	moduleAssets?: boolean;

	/**
	 * Add dependencies and origin of warnings/errors.
	 */
	moduleTrace?: boolean;

	/**
	 * Add built modules information.
	 */
	modules?: boolean;

	/**
	 * Sort the modules by that field.
	 */
	modulesSort?: string;

	/**
	 * Space to display modules (groups will be collapsed to fit this space, value is in number of modules/groups).
	 */
	modulesSpace?: number;

	/**
	 * Add information about modules nested in other modules (like with module concatenation).
	 */
	nestedModules?: boolean;

	/**
	 * Space to display modules nested within other modules (groups will be collapsed to fit this space, value is in number of modules/group).
	 */
	nestedModulesSpace?: number;

	/**
	 * Show reasons why optimization bailed out for modules.
	 */
	optimizationBailout?: boolean;

	/**
	 * Add information about orphan modules.
	 */
	orphanModules?: boolean;

	/**
	 * Add output path information.
	 */
	outputPath?: boolean;

	/**
	 * Add performance hint flags.
	 */
	performance?: boolean;

	/**
	 * Preset for the default values.
	 */
	preset?: string | boolean;

	/**
	 * Show exports provided by modules.
	 */
	providedExports?: boolean;

	/**
	 * Add public path information.
	 */
	publicPath?: boolean;

	/**
	 * Add information about the reasons why modules are included.
	 */
	reasons?: boolean;

	/**
	 * Space to display reasons (groups will be collapsed to fit this space).
	 */
	reasonsSpace?: number;

	/**
	 * Add information about assets that are related to other assets (like SourceMaps for assets).
	 */
	relatedAssets?: boolean;

	/**
	 * Add information about runtime modules (deprecated: use 'runtimeModules' instead).
	 */
	runtime?: boolean;

	/**
	 * Add information about runtime modules.
	 */
	runtimeModules?: boolean;

	/**
	 * Add the source code of modules.
	 */
	source?: boolean;

	/**
	 * Add timing information.
	 */
	timings?: boolean;

	/**
	 * Show exports used by modules.
	 */
	usedExports?: boolean;

	/**
	 * Add webpack version information.
	 */
	version?: boolean;

	/**
	 * Add warnings.
	 */
	warnings?: boolean;

	/**
	 * Add warnings count.
	 */
	warningsCount?: boolean;

	/**
	 * Suppress listing warnings that match the specified filters (they will still be counted). Filters can be Strings, RegExps or Functions.
	 */
	warningsFilter?:
		| string
		| RegExp
		| WarningFilterItemTypes[]
		| ((warning: StatsError, value: string) => boolean);
}
declare abstract class StatsPrinter {
	hooks: Readonly<{
		sortElements: HookMap<SyncBailHook<[string[], StatsPrinterContext], true>>;
		printElements: HookMap<
			SyncBailHook<[PrintedElement[], StatsPrinterContext], string>
		>;
		sortItems: HookMap<SyncBailHook<[any[], StatsPrinterContext], true>>;
		getItemName: HookMap<SyncBailHook<[any, StatsPrinterContext], string>>;
		printItems: HookMap<SyncBailHook<[string[], StatsPrinterContext], string>>;
		print: HookMap<SyncBailHook<[{}, StatsPrinterContext], string>>;
		result: HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>;
	}>;
	print(type: string, object: Object, baseContext?: Object): string;
}
type StatsPrinterContext = KnownStatsPrinterContext & Record<string, any>;
type StatsProfile = KnownStatsProfile & Record<string, any>;
type StatsValue =
	| boolean
	| StatsOptions
	| "none"
	| "verbose"
	| "summary"
	| "errors-only"
	| "errors-warnings"
	| "minimal"
	| "normal"
	| "detailed";
declare class SyncModuleIdsPlugin {
	constructor(__0: {
		/**
		 * path to file
		 */
		path: string;
		/**
		 * context for module names
		 */
		context?: string;
		/**
		 * selector for modules
		 */
		test: (arg0: Module) => boolean;
		/**
		 * operation mode (defaults to merge)
		 */
		mode?: "read" | "create" | "merge" | "update";
	});

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface SyntheticDependencyLocation {
	name: string;
	index?: number;
}
declare const TOMBSTONE: unique symbol;
declare const TRANSITIVE: unique symbol;
declare const TRANSITIVE_ONLY: unique symbol;
declare interface TagInfo {
	tag: any;
	data: any;
	next?: TagInfo;
}
declare class Template {
	constructor();
	static getFunctionContent(fn: Function): string;
	static toIdentifier(str: string): string;
	static toComment(str: string): string;
	static toNormalComment(str: string): string;
	static toPath(str: string): string;
	static numberToIdentifier(n: number): string;
	static numberToIdentifierContinuation(n: number): string;
	static indent(s: string | string[]): string;
	static prefix(s: string | string[], prefix: string): string;
	static asString(str: string | string[]): string;
	static getModulesArrayBounds(modules: WithId[]): false | [number, number];
	static renderChunkModules(
		renderContext: ChunkRenderContext,
		modules: Module[],
		renderModule: (arg0: Module) => Source,
		prefix?: string
	): Source;
	static renderRuntimeModules(
		runtimeModules: RuntimeModule[],
		renderContext: RenderContext & {
			codeGenerationResults?: CodeGenerationResults;
		}
	): Source;
	static renderChunkRuntimeModules(
		runtimeModules: RuntimeModule[],
		renderContext: RenderContext
	): Source;
	static NUMBER_OF_IDENTIFIER_START_CHARS: number;
	static NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS: number;
}
declare interface TimestampAndHash {
	safeTime: number;
	timestamp?: number;
	hash: string;
}
declare class TopLevelSymbol {
	constructor(name: string);
	name: string;
}

/**
 * Use a Trusted Types policy to create urls for chunks.
 */
declare interface TrustedTypes {
	/**
	 * The name of the Trusted Types policy created by webpack to serve bundle chunks.
	 */
	policyName?: string;
}
declare const UNDEFINED_MARKER: unique symbol;
declare interface UpdateHashContextDependency {
	chunkGraph: ChunkGraph;
	runtime: RuntimeSpec;
	runtimeTemplate?: RuntimeTemplate;
}
declare interface UpdateHashContextGenerator {
	/**
	 * the module
	 */
	module: NormalModule;
	chunkGraph: ChunkGraph;
	runtime: RuntimeSpec;
	runtimeTemplate?: RuntimeTemplate;
}
type UsageStateType = 0 | 1 | 2 | 3 | 4;
declare interface UserResolveOptions {
	/**
	 * A list of module alias configurations or an object which maps key to value
	 */
	alias?: AliasOption[] | AliasOptions;

	/**
	 * A list of module alias configurations or an object which maps key to value, applied only after modules option
	 */
	fallback?: AliasOption[] | AliasOptions;

	/**
	 * A list of alias fields in description files
	 */
	aliasFields?: (string | string[])[];

	/**
	 * A function which decides whether a request should be cached or not. An object is passed with at least `path` and `request` properties.
	 */
	cachePredicate?: (arg0: ResolveRequest) => boolean;

	/**
	 * Whether or not the unsafeCache should include request context as part of the cache key.
	 */
	cacheWithContext?: boolean;

	/**
	 * A list of description files to read from
	 */
	descriptionFiles?: string[];

	/**
	 * A list of exports field condition names.
	 */
	conditionNames?: string[];

	/**
	 * Enforce that a extension from extensions must be used
	 */
	enforceExtension?: boolean;

	/**
	 * A list of exports fields in description files
	 */
	exportsFields?: (string | string[])[];

	/**
	 * A list of imports fields in description files
	 */
	importsFields?: (string | string[])[];

	/**
	 * A list of extensions which should be tried for files
	 */
	extensions?: string[];

	/**
	 * The file system which should be used
	 */
	fileSystem: FileSystem;

	/**
	 * Use this cache object to unsafely cache the successful requests
	 */
	unsafeCache?: boolean | object;

	/**
	 * Resolve symlinks to their symlinked location
	 */
	symlinks?: boolean;

	/**
	 * A prepared Resolver to which the plugins are attached
	 */
	resolver?: Resolver;

	/**
	 * A list of directories to resolve modules from, can be absolute path or folder name
	 */
	modules?: string | string[];

	/**
	 * A list of main fields in description files
	 */
	mainFields?: (
		| string
		| string[]
		| { name: string | string[]; forceRelative: boolean }
	)[];

	/**
	 * A list of main files in directories
	 */
	mainFiles?: string[];

	/**
	 * A list of additional resolve plugins which should be applied
	 */
	plugins?: Plugin[];

	/**
	 * A PnP API that should be used - null is "never", undefined is "auto"
	 */
	pnpApi?: null | PnpApiImpl;

	/**
	 * A list of root paths
	 */
	roots?: string[];

	/**
	 * The request is already fully specified and no extensions or directories are resolved for it
	 */
	fullySpecified?: boolean;

	/**
	 * Resolve to a context instead of a file
	 */
	resolveToContext?: boolean;

	/**
	 * A list of resolve restrictions
	 */
	restrictions?: (string | RegExp)[];

	/**
	 * Use only the sync constraints of the file system calls
	 */
	useSyncFileSystemCalls?: boolean;

	/**
	 * Prefer to resolve module requests as relative requests before falling back to modules
	 */
	preferRelative?: boolean;

	/**
	 * Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots
	 */
	preferAbsolute?: boolean;
}
declare abstract class VariableInfo {
	declaredScope: ScopeInfo;
	freeName: string | true;
	tagInfo?: TagInfo;
}
declare interface VariableInfoInterface {
	declaredScope: ScopeInfo;
	freeName: string | true;
	tagInfo?: TagInfo;
}
type WarningFilterItemTypes =
	| string
	| RegExp
	| ((warning: StatsError, value: string) => boolean);
declare interface WatchFileSystem {
	watch: (
		files: Iterable<string>,
		directories: Iterable<string>,
		missing: Iterable<string>,
		startTime: number,
		options: WatchOptions,
		callback: (
			arg0: undefined | Error,
			arg1: Map<string, FileSystemInfoEntry | "ignore">,
			arg2: Map<string, FileSystemInfoEntry | "ignore">,
			arg3: Set<string>,
			arg4: Set<string>
		) => void,
		callbackUndelayed: (arg0: string, arg1: number) => void
	) => Watcher;
}
declare class WatchIgnorePlugin {
	constructor(options: WatchIgnorePluginOptions);
	paths: (string | RegExp)[];

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare interface WatchIgnorePluginOptions {
	/**
	 * A list of RegExps or absolute paths to directories or files that should be ignored.
	 */
	paths: (string | RegExp)[];
}

/**
 * Options for the watcher.
 */
declare interface WatchOptions {
	/**
	 * Delay the rebuilt after the first change. Value is a time in ms.
	 */
	aggregateTimeout?: number;

	/**
	 * Resolve symlinks and watch symlink and real file. This is usually not needed as webpack already resolves symlinks ('resolve.symlinks').
	 */
	followSymlinks?: boolean;

	/**
	 * Ignore some files from watching (glob pattern or regexp).
	 */
	ignored?: string | RegExp | string[];

	/**
	 * Enable polling mode for watching.
	 */
	poll?: number | boolean;

	/**
	 * Stop watching when stdin stream has ended.
	 */
	stdin?: boolean;
}
declare interface Watcher {
	/**
	 * closes the watcher and all underlying file watchers
	 */
	close: () => void;

	/**
	 * closes the watcher, but keeps underlying file watchers alive until the next watch call
	 */
	pause: () => void;

	/**
	 * get current aggregated changes that have not yet send to callback
	 */
	getAggregatedChanges?: () => Set<string>;

	/**
	 * get current aggregated removals that have not yet send to callback
	 */
	getAggregatedRemovals?: () => Set<string>;

	/**
	 * get info about files
	 */
	getFileTimeInfoEntries: () => Map<string, FileSystemInfoEntry | "ignore">;

	/**
	 * get info about directories
	 */
	getContextTimeInfoEntries: () => Map<string, FileSystemInfoEntry | "ignore">;

	/**
	 * get info about timestamps and changes
	 */
	getInfo?: () => WatcherInfo;
}
declare interface WatcherInfo {
	/**
	 * get current aggregated changes that have not yet send to callback
	 */
	changes: Set<string>;

	/**
	 * get current aggregated removals that have not yet send to callback
	 */
	removals: Set<string>;

	/**
	 * get info about files
	 */
	fileTimeInfoEntries: Map<string, FileSystemInfoEntry | "ignore">;

	/**
	 * get info about directories
	 */
	contextTimeInfoEntries: Map<string, FileSystemInfoEntry | "ignore">;
}
declare abstract class Watching {
	startTime: null | number;
	invalid: boolean;
	handler: CallbackFunction<Stats>;
	callbacks: CallbackFunction<void>[];
	closed: boolean;
	suspended: boolean;
	blocked: boolean;
	watchOptions: {
		/**
		 * Delay the rebuilt after the first change. Value is a time in ms.
		 */
		aggregateTimeout?: number;
		/**
		 * Resolve symlinks and watch symlink and real file. This is usually not needed as webpack already resolves symlinks ('resolve.symlinks').
		 */
		followSymlinks?: boolean;
		/**
		 * Ignore some files from watching (glob pattern or regexp).
		 */
		ignored?: string | RegExp | string[];
		/**
		 * Enable polling mode for watching.
		 */
		poll?: number | boolean;
		/**
		 * Stop watching when stdin stream has ended.
		 */
		stdin?: boolean;
	};
	compiler: Compiler;
	running: boolean;
	watcher?: null | Watcher;
	pausedWatcher?: null | Watcher;
	lastWatcherStartTime?: number;
	watch(
		files: Iterable<string>,
		dirs: Iterable<string>,
		missing: Iterable<string>
	): void;
	invalidate(callback?: CallbackFunction<void>): void;
	suspend(): void;
	resume(): void;
	close(callback: CallbackFunction<void>): void;
}
declare abstract class WeakTupleMap<T extends any[], V> {
	set(...args: [T, ...V[]]): void;
	has(...args: T): boolean;
	get(...args: T): V;
	provide(...args: [T, ...(() => V)[]]): V;
	delete(...args: T): void;
	clear(): void;
}
declare interface WebAssemblyRenderContext {
	/**
	 * the chunk
	 */
	chunk: Chunk;

	/**
	 * the dependency templates
	 */
	dependencyTemplates: DependencyTemplates;

	/**
	 * the runtime template
	 */
	runtimeTemplate: RuntimeTemplate;

	/**
	 * the module graph
	 */
	moduleGraph: ModuleGraph;

	/**
	 * the chunk graph
	 */
	chunkGraph: ChunkGraph;

	/**
	 * results of code generation
	 */
	codeGenerationResults: CodeGenerationResults;
}
declare class WebWorkerTemplatePlugin {
	constructor();

	/**
	 * Apply the plugin
	 */
	apply(compiler: Compiler): void;
}
declare class WebpackError extends Error {
	/**
	 * Creates an instance of WebpackError.
	 */
	constructor(message?: string);
	details: any;
	module: Module;
	loc: DependencyLocation;
	hideStack: boolean;
	chunk: Chunk;
	file: string;
	serialize(__0: { write: any }): void;
	deserialize(__0: { read: any }): void;

	/**
	 * Create .stack property on a target object
	 */
	static captureStackTrace(
		targetObject: object,
		constructorOpt?: Function
	): void;

	/**
	 * Optional override for formatting stack traces
	 */
	static prepareStackTrace?: (
		err: Error,
		stackTraces: NodeJS.CallSite[]
	) => any;
	static stackTraceLimit: number;
}
declare abstract class WebpackLogger {
	getChildLogger: (arg0: string | (() => string)) => WebpackLogger;
	error(...args: any[]): void;
	warn(...args: any[]): void;
	info(...args: any[]): void;
	log(...args: any[]): void;
	debug(...args: any[]): void;
	assert(assertion: any, ...args: any[]): void;
	trace(): void;
	clear(): void;
	status(...args: any[]): void;
	group(...args: any[]): void;
	groupCollapsed(...args: any[]): void;
	groupEnd(...args: any[]): void;
	profile(label?: any): void;
	profileEnd(label?: any): void;
	time(label?: any): void;
	timeLog(label?: any): void;
	timeEnd(label?: any): void;
	timeAggregate(label?: any): void;
	timeAggregateEnd(label?: any): void;
}
declare class WebpackOptionsApply extends OptionsApply {
	constructor();
}
declare class WebpackOptionsDefaulter {
	constructor();
	process(options?: any): any;
}

/**
 * Normalized webpack options object.
 */
declare interface WebpackOptionsNormalized {
	/**
	 * Set the value of `require.amd` and `define.amd`. Or disable AMD support.
	 */
	amd?: false | { [index: string]: any };

	/**
	 * Report the first error as a hard error instead of tolerating it.
	 */
	bail?: boolean;

	/**
	 * Cache generated modules and chunks to improve performance for multiple incremental builds.
	 */
	cache: CacheOptionsNormalized;

	/**
	 * The base directory (absolute path!) for resolving the `entry` option. If `output.pathinfo` is set, the included pathinfo is shortened to this directory.
	 */
	context?: string;

	/**
	 * References to other configurations to depend on.
	 */
	dependencies?: string[];

	/**
	 * Options for the webpack-dev-server.
	 */
	devServer?: DevServer;

	/**
	 * A developer tool to enhance debugging (false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map).
	 */
	devtool?: string | false;

	/**
	 * The entry point(s) of the compilation.
	 */
	entry: EntryNormalized;

	/**
	 * Enables/Disables experiments (experimental features with relax SemVer compatibility).
	 */
	experiments: ExperimentsNormalized;

	/**
	 * Specify dependencies that shouldn't be resolved by webpack, but should become dependencies of the resulting bundle. The kind of the dependency depends on `output.libraryTarget`.
	 */
	externals: Externals;

	/**
	 * Enable presets of externals for specific targets.
	 */
	externalsPresets: ExternalsPresets;

	/**
	 * Specifies the default type of externals ('amd*', 'umd*', 'system' and 'jsonp' depend on output.libraryTarget set to the same value).
	 */
	externalsType?:
		| "import"
		| "var"
		| "module"
		| "assign"
		| "this"
		| "window"
		| "self"
		| "global"
		| "commonjs"
		| "commonjs2"
		| "commonjs-module"
		| "commonjs-static"
		| "amd"
		| "amd-require"
		| "umd"
		| "umd2"
		| "jsonp"
		| "system"
		| "promise"
		| "script"
		| "node-commonjs";

	/**
	 * Ignore specific warnings.
	 */
	ignoreWarnings?: ((
		warning: WebpackError,
		compilation: Compilation
	) => boolean)[];

	/**
	 * Options for infrastructure level logging.
	 */
	infrastructureLogging: InfrastructureLogging;

	/**
	 * Custom values available in the loader context.
	 */
	loader?: Loader;

	/**
	 * Enable production optimizations or development hints.
	 */
	mode?: "none" | "development" | "production";

	/**
	 * Options affecting the normal modules (`NormalModuleFactory`).
	 */
	module: ModuleOptionsNormalized;

	/**
	 * Name of the configuration. Used when loading multiple configurations.
	 */
	name?: string;

	/**
	 * Include polyfills or mocks for various node stuff.
	 */
	node: NodeWebpackOptions;

	/**
	 * Enables/Disables integrated optimizations.
	 */
	optimization: Optimization;

	/**
	 * Normalized options affecting the output of the compilation. `output` options tell webpack how to write the compiled files to disk.
	 */
	output: OutputNormalized;

	/**
	 * The number of parallel processed modules in the compilation.
	 */
	parallelism?: number;

	/**
	 * Configuration for web performance recommendations.
	 */
	performance?: false | PerformanceOptions;

	/**
	 * Add additional plugins to the compiler.
	 */
	plugins: (
		| ((this: Compiler, compiler: Compiler) => void)
		| WebpackPluginInstance
	)[];

	/**
	 * Capture timing information for each module.
	 */
	profile?: boolean;

	/**
	 * Store compiler state to a json file.
	 */
	recordsInputPath?: string | false;

	/**
	 * Load compiler state from a json file.
	 */
	recordsOutputPath?: string | false;

	/**
	 * Options for the resolver.
	 */
	resolve: ResolveOptionsWebpackOptions;

	/**
	 * Options for the resolver when resolving loaders.
	 */
	resolveLoader: ResolveOptionsWebpackOptions;

	/**
	 * Options affecting how file system snapshots are created and validated.
	 */
	snapshot: SnapshotOptions;

	/**
	 * Stats options object or preset name.
	 */
	stats: StatsValue;

	/**
	 * Environment to build for. An array of environments to build for all of them when possible.
	 */
	target?: string | false | string[];

	/**
	 * Enter watch mode, which rebuilds on file change.
	 */
	watch?: boolean;

	/**
	 * Options for the watcher.
	 */
	watchOptions: WatchOptions;
}

/**
 * Plugin instance.
 */
declare interface WebpackPluginInstance {
	[index: string]: any;

	/**
	 * The run point of the plugin, required method.
	 */
	apply: (compiler: Compiler) => void;
}
declare interface WithId {
	id: string | number;
}
declare interface WithOptions {
	/**
	 * create a resolver with additional/different options
	 */
	withOptions: (
		arg0: Partial<ResolveOptionsWithDependencyType>
	) => ResolverWithOptions;
}
declare interface WriteOnlySet<T> {
	add: (T?: any) => void;
}
type __TypeWebpackOptions = (data: object) =>
	| string
	| {
			/**
			 * Unique loader options identifier.
			 */
			ident?: string;
			/**
			 * Loader name.
			 */
			loader?: string;
			/**
			 * Loader options.
			 */
			options?: string | { [index: string]: any };
	  }
	| __TypeWebpackOptions
	| RuleSetUseItem[];
declare function exports(
	options: Configuration,
	callback?: CallbackWebpack<Stats>
): Compiler;
declare function exports(
	options: ReadonlyArray<Configuration> & MultiCompilerOptions,
	callback?: CallbackWebpack<MultiStats>
): MultiCompiler;
declare namespace exports {
	export const webpack: {
		(options: Configuration, callback?: CallbackWebpack<Stats>): Compiler;
		(
			options: ReadonlyArray<Configuration> & MultiCompilerOptions,
			callback?: CallbackWebpack<MultiStats>
		): MultiCompiler;
	};
	export const validate: (options?: any) => void;
	export const validateSchema: (
		schema: Parameters<typeof validateFunction>[0],
		options: Parameters<typeof validateFunction>[1],
		validationConfiguration?: ValidationErrorConfiguration
	) => void;
	export const version: string;
	export namespace cli {
		export let getArguments: (schema?: any) => Record<string, Argument>;
		export let processArguments: (
			args: Record<string, Argument>,
			config: any,
			values: Record<
				string,
				| string
				| number
				| boolean
				| RegExp
				| (string | number | boolean | RegExp)[]
			>
		) => null | Problem[];
	}
	export namespace ModuleFilenameHelpers {
		export let ALL_LOADERS_RESOURCE: string;
		export let REGEXP_ALL_LOADERS_RESOURCE: RegExp;
		export let LOADERS_RESOURCE: string;
		export let REGEXP_LOADERS_RESOURCE: RegExp;
		export let RESOURCE: string;
		export let REGEXP_RESOURCE: RegExp;
		export let ABSOLUTE_RESOURCE_PATH: string;
		export let REGEXP_ABSOLUTE_RESOURCE_PATH: RegExp;
		export let RESOURCE_PATH: string;
		export let REGEXP_RESOURCE_PATH: RegExp;
		export let ALL_LOADERS: string;
		export let REGEXP_ALL_LOADERS: RegExp;
		export let LOADERS: string;
		export let REGEXP_LOADERS: RegExp;
		export let QUERY: string;
		export let REGEXP_QUERY: RegExp;
		export let ID: string;
		export let REGEXP_ID: RegExp;
		export let HASH: string;
		export let REGEXP_HASH: RegExp;
		export let NAMESPACE: string;
		export let REGEXP_NAMESPACE: RegExp;
		export let createFilename: (
			module: string | Module,
			options: any,
			__2: {
				/**
				 * requestShortener
				 */
				requestShortener: RequestShortener;
				/**
				 * chunk graph
				 */
				chunkGraph: ChunkGraph;
				/**
				 * the hash function to use
				 */
				hashFunction: string | typeof Hash;
			}
		) => string;
		export let replaceDuplicates: (
			array?: any,
			fn?: any,
			comparator?: any
		) => any;
		export let matchPart: (str?: any, test?: any) => any;
		export let matchObject: (obj?: any, str?: any) => boolean;
	}
	export namespace RuntimeGlobals {
		export let require: string;
		export let requireScope: string;
		export let exports: string;
		export let thisAsExports: string;
		export let returnExportsFromRuntime: string;
		export let module: string;
		export let moduleId: string;
		export let moduleLoaded: string;
		export let publicPath: string;
		export let entryModuleId: string;
		export let moduleCache: string;
		export let moduleFactories: string;
		export let moduleFactoriesAddOnly: string;
		export let ensureChunk: string;
		export let ensureChunkHandlers: string;
		export let ensureChunkIncludeEntries: string;
		export let prefetchChunk: string;
		export let prefetchChunkHandlers: string;
		export let preloadChunk: string;
		export let preloadChunkHandlers: string;
		export let definePropertyGetters: string;
		export let makeNamespaceObject: string;
		export let createFakeNamespaceObject: string;
		export let compatGetDefaultExport: string;
		export let harmonyModuleDecorator: string;
		export let nodeModuleDecorator: string;
		export let getFullHash: string;
		export let wasmInstances: string;
		export let instantiateWasm: string;
		export let uncaughtErrorHandler: string;
		export let scriptNonce: string;
		export let loadScript: string;
		export let createScript: string;
		export let createScriptUrl: string;
		export let getTrustedTypesPolicy: string;
		export let chunkName: string;
		export let runtimeId: string;
		export let getChunkScriptFilename: string;
		export let getChunkCssFilename: string;
		export let hasCssModules: string;
		export let getChunkUpdateScriptFilename: string;
		export let getChunkUpdateCssFilename: string;
		export let startup: string;
		export let startupNoDefault: string;
		export let startupOnlyAfter: string;
		export let startupOnlyBefore: string;
		export let chunkCallback: string;
		export let startupEntrypoint: string;
		export let onChunksLoaded: string;
		export let externalInstallChunk: string;
		export let interceptModuleExecution: string;
		export let global: string;
		export let shareScopeMap: string;
		export let initializeSharing: string;
		export let currentRemoteGetScope: string;
		export let getUpdateManifestFilename: string;
		export let hmrDownloadManifest: string;
		export let hmrDownloadUpdateHandlers: string;
		export let hmrModuleData: string;
		export let hmrInvalidateModuleHandlers: string;
		export let hmrRuntimeStatePrefix: string;
		export let amdDefine: string;
		export let amdOptions: string;
		export let system: string;
		export let hasOwnProperty: string;
		export let systemContext: string;
		export let baseURI: string;
		export let relativeUrl: string;
		export let asyncModule: string;
	}
	export const UsageState: Readonly<{
		Unused: 0;
		OnlyPropertiesUsed: 1;
		NoInfo: 2;
		Unknown: 3;
		Used: 4;
	}>;
	export namespace cache {
		export { MemoryCachePlugin };
	}
	export namespace config {
		export const getNormalizedWebpackOptions: (
			config: Configuration
		) => WebpackOptionsNormalized;
		export const applyWebpackOptionsDefaults: (
			options: WebpackOptionsNormalized
		) => void;
	}
	export namespace dependencies {
		export { ModuleDependency, ConstDependency, NullDependency };
	}
	export namespace ids {
		export {
			ChunkModuleIdRangePlugin,
			NaturalModuleIdsPlugin,
			OccurrenceModuleIdsPlugin,
			NamedModuleIdsPlugin,
			DeterministicChunkIdsPlugin,
			DeterministicModuleIdsPlugin,
			NamedChunkIdsPlugin,
			OccurrenceChunkIdsPlugin,
			HashedModuleIdsPlugin
		};
	}
	export namespace javascript {
		export {
			EnableChunkLoadingPlugin,
			JavascriptModulesPlugin,
			JavascriptParser
		};
	}
	export namespace optimize {
		export namespace InnerGraph {
			export let bailout: (parserState: ParserState) => void;
			export let enable: (parserState: ParserState) => void;
			export let isEnabled: (parserState: ParserState) => boolean;
			export let addUsage: (
				state: ParserState,
				symbol: null | TopLevelSymbol,
				usage: string | true | TopLevelSymbol
			) => void;
			export let addVariableUsage: (
				parser: JavascriptParser,
				name: string,
				usage: string | true | TopLevelSymbol
			) => void;
			export let inferDependencyUsage: (state: ParserState) => void;
			export let onUsage: (
				state: ParserState,
				onUsageCallback: (arg0?: boolean | Set<string>) => void
			) => void;
			export let setTopLevelSymbol: (
				state: ParserState,
				symbol: TopLevelSymbol
			) => void;
			export let getTopLevelSymbol: (
				state: ParserState
			) => void | TopLevelSymbol;
			export let tagTopLevelSymbol: (
				parser: JavascriptParser,
				name: string
			) => TopLevelSymbol;
			export let isDependencyUsedByExports: (
				dependency: Dependency,
				usedByExports: boolean | Set<string>,
				moduleGraph: ModuleGraph,
				runtime: RuntimeSpec
			) => boolean;
			export let getDependencyUsedByExportsCondition: (
				dependency: Dependency,
				usedByExports: boolean | Set<string>,
				moduleGraph: ModuleGraph
			) =>
				| null
				| false
				| ((arg0: ModuleGraphConnection, arg1: RuntimeSpec) => ConnectionState);
			export { TopLevelSymbol, topLevelSymbolTag };
		}
		export {
			AggressiveMergingPlugin,
			AggressiveSplittingPlugin,
			LimitChunkCountPlugin,
			MinChunkSizePlugin,
			ModuleConcatenationPlugin,
			RealContentHashPlugin,
			RuntimeChunkPlugin,
			SideEffectsFlagPlugin,
			SplitChunksPlugin
		};
	}
	export namespace runtime {
		export { GetChunkFilenameRuntimeModule, LoadScriptRuntimeModule };
	}
	export namespace prefetch {
		export { ChunkPrefetchPreloadPlugin };
	}
	export namespace web {
		export {
			FetchCompileAsyncWasmPlugin,
			FetchCompileWasmPlugin,
			JsonpChunkLoadingRuntimeModule,
			JsonpTemplatePlugin
		};
	}
	export namespace webworker {
		export { WebWorkerTemplatePlugin };
	}
	export namespace node {
		export {
			NodeEnvironmentPlugin,
			NodeSourcePlugin,
			NodeTargetPlugin,
			NodeTemplatePlugin,
			ReadFileCompileWasmPlugin
		};
	}
	export namespace electron {
		export { ElectronTargetPlugin };
	}
	export namespace wasm {
		export { AsyncWebAssemblyModulesPlugin };
	}
	export namespace library {
		export { AbstractLibraryPlugin, EnableLibraryPlugin };
	}
	export namespace container {
		export const scope: <T>(
			scope: string,
			options: ContainerOptionsFormat<T>
		) => Record<string, string | string[] | T>;
		export {
			ContainerPlugin,
			ContainerReferencePlugin,
			ModuleFederationPlugin
		};
	}
	export namespace sharing {
		export const scope: <T>(
			scope: string,
			options: ContainerOptionsFormat<T>
		) => Record<string, string | string[] | T>;
		export { ConsumeSharedPlugin, ProvideSharedPlugin, SharePlugin };
	}
	export namespace debug {
		export { ProfilingPlugin };
	}
	export namespace util {
		export const createHash: (algorithm: string | typeof Hash) => Hash;
		export namespace comparators {
			export let compareChunksById: (a: Chunk, b: Chunk) => 0 | 1 | -1;
			export let compareModulesByIdentifier: (
				a: Module,
				b: Module
			) => 0 | 1 | -1;
			export let compareModulesById: ParameterizedComparator<
				ChunkGraph,
				Module
			>;
			export let compareNumbers: (a: number, b: number) => 0 | 1 | -1;
			export let compareStringsNumeric: (a: string, b: string) => 0 | 1 | -1;
			export let compareModulesByPostOrderIndexOrIdentifier: ParameterizedComparator<
				ModuleGraph,
				Module
			>;
			export let compareModulesByPreOrderIndexOrIdentifier: ParameterizedComparator<
				ModuleGraph,
				Module
			>;
			export let compareModulesByIdOrIdentifier: ParameterizedComparator<
				ChunkGraph,
				Module
			>;
			export let compareChunks: ParameterizedComparator<ChunkGraph, Chunk>;
			export let compareIds: (
				a: string | number,
				b: string | number
			) => 0 | 1 | -1;
			export let compareStrings: (a: string, b: string) => 0 | 1 | -1;
			export let compareChunkGroupsByIndex: (
				a: ChunkGroup,
				b: ChunkGroup
			) => 0 | 1 | -1;
			export let concatComparators: <T>(
				c1: Comparator<T>,
				c2: Comparator<T>,
				...cRest: Comparator<T>[]
			) => Comparator<T>;
			export let compareSelect: <T, R>(
				getter: Selector<T, R>,
				comparator: Comparator<R>
			) => Comparator<T>;
			export let compareIterables: <T>(
				elementComparator: Comparator<T>
			) => Comparator<Iterable<T>>;
			export let keepOriginalOrder: <T>(iterable: Iterable<T>) => Comparator<T>;
			export let compareChunksNatural: (
				chunkGraph: ChunkGraph
			) => Comparator<Chunk>;
			export let compareLocations: (
				a: DependencyLocation,
				b: DependencyLocation
			) => 0 | 1 | -1;
		}
		export namespace runtime {
			export let getEntryRuntime: (
				compilation: Compilation,
				name: string,
				options?: EntryOptions
			) => RuntimeSpec;
			export let forEachRuntime: (
				runtime: RuntimeSpec,
				fn: (arg0: string) => void,
				deterministicOrder?: boolean
			) => void;
			export let getRuntimeKey: (runtime: RuntimeSpec) => string;
			export let keyToRuntime: (key: string) => RuntimeSpec;
			export let runtimeToString: (runtime: RuntimeSpec) => string;
			export let runtimeConditionToString: (
				runtimeCondition: RuntimeCondition
			) => string;
			export let runtimeEqual: (a: RuntimeSpec, b: RuntimeSpec) => boolean;
			export let compareRuntime: (a: RuntimeSpec, b: RuntimeSpec) => 0 | 1 | -1;
			export let mergeRuntime: (a: RuntimeSpec, b: RuntimeSpec) => RuntimeSpec;
			export let mergeRuntimeCondition: (
				a: RuntimeCondition,
				b: RuntimeCondition,
				runtime: RuntimeSpec
			) => RuntimeCondition;
			export let mergeRuntimeConditionNonFalse: (
				a: undefined | string | true | SortableSet<string>,
				b: undefined | string | true | SortableSet<string>,
				runtime: RuntimeSpec
			) => undefined | string | true | SortableSet<string>;
			export let mergeRuntimeOwned: (
				a: RuntimeSpec,
				b: RuntimeSpec
			) => RuntimeSpec;
			export let intersectRuntime: (
				a: RuntimeSpec,
				b: RuntimeSpec
			) => RuntimeSpec;
			export let subtractRuntime: (
				a: RuntimeSpec,
				b: RuntimeSpec
			) => RuntimeSpec;
			export let subtractRuntimeCondition: (
				a: RuntimeCondition,
				b: RuntimeCondition,
				runtime: RuntimeSpec
			) => RuntimeCondition;
			export let filterRuntime: (
				runtime: RuntimeSpec,
				filter: (arg0: RuntimeSpec) => boolean
			) => undefined | string | boolean | SortableSet<string>;
			export { RuntimeSpecMap, RuntimeSpecSet };
		}
		export namespace serialization {
			export const register: (
				Constructor: Constructor,
				request: string,
				name: string,
				serializer: ObjectSerializer
			) => void;
			export const registerLoader: (
				regExp: RegExp,
				loader: (arg0: string) => boolean
			) => void;
			export const registerNotSerializable: (Constructor: Constructor) => void;
			export const NOT_SERIALIZABLE: object;
			export const buffersSerializer: Serializer;
			export let createFileSerializer: (
				fs?: any,
				hashFunction?: any
			) => Serializer;
			export { MEASURE_START_OPERATION, MEASURE_END_OPERATION };
		}
		export const cleverMerge: <T, O>(first: T, second: O) => T | O | (T & O);
		export { LazySet };
	}
	export namespace sources {
		export {
			Source,
			RawSource,
			OriginalSource,
			ReplaceSource,
			SourceMapSource,
			ConcatSource,
			PrefixSource,
			CachedSource,
			SizeOnlySource,
			CompatSource
		};
	}
	export namespace experiments {
		export namespace schemes {
			export { HttpUriPlugin };
		}
		export namespace ids {
			export { SyncModuleIdsPlugin };
		}
	}
	export type WebpackPluginFunction = (
		this: Compiler,
		compiler: Compiler
	) => void;
	export {
		AutomaticPrefetchPlugin,
		AsyncDependenciesBlock,
		BannerPlugin,
		Cache,
		Chunk,
		ChunkGraph,
		CleanPlugin,
		Compilation,
		Compiler,
		ConcatenationScope,
		ContextExclusionPlugin,
		ContextReplacementPlugin,
		DefinePlugin,
		DelegatedPlugin,
		Dependency,
		DllPlugin,
		DllReferencePlugin,
		DynamicEntryPlugin,
		EntryOptionPlugin,
		EntryPlugin,
		EnvironmentPlugin,
		EvalDevToolModulePlugin,
		EvalSourceMapDevToolPlugin,
		ExternalModule,
		ExternalsPlugin,
		Generator,
		HotUpdateChunk,
		HotModuleReplacementPlugin,
		IgnorePlugin,
		JavascriptModulesPlugin,
		LibManifestPlugin,
		LibraryTemplatePlugin,
		LoaderOptionsPlugin,
		LoaderTargetPlugin,
		Module,
		ModuleGraph,
		ModuleGraphConnection,
		NoEmitOnErrorsPlugin,
		NormalModule,
		NormalModuleReplacementPlugin,
		MultiCompiler,
		Parser,
		PrefetchPlugin,
		ProgressPlugin,
		ProvidePlugin,
		RuntimeModule,
		EntryPlugin as SingleEntryPlugin,
		SourceMapDevToolPlugin,
		Stats,
		Template,
		WatchIgnorePlugin,
		WebpackError,
		WebpackOptionsApply,
		WebpackOptionsDefaulter,
		ValidationError as WebpackOptionsValidationError,
		ValidationError,
		Entry,
		EntryNormalized,
		EntryObject,
		FileCacheOptions,
		LibraryOptions,
		ModuleOptions,
		ResolveOptionsWebpackOptions as ResolveOptions,
		RuleSetCondition,
		RuleSetConditionAbsolute,
		RuleSetRule,
		RuleSetUse,
		RuleSetUseItem,
		StatsOptions,
		Configuration,
		WebpackOptionsNormalized,
		WebpackPluginInstance,
		Asset,
		AssetInfo,
		EntryOptions,
		AssetEmittedInfo,
		MultiStats,
		ParserState,
		ResolvePluginInstance,
		Resolver,
		Watching,
		Argument,
		Problem,
		StatsAsset,
		StatsChunk,
		StatsChunkGroup,
		StatsChunkOrigin,
		StatsCompilation,
		StatsError,
		StatsLogging,
		StatsLoggingEntry,
		StatsModule,
		StatsModuleIssuer,
		StatsModuleReason,
		StatsModuleTraceDependency,
		StatsModuleTraceItem,
		StatsProfile,
		LoaderModule,
		RawLoaderDefinition,
		LoaderDefinition,
		LoaderDefinitionFunction,
		PitchLoaderDefinitionFunction,
		RawLoaderDefinitionFunction,
		LoaderContext
	};
}
declare const topLevelSymbolTag: unique symbol;

export = exports;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          const Range = require('../classes/range.js')
const Comparator = require('../classes/comparator.js')
const { ANY } = Comparator
const satisfies = require('../functions/satisfies.js')
const compare = require('../functions/compare.js')

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub)
        continue OUTER
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull)
      return false
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true
    else if (options.includePrerelease)
      sub = [ new Comparator('>=0.0.0-0') ]
    else
      sub = [ new Comparator('>=0.0.0') ]
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true
    else
      dom = [ new Comparator('>=0.0.0') ]
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=')
      gt = higherGT(gt, c, options)
    else if (c.operator === '<' || c.operator === '<=')
      lt = lowerLT(lt, c, options)
    else
      eqSet.add(c.semver)
  }

  if (eqSet.size > 1)
    return null

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0)
      return null
    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))
      return null
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options))
      return null

    if (lt && !satisfies(eq, String(lt), options))
      return null

    for (const c of dom) {
      if (!satisfies(eq, String(c), options))
        return false
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt)
          return false
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))
        return false
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt)
          return false
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))
        return false
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0)
      return false
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0)
    return false

  if (lt && hasDomGT && !gt && gtltComp !== 0)
    return false

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre)
    return false

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a)
    return b
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        * {
  margin: 0;
  padding: 0;
  outline: 0;
}

body {
  padding: 80px 100px;
  font: 13px "Helvetica Neue", "Lucida Grande", "Arial";
  background: #ECE9E9 -webkit-gradient(linear, 0% 0%, 0% 100%, from(#fff), to(#ECE9E9));
  background: #ECE9E9 -moz-linear-gradient(top, #fff, #ECE9E9);
  background-repeat: no-repeat;
  color: #555;
  -webkit-font-smoothing: antialiased;
}
h1, h2, h3 {
  font-size: 22px;
  color: #343434;
}
h1 em, h2 em {
  padding: 0 5px;
  font-weight: normal;
}
h1 {
  font-size: 60px;
}
h2 {
  margin-top: 10px;
}
h3 {
  margin: 5px 0 10px 0;
  padding-bottom: 5px;
  border-bottom: 1px solid #eee;
  font-size: 18px;
}
ul li {
  list-style: none;
}
ul li:hover {
  cursor: pointer;
  color: #2e2e2e;
}
ul li .path {
  padding-left: 5px;
  font-weight: bold;
}
ul li .line {
  padding-right: 5px;
  font-style: italic;
}
ul li:first-child .path {
  padding-left: 0;
}
p {
  line-height: 1.5;
}
a {
  color: #555;
  text-decoration: none;
}
a:hover {
  color: #303030;
}
#stacktrace {
  margin-top: 15px;
}
.directory h1 {
  margin-bottom: 15px;
  font-size: 18px;
}
ul#files {
  width: 100%;
  height: 100%;
  overflow: hidden;
}
ul#files li {
  float: left;
  width: 30%;
  line-height: 25px;
  margin: 1px;
}
ul#files li a {
  display: block;
  height: 25px;
  border: 1px solid transparent;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
  overflow: hidden;
  white-space: nowrap;
}
ul#files li a:focus,
ul#files li a:hover {
  background: rgba(255,255,255,0.65);
  border: 1px solid #ececec;
}
ul#files li a.highlight {
  -webkit-transition: background .4s ease-in-out;
  background: #ffff4f;
  border-color: #E9DC51;
}
#search {
  display: block;
  position: fixed;
  top: 20px;
  right: 20px;
  width: 90px;
  -webkit-transition: width ease 0.2s, opacity ease 0.4s;
  -moz-transition: width ease 0.2s, opacity ease 0.4s;
  -webkit-border-radius: 32px;
  -moz-border-radius: 32px;
  -webkit-box-shadow: inset 0px 0px 3px rgba(0, 0, 0, 0.25), inset 0px 1px 3px rgba(0, 0, 0, 0.7), 0px 1px 0px rgba(255, 255, 255, 0.03);
  -moz-box-shadow: inset 0px 0px 3px rgba(0, 0, 0, 0.25), inset 0px 1px 3px rgba(0, 0, 0, 0.7), 0px 1px 0px rgba(255, 255, 255, 0.03);
  -webkit-font-smoothing: antialiased;
  text-align: left;
  font: 13px "Helvetica Neue", Arial, sans-serif;
  padding: 4px 10px;
  border: none;
  background: transparent;
  margin-bottom: 0;
  outline: none;
  opacity: 0.7;
  color: #888;
}
#search:focus {
  width: 120px;
  opacity: 1.0; 
}

/*views*/
#files span {
  display: inline-block;
  overflow: hidden;
  text-overflow: ellipsis;
  text-indent: 10px;
}
#files .name {
  background-repeat: no-repeat;
}
#files .icon .name {
  text-indent: 28px;
}

/*tiles*/
.view-tiles .name {
  width: 100%;
  background-position: 8px 5px;
}
.view-tiles .size,
.view-tiles .date {
  display: none;
}

/*details*/
ul#files.view-details li {
  float: none;
  display: block;
  width: 90%;
}
ul#files.view-details li.header {
  height: 25px;
  background: #000;
  color: #fff;
  font-weight: bold;
}
.view-details .header {
  border-radius: 5px;
}
.view-details .name {
  width: 60%;
  background-position: 8px 5px;
}
.view-details .size {
  width: 10%;
}
.view-details .date {
  width: 30%;
}
.view-details .size,
.view-details .date {
  text-align: right;
  direction: rtl;
}

/*mobile*/
@media (max-width: 768px) {
  body {
    font-size: 13px;
    line-height: 16px;
    padding: 0;
  }
  #search {
    position: static;
    width: 100%;
    font-size: 2em;
    line-height: 1.8em;
    text-indent: 10px;
    border: 0;
    border-radius: 0;
    padding: 10px 0;
    margin: 0;
  }
  #search:focus {
    width: 100%;
    border: 0;
    opacity: 1;
  }
  .directory h1 {
    font-size: 2em;
    line-height: 1.5em;
    color: #fff;
    background: #000;
    padding: 15px 10px;
    margin: 0;
  }
  ul#files {
    border-top: 1px solid #cacaca;
  }
  ul#files li {
    float: none;
    width: auto !important;
    display: block;
    border-bottom: 1px solid #cacaca;
    font-size: 2em;
    line-height: 1.2em;
    text-indent: 0;
    margin: 0;
  }
  ul#files li:nth-child(odd) {
    background: #e0e0e0;
  }
  ul#files li a {
    height: auto;
    border: 0;
    border-radius: 0;
    padding: 15px 10px;
  }
  ul#files li a:focus,
  ul#files li a:hover {
    border: 0;
  }
  #files .header,
  #files .size,
  #files .date {
    display: none !important;
  }
  #files .name {
    float: none;
    display: inline-block;
    width: 100%;
    text-indent: 0;
    background-position: 0 50%;
  }
  #files .icon .name {
    text-indent: 41px;
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              'use strict';

var test = require('tape');

var getSideChannel = require('../');

test('export', function (t) {
	t.equal(typeof getSideChannel, 'function', 'is a function');
	t.equal(getSideChannel.length, 0, 'takes no arguments');

	var channel = getSideChannel();
	t.ok(channel, 'is truthy');
	t.equal(typeof channel, 'object', 'is an object');

	t.end();
});

test('assert', function (t) {
	var channel = getSideChannel();
	t['throws'](
		function () { channel.assert({}); },
		TypeError,
		'nonexistent value throws'
	);

	var o = {};
	channel.set(o, 'data');
	t.doesNotThrow(function () { channel.assert(o); }, 'existent value noops');

	t.end();
});

test('has', function (t) {
	var channel = getSideChannel();
	var o = [];

	t.equal(channel.has(o), false, 'nonexistent value yields false');

	channel.set(o, 'foo');
	t.equal(channel.has(o), true, 'existent value yields true');

	t.end();
});

test('get', function (t) {
	var channel = getSideChannel();
	var o = {};
	t.equal(channel.get(o), undefined, 'nonexistent value yields undefined');

	var data = {};
	channel.set(o, data);
	t.equal(channel.get(o), data, '"get" yields data set by "set"');

	t.end();
});

test('set', function (t) {
	var channel = getSideChannel();
	var o = function () {};
	t.equal(channel.get(o), undefined, 'value not set');

	channel.set(o, 42);
	t.equal(channel.get(o), 42, 'value was set');

	channel.set(o, Infinity);
	t.equal(channel.get(o), Infinity, 'value was set again');

	var o2 = {};
	channel.set(o2, 17);
	t.equal(channel.get(o), Infinity, 'o is not modified');
	t.equal(channel.get(o2), 17, 'o2 is set');

	channel.set(o, 14);
	t.equal(channel.get(o), 14, 'o is modified');
	t.equal(channel.get(o2), 17, 'o2 is not modified');

	t.end();
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
/**
 * Error strings
 */
const ERRORS = {
    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',
    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',
    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',
    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',
    INVALID_OFFSET: 'An invalid offset value was provided.',
    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',
    INVALID_LENGTH: 'An invalid length value was provided.',
    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',
    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',
    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',
    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',
    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'
};
exports.ERRORS = ERRORS;
/**
 * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)
 *
 * @param { String } encoding The encoding string to check.
 */
function checkEncoding(encoding) {
    if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
    }
}
exports.checkEncoding = checkEncoding;
/**
 * Checks if a given number is a finite integer. (Throws an exception if check fails)
 *
 * @param { Number } value The number value to check.
 */
function isFiniteInteger(value) {
    return typeof value === 'number' && isFinite(value) && isInteger(value);
}
exports.isFiniteInteger = isFiniteInteger;
/**
 * Checks if an offset/length value is valid. (Throws an exception if check fails)
 *
 * @param value The value to check.
 * @param offset True if checking an offset, false if checking a length.
 */
function checkOffsetOrLengthValue(value, offset) {
    if (typeof value === 'number') {
        // Check for non finite/non integers
        if (!isFiniteInteger(value) || value < 0) {
            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
    }
    else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
    }
}
/**
 * Checks if a length value is valid. (Throws an exception if check fails)
 *
 * @param { Number } length The value to check.
 */
function checkLengthValue(length) {
    checkOffsetOrLengthValue(length, false);
}
exports.checkLengthValue = checkLengthValue;
/**
 * Checks if a offset value is valid. (Throws an exception if check fails)
 *
 * @param { Number } offset The value to check.
 */
function checkOffsetValue(offset) {
    checkOffsetOrLengthValue(offset, true);
}
exports.checkOffsetValue = checkOffsetValue;
/**
 * Checks if a target offset value is out of bounds. (Throws an exception if check fails)
 *
 * @param { Number } offset The offset value to check.
 * @param { SmartBuffer } buff The SmartBuffer instance to check against.
 */
function checkTargetOffset(offset, buff) {
    if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
    }
}
exports.checkTargetOffset = checkTargetOffset;
/**
 * Determines whether a given number is a integer.
 * @param value The number to check.
 */
function isInteger(value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
}
/**
 * Throws if Node.js version is too low to support bigint
 */
function bigIntAndBufferInt64Check(bufferMethod) {
    if (typeof BigInt === 'undefined') {
        throw new Error('Platform does not support JS BigInt type.');
    }
    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
    }
}
exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
//# sourceMappingURL=utils.js.map                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               {"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":";;AACA,mCAAgC;AAEhC;;GAEG;AACH,MAAM,MAAM,GAAG;IACb,gBAAgB,EAAE,kGAAkG;IACpH,wBAAwB,EAAE,wEAAwE;IAClG,0BAA0B,EAAE,gDAAgD;IAC5E,0BAA0B,EAAE,2FAA2F;IACvH,cAAc,EAAE,uCAAuC;IACvD,yBAAyB,EAAE,oEAAoE;IAC/F,cAAc,EAAE,uCAAuC;IACvD,yBAAyB,EAAE,oEAAoE;IAC/F,qBAAqB,EAAE,sEAAsE;IAC7F,qBAAqB,EAAE,yFAAyF;IAChH,0BAA0B,EAAE,0DAA0D;IACtF,2BAA2B,EAAE,2DAA2D;CACzF,CAAC;AAuGA,wBAAM;AArGR;;;;GAIG;AACH,SAAS,aAAa,CAAC,QAAwB;IAC7C,IAAI,CAAC,eAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;QAChC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;KAC1C;AACH,CAAC;AA4F0B,sCAAa;AA1FxC;;;;GAIG;AACH,SAAS,eAAe,CAAC,KAAa;IACpC,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,SAAS,CAAC,KAAK,CAAC,CAAC;AAC1E,CAAC;AAmFS,0CAAe;AAjFzB;;;;;GAKG;AACH,SAAS,wBAAwB,CAAC,KAAU,EAAE,MAAe;IAC3D,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,oCAAoC;QACpC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE;YACxC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;SACzE;KACF;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,yBAAyB,CAAC,CAAC,CAAC,MAAM,CAAC,yBAAyB,CAAC,CAAC;KAC/F;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,gBAAgB,CAAC,MAAW;IACnC,wBAAwB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;AAC1C,CAAC;AA0DC,4CAAgB;AAxDlB;;;;GAIG;AACH,SAAS,gBAAgB,CAAC,MAAW;IACnC,wBAAwB,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;AACzC,CAAC;AAgDyC,4CAAgB;AA9C1D;;;;;GAKG;AACH,SAAS,iBAAiB,CAAC,MAAc,EAAE,IAAiB;IAC1D,IAAI,MAAM,GAAG,CAAC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE;QACtC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,qBAAqB,CAAC,CAAC;KAC/C;AACH,CAAC;AAqCmB,8CAAiB;AAnCrC;;;GAGG;AACH,SAAS,SAAS,CAAC,KAAa;IAC9B,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,KAAK,CAAC;AACrF,CAAC;AAcD;;GAEG;AACH,SAAS,yBAAyB,CAAC,YAA0B;IAC3D,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;QACjC,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;KAC9D;IAED,IAAI,OAAO,eAAM,CAAC,SAAS,CAAC,YAAY,CAAC,KAAK,WAAW,EAAE;QACzD,MAAM,IAAI,KAAK,CAAC,8CAA8C,YAAY,GAAG,CAAC,CAAC;KAChF;AACH,CAAC;AAIsC,8DAAyB"}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        # Change Log
## 4.1.0
> Released 07/24/2019
* Adds int64 support for node v12+
* Drops support for node v4

## 4.0
> Released 10/21/2017
* Major breaking changes arriving in v4.

### New Features
* Ability to read data from a specific offset. ex: readInt8(5)
* Ability to write over data when an offset is given (see breaking changes) ex:  writeInt8(5, 0);
* Ability to set internal read and write offsets.



### Breaking Changes

* Old constructor patterns have been completely removed. It's now required to use the SmartBuffer.fromXXX() factory constructors. Read more on the v4 docs.
* rewind(), skip(), moveTo() have been removed.
* Internal private properties are now prefixed with underscores (_).
* **All** writeXXX() methods that are given an offset will now **overwrite data** instead of insert
* insertXXX() methods have been added for when you want to insert data at a specific offset (this replaces the old behavior of writeXXX() when an offset was provided)


### Other Changes
* Standardizd error messaging
* Standardized offset/length bounds and sanity checking
* General overall cleanup of code.

## 3.0.3
> Released 02/19/2017
* Adds missing type definitions for some internal functions.

## 3.0.2
> Released 02/17/2017

### Bug Fixes
* Fixes a bug where using readString with a length of zero resulted in reading the remaining data instead of returning an empty string. (Fixed by Seldszar)

## 3.0.1
> Released 02/15/2017

### Bug Fixes
* Fixes a bug leftover from the TypeScript refactor where .readIntXXX() resulted in .readUIntXXX() being called by mistake.

## 3.0
> Released 02/12/2017

### Bug Fixes
* readUIntXXXX() methods will now throw an exception if they attempt to read beyond the bounds of the valid buffer data available.
    * **Note** This is technically a breaking change, so version is bumped to 3.x.

## 2.0
> Relased 01/30/2017

### New Features:

* Entire package re-written in TypeScript (2.1)
* Backwards compatibility is preserved for now
* New factory methods for creating SmartBuffer instances
    * SmartBuffer.fromSize()
    * SmartBuffer.fromBuffer()
    * SmartBuffer.fromOptions()
* New SmartBufferOptions constructor options
* Added additional tests

### Bug Fixes:
* Fixes a bug where reading null terminated strings may result in an exception.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /// <reference types="node" />
import { SmartBuffer } from './smartbuffer';
import { Buffer } from 'buffer';
/**
 * Error strings
 */
declare const ERRORS: {
    INVALID_ENCODING: string;
    INVALID_SMARTBUFFER_SIZE: string;
    INVALID_SMARTBUFFER_BUFFER: string;
    INVALID_SMARTBUFFER_OBJECT: string;
    INVALID_OFFSET: string;
    INVALID_OFFSET_NON_NUMBER: string;
    INVALID_LENGTH: string;
    INVALID_LENGTH_NON_NUMBER: string;
    INVALID_TARGET_OFFSET: string;
    INVALID_TARGET_LENGTH: string;
    INVALID_READ_BEYOND_BOUNDS: string;
    INVALID_WRITE_BEYOND_BOUNDS: string;
};
/**
 * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)
 *
 * @param { String } encoding The encoding string to check.
 */
declare function checkEncoding(encoding: BufferEncoding): void;
/**
 * Checks if a given number is a finite integer. (Throws an exception if check fails)
 *
 * @param { Number } value The number value to check.
 */
declare function isFiniteInteger(value: number): boolean;
/**
 * Checks if a length value is valid. (Throws an exception if check fails)
 *
 * @param { Number } length The value to check.
 */
declare function checkLengthValue(length: any): void;
/**
 * Checks if a offset value is valid. (Throws an exception if check fails)
 *
 * @param { Number } offset The value to check.
 */
declare function checkOffsetValue(offset: any): void;
/**
 * Checks if a target offset value is out of bounds. (Throws an exception if check fails)
 *
 * @param { Number } offset The offset value to check.
 * @param { SmartBuffer } buff The SmartBuffer instance to check against.
 */
declare function checkTargetOffset(offset: number, buff: SmartBuffer): void;
interface Buffer {
    readBigInt64BE(offset?: number): bigint;
    readBigInt64LE(offset?: number): bigint;
    readBigUInt64BE(offset?: number): bigint;
    readBigUInt64LE(offset?: number): bigint;
    writeBigInt64BE(value: bigint, offset?: number): number;
    writeBigInt64LE(value: bigint, offset?: number): number;
    writeBigUInt64BE(value: bigint, offset?: number): number;
    writeBigUInt64LE(value: bigint, offset?: number): number;
}
/**
 * Throws if Node.js version is too low to support bigint
 */
declare function bigIntAndBufferInt64Check(bufferMethod: keyof Buffer): void;
export { ERRORS, isFiniteInteger, checkEncoding, checkOffsetValue, checkLengthValue, checkTargetOffset, bigIntAndBufferInt64Check };
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      P                j   ?Jv              < R E A D M E . m d   P              P j   ?Jv                < R E A D M E . m d   P               j   ?Jv               < R E A D M E . m d   x          "     j   fJv              : < p l u g i n - t r a n s f o r m - s t i c k y - r e g e x   x          "    hj   fJv             : < p l u g i n - t r a n s f o r m - s t i c k y - r e g e x   P              j   fJv                < L I C E N S E       P              0j   fJv               < L I C E N S E       P              j   fJv              < L I C E N S E       P              j   fJv                < L I C E N S E       P               j   fJv               < L I C E N S E       X              pj   Jv                < p a c k a g e . j s o n     X              j   Jv               < p a c k a g e . j s o n     X               j   Jv              < p a c k a g e . j s o n     X              xj   Jv                < p a c k a g e . j s o n     X              j   Jv               < p a c k a g e . j s o n     P              (j   Jv                < R E A D M E . m d   P              xj   Jv               < R E A D M E . m d   P              j   Jv              < R E A D M E . m d   P              j   Jv                < R E A D M E . m d   P              hj   Jv               < R E A D M E . m d             "    j   Kv              D < p l u g i n - t r a n s f o r m - t e m p l a t e - l i t e r a l s           "    8j   Kv             D < p l u g i n - t r a n s f o r m - t e m p l a t e - l i t e r a l s P              j   Kv                < L I C E N S E       P              j   Kv               < L I C E N S E       P              Xj   Kv              < L I C E N S E       P              j   Kv                < L I C E N S E       P              j   Kv               < L I C E N S E       X              H	j   )Kv                < p a c k a g e . j s o n     X              	j   )Kv               < p a c k a g e . j s o n     X              	j   )Kv              < p a c k a g e . j s o n     X              P
j   )Kv                < p a c k a g e . j s o n     X              
j   )Kv               < p a c k a g e . j s o n     P               j   zPKv                < R E A D M E . m d   P              Pj   zPKv               < R E A D M E . m d   P              j   lwKv              < R E A D M E . m d   P              j   lwKv                < R E A D M E . m d   P              @j   lwKv               < R E A D M E . m d   x          "    j   lwKv              < < p l u g i n - t r a n s f o r m - t y p e o f - s y m b o l x          "    j   lwKv             < < p l u g i n - t r a n s f o r m - t y p e o f - s y m b o l P              j   bKv                < L I C E N S E       P              j   bKv               < L I C E N S E       P               j   bKv              < L I C E N S E       P              pj   bKv                < L I C E N S E       P              j   bKv               < L I C E N S E       X              j   XKv                < p a c k a g e . j s o n     X              hj   XKv               < p a c k a g e . j s o n                                                                     X               j   XKv              < p a c k a g e . j s o n     X              Xj   XKv                < p a c k a g e . j s o n     X              j   XKv               < p a c k a g e . j s o n     P              j   WKv                < R E A D M E . m d   P              Xj   ALv               < R E A D M E . m d   P              j   ALv              < R E A D M E . m d   P              j   ALv                < R E A D M E . m d   P              Hj   ALv               < R E A D M E . m d             "    j   4:Lv              @ < p l u g i n - t r a n s f o r m - u n i c o d e - e s c a p e s               "    j   4:Lv             @ < p l u g i n - t r a n s f o r m - u n i c o d e - e s c a p e s     P              j   4:Lv                < L I C E N S E       P              j   0aLv               < L I C E N S E       P              8j   0aLv              < L I C E N S E       P              j   0aLv                < L I C E N S E       P              j   0aLv               < L I C E N S E       X              (j   'Lv                < p a c k a g e . j s o n     X              j   'Lv               < p a c k a g e . j s o n     X              j   'Lv              < p a c k a g e . j s o n     X              0j   'Lv                < p a c k a g e . j s o n     X              j   'Lv               < p a c k a g e . j s o n     P              j   Lv                < R E A D M E . m d   P              0j   Lv               < R E A D M E . m d   P              j   Lv              < R E A D M E . m d   P              j   Lv                < R E A D M E . m d   P               j   Lv               < R E A D M E . m d   x          "    pj   Lv              < < p l u g i n - t r a n s f o r m - u n i c o d e - r e g e x x          "    j   Lv             < < p l u g i n - t r a n s f o r m - u n i c o d e - r e g e x P              `j   Lv                < L I C E N S E       P              j   Lv               < L I C E N S E       P               j   Lv              < L I C E N S E       P              Pj   Lv                < L I C E N S E       P              j   Lv               < L I C E N S E       X              j   Lv                < p a c k a g e . j s o n     X              Hj   Lv               < p a c k a g e . j s o n     X              j   Lv              < p a c k a g e . j s o n     X              j   Lv                < p a c k a g e . j s o n     X              Pj   Lv               < p a c k a g e . j s o n     P              j   #Mv                < R E A D M E . m d   P              j   #Mv               < R E A D M E . m d   P              Hj   JMv              < R E A D M E . m d   P              j   JMv                < R E A D M E . m d   P              j   JMv               < R E A D M E . m d   P          "    8j   JMv               < p r e s e t - e n v P          "    j   qMv              < p r e s e t - e n v P              j   qMv                < L I C E N S E       P              (j   qMv               < L I C E N S E       P              xj   qMv              < L I C E N S E                                                               P                j   qMv                < L I C E N S E       P              P j   qMv               < L I C E N S E       X               j   Mv                < p a c k a g e . j s o n     X               j   Mv               < p a c k a g e . j s o n     X              P!j   Mv              < p a c k a g e . j s o n     X              !j   Mv                < p a c k a g e . j s o n     X               "j   Mv               < p a c k a g e . j s o n     P              X"j   Mv                < R E A D M E . m d   P              "j   Nv               < R E A D M E . m d   P              "j   Nv              < R E A D M E . m d   P              H#j   Nv                < R E A D M E . m d   P              #j   Nv               < R E A D M E . m d   X          "    #j   4Nv               < p r e s e t - m o d u l e s X          "    @$j   4Nv              < p r e s e t - m o d u l e s P              $j   4Nv                < L I C E N S E       P              $j   [Nv               < L I C E N S E       P              8%j   [Nv              < L I C E N S E       P              %j   [Nv                < L I C E N S E       P              %j   [Nv               < L I C E N S E       X              (&j   Nv                < p a c k a g e . j s o n     X              &j   Nv               < p a c k a g e . j s o n     X              &j   Nv              < p a c k a g e . j s o n     X              0'j   Nv                < p a c k a g e . j s o n     X              'j   Nv               < p a c k a g e . j s o n     P              'j   Nv                < R E A D M E . m d   P              0(j   |Nv               < R E A D M E . m d   P              (j   |Nv              < R E A D M E . m d   P              (j   |Nv                < R E A D M E . m d   P               )j   |Nv               < R E A D M E . m d   P          "    p)j   qNv               < r u n t i m e       P          "    )j   qNv              < r u n t i m e       P              *j   qNv                < L I C E N S E       P              `*j   nOv               < L I C E N S E       P              *j   nOv              < L I C E N S E       P               +j   nOv                < L I C E N S E       P              P+j   nOv               < L I C E N S E       X              +j   gEOv                < p a c k a g e . j s o n     X              +j   QlOv               < p a c k a g e . j s o n     X              P,j   QlOv              < p a c k a g e . j s o n     X              ,j   QlOv                < p a c k a g e . j s o n     X               -j   QlOv               < p a c k a g e . j s o n     P              X-j   QOv                < R E A D M E . m d   P              -j   LOv               < R E A D M E . m d   P              -j   LOv              < R E A D M E . m d   P              H.j   LOv                < R E A D M E . m d   P              .j   LOv               < R E A D M E . m d   P          "    .j   LOv               < t e m p l a t e     P          "    8/j   LOv              < t e m p l a t e     P              /j   =Ov                < L I C E N S E                                               P               0j   =Ov               < L I C E N S E       P              P0j   4Pv              < L I C E N S E       P              0j   4Pv                < L I C E N S E       P              0j   4Pv               < L I C E N S E       X              @1j   4Pv                < p a c k a g e . j s o n     X              1j   4Pv               < p a c k a g e . j s o n     X              1j    /Pv              < p a c k a g e . j s o n     X              H2j    /Pv                < p a c k a g e . j s o n     X              2j    /Pv               < p a c k a g e . j s o n     P              2j    /Pv                < R E A D M E . m d   P              H3j   VPv               < R E A D M E . m d   P              3j   VPv              < R E A D M E . m d   P              3j   VPv                < R E A D M E . m d   P              84j   VPv               < R E A D M E . m d   P          "    4j   }Pv               < t r a v e r s e     P          "    4j   }Pv              < t r a v e r s e     P              (5j   Pv                < L I C E N S E       P              x5j   Pv               < L I C E N S E       P              5j   Pv              < L I C E N S E       P              6j   Pv                < L I C E N S E       P              h6j   Pv               < L I C E N S E       X              6j   Pv                < p a c k a g e . j s o n     X              7j   Pv               < p a c k a g e . j s o n     X              h7j   Pv              < p a c k a g e . j s o n     X              7j   Pv                < p a c k a g e . j s o n     X              8j   Pv               < p a c k a g e . j s o n     P              p8j   Pv                < R E A D M E . m d   P              8j   Pv               < R E A D M E . m d   P              9j   Pv              < R E A D M E . m d   P              `9j   Pv                < R E A D M E . m d   P              9j   Pv               < R E A D M E . m d   H          "     :j   Qv              
 < t y p e s   H          "    H:j   Qv             
 < t y p e s   P              :j   Qv                < L I C E N S E       P              :j   Qv               < L I C E N S E       P              0;j   ?Qv              < L I C E N S E       P              ;j   ?Qv                < L I C E N S E       P              ;j   ?Qv               < L I C E N S E       X               <j   ?Qv                < p a c k a g e . j s o n     X              x<j   ?Qv               < p a c k a g e . j s o n     X              <j   ?Qv              < p a c k a g e . j s o n     X              (=j   fQv                < p a c k a g e . j s o n     X              =j   fQv               < p a c k a g e . j s o n     P              =j   Qv                < R E A D M E . m d   P              (>j   Qv               < R E A D M E . m d   P              x>j   Qv              < R E A D M E . m d   P              >j   Qv                < R E A D M E . m d   P              ?j   Qv               < R E A D M E . m d   P              h?j   Qv               < @ c o l o r s                                                                               P               @j   Qv              < @ c o l o r s       H              P@j   Qv               < c o l o r s H              @j   Qv              < c o l o r s P              @j   Qv                < i n d e x . d . t s P              0Aj   Qv               < i n d e x . d . t s P              Aj   Qv              < i n d e x . d . t s P              Aj   Qv                < i n d e x . d . t s P               Bj   Qv               < i n d e x . d . t s P              pBj   Rv                < L I C E N S E       P              Bj   Rv               < L I C E N S E       P              Cj   Rv              < L I C E N S E       P              `Cj   Rv                < L I C E N S E       P              Cj   Rv               < L I C E N S E       X               Dj   )Rv                < p a c k a g e . j s o n     X              XDj   )Rv               < p a c k a g e . j s o n     X              Dj   )Rv              < p a c k a g e . j s o n     X              Ej   )Rv                < p a c k a g e . j s o n     X              `Ej   )Rv               < p a c k a g e . j s o n     P              Ej   PRv                < R E A D M E . m d   P              Fj   PRv               < R E A D M E . m d   P              XFj   PRv              < R E A D M E . m d   P              Fj   PRv                < R E A D M E . m d   P              Fj   PRv               < R E A D M E . m d   P              HGj   }Rv                < s a f e . d . t s   P              Gj   }Rv               < s a f e . d . t s   P              Gj   }Rv              < s a f e . d . t s   P              8Hj   }Rv                < s a f e . d . t s   P              Hj   }Rv               < s a f e . d . t s   P              Hj   }Rv                < s a f e . j s       P              (Ij   lRv               < s a f e . j s       P              xIj   lRv              < s a f e . j s       P              Ij   lRv                < s a f e . j s       P              Jj   lRv               < s a f e . j s       P              hJj   eRv               < @ c s s t o o l s   P              Jj   eRv              < @ c s s t o o l s                 Kj   WSv              J < p o s t c s s - p r o g r e s s i v e - c u s t o m - p r o p e r t i e s                 Kj   WSv             J < p o s t c s s - p r o g r e s s i v e - c u s t o m - p r o p e r t i e s   X              Lj   WSv                < C H A N G E L O G . m d     X              pLj   K:Sv               < C H A N G E L O G . m d     X              Lj   K:Sv              < C H A N G E L O G . m d     X               Mj   K:Sv                < C H A N G E L O G . m d     X              xMj   K:Sv               < C H A N G E L O G . m d     P              Mj   AaSv                < L I C E N S E . m d P               Nj   AaSv               < L I C E N S E . m d P              pNj   AaSv              < L I C E N S E . m d P              Nj   AaSv                < L I C E N S E . m d P              Oj   AaSv               < L I C E N S E . m d X              `Oj   5Sv                < p a c k a g e . j s o n                                                                             X               Pj   5Sv               < p a c k a g e . j s o n     X              XPj   5Sv              < p a c k a g e . j s o n     X              Pj   5Sv                < p a c k a g e . j s o n     X              Qj   5Sv               < p a c k a g e . j s o n     P              `Qj   !Sv                < R E A D M E . m d   P              Qj   !Sv               < R E A D M E . m d   P               Rj   !Sv              < R E A D M E . m d   P              PRj   !Sv                < R E A D M E . m d   P              Rj   !Sv               < R E A D M E . m d   h              Rj   Sv              ( < s e l e c t o r - s p e c i f i c i t y     h              XSj   Sv             ( < s e l e c t o r - s p e c i f i c i t y     X              Sj   Sv                < C H A N G E L O G . m d     X              Tj   $Tv               < C H A N G E L O G . m d     X              pTj   $Tv              < C H A N G E L O G . m d     X              Tj   $Tv                < C H A N G E L O G . m d     X               Uj   $Tv               < C H A N G E L O G . m d     P              xUj   KTv                < L I C E N S E . m d P              Uj   qTv               < L I C E N S E . m d P              Vj   qTv              < L I C E N S E . m d P              hVj   qTv                < L I C E N S E . m d P              Vj   qTv               < L I C E N S E . m d X              Wj   Tv                < p a c k a g e . j s o n     X              `Wj   Tv               < p a c k a g e . j s o n     X              Wj   Tv              < p a c k a g e . j s o n     X              Xj   Tv                < p a c k a g e . j s o n     X              hXj   Tv               < p a c k a g e . j s o n     P              Xj   Tv                < R E A D M E . m d   P              Yj   Tv               < R E A D M E . m d   P              `Yj   Tv              < R E A D M E . m d   P              Yj   Tv                < R E A D M E . m d   P               Zj   Tv               < R E A D M E . m d   X              PZj   Tv               < @ d i s c o v e r y j s     X              Zj   Tv              < @ d i s c o v e r y j s     P               [j   Tv               < j s o n - e x t     P              P[j   Tv              < j s o n - e x t     P              [j   Uv                < i n d e x . d . t s P              [j   Uv               < i n d e x . d . t s P              @\j   Uv              < i n d e x . d . t s P              \j   Uv                < i n d e x . d . t s P              \j   Uv               < i n d e x . d . t s P              0]j   4Uv                < L I C E N S E       P              ]j   4Uv               < L I C E N S E       P              ]j   4Uv              < L I C E N S E       P               ^j   4Uv                < L I C E N S E       P              p^j   4Uv               < L I C E N S E       X              ^j   [Uv                < p a c k a g e . j s o n     X              _j   [Uv               < p a c k a g e . j s o n     X              p_j   [Uv              < p a c k a g e . j s o n                                                             X               `j   [Uv                < p a c k a g e . j s o n     X              X`j   Uv               < p a c k a g e . j s o n     P              `j   Uv                < R E A D M E . m d   P               aj   Uv               < R E A D M E . m d   P              Paj   Uv              < R E A D M E . m d   P              aj   Uv                < R E A D M E . m d   P              aj   Uv               < R E A D M E . m d   H              @bj   Uv               < @ g a r     H              bj   Uv              < @ g a r     P              bj   Uv               < p r o m i s i f y   P               cj   Uv              < p r o m i s i f y   P              pcj   Uv                < i n d e x . j s     P              cj   Uv               < i n d e x . j s     P              dj   Uv              < i n d e x . j s     P              `dj   Uv                < i n d e x . j s     P              dj   Uv               < i n d e x . j s     P               ej   ~Vv                < L I C E N S E . m d P              Pej   ~Vv               < L I C E N S E . m d P              ej   ~Vv              < L I C E N S E . m d P              ej   ~Vv                < L I C E N S E . m d P              @fj   ~Vv               < L I C E N S E . m d X              fj   sEVv                < p a c k a g e . j s o n     X              fj   sEVv               < p a c k a g e . j s o n     X              @gj   sEVv              < p a c k a g e . j s o n     X              gj   sEVv                < p a c k a g e . j s o n     X              gj   klVv               < p a c k a g e . j s o n     P              Hhj   klVv                < R E A D M E . m d   P              hj   `Vv               < R E A D M E . m d   P              hj   `Vv              < R E A D M E . m d   P              8ij   `Vv                < R E A D M E . m d   P              ij   `Vv               < R E A D M E . m d   X              ij   VVv               < @ i s t a n b u l j s       X              0jj   VVv              < @ i s t a n b u l j s       `              jj   VVv               < l o a d - n y c - c o n f i g       `              jj   VVv              < l o a d - n y c - c o n f i g       X              Hkj   VVv                < C H A N G E L O G . m d     X              kj   VVv               < C H A N G E L O G . m d     X              kj   KVv              < C H A N G E L O G . m d     X              Plj   KVv                < C H A N G E L O G . m d     X              lj   KVv               < C H A N G E L O G . m d     P               mj   FWv                < i n d e x . j s     P              Pmj   FWv               < i n d e x . j s     P              mj   FWv              < i n d e x . j s     P              mj   FWv                < i n d e x . j s     P              @nj   FWv               < i n d e x . j s     P              nj   }Wv                < L I C E N S E       P              nj   }Wv               < L I C E N S E       P              0oj   Wv              < L I C E N S E       P              oj   Wv                < L I C E N S E                                                       P               pj   Wv               < L I C E N S E       X              Ppj   Wv                < l o a d - e s m . j s       X              pj   Wv               < l o a d - e s m . j s       X               qj   Wv              < l o a d - e s m . j s       X              Xqj   Wv                < l o a d - e s m . j s       X              qj   Wv               < l o a d - e s m . j s       X              rj   Xv                < p a c k a g e . j s o n     X              `rj   Xv               < p a c k a g e . j s o n     X              rj   Xv              < p a c k a g e . j s o n     X              sj   Xv                < p a c k a g e . j s o n     X              hsj   Xv               < p a c k a g e . j s o n     P              sj   ?Xv                < R E A D M E . m d   P              tj   ?Xv               < R E A D M E . m d   P              `tj   fXv              < R E A D M E . m d   P              tj   fXv                < R E A D M E . m d   P               uj   fXv               < R E A D M E . m d   H              Puj   fXv               < s c h e m a H              uj   fXv              < s c h e m a X              uj   fXv                < C H A N G E L O G . m d     X              8vj   Xv               < C H A N G E L O G . m d     X              vj   Xv              < C H A N G E L O G . m d     X              vj   Xv                < C H A N G E L O G . m d     X              @wj   Xv               < C H A N G E L O G . m d     `              wj   Xv               $ < d e f a u l t - e x c l u d e . j s `              wj   Xv              $ < d e f a u l t - e x c l u d e . j s `              Xxj   Xv             $ < d e f a u l t - e x c l u d e . j s `              xj   Xv               $ < d e f a u l t - e x c l u d e . j s `              yj   Xv              $ < d e f a u l t - e x c l u d e . j s h              xyj   Xv               ( < d e f a u l t - e x t e n s i o n . j s     h              yj   Xv              ( < d e f a u l t - e x t e n s i o n . j s     h              Hzj   Yv             ( < d e f a u l t - e x t e n s i o n . j s     h              zj   Yv               ( < d e f a u l t - e x t e n s i o n . j s     h              {j   Yv              ( < d e f a u l t - e x t e n s i o n . j s     P              {j   )Yv                < i n d e x . j s     P              {j   )Yv               < i n d e x . j s     P               |j   )Yv              < i n d e x . j s     P              p|j   )Yv                < i n d e x . j s     P              |j   )Yv               < i n d e x . j s     P              }j   PYv                < L I C E N S E       P              `}j   PYv               < L I C E N S E       P              }j   PYv              < L I C E N S E       P               ~j   wYv                < L I C E N S E       P              P~j   wYv               < L I C E N S E       X              ~j   wYv                < p a c k a g e . j s o n     X              ~j   wYv               < p a c k a g e . j s o n     X              Pj   Yv              < p a c k a g e . j s o n     X              j   Yv                < p a c k a g e . j s o n     X               j   Yv               < p a c k a g e . j s o n     P              Xj   Yv                < R E A D M E . m d   P              j   Yv               < R E A D M E . m d   P              j   Yv              < R E A D M E . m d   P              Hj   Yv                < R E A D M E . m d   P              j   Yv               < R E A D M E . m d   X              j   uYv               < @ j r i d g e w e l l       X              @j   uYv              < @ j r i d g e w e l l       X              j   uYv               < g e n - m a p p i n g       X              j   uYv              < g e n - m a p p i n g       P              Hj   pZv                < L I C E N S E       P              j   pZv               < L I C E N S E       P              j   pZv              < L I C E N S E       P              8j   pZv                < L I C E N S E       P              j   pZv               < L I C E N S E       X              j   b:Zv                < p a c k a g e . j s o n     X              0j   b:Zv               < p a c k a g e . j s o n     X              j   b:Zv              < p a c k a g e . j s o n     X              j   b:Zv                < p a c k a g e . j s o n     X              8j   b:Zv               < p a c k a g e . j s o n     P              j   TaZv                < R E A D M E . m d   P              j   TaZv               < R E A D M E . m d   P              0j   TaZv              < R E A D M E . m d   P              j   TaZv                < R E A D M E . m d   P              j   TaZv               < R E A D M E . m d   X               j   NZv               < r e s o l v e - u r i       X              xj   NZv              < r e s o l v e - u r i       P              j   ;Zv                < L I C E N S E       P               j   ;Zv               < L I C E N S E       P              pj   ;Zv              < L I C E N S E       P              j   ;Zv                < L I C E N S E       P              j   ;Zv               < L I C E N S E       X              `j   4Zv                < p a c k a g e . j s o n     X              j   4Zv               < p a c k a g e . j s o n     X              j   4Zv              < p a c k a g e . j s o n     X              hj   4Zv                < p a c k a g e . j s o n     X              j   -Zv               < p a c k a g e . j s o n     P              j   $[v                < R E A D M E . m d   P              hj   $[v               < R E A D M E . m d   P              j   $[v              < R E A D M E . m d   P              j   $[v                < R E A D M E . m d   P              Xj   $[v               < R E A D M E . m d   P              j   K[v               < s e t - a r r a y   P              j   K[v              < s e t - a r r a y   P              Hj   K[v                < L I C E N S E       P              j   r[v               < L I C E N S E       P              j   r[v              < L I C E N S E       P              8j   r[v                < L I C E N S E       P              j   r[v               < L I C E N S E                                               X               j   [v                < p a c k a g e . j s o n     X              Xj   [v               < p a c k a g e . j s o n     X              j   [v              < p a c k a g e . j s o n     X              j   [v                < p a c k a g e . j s o n     X              `j   [v               < p a c k a g e . j s o n     P              j   [v                < R E A D M E . m d   P              j   [v               < R E A D M E . m d   P              Xj   [v              < R E A D M E . m d   P              j   [v                < R E A D M E . m d   P              j   [v               < R E A D M E . m d   `              Hj   [v               < s o u r c e m a p - c o d e c       `              j   [v              < s o u r c e m a p - c o d e c       P              j   [v                < L I C E N S E       P              Xj   [v               < L I C E N S E       P              j   [v              < L I C E N S E       P              j   [v                < L I C E N S E       P              Hj   [v               < L I C E N S E       X              j   \v                < p a c k a g e . j s o n     X              j   4\v               < p a c k a g e . j s o n     X              Hj   4\v              < p a c k a g e . j s o n     X              j   4\v                < p a c k a g e . j s o n     X              j   4\v               < p a c k a g e . j s o n     P              Pj   [\v                < R E A D M E . m d   P              j   [\v               < R E A D M E . m d   P              j   [\v              < R E A D M E . m d   P              @j   [\v                < R E A D M E . m d   P              j   [\v               < R E A D M E . m d   X              j   \v               < t r a c e - m a p p i n g   X              8j   \v              < t r a c e - m a p p i n g   P              j   \v                < L I C E N S E       P              j   \v               < L I C E N S E       P              0j   \v              < L I C E N S E       P              j   \v                < L I C E N S E       P              j   \v               < L I C E N S E       X               j   ]v                < p a c k a g e . j s o n     X              xj   ]v               < p a c k a g e . j s o n     X              j   ]v              < p a c k a g e . j s o n     X              (j   E]v                < p a c k a g e . j s o n     X              j   E]v               < p a c k a g e . j s o n     P              j   ~l]v                < R E A D M E . m d   P              (j   ~l]v               < R E A D M E . m d   P              xj   ~l]v              < R E A D M E . m d   P              j   ~l]v                < R E A D M E . m d   P              j   ~l]v               < R E A D M E . m d   P              hj   r]v               < @ n g t o o l s     P              j   r]v              < @ n g t o o l s     P              j   r]v               < w e b p a c k       P              Xj   r]v              < w e b p a c k       P               j   r]v                < L I C E N S E               P                j   m]v               < L I C E N S E       P               Pj   m]v              < L I C E N S E       P               j   m]v                < L I C E N S E       P               j   m]v               < L I C E N S E       X              @j   e]v                < p a c k a g e . j s o n     X              j   e]v               < p a c k a g e . j s o n     X              j   e]v              < p a c k a g e . j s o n     X              Hj   e]v                < p a c k a g e . j s o n     X              j   e]v               < p a c k a g e . j s o n     P              j   e]v                < R E A D M E . m d   P              Hj   e]v               < R E A D M E . m d   P              j   d^v              < R E A D M E . m d   P              j   d^v                < R E A D M E . m d   P              8j   d^v               < R E A D M E . m d   P              j   d^v               < @ n o d e l i b     P              j   d^v              < @ n o d e l i b     P              (j   d^v               < f s . s c a n d i r P              xj   d^v              < f s . s c a n d i r P              j   N/^v                < L I C E N S E       P              j   N/^v               < L I C E N S E       P              hj   N/^v              < L I C E N S E       P              j   DV^v                < L I C E N S E       P              j   DV^v               < L I C E N S E       X              Xj   DV^v                < p a c k a g e . j s o n     X              j   DV^v               < p a c k a g e . j s o n     X              j   DV^v              < p a c k a g e . j s o n     X              `j   ;}^v                < p a c k a g e . j s o n     X              j   ;}^v               < p a c k a g e . j s o n     P              j   ;}^v                < R E A D M E . m d   P              `j   *^v               < R E A D M E . m d   P              j   *^v              < R E A D M E . m d   P               j   *^v                < R E A D M E . m d   P              Pj   *^v               < R E A D M E . m d   P              j   *^v               < f s . s t a t       P              j   ^v              < f s . s t a t       P      	        @j   ^v                < L I C E N S E       P      	        j   ^v               < L I C E N S E       P      	        j   ^v              < L I C E N S E       P      	        0j   ^v                < L I C E N S E       P      	        j   ^v               < L I C E N S E       X      
        j   ^v                < p a c k a g e . j s o n     X      
        (j   ^v               < p a c k a g e . j s o n     X      
        j   _v              < p a c k a g e . j s o n     X      
        j   _v                < p a c k a g e . j s o n     X      
        0j   _v               < p a c k a g e . j s o n     P              j   _v                < R E A D M E . m d   P              j   ?_v               < R E A D M E . m d   P              (j   ?_v              < R E A D M E . m d   P              xj   ?_v                < R E A D M E . m d                                                           P               j   ?_v               < R E A D M E . m d   P              Pj   ?_v               < f s . w a l k       P              j   ?_v              < f s . w a l k       P              j   (x_v                < L I C E N S E       P              @j   (x_v               < L I C E N S E       P              j   (x_v              < L I C E N S E       P              j   (x_v                < L I C E N S E       P              0j   (x_v               < L I C E N S E       X              j   _v                < p a c k a g e . j s o n     X              j   _v               < p a c k a g e . j s o n     X              0j   _v              < p a c k a g e . j s o n     X              j   _v                < p a c k a g e . j s o n     X              j   _v               < p a c k a g e . j s o n     P              8j   _v                < R E A D M E . m d   P              j   _v               < R E A D M E . m d   P              j   _v              < R E A D M E . m d   P              (j   _v                < R E A D M E . m d   P              xj   _v               < R E A D M E . m d   P              j   _v               < @ n p m c l i       P              j   _v              < @ n p m c l i       @              hj   _v               < f s @              j   _v              < f s P              j   _v                < L I C E N S E . m d P              8j   `v               < L I C E N S E . m d P              j   `v              < L I C E N S E . m d P              j   `v                < L I C E N S E . m d P              (j   `v               < L I C E N S E . m d X              xj   :`v                < p a c k a g e . j s o n     X              j   :`v               < p a c k a g e . j s o n     X              (j   :`v              < p a c k a g e . j s o n     X              j   :`v                < p a c k a g e . j s o n     X              j   :`v               < p a c k a g e . j s o n     P              0j   a`v                < R E A D M E . m d   P              j   a`v               < R E A D M E . m d   P              j   a`v              < R E A D M E . m d   P               j   a`v                < R E A D M E . m d   P              pj   a`v               < R E A D M E . m d   H              j   x`v               < g i t       H              j   x`v              < g i t       P              Pj   x`v                < L I C E N S E       P              j   n`v               < L I C E N S E       P              j   n`v              < L I C E N S E       P              @j   n`v                < L I C E N S E       P              j   n`v               < L I C E N S E       X              j   m`v                < p a c k a g e . j s o n     X              8j   m`v               < p a c k a g e . j s o n     X              j   m`v              < p a c k a g e . j s o n     X              j   `v                < p a c k a g e . j s o n     X              @j   `v               < p a c k a g e . j s o n     P              j   `v                < R E A D M E . m d                           P               j   O$av               < R E A D M E . m d   P              Pj   O$av              < R E A D M E . m d   P              j   O$av                < R E A D M E . m d   P              j   O$av               < R E A D M E . m d   p              @j   EKav              4 < i n s t a l l e d - p a c k a g e - c o n t e n t s p              j   EKav             4 < i n s t a l l e d - p a c k a g e - c o n t e n t s P               j   EKav                < i n d e x . j s     P              pj   ?rav               < i n d e x . j s     P              j   ?rav              < i n d e x . j s     P              j   ?rav                < i n d e x . j s     P              `j   ?rav               < i n d e x . j s     P              j   7av                < L I C E N S E       P               j   7av               < L I C E N S E       P              Pj   7av              < L I C E N S E       P              j   7av                < L I C E N S E       P              j   7av               < L I C E N S E       X              @j   /av                < p a c k a g e . j s o n     X              j   /av               < p a c k a g e . j s o n     X              j   /av              < p a c k a g e . j s o n     X              Hj   /av                < p a c k a g e . j s o n     X              j   /av               < p a c k a g e . j s o n     P              j   #av                < R E A D M E . m d   P              Hj   #av               < R E A D M E . m d   P              j   #av              < R E A D M E . m d   P              j   #av                < R E A D M E . m d   P              8j   #av               < R E A D M E . m d   P              j   bv               < m o v e - f i l e   P              j   bv              < m o v e - f i l e   P              (j   5bv                < i n d e x . j s     P              xj   5bv               < i n d e x . j s     P              j   5bv              < i n d e x . j s     P              j   5bv                < i n d e x . j s     P              hj   5bv               < i n d e x . j s     P               j   [bv                < L I C E N S E . m d P               j   [bv               < L I C E N S E . m d P               Xj   [bv              < L I C E N S E . m d P               j   [bv                < L I C E N S E . m d P               j   [bv               < L I C E N S E . m d X      !        Hj   bv                < p a c k a g e . j s o n     X      !        j   bv               < p a c k a g e . j s o n     X      !        j   bv              < p a c k a g e . j s o n     X      !        Pj   bv                < p a c k a g e . j s o n     X      !        j   bv               < p a c k a g e . j s o n     P      "         j   bv                < R E A D M E . m d   P      "        Pj   bv               < R E A D M E . m d   P      "        j   bv              < R E A D M E . m d   P      "        j   bv                < R E A D M E . m d   P      "        @j   bv               < R E A D M E . m d   P      #        j   bv               < n o d e - g y p                                     P      #         j   bv              < n o d e - g y p     X      $    #    Pj   bv                < p a c k a g e . j s o n     X      $    #    j   bv               < p a c k a g e . j s o n     X      $    #     j   bv              < p a c k a g e . j s o n     X      $    #    Xj   bv                < p a c k a g e . j s o n     X      $    #    j   bv               < p a c k a g e . j s o n     P      %    #    j   cv                < R E A D M E . m d   P      %    #    Xj   Ecv               < R E A D M E . m d   P      %    #    j   Ecv              < R E A D M E . m d   P      %    #    j   Ecv                < R E A D M E . m d   P      %    #    Hj   Ecv               < R E A D M E . m d   X      &        j   lcv               < p r o m i s e - s p a w n   X      &        j   cv              < p r o m i s e - s p a w n   P      '    &    Hj   cv                < i n d e x . j s     P      '    &    j   cv               < i n d e x . j s     P      '    &    j   cv              < i n d e x . j s     P      '    &    8j   cv                < i n d e x . j s     P      '    &    j   cv               < i n d e x . j s     P      (    &    j   cv                < L I C E N S E       P      (    &    (j   cv               < L I C E N S E       P      (    &    xj   cv              < L I C E N S E       P      (    &    j   cv                < L I C E N S E       P      (    &    j   cv               < L I C E N S E       X      )    &    hj   dv                < p a c k a g e . j s o n     X      )    &    j   dv               < p a c k a g e . j s o n     X      )    &    j   dv              < p a c k a g e . j s o n     X      )    &    pj   dv                < p a c k a g e . j s o n     X      )    &    j   dv               < p a c k a g e . j s o n     P      *    &     j   /dv                < R E A D M E . m d   P      *    &    pj   /dv               < R E A D M E . m d   P      *    &    j   /dv              < R E A D M E . m d   P      *    &    j   /dv                < R E A D M E . m d   P      *    &    `j   /dv               < R E A D M E . m d   P      +        j   /dv               < r u n - s c r i p t P      +         j   /dv              < r u n - s c r i p t P      ,    +    Pj   |Vdv                < L I C E N S E       P      ,    +    j   |Vdv               < L I C E N S E       P      ,    +    j   |Vdv              < L I C E N S E       P      ,    +    @j   |Vdv                < L I C E N S E       P      ,    +    j   |Vdv               < L I C E N S E       X      -    +    j   h}dv                < p a c k a g e . j s o n     X      -    +    8j   h}dv               < p a c k a g e . j s o n     X      -    +    j   h}dv              < p a c k a g e . j s o n     X      -    +    j   h}dv                < p a c k a g e . j s o n     X      -    +    @j   h}dv               < p a c k a g e . j s o n     P      .    +    j   ^dv                < R E A D M E . m d   P      .    +    j   Pdv               < R E A D M E . m d   P      .    +    8j   Pdv              < R E A D M E . m d   P      .    +    j   Pdv                < R E A D M E . m d                                           P      .    +     j   Pdv               < R E A D M E . m d   X      /        Pj   Ddv               < @ s c h e m a t i c s       X      /        j   Ddv              < @ s c h e m a t i c s       P      0    /     j   Ddv               < a n g u l a r       P      0    /    Pj   Ddv              < a n g u l a r       `      1    0    j   Ddv                < c o l l e c t i o n . j s o n       `      1    0     j   %gev               < c o l l e c t i o n . j s o n       `      1    0    `j   %gev              < c o l l e c t i o n . j s o n       `      1    0    j   %gev                < c o l l e c t i o n . j s o n       `      1    0     j   %gev               < c o l l e c t i o n . j s o n       P      2    0    j   ev                < L I C E N S E       P      2    0    j   ev               < L I C E N S E       P      2    0     j   ev              < L I C E N S E       P      2    0    pj   ev                < L I C E N S E       P      2    0    j   ev               < L I C E N S E       X      3    0    j   ev                < p a c k a g e . j s o n     X      3    0    hj   ev               < p a c k a g e . j s o n     X      3    0    j   ev              < p a c k a g e . j s o n     X      3    0    j   ev                < p a c k a g e . j s o n     X      3    0    pj   ev               < p a c k a g e . j s o n     P      4    0    j   ev                < R E A D M E . m d   P      4    0    j   ev               < R E A D M E . m d   P      4    0    hj   fv              < R E A D M E . m d   P      4    0    j   fv                < R E A D M E . m d   P      4    0    j   fv               < R E A D M E . m d   X      5        Xj   fv               < @ t o o t a l l n a t e     X      5        j   fv              < @ t o o t a l l n a t e     H      6    5    j   fv               < o n c e     H      6    5    Pj   fv              < o n c e     X      7    6    j   )fv                < p a c k a g e . j s o n     X      7    6    j   )fv               < p a c k a g e . j s o n     X      7    6    Hj   )fv              < p a c k a g e . j s o n     X      7    6    j   )fv                < p a c k a g e . j s o n     X      7    6    j   )fv               < p a c k a g e . j s o n     H      8        Pj   Pfv               < @ t y p e s H      8        j   Pfv              < @ t y p e s X      9    8    j   Pfv               < b o d y - p a r s e r       X      9    8    8j   Pfv              < b o d y - p a r s e r       P      :    9    j   wfv                < i n d e x . d . t s P      :    9    j   wfv               < i n d e x . d . t s P      :    9    0j   wfv              < i n d e x . d . t s P      :    9    j   wfv                < i n d e x . d . t s P      :    9    j   wfv               < i n d e x . d . t s P      <    9     j   fv                < L I C E N S E       P      <    9    pj   fv               < L I C E N S E       P      <    9    j   fv              < L I C E N S E       P      <    9    j   fv                < L I C E N S E       P      <    9    `j   fv               < L I C E N S E                                                                                       X      =    9     j   fv                < p a c k a g e . j s o n     X      =    9    Xj   fv               < p a c k a g e . j s o n     X      =    9    j   fv              < p a c k a g e . j s o n     X      =    9    j   fv                < p a c k a g e . j s o n     X      =    9    `j   fv               < p a c k a g e . j s o n     P      >    9    j   gv                < R E A D M E . m d   P      >    9    j   gv               < R E A D M E . m d   P      >    9    Xj   gv              < R E A D M E . m d   P      >    9    j   gv                < R E A D M E . m d   P      >    9    j   gv               < R E A D M E . m d   P      ?    8    Hj   :gv               < b o n j o u r       P      ?    8    j   :gv              < b o n j o u r       P      @    ?    j   :gv                < i n d e x . d . t s P      @    ?    8j   agv               < i n d e x . d . t s P      @    ?    j   agv              < i n d e x . d . t s P      @    ?    j   agv                < i n d e x . d . t s P      @    ?    (j   agv               < i n d e x . d . t s P      A    ?    xj   gv                < L I C E N S E       P      A    ?    j   gv               < L I C E N S E       P      A    ?    j   gv              < L I C E N S E       P      A    ?    hj   gv                < L I C E N S E       P      A    ?    j   gv               < L I C E N S E       X      B    ?    j   gv                < p a c k a g e . j s o n     X      B    ?    `j   gv               < p a c k a g e . j s o n     X      B    ?    j   gv              < p a c k a g e . j s o n     X      B    ?    j   gv                < p a c k a g e . j s o n     X      B    ?    hj   gv               < p a c k a g e . j s o n     P      C    ?    j   gv                < R E A D M E . m d   P      C    ?    j   ngv               < R E A D M E . m d   P      C    ?    `j   ngv              < R E A D M E . m d   P      C    ?    j   ngv                < R E A D M E . m d   P      C    ?     j   ngv               < R E A D M E . m d   `      D    8    Pj   c$hv              " < c o m p o n e n t - e m i t t e r   `      D    8    j   c$hv             " < c o m p o n e n t - e m i t t e r   P      E    D    j   c$hv                < i n d e x . d . t s P      E    D    `j   c$hv               < i n d e x . d . t s P      E    D    j   c$hv              < i n d e x . d . t s P      E    D     j   YKhv                < i n d e x . d . t s P      E    D    Pj   YKhv               < i n d e x . d . t s P      F    D    j   Mrhv                < L I C E N S E       P      F    D    j   Mrhv               < L I C E N S E       P      F    D    @j   Mrhv              < L I C E N S E       P      F    D    j   Mrhv                < L I C E N S E       P      F    D    j   Mrhv               < L I C E N S E       X      G    D    0j   Chv                < p a c k a g e . j s o n     X      G    D    j   Chv               < p a c k a g e . j s o n     X      G    D    j   Chv              < p a c k a g e . j s o n     X      G    D    8j   Chv                < p a c k a g e . j s o n     X      G    D    j   Chv               < p a c k a g e . j s o n                             P      H    D      k   8hv                < R E A D M E . m d   P      H    D    P k   0hv               < R E A D M E . m d   P      H    D     k   0hv              < R E A D M E . m d   P      H    D     k   0hv                < R E A D M E . m d   P      H    D    @k   0hv               < R E A D M E . m d   P      I    8    k   3iv               < c o n n e c t       P      I    8    k   3iv              < c o n n e c t       P      J    I    0k   5iv                < i n d e x . d . t s P      J    I    k   5iv               < i n d e x . d . t s P      J    I    k   5iv              < i n d e x . d . t s P      J    I     k   5iv                < i n d e x . d . t s P      J    I    pk   5iv               < i n d e x . d . t s P      K    I    k   \iv                < L I C E N S E       P      K    I    k   \iv               < L I C E N S E       P      K    I    `k   \iv              < L I C E N S E       P      K    I    k   \iv                < L I C E N S E       P      K    I     k   \iv               < L I C E N S E       X      L    I    Pk   iv                < p a c k a g e . j s o n     X      L    I    k   iv               < p a c k a g e . j s o n     X      L    I     k   iv              < p a c k a g e . j s o n     X      L    I    Xk   iv                < p a c k a g e . j s o n     X      L    I    k   iv               < p a c k a g e . j s o n     P      M    I    k   iv                < R E A D M E . m d   P      M    I    Xk   iv               < R E A D M E . m d   P      M    I    k   iv              < R E A D M E . m d   P      M    I    k   iv                < R E A D M E . m d   P      M    I    Hk   iv               < R E A D M E . m d   x      N    8    k   iv              8 < c o n n e c t - h i s t o r y - a p i - f a l l b a c k     x      N    8    	k   iv             8 < c o n n e c t - h i s t o r y - a p i - f a l l b a c k     P      O    N    	k   iv                < i n d e x . d . t s P      O    N    	k   iv               < i n d e x . d . t s P      O    N    (
k   iv              < i n d e x . d . t s P      O    N    x
k   iv                < i n d e x . d . t s P      O    N    
k   iv               < i n d e x . d . t s P      P    N    k   jv                < L I C E N S E       P      P    N    hk   jv               < L I C E N S E       P      P    N    k   jv              < L I C E N S E       P      P    N    k   Ejv                < L I C E N S E       P      P    N    Xk   Ejv               < L I C E N S E       X      Q    N    k   ljv                < p a c k a g e . j s o n     X      Q    N     k   ljv               < p a c k a g e . j s o n     X      Q    N    Xk   ljv              < p a c k a g e . j s o n     X      Q    N    k   ljv                < p a c k a g e . j s o n     X      Q    N    k   ljv               < p a c k a g e . j s o n     P      R    N    `k   jv                < R E A D M E . m d   P      R    N    k   jv               < R E A D M E . m d   P      R    N     k   jv              < R E A D M E . m d   P      R    N    Pk   jv                < R E A D M E . m d   P      R    N    k   jv               < R E A D M E . m d                   H      S    8     k   jv               < c o o k i e H      S    8    Hk   jv              < c o o k i e P      T    S    k   jv                < i n d e x . d . t s P      T    S    k   jv               < i n d e x . d . t s P      T    S    0k   jv              < i n d e x . d . t s P      T    S    k   jv                < i n d e x . d . t s P      T    S    k   jv               < i n d e x . d . t s P      U    S     k   kv                < L I C E N S E       P      U    S    pk   kv               < L I C E N S E       P      U    S    k   kv              < L I C E N S E       P      U    S    k   kv                < L I C E N S E       P      U    S    `k   kv               < L I C E N S E       X      V    S    k   /kv                < p a c k a g e . j s o n     X      V    S    k   /kv               < p a c k a g e . j s o n     X      V    S    `k   /kv              < p a c k a g e . j s o n     X      V    S    k   /kv                < p a c k a g e . j s o n     X      V    S    k   /kv               < p a c k a g e . j s o n     P      W    S    hk   Vkv                < R E A D M E . m d   P      W    S    k   Vkv               < R E A D M E . m d   P      W    S    k   Vkv              < R E A D M E . m d   P      W    S    Xk   Vkv                < R E A D M E . m d   P      W    S    k   Vkv               < R E A D M E . m d   H      X    8    k   }kv               < c o r s     H      X    8    @k   }kv              < c o r s     P      Y    X    k   }kv                < i n d e x . d . t s P      Y    X    k   }kv               < i n d e x . d . t s P      Y    X    (k   }kv              < i n d e x . d . t s P      Y    X    xk   }kv                < i n d e x . d . t s P      Y    X    k   }kv               < i n d e x . d . t s P      Z    X    k   {kv                < L I C E N S E       P      Z    X    hk   ikv               < L I C E N S E       P      Z    X    k   ikv              < L I C E N S E       P      Z    X    k   ikv                < L I C E N S E       P      Z    X    Xk   ikv               < L I C E N S E       X      [    X    k   Zkv                < p a c k a g e . j s o n     X      [    X     k   Zkv               < p a c k a g e . j s o n     X      [    X    Xk   Zkv              < p a c k a g e . j s o n     X      [    X    k   Zkv                < p a c k a g e . j s o n     X      [    X    k   Zkv               < p a c k a g e . j s o n     P      \    X    `k   Wlv                < R E A D M E . m d   P      \    X    k   Wlv               < R E A D M E . m d   P      \    X     k   L@lv              < R E A D M E . m d   P      \    X    Pk   L@lv                < R E A D M E . m d   P      \    X    k   L@lv               < R E A D M E . m d   H      ]    8    k   L@lv               < e s l i n t H      ]    8    8k   L@lv              < e s l i n t X      ^    ]    k   L@lv                < h e l p e r s . d . t s     X      ^    ]    k   @glv               < h e l p e r s . d . t s     X      ^    ]    0k   @glv              < h e l p e r s . d . t s     X      ^    ]    k   @glv                < h e l p e r s . d . t s                                     X      ^    ]      k   @glv               < h e l p e r s . d . t s     P      _    ]    X k   $lv                < i n d e x . d . t s P      _    ]     k   $lv               < i n d e x . d . t s P      _    ]     k   !lv              < i n d e x . d . t s P      _    ]    H!k   !lv                < i n d e x . d . t s P      _    ]    !k   !lv               < i n d e x . d . t s P      `    ]    !k   mv                < L I C E N S E       P      `    ]    8"k   mv               < L I C E N S E       P      `    ]    "k   mv              < L I C E N S E       P      `    ]    "k   mv                < L I C E N S E       P      `    ]    (#k   mv               < L I C E N S E       X      a    ]    x#k   *mv                < p a c k a g e . j s o n     X      a    ]    #k   *mv               < p a c k a g e . j s o n     X      a    ]    ($k   *mv              < p a c k a g e . j s o n     X      a    ]    $k   *mv                < p a c k a g e . j s o n     X      a    ]    $k   *mv               < p a c k a g e . j s o n     P      b    ]    0%k   Pmv                < R E A D M E . m d   P      b    ]    %k   Pmv               < R E A D M E . m d   P      b    ]    %k   wmv              < R E A D M E . m d   P      b    ]     &k   wmv                < R E A D M E . m d   P      b    ]    p&k   wmv               < R E A D M E . m d   p      c    ]    &k   mv               2 < u s e - a t - y o u r - o w n - r i s k . d . t s   p      c    ]    0'k   mv              2 < u s e - a t - y o u r - o w n - r i s k . d . t s   p      c    ]    'k   mv             2 < u s e - a t - y o u r - o w n - r i s k . d . t s   p      c    ]    (k   mv               2 < u s e - a t - y o u r - o w n - r i s k . d . t s   p      c    ]    (k   mv              2 < u s e - a t - y o u r - o w n - r i s k . d . t s   X      d    8    (k   mv               < e s l i n t - s c o p e     X      d    8    H)k   mv              < e s l i n t - s c o p e     P      e    d    )k   mv                < i n d e x . d . t s P      e    d    )k   mv               < i n d e x . d . t s P      e    d    @*k   mv              < i n d e x . d . t s P      e    d    *k   mv                < i n d e x . d . t s P      e    d    *k   mv               < i n d e x . d . t s P      f    d    0+k   nv                < L I C E N S E       P      f    d    +k   :nv               < L I C E N S E       P      f    d    +k   :nv              < L I C E N S E       P      f    d     ,k   :nv                < L I C E N S E       P      f    d    p,k   :nv               < L I C E N S E       X      g    d    ,k   anv                < p a c k a g e . j s o n     X      g    d    -k   anv               < p a c k a g e . j s o n     X      g    d    p-k   anv              < p a c k a g e . j s o n     X      g    d    -k   anv                < p a c k a g e . j s o n     X      g    d     .k   anv               < p a c k a g e . j s o n     P      h    d    x.k   nv                < R E A D M E . m d   P      h    d    .k   nv               < R E A D M E . m d   P      h    d    /k   nv              < R E A D M E . m d   P      h    d    h/k   [ov                < R E A D M E . m d                                                                           P      h    d     0k   [ov               < R E A D M E . m d   H      i    8    P0k   TAov               < e s t r e e H      i    8    0k   TAov              < e s t r e e P      j    i    0k   TAov                < f l o w . d . t s   P      j    i    01k   TAov               < f l o w . d . t s   P      j    i    1k   TAov              < f l o w . d . t s   P      j    i    1k   TAov                < f l o w . d . t s   P      j    i     2k   TAov               < f l o w . d . t s   P      k    i    p2k   Ehov                < i n d e x . d . t s P      k    i    2k   Dov               < i n d e x . d . t s P      k    i    3k   Dov              < i n d e x . d . t s P      k    i    `3k   Dov                < i n d e x . d . t s P      k    i    3k   Dov               < i n d e x . d . t s P      l    i     4k   9ov                < L I C E N S E       P      l    i    P4k   9ov               < L I C E N S E       P      l    i    4k   9ov              < L I C E N S E       P      l    i    4k   9ov                < L I C E N S E       P      l    i    @5k   9ov               < L I C E N S E       X      m    i    5k   5ov                < p a c k a g e . j s o n     X      m    i    5k   5ov               < p a c k a g e . j s o n     X      m    i    @6k   5ov              < p a c k a g e . j s o n     X      m    i    6k   8pv                < p a c k a g e . j s o n     X      m    i    6k   8pv               < p a c k a g e . j s o n     P      n    i    H7k   +pv                < R E A D M E . m d   P      n    i    7k   +pv               < R E A D M E . m d   P      n    i    7k   +pv              < R E A D M E . m d   P      n    i    88k   +pv                < R E A D M E . m d   P      n    i    8k   +pv               < R E A D M E . m d   P      o    8    8k   
Rpv               < e x p r e s s       P      o    8    (9k   
Rpv              < e x p r e s s       P      p    o    x9k   
Rpv                < i n d e x . d . t s P      p    o    9k   xpv               < i n d e x . d . t s P      p    o    :k   xpv              < i n d e x . d . t s P      p    o    h:k   xpv                < i n d e x . d . t s P      p    o    :k   xpv               < i n d e x . d . t s P      q    o    ;k   pv                < L I C E N S E       P      q    o    X;k   pv               < L I C E N S E       P      q    o    ;k   pv              < L I C E N S E       P      q    o    ;k   pv                < L I C E N S E       P      q    o    H<k   pv               < L I C E N S E       X      r    o    <k   pv                < p a c k a g e . j s o n     X      r    o    <k   pv               < p a c k a g e . j s o n     X      r    o    H=k   pv              < p a c k a g e . j s o n     X      r    o    =k   pv                < p a c k a g e . j s o n     X      r    o    =k   pv               < p a c k a g e . j s o n     P      s    o    P>k   pv                < R E A D M E . m d   P      s    o    >k   pv               < R E A D M E . m d   P      s    o    >k   pv              < R E A D M E . m d   P      s    o    @?k   pv                < R E A D M E . m d   P      s    o    ?k   pv               < R E A D M E . m d                                   p      t    8     @k   qv              2 < e x p r e s s - s e r v e - s t a t i c - c o r e   p      t    8    p@k   qv             2 < e x p r e s s - s e r v e - s t a t i c - c o r e   P      u    t    @k   qv                < i n d e x . d . t s P      u    t    0Ak   ;qv               < i n d e x . d . t s P      u    t    Ak   ;qv              < i n d e x . d . t s P      u    t    Ak   ;qv                < i n d e x . d . t s P      u    t     Bk   ;qv               < i n d e x . d . t s P      v    t    pBk   bqv                < L I C E N S E       P      v    t    Bk   bqv               < L I C E N S E       P      v    t    Ck   qv              < L I C E N S E       P      v    t    `Ck   qv                < L I C E N S E       P      v    t    Ck   qv               < L I C E N S E       X      w    t     Dk   qv                < p a c k a g e . j s o n     X      w    t    XDk   qv               < p a c k a g e . j s o n     X      w    t    Dk   qv              < p a c k a g e . j s o n     X      w    t    Ek   qv                < p a c k a g e . j s o n     X      w    t    `Ek   qv               < p a c k a g e . j s o n     P      x    t    Ek   qv                < R E A D M E . m d   P      x    t    Fk   qv               < R E A D M E . m d   P      x    t    XFk   qv              < R E A D M E . m d   P      x    t    Fk   qv                < R E A D M E . m d   P      x    t    Fk   qv               < R E A D M E . m d   P      y    8    HGk   qv               < h t t p - p r o x y P      y    8    Gk   qv              < h t t p - p r o x y P      z    y    Gk   %rv                < i n d e x . d . t s P      z    y    8Hk   %rv               < i n d e x . d . t s P      z    y    Hk   %rv              < i n d e x . d . t s P      z    y    Hk   %rv                < i n d e x . d . t s P      z    y    (Ik   %rv               < i n d e x . d . t s P      {    y    xIk   Lrv                < L I C E N S E       P      {    y    Ik   Lrv               < L I C E N S E       P      {    y    Jk   ysrv              < L I C E N S E       P      {    y    hJk   ysrv                < L I C E N S E       P      {    y    Jk   ysrv               < L I C E N S E       X      |    y    Kk   qrv                < p a c k a g e . j s o n     X      |    y    `Kk   qrv               < p a c k a g e . j s o n     X      |    y    Kk   qrv              < p a c k a g e . j s o n     X      |    y    Lk   qrv                < p a c k a g e . j s o n     X      |    y    hLk   qrv               < p a c k a g e . j s o n     P      }    y    Lk   drv                < R E A D M E . m d   P      }    y    Mk   drv               < R E A D M E . m d   P      }    y    `Mk   drv              < R E A D M E . m d   P      }    y    Mk   drv                < R E A D M E . m d   P      }    y     Nk   drv               < R E A D M E . m d   P      ~    8    PNk   Srv               < j a s m i n e       P      ~    8    Nk   Srv              < j a s m i n e       P          ~    Nk   Srv                < i n d e x . d . t s P          ~    @Ok   Ksv               < i n d e x . d . t s P          ~    Ok   Ksv              < i n d e x . d . t s                                 P          ~     Pk   Ksv                < i n d e x . d . t s P          ~    PPk   Ksv               < i n d e x . d . t s P          ~    Pk   >6sv                < L I C E N S E       P          ~    Pk   >6sv               < L I C E N S E       P          ~    @Qk   >6sv              < L I C E N S E       P          ~    Qk   >6sv                < L I C E N S E       P          ~    Qk   :]sv               < L I C E N S E       X          ~    0Rk   0sv                < p a c k a g e . j s o n     X          ~    Rk   0sv               < p a c k a g e . j s o n     X          ~    Rk   0sv              < p a c k a g e . j s o n     X          ~    8Sk   0sv                < p a c k a g e . j s o n     X          ~    Sk   0sv               < p a c k a g e . j s o n     P          ~    Sk   $sv                < R E A D M E . m d   P          ~    8Tk   $sv               < R E A D M E . m d   P          ~    Tk   $sv              < R E A D M E . m d   P          ~    Tk   $sv                < R E A D M E . m d   P          ~    (Uk   $sv               < R E A D M E . m d   X          8    xUk   !sv               < j s o n - s c h e m a       X          8    Uk   !sv              < j s o n - s c h e m a       P              (Vk   !sv                < i n d e x . d . t s P              xVk   !sv               < i n d e x . d . t s P              Vk   !sv              < i n d e x . d . t s P              Wk   sv                < i n d e x . d . t s P              hWk   sv               < i n d e x . d . t s P              Wk    tv                < L I C E N S E       P              Xk    tv               < L I C E N S E       P              XXk   mtv              < L I C E N S E       P              Xk   mtv                < L I C E N S E       P              Xk   mtv               < L I C E N S E       X              HYk   tv                < p a c k a g e . j s o n     X              Yk   tv               < p a c k a g e . j s o n     X              Yk   tv              < p a c k a g e . j s o n     X              PZk   tv                < p a c k a g e . j s o n     X              Zk   tv               < p a c k a g e . j s o n     P               [k   tv                < R E A D M E . m d   P              P[k   tv               < R E A D M E . m d   P              [k   	uv              < R E A D M E . m d   P              [k   	uv                < R E A D M E . m d   P              @\k   	uv               < R E A D M E . m d   H          8    \k   0uv               < m i m e     H          8    \k   0uv              < m i m e     P               ]k   0uv                < i n d e x . d . t s P              p]k   0uv               < i n d e x . d . t s P              ]k   0uv              < i n d e x . d . t s P              ^k   0uv                < i n d e x . d . t s P              `^k   0uv               < i n d e x . d . t s P              ^k   Wuv                < L I C E N S E       P               _k   Wuv               < L I C E N S E       P              P_k   Wuv              < L I C E N S E       P              _k   ~uv                < L I C E N S E                       P               `k   ~uv               < L I C E N S E       P      6          P`k   ~uv                < e d b . j c p       P      6          `k   ~uv               < e d b . j c p       P      >
         `k   ~uv                < e d b t m p . j t x P              @ak   uv                < l i t e . d . t s   P              ak   uv               < l i t e . d . t s   P              ak   uv              < l i t e . d . t s   P      h   H      0bk   uv               < e d b . j t x       X      h   H      bk   uv                < e d b 0 0 4 4 3 . j t x     P              bk   uv                < l i t e . d . t s   P              (ck   uv               < l i t e . d . t s   P      >
         xck   uv               < e d b t m p . j t x P      >
         ck   uv                < e d b . j t x       P              dk   uv                < M i m e . d . t s   X               hdk   uv                < e d b 0 0 4 3 F . j t x     P               dk   uv                 < e d b t m p . j t x P               ek   uv                < e d b t m p . j t x P              `ek   uv               < M i m e . d . t s   P              ek   uv              < M i m e . d . t s   P               fk   uv                < M i m e . d . t s   P              Pfk   uv               < M i m e . d . t s   X      h   H      fk   uv               < e d b 0 0 4 4 3 . j t x     X              fk   ~vv                < p a c k a g e . j s o n     X              Pgk   ~vv               < p a c k a g e . j s o n     X              gk   ~vv              < p a c k a g e . j s o n     X               hk   ~vv                < p a c k a g e . j s o n     X              Xhk   ~vv               < p a c k a g e . j s o n     P              hk   hAvv                < R E A D M E . m d   P               ik   \hvv               < R E A D M E . m d   P              Pik   \hvv              < R E A D M E . m d   P              ik   \hvv                < R E A D M E . m d   P              ik   \hvv               < R E A D M E . m d   H          8    @jk   \hvv               < n o d e     H          8    jk   Uvv              < n o d e     X              jk   Uvv                < a s s e r t . d . t s       X              (kk   Uvv               < a s s e r t . d . t s       X              kk   Kvv              < a s s e r t . d . t s       X              kk   Kvv                < a s s e r t . d . t s       X              0lk   Kvv               < a s s e r t . d . t s       `              lk   :vv                 < a s y n c _ h o o k s . d . t s     `              lk   :vv                < a s y n c _ h o o k s . d . t s     `              Hmk   :vv               < a s y n c _ h o o k s . d . t s     `              mk   :vv                 < a s y n c _ h o o k s . d . t s     `              nk   :vv                < a s y n c _ h o o k s . d . t s     X              hnk   2wv                < b u f f e r . d . t s       X              nk   2wv               < b u f f e r . d . t s       X              ok   2wv              < b u f f e r . d . t s       X              pok   2wv                < b u f f e r . d . t s                                                               X               pk   2wv               < b u f f e r . d . t s       `              Xpk   '+wv               $ < c h i l d _ p r o c e s s . d . t s `              pk   '+wv              $ < c h i l d _ p r o c e s s . d . t s `              qk   '+wv             $ < c h i l d _ p r o c e s s . d . t s `              xqk   '+wv               $ < c h i l d _ p r o c e s s . d . t s `              qk   '+wv              $ < c h i l d _ p r o c e s s . d . t s X              8rk   Rwv                < c l u s t e r . d . t s     X              rk   ywv               < c l u s t e r . d . t s     X              rk   ywv              < c l u s t e r . d . t s     X              @sk   ywv                < c l u s t e r . d . t s     X              sk   ywv               < c l u s t e r . d . t s     X              sk   
wv                < c o n s o l e . d . t s     X              Htk   
wv               < c o n s o l e . d . t s     X              tk   
wv              < c o n s o l e . d . t s     X              tk   
wv                < c o n s o l e . d . t s     X              Puk   
wv               < c o n s o l e . d . t s     X              uk   wv                < c o n s t a n t s . d . t s X               vk   wv               < c o n s t a n t s . d . t s X              Xvk   wv              < c o n s t a n t s . d . t s X              vk   wv                < c o n s t a n t s . d . t s X              wk   wv               < c o n s t a n t s . d . t s X              `wk   xv                < c r y p t o . d . t s       X              wk   ;xv               < c r y p t o . d . t s       X              xk   ;xv              < c r y p t o . d . t s       X              hxk   ;xv                < c r y p t o . d . t s       X              xk   ;xv               < c r y p t o . d . t s       P              yk   bxv                < d g r a m . d . t s P              hyk   bxv               < d g r a m . d . t s P              yk   xv              < d g r a m . d . t s P              zk   xv                < d g r a m . d . t s P              Xzk   xv               < d g r a m . d . t s P              zk   xv                < d n s . d . t s     P              zk   xv               < d n s . d . t s     P              H{k   xv              < d n s . d . t s     P              {k   xv                < d n s . d . t s     P              {k   xv               < d n s . d . t s     X              8|k   xv                < d o m a i n . d . t s       X              |k   xv               < d o m a i n . d . t s       X              |k   xv              < d o m a i n . d . t s       X              @}k   xv                < d o m a i n . d . t s       X              }k   xv               < d o m a i n . d . t s       X              }k   %yv                < e v e n t s . d . t s       X              H~k   %yv               < e v e n t s . d . t s       X              ~k   %yv              < e v e n t s . d . t s       X              ~k   %yv                < e v e n t s . d . t s       X              Pk   %yv               < e v e n t s . d . t s       P              k   Lyv                < f s . d . t s               P               k   syv               < f s . d . t s       P              Pk   yv              < f s . d . t s       P              k   yv                < f s . d . t s       P              k   yv               < f s . d . t s       X              @k   ryv                < g l o b a l s . d . t s     X              k   ryv               < g l o b a l s . d . t s     X              k   ryv              < g l o b a l s . d . t s     X              Hk   ryv                < g l o b a l s . d . t s     X              k   ryv               < g l o b a l s . d . t s     h              k   pyv               & < g l o b a l s . g l o b a l . d . t s       h              `k   _zv              & < g l o b a l s . g l o b a l . d . t s       h              k   _zv             & < g l o b a l s . g l o b a l . d . t s       h              0k   _zv               & < g l o b a l s . g l o b a l . d . t s       h              k   _zv              & < g l o b a l s . g l o b a l . d . t s       P               k   T6zv                < h t t p . d . t s   P              Pk   T6zv               < h t t p . d . t s   P              k   T6zv              < h t t p . d . t s   P              k   T6zv                < h t t p . d . t s   P              @k   T6zv               < h t t p . d . t s   P              k   J]zv                < h t t p 2 . d . t s P              k   <zv               < h t t p 2 . d . t s P              0k   <zv              < h t t p 2 . d . t s P              k   <zv                < h t t p 2 . d . t s P              k   <zv               < h t t p 2 . d . t s P               k   2zv                < h t t p s . d . t s P              pk   *zv               < h t t p s . d . t s P              k   *zv              < h t t p s . d . t s P              k   *zv                < h t t p s . d . t s P              `k   *zv               < h t t p s . d . t s P              k   zv                < i n d e x . d . t s P               k   zv               < i n d e x . d . t s P              Pk   zv              < i n d e x . d . t s P              k   zv                < i n d e x . d . t s P              k   zv               < i n d e x . d . t s X              @k    {v                < i n s p e c t o r . d . t s X              k   
G{v               < i n s p e c t o r . d . t s X              k   {v              < i n s p e c t o r . d . t s X              Hk   {v                < i n s p e c t o r . d . t s X              k   {v               < i n s p e c t o r . d . t s P              k   {v                < L I C E N S E       P              Hk   {v               < L I C E N S E       P              k   {v              < L I C E N S E       P              k   {v                < L I C E N S E       P              8k   {v               < L I C E N S E       X              k   	|v                < m o d u l e . d . t s       X              k   	|v               < m o d u l e . d . t s       X              8k   	|v              < m o d u l e . d . t s       X              k   0|v                < m o d u l e . d . t s                               X               k   0|v               < m o d u l e . d . t s       P              Xk   W|v                < n e t . d . t s     P              k   W|v               < n e t . d . t s     P              k   W|v              < n e t . d . t s     P              Hk   W|v                < n e t . d . t s     P              k   W|v               < n e t . d . t s     P              k   ~|v                < o s . d . t s       P              8k   ~|v               < o s . d . t s       P              k   ~|v              < o s . d . t s       P              k   ~|v                < o s . d . t s       P              (k   ~|v               < o s . d . t s       X              xk   |v                < p a c k a g e . j s o n     X              k   |v               < p a c k a g e . j s o n     X              (k   |v              < p a c k a g e . j s o n     X              k   |v                < p a c k a g e . j s o n     X              k   |v               < p a c k a g e . j s o n     P              0k   |v                < p a t h . d . t s   P              k   |v               < p a t h . d . t s   P              k   |v              < p a t h . d . t s   P               k   |v                < p a t h . d . t s   P              pk   |v               < p a t h . d . t s   `              k   |v                < p e r f _ h o o k s . d . t s       `               k   |v               < p e r f _ h o o k s . d . t s       `              k   |v              < p e r f _ h o o k s . d . t s       `              k   }v                < p e r f _ h o o k s . d . t s       `              @k   }v               < p e r f _ h o o k s . d . t s       X              k   }v                < p r o c e s s . d . t s     X              k   {A}v               < p r o c e s s . d . t s     X              Pk   {A}v              < p r o c e s s . d . t s     X              k   {A}v                < p r o c e s s . d . t s     X               k   {A}v               < p r o c e s s . d . t s     X              Xk   qh}v                < p u n y c o d e . d . t s   X              k   qh}v               < p u n y c o d e . d . t s   X              k   qh}v              < p u n y c o d e . d . t s   X              `k   qh}v                < p u n y c o d e . d . t s   X              k   qh}v               < p u n y c o d e . d . t s   `              k   ^}v                 < q u e r y s t r i n g . d . t s     `              pk   ^}v                < q u e r y s t r i n g . d . t s     `              k   ^}v               < q u e r y s t r i n g . d . t s     `              0k   ^}v                 < q u e r y s t r i n g . d . t s     `              k   ^}v                < q u e r y s t r i n g . d . t s     X              k   T}v                < r e a d l i n e . d . t s   X              Hk   T}v               < r e a d l i n e . d . t s   X              k   G~v              < r e a d l i n e . d . t s   X              k   G~v                < r e a d l i n e . d . t s   X              Pk   G~v               < r e a d l i n e . d . t s   P              k   <+~v                < R E A D M E . m d           P               k   <+~v               < R E A D M E . m d   P              Pk   <+~v              < R E A D M E . m d   P              k   <+~v                < R E A D M E . m d   P              k   <+~v               < R E A D M E . m d   P              @k   2R~v                < r e p l . d . t s   P              k   2R~v               < r e p l . d . t s   P              k   2R~v              < r e p l . d . t s   P              0k   2R~v                < r e p l . d . t s   P              k   2R~v               < r e p l . d . t s   X              k   +y~v                < s t r e a m . d . t s       X              (k   ~v               < s t r e a m . d . t s       X              k   ~v              < s t r e a m . d . t s       X              k   ~v                < s t r e a m . d . t s       X              0k   ~v               < s t r e a m . d . t s       h              k   ~v               & < s t r i n g _ d e c o d e r . d . t s       h              k   ~v              & < s t r i n g _ d e c o d e r . d . t s       h              Xk   ~v             & < s t r i n g _ d e c o d e r . d . t s       h              k   ~v               & < s t r i n g _ d e c o d e r . d . t s       h              (k   ~v              & < s t r i n g _ d e c o d e r . d . t s       X              k   ~v                < t i m e r s . d . t s       X              k   ~v               < t i m e r s . d . t s       X              @k    v              < t i m e r s . d . t s       X              k    v                < t i m e r s . d . t s       X              k    v               < t i m e r s . d . t s       P              Hk   ;v                < t l s . d . t s     P              k   ;v               < t l s . d . t s     P              k   bv              < t l s . d . t s     P              8k   bv                < t l s . d . t s     P              k   bv               < t l s . d . t s     `              k   v               " < t r a c e _ e v e n t s . d . t s   `              8k   v              " < t r a c e _ e v e n t s . d . t s   `              k   v             " < t r a c e _ e v e n t s . d . t s   `              k   v               " < t r a c e _ e v e n t s . d . t s   `              Xk   v              " < t r a c e _ e v e n t s . d . t s   P              k   v                < t t y . d . t s     P              k   v               < t t y . d . t s     P              Xk   v              < t t y . d . t s     P              k   v                < t t y . d . t s     P              k   v               < t t y . d . t s     P              Hk   v                < u r l . d . t s     P              k   v               < u r l . d . t s     P              k   v              < u r l . d . t s     P              8k   v                < u r l . d . t s     P              k   v               < u r l . d . t s     P              k   v                < u t i l . d . t s   P              (k   %v               < u t i l . d . t s   P              xk   %v              < u t i l . d . t s                                                           P               k   %v                < u t i l . d . t s   P              Pk   %v               < u t i l . d . t s   P              k   Lv                < v 8 . d . t s       P              k   Lv               < v 8 . d . t s       P              @k   Lv              < v 8 . d . t s       P              k   Lv                < v 8 . d . t s       P              k   Lv               < v 8 . d . t s       P              0k   sv                < v m . d . t s       P              k   sv               < v m . d . t s       P              k   v              < v m . d . t s       P               k   v                < v m . d . t s       P              pk   v               < v m . d . t s       P              k   v                < w a s i . d . t s   P              k   v               < w a s i . d . t s   P              `k   v              < w a s i . d . t s   P              k   v                < w a s i . d . t s   P               k   v               < w a s i . d . t s   h              Pk   sv               & < w o r k e r _ t h r e a d s . d . t s       h              k   sv              & < w o r k e r _ t h r e a d s . d . t s       h               k   sv             & < w o r k e r _ t h r e a d s . d . t s       h              k   sv               & < w o r k e r _ t h r e a d s . d . t s       h              k   sv              & < w o r k e r _ t h r e a d s . d . t s       P              Xk   ^]v                < z l i b . d . t s   P              k   ^]v               < z l i b . d . t s   P              k   ^]v              < z l i b . d . t s   P              Hk   ^]v                < z l i b . d . t s   P              k   ^]v               < z l i b . d . t s   P          8    k   ]v               < p a r s e - j s o n P          8    8k   ]v              < p a r s e - j s o n P              k   ]v                < i n d e x . d . t s P              k   ]v               < i n d e x . d . t s P              (k   ]v              < i n d e x . d . t s P              xk   ]v                < i n d e x . d . t s P              k   ]v               < i n d e x . d . t s P              k   Hv                < L I C E N S E       P              hk   ?v               < L I C E N S E       P              k   ?v              < L I C E N S E       P              k   ?v                < L I C E N S E       P              Xk   ?v               < L I C E N S E       X              k   3v                < p a c k a g e . j s o n     X               k   3v               < p a c k a g e . j s o n     X              Xk   3v              < p a c k a g e . j s o n     X              k   3v                < p a c k a g e . j s o n     X              k   3v               < p a c k a g e . j s o n     P              `k   * v                < R E A D M E . m d   P              k    Gv               < R E A D M E . m d   P               k    Gv              < R E A D M E . m d   P              Pk    Gv                < R E A D M E . m d   P              k    Gv               < R E A D M E . m d                   @          8     k   nv               < q s @          8    @k   nv              < q s P              k   nv                < i n d e x . d . t s P              k   nv               < i n d e x . d . t s P               k   nv              < i n d e x . d . t s P              pk   nv                < i n d e x . d . t s P              k   nv               < i n d e x . d . t s P              k   	v                < L I C E N S E       P              `k   	v               < L I C E N S E       P              k   v              < L I C E N S E       P               k   v                < L I C E N S E       P              Pk   v               < L I C E N S E       X              k   v                < p a c k a g e . j s o n     X              k   v               < p a c k a g e . j s o n     X              Pk   v              < p a c k a g e . j s o n     X              k   v                < p a c k a g e . j s o n     X               k   v               < p a c k a g e . j s o n     P              Xk   v                < R E A D M E . m d   P              k   v               < R E A D M E . m d   P              k   v              < R E A D M E . m d   P              Hk   	v                < R E A D M E . m d   P              k   	v               < R E A D M E . m d   X          8    k   	v               < r a n g e - p a r s e r     X          8    @k   	v              < r a n g e - p a r s e r     P              k   	v                < i n d e x . d . t s P              k   0v               < i n d e x . d . t s P              8k   0v              < i n d e x . d . t s P              k   0v                < i n d e x . d . t s P              k   0v               < i n d e x . d . t s P              (k   Wv                < L I C E N S E       P              xk   Wv               < L I C E N S E       P              k   Wv              < L I C E N S E       P              k   Wv                < L I C E N S E       P              hk   Wv               < L I C E N S E       X              k   ~v                < p a c k a g e . j s o n     X              k   ~v               < p a c k a g e . j s o n     X              hk   ~v              < p a c k a g e . j s o n     X              k   ~v                < p a c k a g e . j s o n     X              k   ~v               < p a c k a g e . j s o n     P              pk   v                < R E A D M E . m d   P              k   v               < R E A D M E . m d   P              k   v              < R E A D M E . m d   P              `k   v                < R E A D M E . m d   P              k   v               < R E A D M E . m d   H          8     k   v              
 < r e t r y   H          8    Hk   v             
 < r e t r y   P              k   v                < i n d e x . d . t s P              k   v               < i n d e x . d . t s P              0k   v              < i n d e x . d . t s P              k   v                < i n d e x . d . t s                                                 P               k   v               < i n d e x . d . t s P              Pk   v                < L I C E N S E       P              k   v               < L I C E N S E       P              k   v              < L I C E N S E       P              @k   v                < L I C E N S E       P              k   v               < L I C E N S E       X              k   Av                < p a c k a g e . j s o n     X              8k   hv               < p a c k a g e . j s o n     X              k   hv              < p a c k a g e . j s o n     X              k   hv                < p a c k a g e . j s o n     X              @k   hv               < p a c k a g e . j s o n     P              k   yv                < R E A D M E . m d   P              k   yv               < R E A D M E . m d   P              8k   ov              < R E A D M E . m d   P              k   ov                < R E A D M E . m d   P              k   ov               < R E A D M E . m d   X          8    (k   W+v               < s e r v e - i n d e x       X          8    k   W+v              < s e r v e - i n d e x       P              k   ORv                < i n d e x . d . t s P              (k   ORv               < i n d e x . d . t s P              xk   ORv              < i n d e x . d . t s P              k   ORv                < i n d e x . d . t s P              k   ORv               < i n d e x . d . t s P              hk   Byv                < L I C E N S E       P              k   Byv               < L I C E N S E       P              k   Byv              < L I C E N S E       P              Xk   Byv                < L I C E N S E       P              k   Byv               < L I C E N S E       X              k   7v                < p a c k a g e . j s o n     X              Pk   7v               < p a c k a g e . j s o n     X              k   7v              < p a c k a g e . j s o n     X               k   7v                < p a c k a g e . j s o n     X              Xk   7v               < p a c k a g e . j s o n     P              k   ,v                < R E A D M E . m d   P               k   ,v               < R E A D M E . m d   P              Pk   ,v              < R E A D M E . m d   P              k   ,v                < R E A D M E . m d   P              k   v               < R E A D M E . m d   X          8    @k   v               < s e r v e - s t a t i c     X          8    k   v              < s e r v e - s t a t i c     P              k   v                < i n d e x . d . t s P              @k   v               < i n d e x . d . t s P              k   v              < i n d e x . d . t s P              k   v                < i n d e x . d . t s P              0k   v               < i n d e x . d . t s P              k   <v                < L I C E N S E       P              k   <v               < L I C E N S E       P               k   <v              < L I C E N S E       P              pk   <v                < L I C E N S E                                                                       P               k   <v               < L I C E N S E       X              Pk   	cv                < p a c k a g e . j s o n     X              k   	cv               < p a c k a g e . j s o n     X               k   	cv              < p a c k a g e . j s o n     X              Xk   	cv                < p a c k a g e . j s o n     X              k   	cv               < p a c k a g e . j s o n     P              k   v                < R E A D M E . m d   P              Xk   v               < R E A D M E . m d   P              k   v              < R E A D M E . m d   P              k   v                < R E A D M E . m d   P              Hk   v               < R E A D M E . m d   H          8    k   v               < s o c k j s H          8    k   v              < s o c k j s P              (k   v                < i n d e x . d . t s P              xk   v               < i n d e x . d . t s P              k   v              < i n d e x . d . t s P              k   v                < i n d e x . d . t s P              hk   v               < i n d e x . d . t s P              k   v                < L I C E N S E       P              k   v               < L I C E N S E       P              Xk   v              < L I C E N S E       P              k   v                < L I C E N S E       P              k   v               < L I C E N S E       X              Hk   v                < p a c k a g e . j s o n     X              k   v               < p a c k a g e . j s o n     X              k   %v              < p a c k a g e . j s o n     X              Pk   %v                < p a c k a g e . j s o n     X              k   %v               < p a c k a g e . j s o n     P               k   %v                < R E A D M E . m d   P              Pk   %v               < R E A D M E . m d   P              k   Lv              < R E A D M E . m d   P              k   Lv                < R E A D M E . m d   P              @k   Lv               < R E A D M E . m d   @          8    k   Lv               < w s @          8    k   Lv              < w s X              k   sv                < i n d e x . d . m t s       X              hk   sv               < i n d e x . d . m t s       X              k   sv              < i n d e x . d . m t s       X              k   sv                < i n d e x . d . m t s       X              pk   sv               < i n d e x . d . m t s       P              k   v                < i n d e x . d . t s P              k   v               < i n d e x . d . t s P              hk   v              < i n d e x . d . t s P              k   v                < i n d e x . d . t s P              k   v               < i n d e x . d . t s P              Xk   v                < L I C E N S E       P              k   v               < L I C E N S E       P              k   v              < L I C E N S E       P              Hk   v                < L I C E N S E       P              k   v               < L I C E N S E                               X               k   v                < p a c k a g e . j s o n     X              Xk   v               < p a c k a g e . j s o n     X              k   6v              < p a c k a g e . j s o n     X              k   6v                < p a c k a g e . j s o n     X              `k   6v               < p a c k a g e . j s o n     P              k   6v                < R E A D M E . m d   P              k   y]v               < R E A D M E . m d   P              Xk   y]v              < R E A D M E . m d   P              k   y]v                < R E A D M E . m d   P              k   y]v               < R E A D M E . m d   X              Hk   y]v               < @ w e b a s s e m b l y j s X              k   iv              < @ w e b a s s e m b l y j s H              k   iv               < a s t       H              @k   iv              < a s t       P              k   iv                < L I C E N S E       P              k   iv               < L I C E N S E       P              (k   iv              < L I C E N S E       P              xk   iv                < L I C E N S E       P              k   iv               < L I C E N S E       X              k   Zv                < p a c k a g e . j s o n     X              pk   Zv               < p a c k a g e . j s o n     X              k   Zv              < p a c k a g e . j s o n     X               k   Sv                < p a c k a g e . j s o n     X              xk   Sv               < p a c k a g e . j s o n     P              k   Fv                < R E A D M E . m d   P               k   Fv               < R E A D M E . m d   P              pk   Fv              < R E A D M E . m d   P              k   Fv                < R E A D M E . m d   P              k   Fv               < R E A D M E . m d   p              `k   < v              2 < f l o a t i n g - p o i n t - h e x - p a r s e r   p              k   < v             2 < f l o a t i n g - p o i n t - h e x - p a r s e r   P              @k   < v                < L I C E N S E       P              k   < v               < L I C E N S E       P              k   1Gv              < L I C E N S E       P              0k   1Gv                < L I C E N S E       P              k   1Gv               < L I C E N S E       X              k   1Gv                < p a c k a g e . j s o n     X              (k   ,nv               < p a c k a g e . j s o n     X              k   ,nv              < p a c k a g e . j s o n     X              k   ,nv                < p a c k a g e . j s o n     X              0k   ,nv               < p a c k a g e . j s o n     P              k   (v                < R E A D M E . m d   P              k   (v               < R E A D M E . m d   P              (k   (v              < R E A D M E . m d   P              xk   (v                < R E A D M E . m d   P              k   (v               < R E A D M E . m d   `              k   v                < h e l p e r - a p i - e r r o r     `              xk   v               < h e l p e r - a p i - e r r o r                                             P                l   v                < L I C E N S E       P              P l   v               < L I C E N S E       P               l   v              < L I C E N S E       P               l   v                < L I C E N S E       P              @l   v               < L I C E N S E       X              l   v                < p a c k a g e . j s o n     X              l   	v               < p a c k a g e . j s o n     X              @l   	v              < p a c k a g e . j s o n     X              l   	v                < p a c k a g e . j s o n     X              l   	v               < p a c k a g e . j s o n     X              Hl   0v               < h e l p e r - b u f f e r   X              l   0v              < h e l p e r - b u f f e r   P              l   0v                < L I C E N S E       P              Hl   0v               < L I C E N S E       P              l   0v              < L I C E N S E       P              l   0v                < L I C E N S E       P              8l   0v               < L I C E N S E       X              l   Wv                < p a c k a g e . j s o n     X              l   Wv               < p a c k a g e . j s o n     X              8l   Wv              < p a c k a g e . j s o n     X              l   Wv                < p a c k a g e . j s o n     X              l   Wv               < p a c k a g e . j s o n     X              @l   ~v               < h e l p e r - n u m b e r s X              l   ~v              < h e l p e r - n u m b e r s P              l   ~v                < L I C E N S E       P              @l   v               < L I C E N S E       P              l   v              < L I C E N S E       P              l   v                < L I C E N S E       P              0	l   v               < L I C E N S E       X              	l   v                < p a c k a g e . j s o n     X              	l   v               < p a c k a g e . j s o n     X              0
l   v              < p a c k a g e . j s o n     X              
l   v                < p a c k a g e . j s o n     X              
l   v               < p a c k a g e . j s o n     h              8l   v              ( < h e l p e r - w a s m - b y t e c o d e     h              l   v             ( < h e l p e r - w a s m - b y t e c o d e     P              l   v                < L I C E N S E       P              Xl   v               < L I C E N S E       P              l   v              < L I C E N S E       P              l   v                < L I C E N S E       P              Hl   v               < L I C E N S E       X              l   v                < p a c k a g e . j s o n     X              l   v               < p a c k a g e . j s o n     X              Hl   v              < p a c k a g e . j s o n     X              l   v                < p a c k a g e . j s o n     X              l   v               < p a c k a g e . j s o n     h              Pl   Av              & < h e l p e r - w a s m - s e c t i o n                                                                               h               l   Av             & < h e l p e r - w a s m - s e c t i o n       P              hl   Av                < L I C E N S E       P              l   Av               < L I C E N S E       P              l   Av              < L I C E N S E       P              Xl   Av                < L I C E N S E       P              l   Av               < L I C E N S E       X              l   hv                < p a c k a g e . j s o n     X              Pl   v               < p a c k a g e . j s o n     X              l   v              < p a c k a g e . j s o n     X               l   v                < p a c k a g e . j s o n     X              Xl   v               < p a c k a g e . j s o n     P              l   v               < i e e e 7 5 4       P               l   v              < i e e e 7 5 4       P               Pl   v                < L I C E N S E       P               l   v               < L I C E N S E       P               l   v              < L I C E N S E       P               @l   v                < L I C E N S E       P               l   v               < L I C E N S E       X              l   v                < p a c k a g e . j s o n     X              8l   pv               < p a c k a g e . j s o n     X              l   pv              < p a c k a g e . j s o n     X              l   pv                < p a c k a g e . j s o n     X              @l   pv               < p a c k a g e . j s o n     H              l   pv               < l e b 1 2 8 H              l   pv              < l e b 1 2 8 X              (l   r+v                < L I C E N S E . t x t       X              l   r+v               < L I C E N S E . t x t       X              l   r+v              < L I C E N S E . t x t       X              0l   r+v                < L I C E N S E . t x t       X              l   r+v               < L I C E N S E . t x t       X              l   ]Rv                < p a c k a g e . j s o n     X              8l   ]Rv               < p a c k a g e . j s o n     X              l   ]Rv              < p a c k a g e . j s o n     X              l   ]Rv                < p a c k a g e . j s o n     X              @l   ]Rv               < p a c k a g e . j s o n     H              l   9v               < u t f 8     H              l   9v              < u t f 8     P              (l   9v                < L I C E N S E       P              xl   $v               < L I C E N S E       P              l   $v              < L I C E N S E       P              l   $v                < L I C E N S E       P              hl   $v               < L I C E N S E       X              l   .v                < p a c k a g e . j s o n     X              l   .v               < p a c k a g e . j s o n     X              hl   zUv              < p a c k a g e . j s o n     X              l   zUv                < p a c k a g e . j s o n     X              l   zUv               < p a c k a g e . j s o n     P              pl   zUv               < w a s m - e d i t                                                                   P                l   zUv              < w a s m - e d i t   P      	        P l   zUv                < L I C E N S E       P      	         l   q|v               < L I C E N S E       P      	         l   q|v              < L I C E N S E       P      	        @!l   q|v                < L I C E N S E       P      	        !l   q|v               < L I C E N S E       X      
        !l   q|v                < p a c k a g e . j s o n     X      
        8"l   q|v               < p a c k a g e . j s o n     X      
        "l   q|v              < p a c k a g e . j s o n     X      
        "l   dv                < p a c k a g e . j s o n     X      
        @#l   dv               < p a c k a g e . j s o n     P              #l   dv                < R E A D M E . m d   P              #l   dv               < R E A D M E . m d   P              8$l   dv              < R E A D M E . m d   P              $l   dv                < R E A D M E . m d   P              $l   dv               < R E A D M E . m d   P              (%l   Yv               < w a s m - g e n     P              x%l   Yv              < w a s m - g e n     P              %l   Yv                < L I C E N S E       P              &l   Iv               < L I C E N S E       P              h&l   Iv              < L I C E N S E       P              &l   Iv                < L I C E N S E       P              'l   Iv               < L I C E N S E       X              X'l   Ev                < p a c k a g e . j s o n     X              'l   Ev               < p a c k a g e . j s o n     X              (l   Ev              < p a c k a g e . j s o n     X              `(l   Ev                < p a c k a g e . j s o n     X              (l   Ev               < p a c k a g e . j s o n     P              )l   ??v               < w a s m - o p t     P              `)l   ??v              < w a s m - o p t     P              )l   ??v                < L I C E N S E       P               *l   6fv               < L I C E N S E       P              P*l   6fv              < L I C E N S E       P              *l   6fv                < L I C E N S E       P              *l   6fv               < L I C E N S E       X              @+l   6fv                < p a c k a g e . j s o n     X              +l   6fv               < p a c k a g e . j s o n     X              +l   )v              < p a c k a g e . j s o n     X              H,l   )v                < p a c k a g e . j s o n     X              ,l   )v               < p a c k a g e . j s o n     X              ,l   )v               < w a s m - p a r s e r       X              P-l   )v              < w a s m - p a r s e r       P              -l   )v                < L I C E N S E       P              -l   v               < L I C E N S E       P              H.l   v              < L I C E N S E       P              .l   v                < L I C E N S E       P              .l   v               < L I C E N S E       X              8/l   v                < p a c k a g e . j s o n     X              /l   v               < p a c k a g e . j s o n                             X               0l   v              < p a c k a g e . j s o n     X              X0l   v                < p a c k a g e . j s o n     X              0l   v               < p a c k a g e . j s o n     P              1l   v                < R E A D M E . m d   P              X1l   v               < R E A D M E . m d   P              1l   v              < R E A D M E . m d   P              1l   (v                < R E A D M E . m d   P              H2l   (v               < R E A D M E . m d   X              2l   (v               < w a s t - p r i n t e r     X              2l   (v              < w a s t - p r i n t e r     P              H3l   Ov                < L I C E N S E       P              3l   Ov               < L I C E N S E       P              3l   Ov              < L I C E N S E       P              84l   Ov                < L I C E N S E       P              4l   Ov               < L I C E N S E       X              4l   vv                < p a c k a g e . j s o n     X              05l   vv               < p a c k a g e . j s o n     X              5l   vv              < p a c k a g e . j s o n     X              5l   vv                < p a c k a g e . j s o n     X              86l   vv               < p a c k a g e . j s o n     P              6l   v                < R E A D M E . m d   P              6l   v               < R E A D M E . m d   P              07l   v              < R E A D M E . m d   P              7l   v                < R E A D M E . m d   P              7l   v               < R E A D M E . m d   H               8l   v              
 < @ x t u c   H              h8l   v             
 < @ x t u c   P              8l   v               < i e e e 7 5 4       P               9l   v              < i e e e 7 5 4       P              P9l   v                < i n d e x . j s     P              9l   v               < i n d e x . j s     P              9l   v              < i n d e x . j s     P              @:l   v                < i n d e x . j s     P              :l   v               < i n d e x . j s     P              :l   v                < L I C E N S E       P              0;l   v               < L I C E N S E       P              ;l   v              < L I C E N S E       P              ;l   v                < L I C E N S E       P               <l   v               < L I C E N S E       X              p<l   9v                < p a c k a g e . j s o n     X              <l   9v               < p a c k a g e . j s o n     X               =l   9v              < p a c k a g e . j s o n     X              x=l   9v                < p a c k a g e . j s o n     X              =l   9v               < p a c k a g e . j s o n     P              (>l   `v                < R E A D M E . m d   P              x>l   `v               < R E A D M E . m d   P              >l   `v              < R E A D M E . m d   P              ?l   `v                < R E A D M E . m d   P              h?l   `v               < R E A D M E . m d   H               ?l   v               < l o n g     H                @l   v              < l o n g     P      !         H@l   v                < i n d e x . d . t s P      !         @l   v               < i n d e x . d . t s P      !         @l   v              < i n d e x . d . t s P      !         8Al   v                < i n d e x . d . t s P      !         Al   v               < i n d e x . d . t s P      "         Al   v                < i n d e x . j s     P      "         (Bl   rv               < i n d e x . j s     P      "         xBl   e#v              < i n d e x . j s     P      "         Bl   e#v                < i n d e x . j s     P      "         Cl   e#v               < i n d e x . j s     P      #         hCl   gJv                < L I C E N S E       P      #         Cl   gJv               < L I C E N S E       P      #         Dl   gJv              < L I C E N S E       P      #         XDl   gJv                < L I C E N S E       P      #         Dl   gJv               < L I C E N S E       X      $         Dl   gJv                < p a c k a g e . j s o n     X      $         PEl   gJv               < p a c k a g e . j s o n     X      $         El   `qv              < p a c k a g e . j s o n     X      $          Fl   `qv                < p a c k a g e . j s o n     X      $         XFl   `qv               < p a c k a g e . j s o n     P      %         Fl   Iv                < R E A D M E . m d   P      %          Gl   Iv               < R E A D M E . m d   P      %         PGl   Iv              < R E A D M E . m d   P      %         Gl   Iv                < R E A D M E . m d   P      %         Gl   Iv               < R E A D M E . m d   P      &        @Hl   >v               < @ y a r n p k g     P      &        Hl   >v              < @ y a r n p k g     P      '    &    Hl   >v               < l o c k f i l e     P      '    &    0Il   >v              < l o c k f i l e     P      (    '    Il   >v                < i n d e x . j s     P      (    '    Il   6v               < i n d e x . j s     P      (    '     Jl   $4v              < i n d e x . j s     P      (    '    pJl   [v                < i n d e x . j s     P      (    '    Jl   [v               < i n d e x . j s     X      )    '    Kl   [v                < p a c k a g e . j s o n     X      )    '    hKl   [v               < p a c k a g e . j s o n     X      )    '    Kl   v              < p a c k a g e . j s o n     X      )    '    Ll   v                < p a c k a g e . j s o n     X      )    '    pLl   v               < p a c k a g e . j s o n     P      *    '    Ll   v                < R E A D M E . m d   P      *    '    Ml   v               < R E A D M E . m d   P      *    '    hMl   v              < R E A D M E . m d   P      *    '    Ml   v                < R E A D M E . m d   P      *    '    Nl   v               < R E A D M E . m d   H      +        XNl   v               < l i b       H      +        Nl   v              < l i b       P      ,    +    Nl   v                < a t o b . j s       P      ,    +    8Ol   v               < a t o b . j s       P      ,    +    Ol   v              < a t o b . j s                                               P      ,    +     Pl   v                < a t o b . j s       P      ,    +    PPl   v               < a t o b . j s       P      -    +    Pl   v                < b t o a . j s       P      -    +    Pl   v               < b t o a . j s       P      -    +    @Ql   v              < b t o a . j s       P      -    +    Ql   v                < b t o a . j s       P      -    +    Ql   v               < b t o a . j s       H      .    	    0Rl   v               < b i n       H      .    	    xRl   v              < b i n       H      /    .    Rl   Dv               
 < a c o r n   H      /    .    Sl   Dv              
 < a c o r n   H      /    .    PSl   Dv             
 < a c o r n   H      /    .    Sl   Dv               
 < a c o r n   H      /    .    Sl   Dv              
 < a c o r n   H      0    	    (Tl   kv               < d i s t     H      0    	    pTl   kv              < d i s t     P      1    0    Tl   kv                < a c o r n . d . t s P      1    0    Ul   kv               < a c o r n . d . t s P      1    0    XUl   v              < a c o r n . d . t s P      1    0    Ul   v                < a c o r n . d . t s P      1    0    Ul   v               < a c o r n . d . t s P      2    0    HVl   v                < a c o r n . j s     P      2    0    Vl   v               < a c o r n . j s     P      2    0    Vl   v              < a c o r n . j s     P      2    0    8Wl   v                < a c o r n . j s     P      2    0    Wl   v               < a c o r n . j s     P      3    0    Wl   .v                < a c o r n . m j s   P      3    0    (Xl   Uv               < a c o r n . m j s   P      3    0    xXl   Uv              < a c o r n . m j s   P      3    0    Xl   }|v                < a c o r n . m j s   P      3    0    Yl   }|v               < a c o r n . m j s   X      4    0    hYl   v                < a c o r n . m j s . d . t s X      4    0    Yl   v               < a c o r n . m j s . d . t s X      4    0    Zl   v              < a c o r n . m j s . d . t s X      4    0    pZl   v                < a c o r n . m j s . d . t s X      4    0    Zl   v               < a c o r n . m j s . d . t s H      5    0     [l   nv                < b i n . j s H      5    0    h[l   fv               < b i n . j s H      5    0    [l   fv              < b i n . j s H      5    0    [l   fv                < b i n . j s H      5    0    @\l   fv               < b i n . j s H      6        \l   Vv               < l i b       H      6        \l   Vv              < l i b       P      7    6    ]l   Vv                < i n d e x . j s     P      7    6    h]l   O?v               < i n d e x . j s     P      7    6    ]l   O?v              < i n d e x . j s     P      7    6    ^l   O?v                < i n d e x . j s     P      7    6    X^l   O?v               < i n d e x . j s     P      8    6    ^l   Efv                < i n d e x . m j s   P      8    6    ^l   Efv               < i n d e x . m j s   P      8    6    H_l   Efv              < i n d e x . m j s   P      8    6    _l   Efv                < i n d e x . m j s                           P      8    6     `l   Efv               < i n d e x . m j s   H      9        P`l   6v               < s r c       H      9        `l   6v              < s r c       P      :    9    `l   6v                < i n d e x . j s     P      :    9    0al   6v               < i n d e x . j s     P      :    9    al   6v              < i n d e x . j s     P      :    9    al   6v                < i n d e x . j s     P      :    9     bl   6v               < i n d e x . j s     H      ;        pbl   5v              
 < c o d e c   H      ;        bl   5v             
 < c o d e c   X      <    ;     cl   5v                < a b s o l u t e . j s       X      <    ;    Xcl   5v               < a b s o l u t e . j s       X      <    ;    cl   v              < a b s o l u t e . j s       X      <    ;    dl   v                < a b s o l u t e . j s       X      <    ;    `dl   v               < a b s o l u t e . j s       `      =    ;    dl   v               $ < b o w e r - c o m p o n e n t . j s `      =    ;    el   
)v              $ < b o w e r - c o m p o n e n t . j s `      =    ;    xel   
)v             $ < b o w e r - c o m p o n e n t . j s `      =    ;    el   
)v               $ < b o w e r - c o m p o n e n t . j s `      =    ;    8fl   
)v              $ < b o w e r - c o m p o n e n t . j s P      >    ;    fl   Pv                < i n d e x . j s     P      >    ;    fl   Pv               < i n d e x . j s     P      >    ;    8gl   Pv              < i n d e x . j s     P      >    ;    gl   Pv                < i n d e x . j s     P      >    ;    gl   Pv               < i n d e x . j s     X      ?    ;    (hl   v                < n p m - m o d u l e . j s   X      ?    ;    hl   v               < n p m - m o d u l e . j s   X      ?    ;    hl   v              < n p m - m o d u l e . j s   X      ?    ;    0il   v                < n p m - m o d u l e . j s   X      ?    ;    il   v               < n p m - m o d u l e . j s   `      @    ;    il   v               $ < o u t p u t - r e l a t i v e . j s `      @    ;    @jl   v              $ < o u t p u t - r e l a t i v e . j s `      @    ;    jl   v             $ < o u t p u t - r e l a t i v e . j s `      @    ;     kl   v               $ < o u t p u t - r e l a t i v e . j s `      @    ;    `kl   v              $ < o u t p u t - r e l a t i v e . j s p      A    ;    kl   v               . < o u t p u t - r o o t - r e l a t i v e . j s       p      A    ;    0ll   v              . < o u t p u t - r o o t - r e l a t i v e . j s       p      A    ;    ll   v             . < o u t p u t - r o o t - r e l a t i v e . j s       p      A    ;    ml   v               . < o u t p u t - r o o t - r e l a t i v e . j s       p      A    ;    ml   v              . < o u t p u t - r o o t - r e l a t i v e . j s       h      B    ;    ml   9v               & < p r o j e c t - r e l a t i v e . j s       h      B    ;    Xnl   9v              & < p r o j e c t - r e l a t i v e . j s       h      B    ;    nl   `v             & < p r o j e c t - r e l a t i v e . j s       h      B    ;    (ol   `v               & < p r o j e c t - r e l a t i v e . j s       h      B    ;    ol   `v              & < p r o j e c t - r e l a t i v e . j s               p      C    ;     pl   v               0 < p r o j e c t - r o o t - r e l a t i v e . j s     p      C    ;    ppl   v              0 < p r o j e c t - r o o t - r e l a t i v e . j s     p      C    ;    pl   v             0 < p r o j e c t - r o o t - r e l a t i v e . j s     p      C    ;    Pql   v               0 < p r o j e c t - r o o t - r e l a t i v e . j s     p      C    ;    ql   v              0 < p r o j e c t - r o o t - r e l a t i v e . j s     `      D    ;    0rl   v               $ < s o u r c e - r e l a t i v e . j s `      D    ;    rl   v              $ < s o u r c e - r e l a t i v e . j s `      D    ;    rl   v             $ < s o u r c e - r e l a t i v e . j s `      D    ;    Psl   v               $ < s o u r c e - r e l a t i v e . j s `      D    ;    sl   v              $ < s o u r c e - r e l a t i v e . j s p      E    ;    tl   v               . < s o u r c e - r o o t - r e l a t i v e . j s       p      E    ;    tl   v              . < s o u r c e - r o o t - r e l a t i v e . j s       p      E    ;    tl   v             . < s o u r c e - r o o t - r e l a t i v e . j s       p      E    ;    `ul   v               . < s o u r c e - r o o t - r e l a t i v e . j s       p      E    ;    ul   v              . < s o u r c e - r o o t - r e l a t i v e . j s       h      F    ;    @vl   |#v               ( < w e b p a c k - b o o t s t r a p . j s     h      F    ;    vl   vJv              ( < w e b p a c k - b o o t s t r a p . j s     h      F    ;    wl   vJv             ( < w e b p a c k - b o o t s t r a p . j s     h      F    ;    xwl   vJv               ( < w e b p a c k - b o o t s t r a p . j s     h      F    ;    wl   vJv              ( < w e b p a c k - b o o t s t r a p . j s     h      G    ;    Hxl   nqv               & < w e b p a c k - p r o t o c o l . j s       h      G    ;    xl   nqv              & < w e b p a c k - p r o t o c o l . j s       h      G    ;    yl   _v             & < w e b p a c k - p r o t o c o l . j s       h      G    ;    yl   _v               & < w e b p a c k - p r o t o c o l . j s       h      G    ;    yl   _v              & < w e b p a c k - p r o t o c o l . j s       H      H        Pzl   qv               < l i b       H      H        zl   qv              < l i b       P      I    H    zl   qv                < l o a d e r . j s   P      I    H    0{l   qv               < l o a d e r . j s   P      I    H    {l   qv              < l o a d e r . j s   P      I    H    {l   qv                < l o a d e r . j s   P      I    H     |l   qv               < l o a d e r . j s   x      J    H    p|l   Bv               6 < m o d u l e - f i l e n a m e - t e m p l a t e . j s       x      J    H    |l   Bv              6 < m o d u l e - f i l e n a m e - t e m p l a t e . j s       x      J    H    `}l   Bv             6 < m o d u l e - f i l e n a m e - t e m p l a t e . j s       x      J    H    }l   Bv               6 < m o d u l e - f i l e n a m e - t e m p l a t e . j s       x      J    H    P~l   Bv              6 < m o d u l e - f i l e n a m e - t e m p l a t e . j s       H      K        ~l   44v               < s r c       H      K        l   44v              < s r c       P      L    K    Xl   44v                < i n d e x . t s     P      L    K    l   /[v               < i n d e x . t s             P      L    K     l   "v              < i n d e x . t s     P      L    K    Pl   "v                < i n d e x . t s     P      L    K    l   "v               < i n d e x . t s     X      M    K    l   v                < p r o m i s i f y . t s     X      M    K    Hl   v               < p r o m i s i f y . t s     X      M    K    l   v              < p r o m i s i f y . t s     X      M    K    l   v                < p r o m i s i f y . t s     X      M    K    Pl   v               < p r o m i s i f y . t s     H      N        l   v               < l i b       H      N        l   v              < l i b       P      O    N    8l   v                < a g e n t . j s     P      O    N    l   v               < a g e n t . j s     P      O    N    l   v              < a g e n t . j s     P      O    N    (l   v                < a g e n t . j s     P      O    N    xl   v               < a g e n t . j s     X      P    N    l   v                < c o n s t a n t s . j s     X      P    N     l   Dv               < c o n s t a n t s . j s     X      P    N    xl   Dv              < c o n s t a n t s . j s     X      P    N    l   Dv                < c o n s t a n t s . j s     X      P    N    (l   v               < c o n s t a n t s . j s     X      Q    N    l   v                < h t t p s _ a g e n t . j s X      Q    N    l   v               < h t t p s _ a g e n t . j s X      Q    N    0l   v              < h t t p s _ a g e n t . j s X      Q    N    l   v                < h t t p s _ a g e n t . j s X      Q    N    l   v               < h t t p s _ a g e n t . j s H      R    )    8l   .v               < d i s t     H      R    )    l   .v              < d i s t     P      S    R    l   .v                < 2 0 1 9 . d . t s   P      S    R    l   Uv               < 2 0 1 9 . d . t s   P      S    R    hl   Uv              < 2 0 1 9 . d . t s   P      S    R    l   |v                < 2 0 1 9 . d . t s   P      S    R    l   |v               < 2 0 1 9 . d . t s   P      T    R    Xl   v                < 2 0 1 9 . j s       P      T    R    l   v               < 2 0 1 9 . j s       P      T    R    l   v              < 2 0 1 9 . j s       P      T    R    Hl   v                < 2 0 1 9 . j s       P      T    R    l   v               < 2 0 1 9 . j s       X      U    R    l   v                < 2 0 1 9 . j s . m a p       X      U    R    @l   v               < 2 0 1 9 . j s . m a p       X      U    R    l   v              < 2 0 1 9 . j s . m a p       X      U    R    l   v                < 2 0 1 9 . j s . m a p       X      U    R    Hl   v               < 2 0 1 9 . j s . m a p       P      V    R    l   xv                < 2 0 2 0 . d . t s   P      V    R    l   mv               < 2 0 2 0 . d . t s   P      V    R    @l   mv              < 2 0 2 0 . d . t s   P      V    R    l   mv                < 2 0 2 0 . d . t s   P      V    R    l   mv               < 2 0 2 0 . d . t s   P      W    R    0l   b?v                < 2 0 2 0 . j s       P      W    R    l   b?v               < 2 0 2 0 . j s                                                       P      W    R     l   b?v              < 2 0 2 0 . j s       P      W    R    Pl   b?v                < 2 0 2 0 . j s       P      W    R    l   b?v               < 2 0 2 0 . j s       X      X    R    l   Ufv                < 2 0 2 0 . j s . m a p       X      X    R    Hl   Ufv               < 2 0 2 0 . j s . m a p       X      X    R    l   Ufv              < 2 0 2 0 . j s . m a p       X      X    R    l   Ufv                < 2 0 2 0 . j s . m a p       X      X    R    Pl   Ufv               < 2 0 2 0 . j s . m a p       P      Y    R    l   Ev                < a j v . d . t s     P      Y    R    l   Ev               < a j v . d . t s     P      Y    R    Hl   Ev              < a j v . d . t s     P      Y    R    l   Ev                < a j v . d . t s     P      Y    R    l   Ev               < a j v . d . t s     H      Z    R    8l   <v                < a j v . j s H      Z    R    l   <v               < a j v . j s H      Z    R    l   <v              < a j v . j s H      Z    R    l   <v                < a j v . j s H      Z    R    Xl   <v               < a j v . j s P      [    R    l   .v                < a j v . j s . m a p P      [    R    l   $)v               < a j v . j s . m a p P      [    R    @l   $)v              < a j v . j s . m a p P      [    R    l   $)v                < a j v . j s . m a p P      [    R    l   $)v               < a j v . j s . m a p P      \    R    0l   Pv                < c o r e . d . t s   P      \    R    l   Pv               < c o r e . d . t s   P      \    R    l   Pv              < c o r e . d . t s   P      \    R     l   Pv                < c o r e . d . t s   P      \    R    pl   Pv               < c o r e . d . t s   P      ]    R    l   wv                < c o r e . j s       P      ]    R    l   v               < c o r e . j s       P      ]    R    `l   v              < c o r e . j s       P      ]    R    l   v                < c o r e . j s       P      ]    R     l   v               < c o r e . j s       X      ^    R    Pl   v                < c o r e . j s . m a p       X      ^    R    l   v               < c o r e . j s . m a p       X      ^    R     l   v              < c o r e . j s . m a p       X      ^    R    Xl   v                < c o r e . j s . m a p       X      ^    R    l   v               < c o r e . j s . m a p       P      _    R    l   v                < j t d . d . t s     P      _    R    Xl   v               < j t d . d . t s     P      _    R    l   v              < j t d . d . t s     P      _    R    l   v                < j t d . d . t s     P      _    R    Hl   v               < j t d . d . t s     H      `    R    l   9v                < j t d . j s H      `    R    l   9v               < j t d . j s H      `    R    (l   9v              < j t d . j s H      `    R    pl   9v                < j t d . j s H      `    R    l   9v               < j t d . j s P      a    R     l   `v                < j t d . j s . m a p P      a    R    Pl   `v               < j t d . j s . m a p P      a    R    l   `v              < j t d . j s . m a p                 P      a    R     l   `v                < j t d . j s . m a p P      a    R    Pl   v               < j t d . j s . m a p H      b    )    l   v               < l i b       H      b    )    l   v              < l i b       P      c    b    0l   v                < 2 0 1 9 . t s       P      c    b    l   v               < 2 0 1 9 . t s       P      c    b    l   v              < 2 0 1 9 . t s       P      c    b     l   v                < 2 0 1 9 . t s       P      c    b    pl   v               < 2 0 1 9 . t s       P      d    b    l   v                < 2 0 2 0 . t s       P      d    b    l   v               < 2 0 2 0 . t s       P      d    b    `l   v              < 2 0 2 0 . t s       P      d    b    l   v                < 2 0 2 0 . t s       P      d    b     l   v               < 2 0 2 0 . t s       H      e    b    Pl   #v                < a j v . t s H      e    b    l   #v               < a j v . t s H      e    b    l   #v              < a j v . t s H      e    b    (l   #v                < a j v . t s H      e    b    pl   #v               < a j v . t s P      f    b    l   Jv                < c o r e . t s       P      f    b    l   Jv               < c o r e . t s       P      f    b    Xl   Jv              < c o r e . t s       P      f    b    l   Jv                < c o r e . t s       P      f    b    l   Jv               < c o r e . t s       H      g    b    Hl   qv                < j t d . t s H      g    b    l   qv               < j t d . t s H      g    b    l   v              < j t d . t s H      g    b     l   v                < j t d . t s H      g    b    hl   v               < j t d . t s H      h    .    l   v               < d i s t     H      h    .    l   mv              < d i s t     X      i    h    @l   mv                < f o r m a t s . d . t s     X      i    h    l   mv               < f o r m a t s . d . t s     X      i    h    l   bv              < f o r m a t s . d . t s     X      i    h    Hl   bv                < f o r m a t s . d . t s     X      i    h    l   bv               < f o r m a t s . d . t s     P      j    h    l   Tv                < f o r m a t s . j s P      j    h    Hl   Tv               < f o r m a t s . j s P      j    h    l   Tv              < f o r m a t s . j s P      j    h    l   Tv                < f o r m a t s . j s P      j    h    8l   Tv               < f o r m a t s . j s X      k    h    l   J4v                < f o r m a t s . j s . m a p X      k    h    l   J4v               < f o r m a t s . j s . m a p X      k    h    8l   J4v              < f o r m a t s . j s . m a p X      k    h    l   J4v                < f o r m a t s . j s . m a p X      k    h    l   J4v               < f o r m a t s . j s . m a p P      l    h    @l   B[v                < i n d e x . d . t s P      l    h    l   /v               < i n d e x . d . t s P      l    h    l   /v              < i n d e x . d . t s P      l    h    0l   /v                < i n d e x . d . t s P      l    h    l   /v               < i n d e x . d . t s                                                 P      m    h     l   *v                < i n d e x . j s     P      m    h    Pl   *v               < i n d e x . j s     P      m    h    l   *v              < i n d e x . j s     P      m    h    l   *v                < i n d e x . j s     P      m    h    @l   *v               < i n d e x . j s     X      n    h    l   v                < i n d e x . j s . m a p     X      n    h    l   v               < i n d e x . j s . m a p     X      n    h    @l   v              < i n d e x . j s . m a p     X      n    h    l   v                < i n d e x . j s . m a p     X      n    h    l   v               < i n d e x . j s . m a p     P      o    h    Hl   v                < l i m i t . d . t s P      o    h    l   v               < l i m i t . d . t s P      o    h    l   v              < l i m i t . d . t s P      o    h    8l   v                < l i m i t . d . t s P      o    h    l   v               < l i m i t . d . t s P      p    h    l   Ev                < l i m i t . j s     P      p    h    (l   Ev               < l i m i t . j s     P      p    h    xl   Ev              < l i m i t . j s     P      p    h    l   Ev                < l i m i t . j s     P      p    h    l   Ev               < l i m i t . j s     X      q    h    hl    lv                < l i m i t . j s . m a p     X      q    h    l    lv               < l i m i t . j s . m a p     X      q    h    l    lv              < l i m i t . j s . m a p     X      q    h    pl    lv                < l i m i t . j s . m a p     X      q    h    l    lv               < l i m i t . j s . m a p     H      r    .     l   v               < s r c       H      r    .    hl   v              < s r c       P      s    r    l   v                < f o r m a t s . t s P      s    r     l   v               < f o r m a t s . t s P      s    r    Pl   v              < f o r m a t s . t s P      s    r    l   v                < f o r m a t s . t s P      s    r    l   v               < f o r m a t s . t s P      t    r    @l   v                < i n d e x . t s     P      t    r    l   v               < i n d e x . t s     P      t    r    l   v              < i n d e x . t s     P      t    r    0l   v                < i n d e x . t s     P      t    r    l   v               < i n d e x . t s     P      u    r    l   v                < l i m i t . t s     P      u    r     l   .v               < l i m i t . t s     P      u    r    pl   .v              < l i m i t . t s     P      u    r    l   .v                < l i m i t . t s     P      u    r    l   .v               < l i m i t . t s     H      v    2    `l   Uv               < d i s t     H      v    2    l   Uv              < d i s t     P      w    v    l   Uv                < i n d e x . d . t s P      w    v    @l   Uv               < i n d e x . d . t s P      w    v    l   Uv              < i n d e x . d . t s P      w    v    l   Uv                < i n d e x . d . t s P      w    v    0l   Uv               < i n d e x . d . t s P      x    v    l   |v                < i n d e x . j s                                                     P      x    v     l   |v               < i n d e x . j s     P      x    v    Pl   |v              < i n d e x . j s     P      x    v    l   v                < i n d e x . j s     P      x    v    l   v               < i n d e x . j s     X      y    v    @l   v                < i n d e x . j s . m a p     X      y    v    l   v               < i n d e x . j s . m a p     X      y    v    l   v              < i n d e x . j s . m a p     X      y    v    Hl   v                < i n d e x . j s . m a p     X      y    v    l   v               < i n d e x . j s . m a p     H      z    2    l   v               < s r c       H      z    2    @l   v              < s r c       P      {    z    l   v                < i n d e x . t s     P      {    z    l   }v               < i n d e x . t s     P      {    z    (l   }v              < i n d e x . t s     P      {    z    xl   }v                < i n d e x . t s     P      {    z    l   }v               < i n d e x . t s     H      |    6    l   ?v              
 < t y p e s   H      |    6    `l   ?v             
 < t y p e s   P      }    |    l   ?v                < i n d e x . d . t s P      }    |    l   gfv               < i n d e x . d . t s P      }    |    Hl   gfv              < i n d e x . d . t s P      }    |    l   gfv                < i n d e x . d . t s P      }    |    l   gfv               < i n d e x . d . t s H      ~    B    8l   bv               < b i n       H      ~    B    l   bv              < b i n       P          ~    l   bv                < a n s i - h t m l   P          ~    l   Yv               < a n s i - h t m l   P          ~    hl   Yv              < a n s i - h t m l   P          ~    l   Yv                < a n s i - h t m l   P          ~    l   Yv               < a n s i - h t m l   H          ^    Xl   *Pv               < l i b       H          ^    l   *Pv              < l i b       P              l   *Pv                < i n d e x . j s     P              8l   v               < i n d e x . j s     P              l   v              < i n d e x . j s     P              l   v                < i n d e x . j s     P              (l   v               < i n d e x . j s     `              xl   v                < t r a c k e r - b a s e . j s       `              l   v               < t r a c k e r - b a s e . j s       `              8l   v              < t r a c k e r - b a s e . j s       `              l   v                < t r a c k e r - b a s e . j s       `              l   v               < t r a c k e r - b a s e . j s       `              Xl   v                 < t r a c k e r - g r o u p . j s     `              l   v                < t r a c k e r - g r o u p . j s     `              l   v               < t r a c k e r - g r o u p . j s     `              xl   v                 < t r a c k e r - g r o u p . j s     `              l   v                < t r a c k e r - g r o u p . j s     `              8l   9v               " < t r a c k e r - s t r e a m . j s   `              l   `v              " < t r a c k e r - s t r e a m . j s           `               l   `v             " < t r a c k e r - s t r e a m . j s   `              `l   `v               " < t r a c k e r - s t r e a m . j s   `              l   `v              " < t r a c k e r - s t r e a m . j s   P               l   v                < t r a c k e r . j s P              pl   v               < t r a c k e r . j s P              l   v              < t r a c k e r . j s P              l   v                < t r a c k e r . j s P              `l   v               < t r a c k e r . j s H          b    l   v               < l i b       H          b    l   v              < l i b       P              @l   v                < a c t i o n . j s   P              l   v               < a c t i o n . j s   P              l   v              < a c t i o n . j s   P              0l   v                < a c t i o n . j s   P              l   v               < a c t i o n . j s   h              l   v               & < a c t i o n _ c o n t a i n e r . j s       h              8l   v              & < a c t i o n _ c o n t a i n e r . j s       h              l   v             & < a c t i o n _ c o n t a i n e r . j s       h              l   #v               & < a c t i o n _ c o n t a i n e r . j s       h              pl   #v              & < a c t i o n _ c o n t a i n e r . j s       X              l   #v                < a r g p a r s e . j s       X              0l   Jv               < a r g p a r s e . j s       X              l   Jv              < a r g p a r s e . j s       X              l   Jv                < a r g p a r s e . j s       X              8l   Jv               < a r g p a r s e . j s       `              l   qv               $ < a r g u m e n t _ p a r s e r . j s `              l   qv              $ < a r g u m e n t _ p a r s e r . j s `              Pl   v             $ < a r g u m e n t _ p a r s e r . j s `              l   v               $ < a r g u m e n t _ p a r s e r . j s `              l   v              $ < a r g u m e n t _ p a r s e r . j s P              pl   v                < c o n s t . j s     P              l   v               < c o n s t . j s     P              l   v              < c o n s t . j s     P              `l   v                < c o n s t . j s     P              l   v               < c o n s t . j s     X               l   lv                < n a m e s p a c e . j s     X              Xl   lv               < n a m e s p a c e . j s     X              l   lv              < n a m e s p a c e . j s     X              l   lv                < n a m e s p a c e . j s     X              `l   lv               < n a m e s p a c e . j s     P              l   d4v                < u t i l s . j s     P              l   d4v               < u t i l s . j s     P              Xl   d4v              < u t i l s . j s     P              l   d4v                < u t i l s . j s     P              l   d4v               < u t i l s . j s     H          t    Hl   X[v               < d i s t     H          t    l   X[v              < d i s t                                             P               l   Mv                < a s y n c . j s     P              Pl   =v               < a s y n c . j s     P              l   =v              < a s y n c . j s     P              l   6v                < a s y n c . j s     P              @l   6v               < a s y n c . j s     X              l   )v                < a s y n c . m i n . j s     X              l   )v               < a s y n c . m i n . j s     X              @l   )v              < a s y n c . m i n . j s     X              l   )v                < a s y n c . m i n . j s     X              l   )v               < a s y n c . m i n . j s     X              Hl   "v                < a s y n c . m i n . m a p   X              l   Ev               < a s y n c . m i n . m a p   X              l   lv              < a s y n c . m i n . m a p   X              Pl   lv                < a s y n c . m i n . m a p   X              l   lv               < a s y n c . m i n . m a p   P          t     l   lv               < i n t e r n a l     P          t    Pl   v              < i n t e r n a l     X              l   v                < a p p l y E a c h . j s     X              l   v               < a p p l y E a c h . j s     X              Pl   v              < a p p l y E a c h . j s     X              l   v                < a p p l y E a c h . j s     X               l   v               < a p p l y E a c h . j s     X              Xl   v                < b r e a k L o o p . j s     X              l   v               < b r e a k L o o p . j s     X              l   v              < b r e a k L o o p . j s     X              `l   v                < b r e a k L o o p . j s     X              l   v               < b r e a k L o o p . j s     X              l   v                < c o n s o l e F u n c . j s X              hl   v               < c o n s o l e F u n c . j s X              l   v              < c o n s o l e F u n c . j s X              l   v                < c o n s o l e F u n c . j s X              pl   v               < c o n s o l e F u n c . j s `              l   .v                < c r e a t e T e s t e r . j s       `              (l   .v               < c r e a t e T e s t e r . j s       `              l   .v              < c r e a t e T e s t e r . j s       `              l   Uv                < c r e a t e T e s t e r . j s       `              Hl   Uv               < c r e a t e T e s t e r . j s       P              l   |v                < d o L i m i t . j s P              l   |v               < d o L i m i t . j s P              Hl   |v              < d o L i m i t . j s P              l   |v                < d o L i m i t . j s P              l   |v               < d o L i m i t . j s X              8l   v                < d o P a r a l l e l . j s   X              l   v               < d o P a r a l l e l . j s   X              l   v              < d o P a r a l l e l . j s   X              @l   v                < d o P a r a l l e l . j s   X              l   v               < d o P a r a l l e l . j s                   `               l   v               $ < d o P a r a l l e l L i m i t . j s `              `l   v              $ < d o P a r a l l e l L i m i t . j s `              l   v             $ < d o P a r a l l e l L i m i t . j s `               l   v               $ < d o P a r a l l e l L i m i t . j s `              l   v              $ < d o P a r a l l e l L i m i t . j s h              l   ?v               & < D o u b l y L i n k e d L i s t . j s       h              Hl   ?v              & < D o u b l y L i n k e d L i s t . j s       h              l   ?v             & < D o u b l y L i n k e d L i s t . j s       h              l   fv               & < D o u b l y L i n k e d L i s t . j s       h              l   fv              & < D o u b l y L i n k e d L i s t . j s       X              l   tv                < e a c h O f L i m i t . j s X              @l   tv               < e a c h O f L i m i t . j s X              l   tv              < e a c h O f L i m i t . j s X              l   tv                < e a c h O f L i m i t . j s X              Hl   tv               < e a c h O f L i m i t . j s P              l   nv                < f i l t e r . j s   P              l   nv               < f i l t e r . j s   P              @l   nv              < f i l t e r . j s   P              l   nv                < f i l t e r . j s   P              l   nv               < f i l t e r . j s   `              0l   _v                 < f i n d G e t R e s u l t . j s     `              l   Yv                < f i n d G e t R e s u l t . j s     `              l   Yv               < f i n d G e t R e s u l t . j s     `              Pl   Yv                 < f i n d G e t R e s u l t . j s     `              l   Yv                < f i n d G e t R e s u l t . j s     X              l   S)v                < g e t I t e r a t o r . j s X              hl   S)v               < g e t I t e r a t o r . j s X              l   FPv              < g e t I t e r a t o r . j s X              l   FPv                < g e t I t e r a t o r . j s X              pl   FPv               < g e t I t e r a t o r . j s `              l   8wv                 < i n i t i a l P a r a m s . j s     `              (l   8wv                < i n i t i a l P a r a m s . j s     `              l   8wv               < i n i t i a l P a r a m s . j s     `              l   8wv                 < i n i t i a l P a r a m s . j s     `              Hl   8wv                < i n i t i a l P a r a m s . j s     X              l   )v                < i t e r a t o r . j s       X               l   "v               < i t e r a t o r . j s       X              Xl   "v              < i t e r a t o r . j s       X              l   "v                < i t e r a t o r . j s       X              l   "v               < i t e r a t o r . j s       H              `l   sv                < m a p . j s H              l   sv               < m a p . j s H              l   v              < m a p . j s H              8l   v                < m a p . j s H              l   v               < m a p . j s                                                         P                m   &v                < n o t I d . j s     P              P m   v               < n o t I d . j s     P               m   v              < n o t I d . j s     P               m   v                < n o t I d . j s     P              @m   v               < n o t I d . j s     P              m   v                < o n c e . j s       P              m   v               < o n c e . j s       P              0m   v              < o n c e . j s       P              m   v                < o n c e . j s       P              m   v               < o n c e . j s       X               m   v                < o n l y O n c e . j s       X              xm   v               < o n l y O n c e . j s       X              m   v              < o n l y O n c e . j s       X              (m   v                < o n l y O n c e . j s       X              m   v               < o n l y O n c e . j s       X              m   7v                < p a r a l l e l . j s       X              0m   7v               < p a r a l l e l . j s       X              m   7v              < p a r a l l e l . j s       X              m   7v                < p a r a l l e l . j s       X              8m   7v               < p a r a l l e l . j s       P              m   ^v                < q u e u e . j s     P              m   ^v               < q u e u e . j s     P              0m   ^v              < q u e u e . j s     P              m   ^v                < q u e u e . j s     P              m   ^v               < q u e u e . j s     P               m   v                < r e j e c t . j s   P              pm   v               < r e j e c t . j s   P              m   v              < r e j e c t . j s   P              	m   v                < r e j e c t . j s   P              `	m   v               < r e j e c t . j s   `              	m   {v                < s e t I m m e d i a t e . j s       `              
m   {v               < s e t I m m e d i a t e . j s       `              p
m   {v              < s e t I m m e d i a t e . j s       `              
m   {v                < s e t I m m e d i a t e . j s       `              0m   {v               < s e t I m m e d i a t e . j s       P              m   nv                < s l i c e . j s     P              m   nv               < s l i c e . j s     P              0m   nv              < s l i c e . j s     P              m   nv                < s l i c e . j s     P              m   nv               < s l i c e . j s     `               m   b!v                < w i t h o u t I n d e x . j s       `              m   XHv               < w i t h o u t I n d e x . j s       `              m   XHv              < w i t h o u t I n d e x . j s       `              @m   XHv                < w i t h o u t I n d e x . j s       `              m   XHv               < w i t h o u t I n d e x . j s       X               m   Dv                < w r a p A s y n c . j s     X              Xm   Dv               < w r a p A s y n c . j s                                                                                     X               m   Dv              < w r a p A s y n c . j s     X              Xm   Hv                < w r a p A s y n c . j s     X              m   Hv               < w r a p A s y n c . j s     H              m   7v               < b i n       H              Pm   7v              < b i n       P              m   7v                < a t o b . j s       P              m   7v               < a t o b . j s       P              8m   7v              < a t o b . j s       P              m   7v                < a t o b . j s       P              m   7v               < a t o b . j s       H              (m   $v               < b i n       H              pm   $v              < b i n       X              m   $v                < a u t o p r e f i x e r     X              m   2v               < a u t o p r e f i x e r     X              hm   2v              < a u t o p r e f i x e r     X              m   2v                < a u t o p r e f i x e r     X              m   2v               < a u t o p r e f i x e r     H              pm   Yv               < d a t a     H              m   Yv              < d a t a     X               m   Yv                < p r e f i x e s . j s       X              Xm   v               < p r e f i x e s . j s       X              m   v              < p r e f i x e s . j s       X              m   v                < p r e f i x e s . j s       X              `m   v               < p r e f i x e s . j s       H              m   v               < l i b       H               m   v              < l i b       P              Hm   v                < a t - r u l e . j s P              m   v               < a t - r u l e . j s P              m   v              < a t - r u l e . j s P              8m   v                < a t - r u l e . j s P              m   v               < a t - r u l e . j s `              m   v               " < a u t o p r e f i x e r . d . t s   `              8m   v              " < a u t o p r e f i x e r . d . t s   `              m   v             " < a u t o p r e f i x e r . d . t s   `              m   v               " < a u t o p r e f i x e r . d . t s   `              Xm   v              " < a u t o p r e f i x e r . d . t s   `              m   v                < a u t o p r e f i x e r . j s       `              m   v               < a u t o p r e f i x e r . j s       `              xm   v              < a u t o p r e f i x e r . j s       `              m   Bv                < a u t o p r e f i x e r . j s       `              8m   Bv               < a u t o p r e f i x e r . j s       X              m   Bv                < b r a c k e t s . j s       X              m   iv               < b r a c k e t s . j s       X              Hm   iv              < b r a c k e t s . j s       X              m   iv                < b r a c k e t s . j s       X              m   iv               < b r a c k e t s . j s       X              Pm   v                < b r o w s e r s . j s       X              m   v               < b r o w s e r s . j s       X                m   v              < b r o w s e r s . j s       X              X m   v                < b r o w s e r s . j s       X               m   v               < b r o w s e r s . j s       X              !m   v                < d e c l a r a t i o n . j s X              `!m   v               < d e c l a r a t i o n . j s X              !m   v              < d e c l a r a t i o n . j s X              "m   v                < d e c l a r a t i o n . j s X              h"m   v               < d e c l a r a t i o n . j s P              "m   v                < i n f o . j s       P              #m   v               < i n f o . j s       P              `#m   v              < i n f o . j s       P              #m   v                < i n f o . j s       P               $m   v               < i n f o . j s       `              P$m   ,v                < o l d - s e l e c t o r . j s       `              $m   ,v               < o l d - s e l e c t o r . j s       `              %m   ,v              < o l d - s e l e c t o r . j s       `              p%m   ,v                < o l d - s e l e c t o r . j s       `              %m   ,v               < o l d - s e l e c t o r . j s       X              0&m   Sv                < o l d - v a l u e . j s     X              &m   Sv               < o l d - v a l u e . j s     X              &m   Sv              < o l d - v a l u e . j s     X              8'm   zzv                < o l d - v a l u e . j s     X              'm   zzv               < o l d - v a l u e . j s     X              'm   mv                < p r e f i x e r . j s       X              @(m   mv               < p r e f i x e r . j s       X              (m   mv              < p r e f i x e r . j s       X              (m   mv                < p r e f i x e r . j s       X              H)m   mv               < p r e f i x e r . j s       X              )m   Ov                < p r e f i x e s . j s       X              )m   Ov               < p r e f i x e s . j s       X              P*m   Ov              < p r e f i x e s . j s       X              *m   Ov                < p r e f i x e s . j s       X               +m   Ov               < p r e f i x e s . j s       X              X+m   E=v                < p r o c e s s o r . j s     X              +m   E=v               < p r o c e s s o r . j s     X              ,m   E=v              < p r o c e s s o r . j s     X              `,m   E=v                < p r o c e s s o r . j s     X              ,m   E=v               < p r o c e s s o r . j s     X              -m   Fdv                < r e s o l u t i o n . j s   X              h-m   Fdv               < r e s o l u t i o n . j s   X              -m   Fdv              < r e s o l u t i o n . j s   X              .m   Fdv                < r e s o l u t i o n . j s   X              p.m   Fdv               < r e s o l u t i o n . j s   X              .m   3v                < s e l e c t o r . j s       X               /m   3v               < s e l e c t o r . j s       X              x/m   3v              < s e l e c t o r . j s                                                       X               0m   3v                < s e l e c t o r . j s       X              X0m   3v               < s e l e c t o r . j s       X              0m   *v                < s u p p o r t s . j s       X              1m   *v               < s u p p o r t s . j s       X              `1m   *v              < s u p p o r t s . j s       X              1m   *v                < s u p p o r t s . j s       X              2m   *v               < s u p p o r t s . j s       X              h2m   /v                < t r a n s i t i o n . j s   X              2m    v               < t r a n s i t i o n . j s   X              3m    v              < t r a n s i t i o n . j s   X              p3m    v                < t r a n s i t i o n . j s   X              3m    v               < t r a n s i t i o n . j s   P               4m   'v                < u t i l s . j s     P              p4m   'v               < u t i l s . j s     P              4m   'v              < u t i l s . j s     P              5m   'v                < u t i l s . j s     P              `5m   'v               < u t i l s . j s     P              5m   Mv                < v a l u e . j s     P               6m   Mv               < v a l u e . j s     P              P6m   Mv              < v a l u e . j s     P              6m   Mv                < v a l u e . j s     P              6m   Mv               < v a l u e . j s     P              @7m   v                < v e n d o r . j s   P              7m   v               < v e n d o r . j s   P              7m   v              < v e n d o r . j s   P              08m   v                < v e n d o r . j s   P              8m   v               < v e n d o r . j s   H              8m   v               < l i b       H              9m   v              < l i b       P              `9m   v                < c a c h e . j s     P              9m   v               < c a c h e . j s     P               :m   v              < c a c h e . j s     P              P:m   v                < c a c h e . j s     P              :m   v               < c a c h e . j s     P              :m   7v                < E r r o r . j s     P              @;m   7v               < E r r o r . j s     P              ;m   7v              < E r r o r . j s     P              ;m   7v                < E r r o r . j s     P              0<m   7v               < E r r o r . j s     P              <m   ^v                < i n d e x . j s     P              <m   ^v               < i n d e x . j s     P               =m   ^v              < i n d e x . j s     P              p=m   ^v                < i n d e x . j s     P              =m   ^v               < i n d e x . j s     `              >m   v                < i n j e c t C a l l e r . j s       `              p>m   v               < i n j e c t C a l l e r . j s       `              >m   v              < i n j e c t C a l l e r . j s       `              0?m   v                < i n j e c t C a l l e r . j s       `              ?m   v               < i n j e c t C a l l e r . j s                       X               @m   v                < s c h e m a . j s o n       X              X@m   v               < s c h e m a . j s o n       X              @m   v              < s c h e m a . j s o n       X              Am   v                < s c h e m a . j s o n       X              `Am   v               < s c h e m a . j s o n       X              Am   z!v                < t r a n s f o r m . j s     X              Bm   z!v               < t r a n s f o r m . j s     X              hBm   z!v              < t r a n s f o r m . j s     X              Bm   z!v                < t r a n s f o r m . j s     X              Cm   z!v               < t r a n s f o r m . j s     H              pCm   oHv               < l i b       H              Cm   oHv              < l i b       P               Dm   eov                < i n d e x . j s     P              PDm   eov               < i n d e x . j s     P              Dm   eov              < i n d e x . j s     P              Dm   [v                < i n d e x . j s     P              @Em   [v               < i n d e x . j s     P              Em   Rv                < u t i l s . j s     P              Em   Rv               < u t i l s . j s     P              0Fm   Rv              < u t i l s . j s     P              Fm   Rv                < u t i l s . j s     P              Fm   Rv               < u t i l s . j s     H               Gm   @v               < l i b       H              hGm   @v              < l i b       P              Gm   @v                < i n d e x . j s     P               Hm   @v               < i n d e x . j s     P              PHm   @v              < i n d e x . j s     P              Hm   @v                < i n d e x . j s     P              Hm   @v               < i n d e x . j s     p              @Im   <v               . < l o a d - n y c - c o n f i g - s y n c . j s       p              Im   <v              . < l o a d - n y c - c o n f i g - s y n c . j s       p               Jm   22v             . < l o a d - n y c - c o n f i g - s y n c . j s       p              Jm   22v               . < l o a d - n y c - c o n f i g - s y n c . j s       p               Km   22v              . < l o a d - n y c - c o n f i g - s y n c . j s       H              pKm   %Yv               < e s m       H              Km   %Yv              < e s m       P               Lm   %Yv                < i n d e x . m j s   P              PLm   v               < i n d e x . m j s   P              Lm   v              < i n d e x . m j s   P              Lm   v                < i n d e x . m j s   P              @Mm   v               < i n d e x . m j s   X              Mm   v                < i n d e x . m j s . m a p   X              Mm   v               < i n d e x . m j s . m a p   X              @Nm   v              < i n d e x . m j s . m a p   X              Nm   v                < i n d e x . m j s . m a p   X              Nm   v               < i n d e x . m j s . m a p   H              HOm   v               < l i b       H              Om   v              < l i b                                                              Pm   v               D < a d d - p l a t f o r m - s p e c i f i c - p o l y f i l l s . j s               Pm   v              D < a d d - p l a t f o r m - s p e c i f i c - p o l y f i l l s . j s                Qm   v             D < a d d - p l a t f o r m - s p e c i f i c - p o l y f i l l s . j s               Qm   v               D < a d d - p l a t f o r m - s p e c i f i c - p o l y f i l l s . j s                Rm   v              D < a d d - p l a t f o r m - s p e c i f i c - p o l y f i l l s . j s p              Rm   v               . < b u i l t - i n - d e f i n i t i o n s . j s       p              Rm   Bv              . < b u i l t - i n - d e f i n i t i o n s . j s       p              `Sm   Bv             . < b u i l t - i n - d e f i n i t i o n s . j s       p              Sm   Bv               . < b u i l t - i n - d e f i n i t i o n s . j s       p              @Tm   Bv              . < b u i l t - i n - d e f i n i t i o n s . j s       P              Tm   iv                < h e l p e r s . j s P               Um   iv               < h e l p e r s . j s P              PUm   iv              < h e l p e r s . j s P              Um   iv                < h e l p e r s . j s P              Um   iv               < h e l p e r s . j s P              @Vm   v                < i n d e x . j s     P              Vm   v               < i n d e x . j s     P              Vm   v              < i n d e x . j s     P              0Wm   v                < i n d e x . j s     P              Wm   v               < i n d e x . j s     X              Wm   v               < c o r e - j s - c o m p a t X              (Xm   v              < c o r e - j s - c o m p a t P              Xm   v                < d a t a . j s       P              Xm   ,v               < d a t a . j s       P               Ym   ,v              < d a t a . j s       P              pYm   ,v                < d a t a . j s       P              Ym   ,v               < d a t a . j s       P              Zm   Sv                < e n t r i e s . j s P              `Zm   Sv               < e n t r i e s . j s P              Zm   Sv              < e n t r i e s . j s P               [m   zv                < e n t r i e s . j s P              P[m   zv               < e n t r i e s . j s               [m   v               L < g e t - m o d u l e s - l i s t - f o r - t a r g e t - v e r s i o n . j s               (\m   v              L < g e t - m o d u l e s - l i s t - f o r - t a r g e t - v e r s i o n . j s               \m   v             L < g e t - m o d u l e s - l i s t - f o r - t a r g e t - v e r s i o n . j s               8]m   v               L < g e t - m o d u l e s - l i s t - f o r - t a r g e t - v e r s i o n . j s               ]m   v              L < g e t - m o d u l e s - l i s t - f o r - t a r g e t - v e r s i o n . j s P              H^m   v                < R E A D M E . m d   P              ^m   nv               < R E A D M E . m d   P              ^m   nv              < R E A D M E . m d   P              8_m   nv                < R E A D M E . m d   P              _m   nv               < R E A D M E . m d                                           H               `m   ev               < e s m       H              H`m   ev              < e s m       P              `m   ev                < i n d e x . m j s   P              `m   j=v               < i n d e x . m j s   P              0am   j=v              < i n d e x . m j s   P              am   j=v                < i n d e x . m j s   P              am   j=v               < i n d e x . m j s   X               bm   Tdv                < i n d e x . m j s . m a p   X              xbm   Bv               < i n d e x . m j s . m a p   X              bm   Bv              < i n d e x . m j s . m a p   X              (cm   Bv                < i n d e x . m j s . m a p   X              cm   Bv               < i n d e x . m j s . m a p   H              cm   7v               < l i b       H               dm   7v              < l i b       p              hdm   7v               . < b u i l t - i n - d e f i n i t i o n s . j s       p              dm   .v              . < b u i l t - i n - d e f i n i t i o n s . j s       p              Hem   .v             . < b u i l t - i n - d e f i n i t i o n s . j s       p              em   .v               . < b u i l t - i n - d e f i n i t i o n s . j s       p              (fm   .v              . < b u i l t - i n - d e f i n i t i o n s . j s       P              fm     v                < i n d e x . j s     P              fm     v               < i n d e x . j s     P              8gm     v              < i n d e x . j s     P              gm   'v                < i n d e x . j s     P              gm   'v               < i n d e x . j s     h              (hm   Nv               ( < s h i p p e d - p r o p o s a l s . j s     h              hm   Nv              ( < s h i p p e d - p r o p o s a l s . j s     h              hm   Nv             ( < s h i p p e d - p r o p o s a l s . j s     h              `im   Nv               ( < s h i p p e d - p r o p o s a l s . j s     h              im   Nv              ( < s h i p p e d - p r o p o s a l s . j s     P              0jm   uv                < u t i l s . j s     P              jm   uv               < u t i l s . j s     P              jm   v              < u t i l s . j s     P               km   v                < u t i l s . j s     P              pkm   v               < u t i l s . j s     H              km   v               < e s m       H              lm   v              < e s m       P              Plm   v                < i n d e x . m j s   P              lm   v               < i n d e x . m j s   P              lm   v              < i n d e x . m j s   P              @mm   v                < i n d e x . m j s   P              mm   v               < i n d e x . m j s   X              mm   v                < i n d e x . m j s . m a p   X              8nm   v               < i n d e x . m j s . m a p   X              nm   v              < i n d e x . m j s . m a p   X              nm   v                < i n d e x . m j s . m a p   X              @om   v               < i n d e x . m j s . m a p   H              om   7v               < l i b                                       H               pm   7v              < l i b       P              Hpm   7v                < i n d e x . j s     P              pm   ^v               < i n d e x . j s     P              pm   ^v              < i n d e x . j s     P              8qm   ^v                < i n d e x . j s     P              qm   ^v               < i n d e x . j s     P              qm   v               < . g i t h u b       P              (rm   v              < . g i t h u b       X              xrm   !v                < F U N D I N G . y m l       X              rm   !v               < F U N D I N G . y m l       X              (sm   !v              < F U N D I N G . y m l       X              sm   !v                < F U N D I N G . y m l       X              sm   !v               < F U N D I N G . y m l       H              0tm   Hv               < l i b       H              xtm   Hv              < l i b       X              tm   Hv                < b a s e 6 4 i d . j s       X              um   ov               < b a s e 6 4 i d . j s       X              pum   yv              < b a s e 6 4 i d . j s       X              um   yv                < b a s e 6 4 i d . j s       X               vm   yv               < b a s e 6 4 i d . j s       H          5    xvm   yv               < t e s t     H          5    vm   yv              < t e s t     P              wm   jv                < c o n v e r t . j s P              Xwm   jv               < c o n v e r t . j s P              wm   jv              < c o n v e r t . j s P              wm   jv                < c o n v e r t . j s P              Hxm   av               < c o n v e r t . j s P              xm   av                < i n d e x O f . j s P              xm   Lv               < i n d e x O f . j s P              8ym   Lv              < i n d e x O f . j s P              ym   Lv                < i n d e x O f . j s P              ym   Lv               < i n d e x O f . j s `              (zm   @2v                < i s B u f f e r L i s t . j s       `              zm   @2v               < i s B u f f e r L i s t . j s       `              zm   @2v              < i s B u f f e r L i s t . j s       `              H{m   @2v                < i s B u f f e r L i s t . j s       `              {m   @2v               < i s B u f f e r L i s t . j s       P              |m   7Yv                < t e s t . j s       P              X|m   7Yv               < t e s t . j s       P              |m   7Yv              < t e s t . j s       P              |m   7Yv                < t e s t . j s       P              H}m   7Yv               < t e s t . j s       H          <    }m   ,v               < l i b       H          <    }m   ,v              < l i b       P              (~m   ,v                < r e a d . j s       P              x~m   v               < r e a d . j s       P              ~m   v              < r e a d . j s       P              m   v                < r e a d . j s       P              hm   v               < r e a d . j s       H          C    m   v               < l i b       H          C     m   v              < l i b       P              Hm   v                < b r o w s e r . j s P              m   v               < b r o w s e r . j s P              m   v              < b r o w s e r . j s P              8m   v                < b r o w s e r . j s P              m   v               < b r o w s e r . j s X              m   v                < m d n s - s e r v e r . j s X              0m   v               < m d n s - s e r v e r . j s X              m   v              < m d n s - s e r v e r . j s X              m   v                < m d n s - s e r v e r . j s X              8m   v               < m d n s - s e r v e r . j s X              m   Bv                < r e g i s t r y . j s       X              m   Bv               < r e g i s t r y . j s       X              @m   Bv              < r e g i s t r y . j s       X              m   Bv                < r e g i s t r y . j s       X              m   Bv               < r e g i s t r y . j s       P              Hm   iv                < s e r v i c e . j s P              m   iv               < s e r v i c e . j s P              m   iv              < s e r v i c e . j s P              8m   iv                < s e r v i c e . j s P              m   v               < s e r v i c e . j s H          C    m   v               < t e s t     H          C     m   v              < t e s t     P              hm   v                < b o n j o u r . j s P              m   v               < b o n j o u r . j s P              m   v              < b o n j o u r . j s P              Xm   v                < b o n j o u r . j s P              m   v               < b o n j o u r . j s P              m   v                < s e r v i c e . j s P              Hm   v               < s e r v i c e . j s P              m   v              < s e r v i c e . j s P              m   v                < s e r v i c e . j s P              8m   v               < s e r v i c e . j s H           S    m   v               < l i b       H           S    m   v              < l i b       P               m   v                < c o m p i l e . j s P               hm   v               < c o m p i l e . j s P               m   v              < c o m p i l e . j s P               m   v                < c o m p i l e . j s P               Xm   v               < c o m p i l e . j s X               m   ,v                < c o n s t a n t s . j s     X                m   Sv               < c o n s t a n t s . j s     X               Xm   Sv              < c o n s t a n t s . j s     X               m   Sv                < c o n s t a n t s . j s     X               m   Sv               < c o n s t a n t s . j s     P               `m   zv                < e x p a n d . j s   P               m   zv               < e x p a n d . j s   P                m   zv              < e x p a n d . j s   P               Pm   zv                < e x p a n d . j s   P               m   zv               < e x p a n d . j s                   P                m   v                < p a r s e . j s     P               Pm   v               < p a r s e . j s     P               m   v              < p a r s e . j s     P               m   v                < p a r s e . j s     P               @m   v               < p a r s e . j s     X               m   v                < s t r i n g i f y . j s     X               m   v               < s t r i n g i f y . j s     X               @m   v              < s t r i n g i f y . j s     X               m   v                < s t r i n g i f y . j s     X               m   v               < s t r i n g i f y . j s     P               Hm   tv                < u t i l s . j s     P               m   tv               < u t i l s . j s     P               m   tv              < u t i l s . j s     P               8m   tv                < u t i l s . j s     P               m   tv               < u t i l s . j s     H          q    m   v=v               < t e s t     H          q     m   v=v              < t e s t     H      	        hm   fdv               
 < b m . j s   H      	        m   Yv              
 < b m . j s   H      	        m   Yv             
 < b m . j s   H      	        @m   Yv               
 < b m . j s   H      	        m   Yv              
 < b m . j s   `      
        m   Nv               $ < m u l t i b y t e n e e d l e . j s `      
        0m   Nv              $ < m u l t i b y t e n e e d l e . j s `      
        m   Nv             $ < m u l t i b y t e n e e d l e . j s `      
        m   Dv               $ < m u l t i b y t e n e e d l e . j s `      
        Pm   Dv              $ < m u l t i b y t e n e e d l e . j s `              m   = v                 < p a r t i a l - m a t c h . j s     `              m   = v                < p a r t i a l - m a t c h . j s     `              pm   = v               < p a r t i a l - m a t c h . j s     `              m   = v                 < p a r t i a l - m a t c h . j s     `              0m   = v                < p a r t i a l - m a t c h . j s     h              m   ,'v               , < t e s t - b u f f e r - i n d e x o f . j s h              m   !Nv              , < t e s t - b u f f e r - i n d e x o f . j s h              `m   !Nv             , < t e s t - b u f f e r - i n d e x o f . j s h              m   !Nv               , < t e s t - b u f f e r - i n d e x o f . j s h              0m   !Nv              , < t e s t - b u f f e r - i n d e x o f . j s P              m   uv                < t e s t . j s       P              m   uv               < t e s t . j s       P              8m   uv              < t e s t . j s       P              m   uv                < t e s t . j s       P              m   uv               < t e s t . j s       H              (m   v               < l i b       H              pm   v              < l i b       X              m   v                < e n t r y - i n d e x . j s X              m   v               < e n t r y - i n d e x . j s X              hm   v              < e n t r y - i n d e x . j s                                                                 X               m   v                < e n t r y - i n d e x . j s X              Xm   v               < e n t r y - i n d e x . j s X              m   v                < m e m o i z a t i o n . j s X              m   v               < m e m o i z a t i o n . j s X              `m   v              < m e m o i z a t i o n . j s X              m   v                < m e m o i z a t i o n . j s X              m   v               < m e m o i z a t i o n . j s P              hm   7v                < v e r i f y . j s   P              m   7v               < v e r i f y . j s   P              m   7v              < v e r i f y . j s   P              Xm   7v                < v e r i f y . j s   P              m   7v               < v e r i f y . j s   P              m   ^v               < . g i t h u b       P              Hm   ^v              < . g i t h u b       X              m   ^v                < F U N D I N G . y m l       X              m   ^v               < F U N D I N G . y m l       X              Hm   ^v              < F U N D I N G . y m l       X              m   ^v                < F U N D I N G . y m l       X              m   ^v               < F U N D I N G . y m l       H              Pm   v               < t e s t     H              m   v              < t e s t     X              m   v                < c a l l B o u n d . j s     X              8m   v               < c a l l B o u n d . j s     X              m   v              < c a l l B o u n d . j s     X              m   v                < c a l l B o u n d . j s     X              @m   v               < c a l l B o u n d . j s     P              m   v                < i n d e x . j s     P              m   v               < i n d e x . j s     P              8m   v              < i n d e x . j s     P              m   v                < i n d e x . j s     P              m   v               < i n d e x . j s     H              (m   !v               < d a t a     H              pm   !v              < d a t a     P              m   Hv                < a g e n t s . j s   P              m   Hv               < a g e n t s . j s   P              Xm   Hv              < a g e n t s . j s   P              m   Hv                < a g e n t s . j s   P              m   ov               < a g e n t s . j s   X              Hm   ov                < b r o w s e r s . j s       X              m   v               < b r o w s e r s . j s       X              m   v              < b r o w s e r s . j s       X              Pm   v                < b r o w s e r s . j s       X              m   v               < b r o w s e r s . j s       `               m   ov               $ < b r o w s e r V e r s i o n s . j s `              `m   ov              $ < b r o w s e r V e r s i o n s . j s `              m   ov             $ < b r o w s e r V e r s i o n s . j s `               m   ov               $ < b r o w s e r V e r s i o n s . j s `              m   ov              $ < b r o w s e r V e r s i o n s . j s                                 X               m   ev                < f e a t u r e s . j s       X              Xm   ev               < f e a t u r e s . j s       X              m   ev              < f e a t u r e s . j s       X              m   b2v                < f e a t u r e s . j s       X              `m   b2v               < f e a t u r e s . j s       H              m   b2v              
 < t y p e s   H               m   b2v             
 < t y p e s   P              Hm   KYv                < i n d e x . d . t s P              m   KYv               < i n d e x . d . t s P              m   KYv              < i n d e x . d . t s P              8m   KYv                < i n d e x . d . t s P              m   KYv               < i n d e x . d . t s P              m   ,v               < e n c o d i n g     P              (m   ,v              < e n c o d i n g     P               xm   ,v                < i s o 2 0 2 2 . j s P               m   ,v               < i s o 2 0 2 2 . j s P               m   ,v              < i s o 2 0 2 2 . j s P               hm   ,v                < i s o 2 0 2 2 . j s P               m   ,v               < i s o 2 0 2 2 . j s P      !        m   !v                < m b c s . j s       P      !        Xm   !v               < m b c s . j s       P      !        m   Cv              < m b c s . j s       P      !        m   Cv                < m b c s . j s       P      !        Hm   Cv               < m b c s . j s       P      "        m   Cv                < s b c s . j s       P      "        m    jv               < s b c s . j s       P      "        8m    jv              < s b c s . j s       P      "        m    jv                < s b c s . j s       P      "        m    jv               < s b c s . j s       P      #        (m   v                < u n i c o d e . j s P      #        xm   v               < u n i c o d e . j s P      #        m   v              < u n i c o d e . j s P      #        m   v                < u n i c o d e . j s P      #        hm   v               < u n i c o d e . j s P      $        m   v                < u t f 8 . j s       P      $        m   v               < u t f 8 . j s       P      $        Xm   v              < u t f 8 . j s       P      $        m   v                < u t f 8 . j s       P      $        m   v               < u t f 8 . j s       H      %        Hm   v               < l i b       H      %        m   v              < l i b       X      &    %    m   v                < c o n s t a n t s . j s     X      &    %    0m   ,v               < c o n s t a n t s . j s     X      &    %    m   ,v              < c o n s t a n t s . j s     X      &    %    m   ,v                < c o n s t a n t s . j s     X      &    %    8m   ,v               < c o n s t a n t s . j s     h      '    %    m   Sv               & < f s e v e n t s - h a n d l e r . j s       h      '    %    m   Sv              & < f s e v e n t s - h a n d l e r . j s       h      '    %    `m   Sv             & < f s e v e n t s - h a n d l e r . j s                                                               h      '    %     m   zv               & < f s e v e n t s - h a n d l e r . j s       h      '    %    hm   zv              & < f s e v e n t s - h a n d l e r . j s       `      (    %    m   v               " < n o d e f s - h a n d l e r . j s   `      (    %    0m   v              " < n o d e f s - h a n d l e r . j s   `      (    %    m   v             " < n o d e f s - h a n d l e r . j s   `      (    %    m   v               " < n o d e f s - h a n d l e r . j s   `      (    %    Pm   v              " < n o d e f s - h a n d l e r . j s   H      )        m   v              
 < t y p e s   H      )        m   v             
 < t y p e s   P      *    )    @m   v                < i n d e x . d . t s P      *    )    m   v               < i n d e x . d . t s P      *    )    m   v              < i n d e x . d . t s P      *    )    0m   v                < i n d e x . d . t s P      *    )    m   v               < i n d e x . d . t s H      +        m   v               < d i s t     H      +        m   v              < d i s t     `      ,    +    `m   v                 < t r a c e - e v e n t . d . t s     `      ,    +    m   =v                < t r a c e - e v e n t . d . t s     `      ,    +     m   =v               < t r a c e - e v e n t . d . t s     `      ,    +    m   =v                 < t r a c e - e v e n t . d . t s     `      ,    +    m   =v                < t r a c e - e v e n t . d . t s     X      -    +    @m   xdv                < t r a c e - e v e n t . j s X      -    +    m   xdv               < t r a c e - e v e n t . j s X      -    +    m   xdv              < t r a c e - e v e n t . j s X      -    +    Hm   xdv                < t r a c e - e v e n t . j s X      -    +    m   xdv               < t r a c e - e v e n t . j s `      .    +    m   jv               $ < t r a c e - e v e n t . j s . m a p `      .    +    Xm   jv              $ < t r a c e - e v e n t . j s . m a p `      .    +    m   jv             $ < t r a c e - e v e n t . j s . m a p `      .    +    m   jv               $ < t r a c e - e v e n t . j s . m a p `      .    +    xm   jv              $ < t r a c e - e v e n t . j s . m a p X      /        m   `v               < . n y c _ o u t p u t       X      /        0m   `v              < . n y c _ o u t p u t             0    /    m   Vv               R < 0 0 e f 1 b 3 d - 3 6 8 7 - 4 8 2 b - 8 d 0 3 - d e 2 f 7 6 b 5 8 f 5 4 . j s o n         0    /    m   L v              R < 0 0 e f 1 b 3 d - 3 6 8 7 - 4 8 2 b - 8 d 0 3 - d e 2 f 7 6 b 5 8 f 5 4 . j s o n         0    /    m   L v             R < 0 0 e f 1 b 3 d - 3 6 8 7 - 4 8 2 b - 8 d 0 3 - d e 2 f 7 6 b 5 8 f 5 4 . j s o n         0    /    8m   L v               R < 0 0 e f 1 b 3 d - 3 6 8 7 - 4 8 2 b - 8 d 0 3 - d e 2 f 7 6 b 5 8 f 5 4 . j s o n         0    /    m   L v              R < 0 0 e f 1 b 3 d - 3 6 8 7 - 4 8 2 b - 8 d 0 3 - d e 2 f 7 6 b 5 8 f 5 4 . j s o n   H      1        Xm   D'v              
 < b u i l d   H      1        m   D'v             
 < b u i l d   P      2    1    m   D'v                < i n d e x . c j s   P      2    1    8m   D'v               < i n d e x . c j s   P      2    1    m   ;Nv              < i n d e x . c j s                                           P      2    1     m   ;Nv                < i n d e x . c j s   P      2    1    Pm   ;Nv               < i n d e x . c j s   P      3        m   ;Nv               < t y p i n g s       P      3        m   ,uv              < t y p i n g s       P      4    3    @m   ,uv                < i n d e x . d . t s P      4    3    m   ,uv               < i n d e x . d . t s P      4    3    m   ,uv              < i n d e x . d . t s P      4    3    0m   (v                < i n d e x . d . t s P      4    3    m   (v               < i n d e x . d . t s P      5        m   (v               < e x a m p l e       P      5         m   v              < e x a m p l e       H      6    5    pm   v                < d i r . j s H      6    5    m   
v               < d i r . j s H      6    5     m   
v              < d i r . j s H      6    5    Hm   
v                < d i r . j s H      6    5    m   
v               < d i r . j s H      7        m   v               < t e s t     H      7         m   v              < t e s t     P      8    7    hm   7v                < d i r s . j s       P      8    7    m   7v               < d i r s . j s       P      8    7    m   7v              < d i r s . j s       P      8    7    Xm   7v                < d i r s . j s       P      8    7    m   7v               < d i r s . j s       P      9    4    m   ^v               < e x a m p l e       P      9    4    Hm   ^v              < e x a m p l e       H      :    9    m   ^v                < m a p . j s H      :    9    m   ^v               < m a p . j s H      :    9    (m   ^v              < m a p . j s H      :    9    pm   v                < m a p . j s H      :    9    m   v               < m a p . j s H      ;    4     m   v               < t e s t     H      ;    4    Hm   v              < t e s t     H      <    ;    m   v                < m a p . j s H      <    ;    m   v               < m a p . j s H      <    ;     m   v              < m a p . j s H      <    ;    hm   v                < m a p . j s H      <    ;    m   v               < m a p . j s H      =    A    m   v               < l i b       H      =    A    @m   v              < l i b       P      >    =    m   v                < i n d e x . j s     P      >    =    m   !v               < i n d e x . j s     P      >    =    (m   !v              < i n d e x . j s     P      >    =    xm   !v                < i n d e x . j s     P      >    =    m   !v               < i n d e x . j s     H      ?    i    m   Hv               < d i s t     H      ?    i    `m   Hv              < d i s t     P      @    ?    m   Hv                < i n d e x . c j s   P      @    ?    m   ov               < i n d e x . c j s   P      @    ?    Hm   ov              < i n d e x . c j s   P      @    ?    m   ov                < i n d e x . c j s   P      @    ?    m   ov               < i n d e x . c j s   X      A    ?    8m   v                < i n d e x . e s . j s       X      A    ?    m   v               < i n d e x . e s . j s                               X      A    ?     m   v              < i n d e x . e s . j s       X      A    ?    Xm   v                < i n d e x . e s . j s       X      A    ?    m   v               < i n d e x . e s . j s       H      B    m    m   v               < d i s t     H      B    m    Pm   v              < d i s t     P      C    B    m   v                < i n d e x . j s     P      C    B    m   v               < i n d e x . j s     P      C    B    8m   v              < i n d e x . j s     P      C    B    m   xv                < i n d e x . j s     P      C    B    m   xv               < i n d e x . j s     X      D    B    (m   o2v                < o p t i o n s . j s o n     X      D    B    m   o2v               < o p t i o n s . j s o n     X      D    B    m   o2v              < o p t i o n s . j s o n     X      D    B    0m   o2v                < o p t i o n s . j s o n     X      D    B    m   o2v               < o p t i o n s . j s o n     P      E    B    m   `Yv                < u t i l s . j s     P      E    B    0m   `Yv               < u t i l s . j s     P      E    B    m   `Yv              < u t i l s . j s     P      E    B    m   `Yv                < u t i l s . j s     P      E    B     m   `Yv               < u t i l s . j s     H      F    m    pm   Vv              
 < t y p e s   H      F    m    m   Vv             
 < t y p e s   P      G    F     m   Jv                < i n d e x . d . t s P      G    F    Pm   Jv               < i n d e x . d . t s P      G    F    m   Jv              < i n d e x . d . t s P      G    F    m   Jv                < i n d e x . d . t s P      G    F    @m   Bv               < i n d e x . d . t s P      H    F    m   Bv                < u t i l s . d . t s P      H    F    m   Bv               < u t i l s . d . t s P      H    F    0m   6v              < u t i l s . d . t s P      H    F    m   6v                < u t i l s . d . t s P      H    F    m   6v               < u t i l s . d . t s H      I    q     m   6v               < a c t u a l H      I    q    hm   6v              < a c t u a l `      J    I    m   +v               $ < a g g r e g a t e - e r r o r . j s `      J    I    m   Cv              $ < a g g r e g a t e - e r r o r . j s `      J    I    pm   Cv             $ < a g g r e g a t e - e r r o r . j s `      J    I    m   Cv               $ < a g g r e g a t e - e r r o r . j s `      J    I    0m   Cv              $ < a g g r e g a t e - e r r o r . j s `      K    I    m   jv               $ < c l e a r - i m m e d i a t e . j s `      K    I    m   v              $ < c l e a r - i m m e d i a t e . j s `      K    I    Pm   v             $ < c l e a r - i m m e d i a t e . j s `      K    I    m   v               $ < c l e a r - i m m e d i a t e . j s `      K    I    m   v              $ < c l e a r - i m m e d i a t e . j s P      L    I    pm   v                < e s c a p e . j s   P      L    I    m   v               < e s c a p e . j s   P      L    I    m   v              < e s c a p e . j s   P      L    I    `m   v                < e s c a p e . j s   P      L    I    m   v               < e s c a p e . j s   h      M    I     m   v               , < g e t - i t e r a t o r - m e t h o d . j s h      M    I    hm   v              , < g e t - i t e r a t o r - m e t h o d . j s h      M    I    m   v             , < g e t - i t e r a t o r - m e t h o d . j s h      M    I    8m   v               , < g e t - i t e r a t o r - m e t h o d . j s h      M    I    m   v              , < g e t - i t e r a t o r - m e t h o d . j s `      O    I    m   ,v                < g e t - i t e r a t o r . j s       `      O    I    hm   Sv               < g e t - i t e r a t o r . j s       `      O    I    m   Sv              < g e t - i t e r a t o r . j s       `      O    I    (m   Sv                < g e t - i t e r a t o r . j s       `      O    I    m   Sv               < g e t - i t e r a t o r . j s       X      P    I    m   zv                < g l o b a l - t h i s . j s X      P    I    @m   zv               < g l o b a l - t h i s . j s X      P    I    m   zv              < g l o b a l - t h i s . j s X      P    I    m   v                < g l o b a l - t h i s . j s X      P    I    Hm   v               < g l o b a l - t h i s . j s P      Q    I    m   v                < i n d e x . j s     P      Q    I    m   v               < i n d e x . j s     P      Q    I    @m   v              < i n d e x . j s     P      Q    I    m   v                < i n d e x . j s     P      Q    I    m   v               < i n d e x . j s     X      R    I    0m   |v                < i s - i t e r a b l e . j s X      R    I    m   |v               < i s - i t e r a b l e . j s X      R    I    m   |v              < i s - i t e r a b l e . j s X      R    I    8m   |v                < i s - i t e r a b l e . j s X      R    I    m   |v               < i s - i t e r a b l e . j s X      S    I    m   pv                < p a r s e - f l o a t . j s X      S    I    @m   pv               < p a r s e - f l o a t . j s X      S    I    m   pv              < p a r s e - f l o a t . j s X      S    I    m   ` v                < p a r s e - f l o a t . j s X      S    I    Hm   ` v               < p a r s e - f l o a t . j s X      T    I    m   ]'v                < p a r s e - i n t . j s     X      T    I    m   ]'v               < p a r s e - i n t . j s     X      T    I    Pm   ]'v              < p a r s e - i n t . j s     X      T    I    m   ]'v                < p a r s e - i n t . j s     X      T    I     m   ]'v               < p a r s e - i n t . j s     `      U    I    Xm   Buv               $ < q u e u e - m i c r o t a s k . j s `      U    I    m   Buv              $ < q u e u e - m i c r o t a s k . j s `      U    I    m   Buv             $ < q u e u e - m i c r o t a s k . j s `      U    I    xm   Buv               $ < q u e u e - m i c r o t a s k . j s `      U    I    m   Buv              $ < q u e u e - m i c r o t a s k . j s P      V    I    8m   6v                < R E A D M E . m d   P      V    I    m   6v               < R E A D M E . m d   P      V    I    m   6v              < R E A D M E . m d   P      V    I    (m   6v                < R E A D M E . m d   P      V    I    xm   6v               < R E A D M E . m d                                                           `      W    I      n   !v                 < s e t - i m m e d i a t e . j s     `      W    I    ` n   !v                < s e t - i m m e d i a t e . j s     `      W    I     n   !v               < s e t - i m m e d i a t e . j s     `      W    I     n   !v                 < s e t - i m m e d i a t e . j s     `      W    I    n   !v                < s e t - i m m e d i a t e . j s     `      X    I    n   v                < s e t - i n t e r v a l . j s       `      X    I    @n   v               < s e t - i n t e r v a l . j s       `      X    I    n   8v              < s e t - i n t e r v a l . j s       `      X    I     n   8v                < s e t - i n t e r v a l . j s       `      X    I    `n   8v               < s e t - i n t e r v a l . j s       X      Y    I    n   _v                < s e t - t i m e o u t . j s X      Y    I    n   _v               < s e t - t i m e o u t . j s X      Y    I    pn   _v              < s e t - t i m e o u t . j s X      Y    I    n   _v                < s e t - t i m e o u t . j s X      Y    I     n   v               < s e t - t i m e o u t . j s h      Z    I    xn   v               & < s t r u c t u r e d - c l o n e . j s       h      Z    I    n   v              & < s t r u c t u r e d - c l o n e . j s       h      Z    I    Hn   v             & < s t r u c t u r e d - c l o n e . j s       h      Z    I    n   v               & < s t r u c t u r e d - c l o n e . j s       h      Z    I    n   v              & < s t r u c t u r e d - c l o n e . j s       X      [    I    n   v                < u n e s c a p e . j s       X      [    I    n   v               < u n e s c a p e . j s       X      [    I    0n   v              < u n e s c a p e . j s       X      [    I    n   v                < u n e s c a p e . j s       X      [    I    n   v               < u n e s c a p e . j s       @      \    q    8	n   !v               < e s @      \    q    x	n   !v              < e s `      ]    \    	n   Hv               $ < a g g r e g a t e - e r r o r . j s `      ]    \    
n   Hv              $ < a g g r e g a t e - e r r o r . j s `      ]    \    x
n   Hv             $ < a g g r e g a t e - e r r o r . j s `      ]    \    
n   ov               $ < a g g r e g a t e - e r r o r . j s `      ]    \    8n   ov              $ < a g g r e g a t e - e r r o r . j s P      ^    \    n   v                < e s c a p e . j s   P      ^    \    n   v               < e s c a p e . j s   P      ^    \    8n   v              < e s c a p e . j s   P      ^    \    n   v                < e s c a p e . j s   P      ^    \    n   v               < e s c a p e . j s   h      _    \    (n   v               , < g e t - i t e r a t o r - m e t h o d . j s h      _    \    n   v              , < g e t - i t e r a t o r - m e t h o d . j s h      _    \    n   v             , < g e t - i t e r a t o r - m e t h o d . j s h      _    \    `n   v               , < g e t - i t e r a t o r - m e t h o d . j s h      _    \    n   v              , < g e t - i t e r a t o r - m e t h o d . j s `      `    \    0n   zYv                < g e t - i t e r a t o r . j s       `      `    \    n   zYv               < g e t - i t e r a t o r . j s                       `      `    \     n   zYv              < g e t - i t e r a t o r . j s       `      `    \    `n   zYv                < g e t - i t e r a t o r . j s       `      `    \    n   zYv               < g e t - i t e r a t o r . j s       X      a    \     n   iv                < g l o b a l - t h i s . j s X      a    \    xn   iv               < g l o b a l - t h i s . j s X      a    \    n   iv              < g l o b a l - t h i s . j s X      a    \    (n   iv                < g l o b a l - t h i s . j s X      a    \    n   iv               < g l o b a l - t h i s . j s P      b    \    n   ^v                < i n d e x . j s     P      b    \    (n   Tv               < i n d e x . j s     P      b    \    xn   Tv              < i n d e x . j s     P      b    \    n   Tv                < i n d e x . j s     P      b    \    n   Tv               < i n d e x . j s     X      c    \    hn   Av                < i s - i t e r a b l e . j s X      c    \    n   =Cv               < i s - i t e r a b l e . j s X      c    \    n   =Cv              < i s - i t e r a b l e . j s X      c    \    pn   =Cv                < i s - i t e r a b l e . j s X      c    \    n   =Cv               < i s - i t e r a b l e . j s X      d    \     n   Djv                < p a r s e - f l o a t . j s X      d    \    xn   Djv               < p a r s e - f l o a t . j s X      d    \    n   (v              < p a r s e - f l o a t . j s X      d    \    (n   (v                < p a r s e - f l o a t . j s X      d    \    n   (v               < p a r s e - f l o a t . j s X      e    \    n   v                < p a r s e - i n t . j s     X      e    \    0n   v               < p a r s e - i n t . j s     X      e    \    n   v              < p a r s e - i n t . j s     X      e    \    n   v                < p a r s e - i n t . j s     X      e    \    8n   v               < p a r s e - i n t . j s     P      f    \    n   v                < R E A D M E . m d   P      f    \    n   v               < R E A D M E . m d   P      f    \    0n   v              < R E A D M E . m d   P      f    \    n   v                < R E A D M E . m d   P      f    \    n   v               < R E A D M E . m d   X      g    \     n   Sv                < u n e s c a p e . j s       X      g    \    xn   Sv               < u n e s c a p e . j s       X      g    \    n   Sv              < u n e s c a p e . j s       X      g    \    (n   Sv                < u n e s c a p e . j s       X      g    \    n   Sv               < u n e s c a p e . j s       P      h    q    n   zv               < f e a t u r e s     P      h    q    (n   zv              < f e a t u r e s     `      i    h    xn   v               $ < a g g r e g a t e - e r r o r . j s `      i    h    n   v              $ < a g g r e g a t e - e r r o r . j s `      i    h    8n   v             $ < a g g r e g a t e - e r r o r . j s `      i    h    n   v               $ < a g g r e g a t e - e r r o r . j s `      i    h    n   v              $ < a g g r e g a t e - e r r o r . j s `      j    h    Xn   v               $ < c l e a r - i m m e d i a t e . j s                                                                         `      j    h      n   v              $ < c l e a r - i m m e d i a t e . j s `      j    h    ` n   v             $ < c l e a r - i m m e d i a t e . j s `      j    h     n   v               $ < c l e a r - i m m e d i a t e . j s `      j    h     !n   v              $ < c l e a r - i m m e d i a t e . j s `      k    h    !n   v                 < c o m p o s i t e - k e y . j s     `      k    h    !n   v                < c o m p o s i t e - k e y . j s     `      k    h    @"n   v               < c o m p o s i t e - k e y . j s     `      k    h    "n   v                 < c o m p o s i t e - k e y . j s     `      k    h     #n   v                < c o m p o s i t e - k e y . j s     h      l    h    `#n   v               & < c o m p o s i t e - s y m b o l . j s       h      l    h    #n   v              & < c o m p o s i t e - s y m b o l . j s       h      l    h    0$n   v             & < c o m p o s i t e - s y m b o l . j s       h      l    h    $n   v               & < c o m p o s i t e - s y m b o l . j s       h      l    h     %n   v              & < c o m p o s i t e - s y m b o l . j s       P      m    h    h%n   v                < e s c a p e . j s   P      m    h    %n   v               < e s c a p e . j s   P      m    h    &n   v              < e s c a p e . j s   P      m    h    X&n   v                < e s c a p e . j s   P      m    h    &n   v               < e s c a p e . j s   h      n    h    &n   2v               , < g e t - i t e r a t o r - m e t h o d . j s h      n    h    `'n   2v              , < g e t - i t e r a t o r - m e t h o d . j s h      n    h    'n   2v             , < g e t - i t e r a t o r - m e t h o d . j s h      n    h    0(n   Yv               , < g e t - i t e r a t o r - m e t h o d . j s h      n    h    (n   Yv              , < g e t - i t e r a t o r - m e t h o d . j s `      o    h     )n   v                < g e t - i t e r a t o r . j s       `      o    h    `)n   v               < g e t - i t e r a t o r . j s       `      o    h    )n   v              < g e t - i t e r a t o r . j s       `      o    h     *n   v                < g e t - i t e r a t o r . j s       `      o    h    *n   v               < g e t - i t e r a t o r . j s       X      p    h    *n   vv                < g l o b a l - t h i s . j s X      p    h    8+n   vv               < g l o b a l - t h i s . j s X      p    h    +n   vv              < g l o b a l - t h i s . j s X      p    h    +n   vv                < g l o b a l - t h i s . j s X      p    h    @,n   vv               < g l o b a l - t h i s . j s P      q    h    ,n   iv                < i n d e x . j s     P      q    h    ,n   _v               < i n d e x . j s     P      q    h    8-n   _v              < i n d e x . j s     P      q    h    -n   _v                < i n d e x . j s     P      q    h    -n   _v               < i n d e x . j s     X      r    h    (.n   Rv                < i s - i t e r a b l e . j s X      r    h    .n   KCv               < i s - i t e r a b l e . j s X      r    h    .n   KCv              < i s - i t e r a b l e . j s X      r    h    0/n   KCv                < i s - i t e r a b l e . j s X      r    h    /n   KCv               < i s - i t e r a b l e . j s                                 X      s    h     0n   Bjv                < p a r s e - f l o a t . j s X      s    h    X0n   Bjv               < p a r s e - f l o a t . j s X      s    h    0n   Bjv              < p a r s e - f l o a t . j s X      s    h    1n   Bjv                < p a r s e - f l o a t . j s X      s    h    `1n   Bjv               < p a r s e - f l o a t . j s X      u    h    1n   7v                < p a r s e - i n t . j s     X      u    h    2n   7v               < p a r s e - i n t . j s     X      u    h    h2n   .v              < p a r s e - i n t . j s     X      u    h    2n   .v                < p a r s e - i n t . j s     X      u    h    3n   .v               < p a r s e - i n t . j s     `      v    h    p3n   "v               $ < q u e u e - m i c r o t a s k . j s `      v    h    3n   "v              $ < q u e u e - m i c r o t a s k . j s `      v    h    04n   "v             $ < q u e u e - m i c r o t a s k . j s `      v    h    4n   "v               $ < q u e u e - m i c r o t a s k . j s `      v    h    4n   "v              $ < q u e u e - m i c r o t a s k . j s P      w    h    P5n   -v                < R E A D M E . m d   P      w    h    5n   -v               < R E A D M E . m d   P      w    h    5n   -v              < R E A D M E . m d   P      w    h    @6n   -v                < R E A D M E . m d   P      w    h    6n   -v               < R E A D M E . m d   `      x    h    6n   Sv                 < s e t - i m m e d i a t e . j s     `      x    h    @7n   zv                < s e t - i m m e d i a t e . j s     `      x    h    7n   zv               < s e t - i m m e d i a t e . j s     `      x    h     8n   zv                 < s e t - i m m e d i a t e . j s     `      x    h    `8n   zv                < s e t - i m m e d i a t e . j s     `      y    h    8n   v                < s e t - i n t e r v a l . j s       `      y    h     9n   v               < s e t - i n t e r v a l . j s       `      y    h    9n   v              < s e t - i n t e r v a l . j s       `      y    h    9n   v                < s e t - i n t e r v a l . j s       `      y    h    @:n   v               < s e t - i n t e r v a l . j s       X      z    h    :n   v                < s e t - t i m e o u t . j s X      z    h    :n   v               < s e t - t i m e o u t . j s X      z    h    P;n   v              < s e t - t i m e o u t . j s X      z    h    ;n   v                < s e t - t i m e o u t . j s X      z    h     <n   v               < s e t - t i m e o u t . j s h      {    h    X<n   v               & < s t r u c t u r e d - c l o n e . j s       h      {    h    <n   v              & < s t r u c t u r e d - c l o n e . j s       h      {    h    (=n   v             & < s t r u c t u r e d - c l o n e . j s       h      {    h    =n   v               & < s t r u c t u r e d - c l o n e . j s       h      {    h    =n   v              & < s t r u c t u r e d - c l o n e . j s       X      }    h    `>n   dv                < u n e s c a p e . j s       X      }    h    >n   dv               < u n e s c a p e . j s       X      }    h    ?n   dv              < u n e s c a p e . j s       X      }    h    h?n   dv                < u n e s c a p e . j s                                                                       X      }    h     @n   dv               < u n e s c a p e . j s       P      ~    q    X@n   v               < i n t e r n a l s   P      ~    q    @n   v              < i n t e r n a l s   X          ~    @n   v                < a - c a l l a b l e . j s   X          ~    PAn   v               < a - c a l l a b l e . j s   X          ~    An   v              < a - c a l l a b l e . j s   X          ~     Bn   v                < a - c a l l a b l e . j s   X          ~    XBn   v               < a - c a l l a b l e . j s   `          ~    Bn    v                 < a - c o n s t r u c t o r . j s     `          ~    Cn    v                < a - c o n s t r u c t o r . j s     `          ~    pCn    v               < a - c o n s t r u c t o r . j s     `          ~    Cn    v                 < a - c o n s t r u c t o r . j s     `          ~    0Dn    v                < a - c o n s t r u c t o r . j s     p          ~    Dn   wNv               . < a - p o s s i b l e - p r o t o t y p e . j s       p          ~     En   puv              . < a - p o s s i b l e - p r o t o t y p e . j s       p          ~    pEn   puv             . < a - p o s s i b l e - p r o t o t y p e . j s       p          ~    En   puv               . < a - p o s s i b l e - p r o t o t y p e . j s       p          ~    PFn   puv              . < a - p o s s i b l e - p r o t o t y p e . j s       h          ~    Fn   bv               * < a d d - t o - u n s c o p a b l e s . j s   h          ~    (Gn   Uv              * < a d d - t o - u n s c o p a b l e s . j s   h          ~    Gn   Uv             * < a d d - t o - u n s c o p a b l e s . j s   h          ~    Gn   Uv               * < a d d - t o - u n s c o p a b l e s . j s   h          ~    `Hn   Uv              * < a d d - t o - u n s c o p a b l e s . j s   p          ~    Hn   Zv               . < a d v a n c e - s t r i n g - i n d e x . j s       p          ~    8In   Zv              . < a d v a n c e - s t r i n g - i n d e x . j s       p          ~    In   Zv             . < a d v a n c e - s t r i n g - i n d e x . j s       p          ~    Jn   Zv               . < a d v a n c e - s t r i n g - i n d e x . j s       p          ~    Jn   =v              . < a d v a n c e - s t r i n g - i n d e x . j s       X          ~    Jn   38v                < a n - i n s t a n c e . j s X          ~    PKn   38v               < a n - i n s t a n c e . j s X          ~    Kn   38v              < a n - i n s t a n c e . j s X          ~     Ln   38v                < a n - i n s t a n c e . j s X          ~    XLn   38v               < a n - i n s t a n c e . j s X          ~    Ln   )_v                < a n - o b j e c t . j s     X          ~    Mn   $v               < a n - o b j e c t . j s     X          ~    `Mn   $v              < a n - o b j e c t . j s     X          ~    Mn   $v                < a n - o b j e c t . j s     X          ~    Nn   $v               < a n - o b j e c t . j s     h          ~    hNn   v               , < a r r a y - b u f f e r - n a t i v e . j s h          ~    Nn   v              , < a r r a y - b u f f e r - n a t i v e . j s h          ~    8On   v             , < a r r a y - b u f f e r - n a t i v e . j s                                                                                                 h          ~     Pn   v               , < a r r a y - b u f f e r - n a t i v e . j s h          ~    hPn   v              , < a r r a y - b u f f e r - n a t i v e . j s x          ~    Pn   v               < < a r r a y - b u f f e r - n o n - e x t e n s i b l e . j s x          ~    HQn   v              < < a r r a y - b u f f e r - n o n - e x t e n s i b l e . j s x          ~    Qn   v             < < a r r a y - b u f f e r - n o n - e x t e n s i b l e . j s x          ~    8Rn   v               < < a r r a y - b u f f e r - n o n - e x t e n s i b l e . j s x          ~    Rn   v              < < a r r a y - b u f f e r - n o n - e x t e n s i b l e . j s p          ~    (Sn   !v               2 < a r r a y - b u f f e r - v i e w - c o r e . j s   p          ~    Sn   !v              2 < a r r a y - b u f f e r - v i e w - c o r e . j s   p          ~    Tn   Hv             2 < a r r a y - b u f f e r - v i e w - c o r e . j s   p          ~    xTn   Hv               2 < a r r a y - b u f f e r - v i e w - c o r e . j s   p          ~    Tn   Hv              2 < a r r a y - b u f f e r - v i e w - c o r e . j s   `          ~    XUn   ov                < a r r a y - b u f f e r . j s       `          ~    Un   ov               < a r r a y - b u f f e r . j s       `          ~    Vn   ov              < a r r a y - b u f f e r . j s       `          ~    xVn   ov                < a r r a y - b u f f e r . j s       `          ~    Vn   ov               < a r r a y - b u f f e r . j s       h          ~    8Wn   v               ( < a r r a y - c o p y - w i t h i n . j s     h          ~    Wn   v              ( < a r r a y - c o p y - w i t h i n . j s     h          ~    Xn   v             ( < a r r a y - c o p y - w i t h i n . j s     h          ~    pXn   v               ( < a r r a y - c o p y - w i t h i n . j s     h          ~    Xn   v              ( < a r r a y - c o p y - w i t h i n . j s     X          ~    @Yn   v                < a r r a y - f i l l . j s   X          ~    Yn   v               < a r r a y - f i l l . j s   X          ~    Yn   v              < a r r a y - f i l l . j s   X          ~    HZn   v                < a r r a y - f i l l . j s   X          ~    Zn   v               < a r r a y - f i l l . j s   `          ~    Zn   v               " < a r r a y - f o r - e a c h . j s   `          ~    X[n   v              " < a r r a y - f o r - e a c h . j s   `          ~    [n   v             " < a r r a y - f o r - e a c h . j s   `          ~    \n   v               " < a r r a y - f o r - e a c h . j s   `          ~    x\n   v              " < a r r a y - f o r - e a c h . j s   h          ~    \n   Yv               & < a r r a y - f r o m - a s y n c . j s       h          ~    @]n   Yv              & < a r r a y - f r o m - a s y n c . j s       h          ~    ]n   Yv             & < a r r a y - f r o m - a s y n c . j s       h          ~    ^n   Yv               & < a r r a y - f r o m - a s y n c . j s       h          ~    x^n   Yv              & < a r r a y - f r o m - a s y n c . j s                 ~    ^n   v               D < a r r a y - f r o m - c o n s t r u c t o r - a n d - l i s t . j s           ~    `_n   v              D < a r r a y - f r o m - c o n s t r u c t o r - a n d - l i s t . j s                                           ~     `n   v             D < a r r a y - f r o m - c o n s t r u c t o r - a n d - l i s t . j s           ~    `n   v               D < a r r a y - f r o m - c o n s t r u c t o r - a n d - l i s t . j s           ~     an   v              D < a r r a y - f r o m - c o n s t r u c t o r - a n d - l i s t . j s X          ~    an   v                < a r r a y - f r o m . j s   X          ~    an   v               < a r r a y - f r o m . j s   X          ~    0bn   v              < a r r a y - f r o m . j s   X          ~    bn   v                < a r r a y - f r o m . j s   X          ~    bn   v               < a r r a y - f r o m . j s   `          ~    8cn   sv               " < a r r a y - g r o u p - b y . j s   `          ~    cn   sv              " < a r r a y - g r o u p - b y . j s   `          ~    cn   sv             " < a r r a y - g r o u p - b y . j s   `          ~    Xdn   sv               " < a r r a y - g r o u p - b y . j s   `          ~    dn   sv              " < a r r a y - g r o u p - b y . j s   `          ~    en   fv               " < a r r a y - i n c l u d e s . j s   `          ~    xen   ]Cv              " < a r r a y - i n c l u d e s . j s   `          ~    en   ]Cv             " < a r r a y - i n c l u d e s . j s   `          ~    8fn   ]Cv               " < a r r a y - i n c l u d e s . j s   `          ~    fn   ]Cv              " < a r r a y - i n c l u d e s . j s   x          ~    fn   Sjv               8 < a r r a y - i t e r a t i o n - f r o m - l a s t . j s     x          ~    pgn   Sjv              8 < a r r a y - i t e r a t i o n - f r o m - l a s t . j s     x          ~    gn   Sjv             8 < a r r a y - i t e r a t i o n - f r o m - l a s t . j s     x          ~    `hn   Nv               8 < a r r a y - i t e r a t i o n - f r o m - l a s t . j s     x          ~    hn   Nv              8 < a r r a y - i t e r a t i o n - f r o m - l a s t . j s     `          ~    Pin   Ev               $ < a r r a y - i t e r a t i o n . j s `          ~    in   Ev              $ < a r r a y - i t e r a t i o n . j s `          ~    jn   Ev             $ < a r r a y - i t e r a t i o n . j s `          ~    pjn   Ev               $ < a r r a y - i t e r a t i o n . j s `          ~    jn   Ev              $ < a r r a y - i t e r a t i o n . j s h          ~    0kn   :v               , < a r r a y - l a s t - i n d e x - o f . j s h          ~    kn   :v              , < a r r a y - l a s t - i n d e x - o f . j s h          ~     ln   :v             , < a r r a y - l a s t - i n d e x - o f . j s h          ~    hln   :v               , < a r r a y - l a s t - i n d e x - o f . j s h          ~    ln   :v              , < a r r a y - l a s t - i n d e x - o f . j s           ~    8mn   -v               F < a r r a y - m e t h o d - h a s - s p e c i e s - s u p p o r t . j s                 ~    mn   -v              F < a r r a y - m e t h o d - h a s - s p e c i e s - s u p p o r t . j s                 ~    Hnn   -v             F < a r r a y - m e t h o d - h a s - s p e c i e s - s u p p o r t . j s                 ~    nn   -v               F < a r r a y - m e t h o d - h a s - s p e c i e s - s u p p o r t . j s                 ~    Xon   -v              F < a r r a y - m e t h o d - h a s - s p e c i e s - s u p p o r t . j s                                       p          ~     pn   Tv               2 < a r r a y - m e t h o d - i s - s t r i c t . j s   p          ~    ppn   Tv              2 < a r r a y - m e t h o d - i s - s t r i c t . j s   p          ~    pn   Tv             2 < a r r a y - m e t h o d - i s - s t r i c t . j s   p          ~    Pqn   Tv               2 < a r r a y - m e t h o d - i s - s t r i c t . j s   p          ~    qn   
{v              2 < a r r a y - m e t h o d - i s - s t r i c t . j s   `          ~    0rn   v                < a r r a y - r e d u c e . j s       `          ~    rn   v               < a r r a y - r e d u c e . j s       `          ~    rn   v              < a r r a y - r e d u c e . j s       `          ~    Psn   v                < a r r a y - r e d u c e . j s       `          ~    sn   v               < a r r a y - r e d u c e . j s       h          ~    tn   v               * < a r r a y - s l i c e - s i m p l e . j s   h          ~    xtn   v              * < a r r a y - s l i c e - s i m p l e . j s   h          ~    tn   v             * < a r r a y - s l i c e - s i m p l e . j s   h          ~    Hun   v               * < a r r a y - s l i c e - s i m p l e . j s   h          ~    un   v              * < a r r a y - s l i c e - s i m p l e . j s   X          ~    vn   v                < a r r a y - s l i c e . j s X          ~    pvn   v               < a r r a y - s l i c e . j s X          ~    vn   v              < a r r a y - s l i c e . j s X          ~     wn   v                < a r r a y - s l i c e . j s X          ~    xwn   v               < a r r a y - s l i c e . j s X          ~    wn   =v                < a r r a y - s o r t . j s   X          ~    (xn   =v               < a r r a y - s o r t . j s   X          ~    xn   =v              < a r r a y - s o r t . j s   X          ~    xn   =v                < a r r a y - s o r t . j s   X          ~    0yn   =v               < a r r a y - s o r t . j s   x          ~    yn   dv               8 < a r r a y - s p e c i e s - c o n s t r u c t o r . j s     x          ~     zn   dv              8 < a r r a y - s p e c i e s - c o n s t r u c t o r . j s     x          ~    xzn   dv             8 < a r r a y - s p e c i e s - c o n s t r u c t o r . j s     x          ~    zn   v               8 < a r r a y - s p e c i e s - c o n s t r u c t o r . j s     x          ~    h{n   v              8 < a r r a y - s p e c i e s - c o n s t r u c t o r . j s     p          ~    {n   v               . < a r r a y - s p e c i e s - c r e a t e . j s       p          ~    P|n   v              . < a r r a y - s p e c i e s - c r e a t e . j s       p          ~    |n   v             . < a r r a y - s p e c i e s - c r e a t e . j s       p          ~    0}n   v               . < a r r a y - s p e c i e s - c r e a t e . j s       p          ~    }n   v              . < a r r a y - s p e c i e s - c r e a t e . j s       h          ~    ~n   v               ( < a r r a y - t o - r e v e r s e d . j s     h          ~    x~n    v              ( < a r r a y - t o - r e v e r s e d . j s     h          ~    ~n    v             ( < a r r a y - t o - r e v e r s e d . j s     h          ~    Hn    v               ( < a r r a y - t o - r e v e r s e d . j s                                                                                     h          ~     n    v              ( < a r r a y - t o - r e v e r s e d . j s     h          ~    hn   'v               & < a r r a y - t o - s p l i c e d . j s       h          ~    n   'v              & < a r r a y - t o - s p l i c e d . j s       h          ~    8n   'v             & < a r r a y - t o - s p l i c e d . j s       h          ~    n   'v               & < a r r a y - t o - s p l i c e d . j s       h          ~    n   'v              & < a r r a y - t o - s p l i c e d . j s       `          ~    pn   Nv               $ < a r r a y - u n i q u e - b y . j s `          ~    n   Nv              $ < a r r a y - u n i q u e - b y . j s `          ~    0n   Nv             $ < a r r a y - u n i q u e - b y . j s `          ~    n   uv               $ < a r r a y - u n i q u e - b y . j s `          ~    n   uv              $ < a r r a y - u n i q u e - b y . j s X          ~    Pn   sv                < a r r a y - w i t h . j s   X          ~    n   sv               < a r r a y - w i t h . j s   X          ~     n   sv              < a r r a y - w i t h . j s   X          ~    Xn   sv                < a r r a y - w i t h . j s   X          ~    n   sv               < a r r a y - w i t h . j s   x          ~    n   jv               6 < a s y n c - f r o m - s y n c - i t e r a t o r . j s       x          ~    n   jv              6 < a s y n c - f r o m - s y n c - i t e r a t o r . j s       x          ~    n   jv             6 < a s y n c - f r o m - s y n c - i t e r a t o r . j s       x          ~    pn   jv               6 < a s y n c - f r o m - s y n c - i t e r a t o r . j s       x          ~    n   jv              6 < a s y n c - f r o m - s y n c - i t e r a t o r . j s       x          ~    `n   \v               < < a s y n c - i t e r a t o r - c r e a t e - p r o x y . j s x          ~    n   \v              < < a s y n c - i t e r a t o r - c r e a t e - p r o x y . j s x          ~    Pn   Sv             < < a s y n c - i t e r a t o r - c r e a t e - p r o x y . j s x          ~    n   Sv               < < a s y n c - i t e r a t o r - c r e a t e - p r o x y . j s x          ~    @n   Sv              < < a s y n c - i t e r a t o r - c r e a t e - p r o x y . j s x          ~    n   J8v               6 < a s y n c - i t e r a t o r - i t e r a t i o n . j s       x          ~    0n   J8v              6 < a s y n c - i t e r a t o r - i t e r a t i o n . j s       x          ~    n   J8v             6 < a s y n c - i t e r a t o r - i t e r a t i o n . j s       x          ~     n   J8v               6 < a s y n c - i t e r a t o r - i t e r a t i o n . j s       x          ~    n   J8v              6 < a s y n c - i t e r a t o r - i t e r a t i o n . j s       x          ~    n   B_v               6 < a s y n c - i t e r a t o r - p r o t o t y p e . j s       x          ~    n   B_v              6 < a s y n c - i t e r a t o r - p r o t o t y p e . j s       x          ~     n   B_v             6 < a s y n c - i t e r a t o r - p r o t o t y p e . j s       x          ~    xn   B_v               6 < a s y n c - i t e r a t o r - p r o t o t y p e . j s       x          ~    n   B_v              6 < a s y n c - i t e r a t o r - p r o t o t y p e . j s                 ~    hn   5v               F < c a l l - w i t h - s a f e - i t e r a t i o n - c l o s i n g . j s                                 ~     n   ,v              F < c a l l - w i t h - s a f e - i t e r a t i o n - c l o s i n g . j s                 ~    n   ,v             F < c a l l - w i t h - s a f e - i t e r a t i o n - c l o s i n g . j s                 ~    n   ,v               F < c a l l - w i t h - s a f e - i t e r a t i o n - c l o s i n g . j s                 ~    n   ,v              F < c a l l - w i t h - s a f e - i t e r a t i o n - c l o s i n g . j s                 ~     n   v               B < c h e c k - c o r r e c t n e s s - o f - i t e r a t i o n . j s             ~    n   v              B < c h e c k - c o r r e c t n e s s - o f - i t e r a t i o n . j s             ~     n   v             B < c h e c k - c o r r e c t n e s s - o f - i t e r a t i o n . j s             ~    n   v               B < c h e c k - c o r r e c t n e s s - o f - i t e r a t i o n . j s             ~     n   v              B < c h e c k - c o r r e c t n e s s - o f - i t e r a t i o n . j s   X          ~    n   "v                < c l a s s o f - r a w . j s X          ~    n   "v               < c l a s s o f - r a w . j s X          ~    Pn   "v              < c l a s s o f - r a w . j s X          ~    n   "v                < c l a s s o f - r a w . j s X          ~     n   Hv               < c l a s s o f - r a w . j s P          ~    Xn   ov                < c l a s s o f . j s P          ~    n   ov               < c l a s s o f . j s P          ~    n   ov              < c l a s s o f . j s P          ~    Hn   ov                < c l a s s o f . j s P          ~    n   ov               < c l a s s o f . j s h          ~    n   v               ( < c l e a r - e r r o r - s t a c k . j s     h          ~    Pn   v              ( < c l e a r - e r r o r - s t a c k . j s     h          ~    n   v             ( < c l e a r - e r r o r - s t a c k . j s     h          ~     n   v               ( < c l e a r - e r r o r - s t a c k . j s     h          ~    n   v              ( < c l e a r - e r r o r - s t a c k . j s     h          ~    n   v               * < c o l l e c t i o n - a d d - a l l . j s   h          ~    Xn   v              * < c o l l e c t i o n - a d d - a l l . j s   h          ~    n   v             * < c o l l e c t i o n - a d d - a l l . j s   h          ~    (n   v               * < c o l l e c t i o n - a d d - a l l . j s   h          ~    n   v              * < c o l l e c t i o n - a d d - a l l . j s   p          ~    n   2v               0 < c o l l e c t i o n - d e l e t e - a l l . j s     p          ~    hn   2v              0 < c o l l e c t i o n - d e l e t e - a l l . j s     p          ~    n   2v             0 < c o l l e c t i o n - d e l e t e - a l l . j s     p          ~    Hn   2v               0 < c o l l e c t i o n - d e l e t e - a l l . j s     p          ~    n   2v              0 < c o l l e c t i o n - d e l e t e - a l l . j s     `          ~    (n   Yv               $ < c o l l e c t i o n - f r o m . j s `          ~    n   Yv              $ < c o l l e c t i o n - f r o m . j s `          ~    n   v             $ < c o l l e c t i o n - f r o m . j s `          ~    Hn   v               $ < c o l l e c t i o n - f r o m . j s                                                                                         `          ~     n   v              $ < c o l l e c t i o n - f r o m . j s `          ~    `n   v                 < c o l l e c t i o n - o f . j s     `          ~    n   v                < c o l l e c t i o n - o f . j s     `          ~     n   v               < c o l l e c t i o n - o f . j s     `          ~    n   v                 < c o l l e c t i o n - o f . j s     `          ~    n   v                < c o l l e c t i o n - o f . j s     h          ~    @n   v               ( < c o l l e c t i o n - s t r o n g . j s     h          ~    n   v              ( < c o l l e c t i o n - s t r o n g . j s     h          ~    n   v             ( < c o l l e c t i o n - s t r o n g . j s     h          ~    xn   v               ( < c o l l e c t i o n - s t r o n g . j s     h          ~    n   v              ( < c o l l e c t i o n - s t r o n g . j s     `          ~    Hn   v               $ < c o l l e c t i o n - w e a k . j s `          ~    n   v              $ < c o l l e c t i o n - w e a k . j s `          ~    n   v             $ < c o l l e c t i o n - w e a k . j s `          ~    hn   v               $ < c o l l e c t i o n - w e a k . j s `          ~    n   v              $ < c o l l e c t i o n - w e a k . j s X          ~    (n   wCv                < c o l l e c t i o n . j s   X          ~    n   wCv               < c o l l e c t i o n . j s   X          ~    n   jjv              < c o l l e c t i o n . j s   X          ~    0n   jjv                < c o l l e c t i o n . j s   X          ~    n   jjv               < c o l l e c t i o n . j s   `          ~    n   ]v                 < c o m p o s i t e - k e y . j s     `          ~    @n   ]v                < c o m p o s i t e - k e y . j s     `          ~    n   ]v               < c o m p o s i t e - k e y . j s     `          ~     n   ]v                 < c o m p o s i t e - k e y . j s     `          ~    `n   Sv                < c o m p o s i t e - k e y . j s     x          ~    n   Iv               < < c o p y - c o n s t r u c t o r - p r o p e r t i e s . j s x          ~    8n   Iv              < < c o p y - c o n s t r u c t o r - p r o p e r t i e s . j s x          ~    n   Iv             < < c o p y - c o n s t r u c t o r - p r o p e r t i e s . j s x          ~    (n   Iv               < < c o p y - c o n s t r u c t o r - p r o p e r t i e s . j s x          ~    n   Iv              < < c o p y - c o n s t r u c t o r - p r o p e r t i e s . j s p          ~    n   @v               4 < c o r r e c t - i s - r e g e x p - l o g i c . j s p          ~    n   @v              4 < c o r r e c t - i s - r e g e x p - l o g i c . j s p          ~    n   @v             4 < c o r r e c t - i s - r e g e x p - l o g i c . j s p          ~    hn   @v               4 < c o r r e c t - i s - r e g e x p - l o g i c . j s p          ~    n   @v              4 < c o r r e c t - i s - r e g e x p - l o g i c . j s x          ~    Hn   1-v               6 < c o r r e c t - p r o t o t y p e - g e t t e r . j s       x          ~    n   (Tv              6 < c o r r e c t - p r o t o t y p e - g e t t e r . j s       x          ~    8n   (Tv             6 < c o r r e c t - p r o t o t y p e - g e t t e r . j s                                                                                       x          ~     n   (Tv               6 < c o r r e c t - p r o t o t y p e - g e t t e r . j s       x          ~    xn   (Tv              6 < c o r r e c t - p r o t o t y p e - g e t t e r . j s       X          ~    n   "{v                < c r e a t e - h t m l . j s X          ~    Hn   "{v               < c r e a t e - h t m l . j s X          ~    n   v              < c r e a t e - h t m l . j s X          ~    n   v                < c r e a t e - h t m l . j s X          ~    Pn   v               < c r e a t e - h t m l . j s x          ~    n   v               < < c r e a t e - i t e r a t o r - c o n s t r u c t o r . j s x          ~     n   v              < < c r e a t e - i t e r a t o r - c o n s t r u c t o r . j s x          ~    n   v             < < c r e a t e - i t e r a t o r - c o n s t r u c t o r . j s x          ~    n   v               < < c r e a t e - i t e r a t o r - c o n s t r u c t o r . j s x          ~    n   v              < < c r e a t e - i t e r a t o r - c o n s t r u c t o r . j s           ~     n   =v               B < c r e a t e - n o n - e n u m e r a b l e - p r o p e r t y . j s             ~    n   =v              B < c r e a t e - n o n - e n u m e r a b l e - p r o p e r t y . j s             ~     n   =v             B < c r e a t e - n o n - e n u m e r a b l e - p r o p e r t y . j s             ~    n   =v               B < c r e a t e - n o n - e n u m e r a b l e - p r o p e r t y . j s             ~     n   =v              B < c r e a t e - n o n - e n u m e r a b l e - p r o p e r t y . j s   x          ~    n   v               : < c r e a t e - p r o p e r t y - d e s c r i p t o r . j s   x          ~    n   v              : < c r e a t e - p r o p e r t y - d e s c r i p t o r . j s   x          ~    pn   v             : < c r e a t e - p r o p e r t y - d e s c r i p t o r . j s   x          ~    n   v               : < c r e a t e - p r o p e r t y - d e s c r i p t o r . j s   x          ~    `n   v              : < c r e a t e - p r o p e r t y - d e s c r i p t o r . j s   `          ~    n   v               $ < c r e a t e - p r o p e r t y . j s `          ~    8n   v              $ < c r e a t e - p r o p e r t y . j s `          ~    n   v             $ < c r e a t e - p r o p e r t y . j s `          ~    n   v               $ < c r e a t e - p r o p e r t y . j s `          ~    Xn   v              $ < c r e a t e - p r o p e r t y . j s h          ~    n   'v               * < d a t e - t o - i s o - s t r i n g . j s   h          ~     n   'v              * < d a t e - t o - i s o - s t r i n g . j s   h          ~    n   'v             * < d a t e - t o - i s o - s t r i n g . j s   h          ~    n   'v               * < d a t e - t o - i s o - s t r i n g . j s   h          ~    Xn   'v              * < d a t e - t o - i s o - s t r i n g . j s   h          ~    n   Nv               ( < d a t e - t o - p r i m i t i v e . j s     h          ~    (n   Nv              ( < d a t e - t o - p r i m i t i v e . j s     h          ~    n   Nv             ( < d a t e - t o - p r i m i t i v e . j s     h          ~    n   Nv               ( < d a t e - t o - p r i m i t i v e . j s     h          ~    `n   Nv              ( < d a t e - t o - p r i m i t i v e . j s                                                             `          ~     n   v               $ < d e f i n e - i t e r a t o r . j s `          ~    `n   v              $ < d e f i n e - i t e r a t o r . j s `          ~    n   v             $ < d e f i n e - i t e r a t o r . j s `          ~     n   v               $ < d e f i n e - i t e r a t o r . j s `          ~    n   v              $ < d e f i n e - i t e r a t o r . j s x          ~    n   v               6 < d e f i n e - w e l l - k n o w n - s y m b o l . j s       x          ~    Xn   v              6 < d e f i n e - w e l l - k n o w n - s y m b o l . j s       x          ~    n   v             6 < d e f i n e - w e l l - k n o w n - s y m b o l . j s       x          ~    Hn   v               6 < d e f i n e - w e l l - k n o w n - s y m b o l . j s       x          ~    n   v              6 < d e f i n e - w e l l - k n o w n - s y m b o l . j s       X          ~    8n   lv                < d e s c r i p t o r s . j s X          ~    n   lv               < d e s c r i p t o r s . j s X          ~    n   lv              < d e s c r i p t o r s . j s X          ~    @n   lv                < d e s c r i p t o r s . j s X          ~    n   lv               < d e s c r i p t o r s . j s p          ~    n   ^8v               4 < d o c u m e n t - c r e a t e - e l e m e n t . j s p          ~    `n   Y_v              4 < d o c u m e n t - c r e a t e - e l e m e n t . j s p          ~    n   Hv             4 < d o c u m e n t - c r e a t e - e l e m e n t . j s p          ~    @n   Hv               4 < d o c u m e n t - c r e a t e - e l e m e n t . j s p          ~    n   Hv              4 < d o c u m e n t - c r e a t e - e l e m e n t . j s p          ~     n   Av               4 < d o m - e x c e p t i o n - c o n s t a n t s . j s p          ~    n   Av              4 < d o m - e x c e p t i o n - c o n s t a n t s . j s p          ~     n   Av             4 < d o m - e x c e p t i o n - c o n s t a n t s . j s p          ~    pn   Av               4 < d o m - e x c e p t i o n - c o n s t a n t s . j s p          ~    n   Av              4 < d o m - e x c e p t i o n - c o n s t a n t s . j s `          ~    Pn   'v                 < d o m - i t e r a b l e s . j s     `          ~    n   'v                < d o m - i t e r a b l e s . j s     `          ~    n   'v               < d o m - i t e r a b l e s . j s     `          ~    pn   'v                 < d o m - i t e r a b l e s . j s     `          ~    n   'v                < d o m - i t e r a b l e s . j s     x          ~    0n   "v               6 < d o m - t o k e n - l i s t - p r o t o t y p e . j s       x          ~    n   "v              6 < d o m - t o k e n - l i s t - p r o t o t y p e . j s       x          ~     n   Iv             6 < d o m - t o k e n - l i s t - p r o t o t y p e . j s       x          ~    n   Iv               6 < d o m - t o k e n - l i s t - p r o t o t y p e . j s       x          ~    n   Iv              6 < d o m - t o k e n - l i s t - p r o t o t y p e . j s       h          ~    n   pv               ( < e n g i n e - f f - v e r s i o n . j s     h          ~    n   pv              ( < e n g i n e - f f - v e r s i o n . j s     h          ~    Xn   v             ( < e n g i n e - f f - v e r s i o n . j s                                                                     h          ~     n   v               ( < e n g i n e - f f - v e r s i o n . j s     h          ~    hn   v              ( < e n g i n e - f f - v e r s i o n . j s     h          ~    n   v               ( < e n g i n e - i s - b r o w s e r . j s     h          ~    8n   v              ( < e n g i n e - i s - b r o w s e r . j s     h          ~    n   v             ( < e n g i n e - i s - b r o w s e r . j s     h          ~    n   v               ( < e n g i n e - i s - b r o w s e r . j s     h          ~    pn   v              ( < e n g i n e - i s - b r o w s e r . j s     p          ~    n   v               . < e n g i n e - i s - i e - o r - e d g e . j s       p          ~    Hn   v              . < e n g i n e - i s - i e - o r - e d g e . j s       p          ~    n   v             . < e n g i n e - i s - i e - o r - e d g e . j s       p          ~    (n   v               . < e n g i n e - i s - i e - o r - e d g e . j s       p          ~    n   v              . < e n g i n e - i s - i e - o r - e d g e . j s       p          ~    n   2v               . < e n g i n e - i s - i o s - p e b b l e . j s       p          ~    xn   Yv              . < e n g i n e - i s - i o s - p e b b l e . j s       p          ~    n   Yv             . < e n g i n e - i s - i o s - p e b b l e . j s       p          ~    Xn   Yv               . < e n g i n e - i s - i o s - p e b b l e . j s       p          ~    n   Yv              . < e n g i n e - i s - i o s - p e b b l e . j s       `          ~    8n   v                 < e n g i n e - i s - i o s . j s     `          ~    n   v                < e n g i n e - i s - i o s . j s     `          ~    n   v               < e n g i n e - i s - i o s . j s     `          ~    Xn   v                 < e n g i n e - i s - i o s . j s     `          ~    n   v                < e n g i n e - i s - i o s . j s     `          ~    n   v               " < e n g i n e - i s - n o d e . j s   `          ~    xn   v              " < e n g i n e - i s - n o d e . j s   `          ~    n   v             " < e n g i n e - i s - n o d e . j s   `          ~    8n   v               " < e n g i n e - i s - n o d e . j s   `          ~    n   v              " < e n g i n e - i s - n o d e . j s   p          ~    n   v               2 < e n g i n e - i s - w e b o s - w e b k i t . j s   p          ~    hn   Cv              2 < e n g i n e - i s - w e b o s - w e b k i t . j s   p          ~    n   Cv             2 < e n g i n e - i s - w e b o s - w e b k i t . j s   p          ~    Hn   Cv               2 < e n g i n e - i s - w e b o s - w e b k i t . j s   p          ~    n   Cv              2 < e n g i n e - i s - w e b o s - w e b k i t . j s   h          ~    (n   jv               ( < e n g i n e - u s e r - a g e n t . j s     h          ~    n   tv              ( < e n g i n e - u s e r - a g e n t . j s     h          ~    n   tv             ( < e n g i n e - u s e r - a g e n t . j s     h          ~    `n   tv               ( < e n g i n e - u s e r - a g e n t . j s     h          ~    n   tv              ( < e n g i n e - u s e r - a g e n t . j s     h          ~    0n   v               ( < e n g i n e - v 8 - v e r s i o n . j s     h          ~    n    >v              ( < e n g i n e - v 8 - v e r s i o n . j s     h          ~     n    >v             ( < e n g i n e - v 8 - v e r s i o n . j s     h          ~    hn   ev               ( < e n g i n e - v 8 - v e r s i o n . j s     h          ~    n   ev              ( < e n g i n e - v 8 - v e r s i o n . j s     p          ~    8n   v               0 < e n g i n e - w e b k i t - v e r s i o n . j s     p          ~    n   v              0 < e n g i n e - w e b k i t - v e r s i o n . j s     p          ~    n   v             0 < e n g i n e - w e b k i t - v e r s i o n . j s     p          ~    n   v               0 < e n g i n e - w e b k i t - v e r s i o n . j s     p          ~    n   v              0 < e n g i n e - w e b k i t - v e r s i o n . j s     `          ~    hn   v                < e n t r y - u n b i n d . j s       `          ~    n   v               < e n t r y - u n b i n d . j s       `          ~    (n   v              < e n t r y - u n b i n d . j s       `          ~    n   v                < e n t r y - u n b i n d . j s       `          ~    n   v               < e n t r y - u n b i n d . j s       `          ~    Hn    v                 < e n t r y - v i r t u a l . j s     `          ~    n   'v                < e n t r y - v i r t u a l . j s     `          ~    n   'v               < e n t r y - v i r t u a l . j s     `          ~    hn   'v                 < e n t r y - v i r t u a l . j s     `          ~    n   'v                < e n t r y - v i r t u a l . j s     `          ~    (n   Nv                 < e n u m - b u g - k e y s . j s     `          ~    n   Nv                < e n u m - b u g - k e y s . j s     `          ~    n   uv               < e n u m - b u g - k e y s . j s     `          ~    Hn   uv                 < e n u m - b u g - k e y s . j s     `          ~    n   uv                < e n u m - b u g - k e y s . j s     p          ~    n   v               4 < e r r o r - s t a c k - i n s t a l l a b l e . j s p          ~    xn   v              4 < e r r o r - s t a c k - i n s t a l l a b l e . j s p          ~    n   v             4 < e r r o r - s t a c k - i n s t a l l a b l e . j s p          ~    Xn   v               4 < e r r o r - s t a c k - i n s t a l l a b l e . j s p          ~    n   v              4 < e r r o r - s t a c k - i n s t a l l a b l e . j s `          ~    8n   v               $ < e r r o r - t o - s t r i n g . j s `          ~    n   v              $ < e r r o r - t o - s t r i n g . j s `          ~    n   v             $ < e r r o r - t o - s t r i n g . j s `          ~    Xn   v               $ < e r r o r - t o - s t r i n g . j s `          ~    n   v              $ < e r r o r - t o - s t r i n g . j s P          ~    n   v                < e x p o r t . j s   P          ~    hn   v               < e x p o r t . j s   P          ~    n   s8v              < e x p o r t . j s   P          ~    n   s8v                < e x p o r t . j s   P          ~    Xn   s8v               < e x p o r t . j s   P          ~    n   p_v                < f a i l s . j s     P          ~    n   p_v               < f a i l s . j s     P          ~    Hn   p_v              < f a i l s . j s     P          ~    n   p_v                < f a i l s . j s                             P          ~     n   p_v               < f a i l s . j s               ~    Pn   Sv               J < f i x - r e g e x p - w e l l - k n o w n - s y m b o l - l o g i c . j s             ~    n   Sv              J < f i x - r e g e x p - w e l l - k n o w n - s y m b o l - l o g i c . j s             ~    `n   Sv             J < f i x - r e g e x p - w e l l - k n o w n - s y m b o l - l o g i c . j s             ~    n   Sv               J < f i x - r e g e x p - w e l l - k n o w n - s y m b o l - l o g i c . j s             ~    pn   Sv              J < f i x - r e g e x p - w e l l - k n o w n - s y m b o l - l o g i c . j s   h          ~    n   Iv               * < f l a t t e n - i n t o - a r r a y . j s   h          ~    `n   Iv              * < f l a t t e n - i n t o - a r r a y . j s   h          ~    n   Iv             * < f l a t t e n - i n t o - a r r a y . j s   h          ~    0n   Iv               * < f l a t t e n - i n t o - a r r a y . j s   h          ~    n   Iv              * < f l a t t e n - i n t o - a r r a y . j s   X          ~     n   Dv                < f r e e z i n g . j s       X          ~    Xn   6"v               < f r e e z i n g . j s       X          ~    n   6"v              < f r e e z i n g . j s       X          ~    n   6"v                < f r e e z i n g . j s       X          ~    `n   6"v               < f r e e z i n g . j s       `          ~    n   +Iv               " < f u n c t i o n - a p p l y . j s   `          ~    n   "pv              " < f u n c t i o n - a p p l y . j s   `          ~    xn   "pv             " < f u n c t i o n - a p p l y . j s   `          ~    n   "pv               " < f u n c t i o n - a p p l y . j s   `          ~    8n   "pv              " < f u n c t i o n - a p p l y . j s   p          ~    n   v               0 < f u n c t i o n - b i n d - c o n t e x t . j s     p          ~    n   v              0 < f u n c t i o n - b i n d - c o n t e x t . j s     p          ~    xn   v             0 < f u n c t i o n - b i n d - c o n t e x t . j s     p          ~    n   v               0 < f u n c t i o n - b i n d - c o n t e x t . j s     p          ~    Xn   v              0 < f u n c t i o n - b i n d - c o n t e x t . j s     p          ~    n   v               . < f u n c t i o n - b i n d - n a t i v e . j s       p          ~    8n   v              . < f u n c t i o n - b i n d - n a t i v e . j s       p          ~    n   v             . < f u n c t i o n - b i n d - n a t i v e . j s       p          ~    n   v               . < f u n c t i o n - b i n d - n a t i v e . j s       p          ~    n   v              . < f u n c t i o n - b i n d - n a t i v e . j s       `          ~    n   v                 < f u n c t i o n - b i n d . j s     `          ~    Xn   v                < f u n c t i o n - b i n d . j s     `          ~    n   v               < f u n c t i o n - b i n d . j s     `          ~    n   v                 < f u n c t i o n - b i n d . j s     `          ~    xn   v                < f u n c t i o n - b i n d . j s     `          ~    n   v                 < f u n c t i o n - c a l l . j s     `          ~    8n   v                < f u n c t i o n - c a l l . j s     `          ~    n   v               < f u n c t i o n - c a l l . j s             `          ~      o   v                 < f u n c t i o n - c a l l . j s     `          ~    ` o   v                < f u n c t i o n - c a l l . j s     `          ~     o   v                 < f u n c t i o n - n a m e . j s     `          ~     o   v                < f u n c t i o n - n a m e . j s     `          ~    o   v               < f u n c t i o n - n a m e . j s     `          ~    o   v                 < f u n c t i o n - n a m e . j s     `          ~    @o   v                < f u n c t i o n - n a m e . j s     p          ~    o   v               0 < f u n c t i o n - u n c u r r y - t h i s . j s     p          ~    o   rv              0 < f u n c t i o n - u n c u r r y - t h i s . j s     p          ~    o   rv             0 < f u n c t i o n - u n c u r r y - t h i s . j s     p          ~    o   rv               0 < f u n c t i o n - u n c u r r y - t h i s . j s     p          ~    `o   rv              0 < f u n c t i o n - u n c u r r y - t h i s . j s     h          ~    o   qv               * < g e t - a s y n c - i t e r a t o r . j s   h          ~    8o   qv              * < g e t - a s y n c - i t e r a t o r . j s   h          ~    o   qv             * < g e t - a s y n c - i t e r a t o r . j s   h          ~    o   b-v               * < g e t - a s y n c - i t e r a t o r . j s   h          ~    po   b-v              * < g e t - a s y n c - i t e r a t o r . j s   `          ~    o   WTv                < g e t - b u i l t - i n . j s       `          ~    8o   WTv               < g e t - b u i l t - i n . j s       `          ~    o   WTv              < g e t - b u i l t - i n . j s       `          ~    o   WTv                < g e t - b u i l t - i n . j s       `          ~    Xo   WTv               < g e t - b u i l t - i n . j s       h          ~    o   Av               , < g e t - i t e r a t o r - m e t h o d . j s h          ~     	o   Av              , < g e t - i t e r a t o r - m e t h o d . j s h          ~    	o   Av             , < g e t - i t e r a t o r - m e t h o d . j s h          ~    	o   Av               , < g e t - i t e r a t o r - m e t h o d . j s h          ~    X
o   Av              , < g e t - i t e r a t o r - m e t h o d . j s `          ~    
o   3v                < g e t - i t e r a t o r . j s       `          ~     o   3v               < g e t - i t e r a t o r . j s       `          ~    o   'v              < g e t - i t e r a t o r . j s       `          ~    o   'v                < g e t - i t e r a t o r . j s       `          ~    @o   'v               < g e t - i t e r a t o r . j s       h          ~    o   'v               & < g e t - m a p - i t e r a t o r . j s       h          ~    o   'v              & < g e t - m a p - i t e r a t o r . j s       h          ~    po   'v             & < g e t - m a p - i t e r a t o r . j s       h          ~    o   'v               & < g e t - m a p - i t e r a t o r . j s       h          ~    @o   >v              & < g e t - m a p - i t e r a t o r . j s       X          ~    o   
ev                < g e t - m e t h o d . j s   X          ~     o   
ev               < g e t - m e t h o d . j s   X          ~    Xo   
ev              < g e t - m e t h o d . j s                                                                                   X          ~     o   
ev                < g e t - m e t h o d . j s   X          ~    Xo   
ev               < g e t - m e t h o d . j s   h          ~    o   v               & < g e t - s e t - i t e r a t o r . j s       h          ~    o   v              & < g e t - s e t - i t e r a t o r . j s       h          ~    o   v             & < g e t - s e t - i t e r a t o r . j s       h          ~    o   v               & < g e t - s e t - i t e r a t o r . j s       h          ~    Po   v              & < g e t - s e t - i t e r a t o r . j s       h          ~    o    v               & < g e t - s u b s t i t u t i o n . j s       h          ~     o    v              & < g e t - s u b s t i t u t i o n . j s       h          ~    o    v             & < g e t - s u b s t i t u t i o n . j s       h          ~    o    v               & < g e t - s u b s t i t u t i o n . j s       h          ~    Xo    v              & < g e t - s u b s t i t u t i o n . j s       P          ~    o   'v                < g l o b a l . j s   P          ~    o   Nv               < g l o b a l . j s   P          ~    `o   Nv              < g l o b a l . j s   P          ~    o   Nv                < g l o b a l . j s   P          ~     o   Nv               < g l o b a l . j s   h          ~    Po   uv               & < h a s - o w n - p r o p e r t y . j s       h          ~    o   v              & < h a s - o w n - p r o p e r t y . j s       h          ~     o   v             & < h a s - o w n - p r o p e r t y . j s       h          ~    o   v               & < h a s - o w n - p r o p e r t y . j s       h          ~    o   v              & < h a s - o w n - p r o p e r t y . j s       X          ~    Xo   v                < h i d d e n - k e y s . j s X          ~    o   v               < h i d d e n - k e y s . j s X          ~    o   v              < h i d d e n - k e y s . j s X          ~    `o   v                < h i d d e n - k e y s . j s X          ~    o   v               < h i d d e n - k e y s . j s h          ~    o   v               * < h o s t - r e p o r t - e r r o r s . j s   h          ~    xo   v              * < h o s t - r e p o r t - e r r o r s . j s   h          ~    o   v             * < h o s t - r e p o r t - e r r o r s . j s   h          ~    Ho   8v               * < h o s t - r e p o r t - e r r o r s . j s   h          ~    o   8v              * < h o s t - r e p o r t - e r r o r s . j s   P          ~    o   _v                < h t m l . j s       P          ~    ho   _v               < h t m l . j s       P          ~    o   _v              < h t m l . j s       P          ~    o   _v                < h t m l . j s       P          ~    Xo   _v               < h t m l . j s       `          ~    o   ov               " < i e 8 - d o m - d e f i n e . j s   `          ~    o   ov              " < i e 8 - d o m - d e f i n e . j s   `          ~    ho   ov             " < i e 8 - d o m - d e f i n e . j s   `          ~    o   ov               " < i e 8 - d o m - d e f i n e . j s   `          ~    (o   ov              " < i e 8 - d o m - d e f i n e . j s   P          ~    o   5pv                < i e e e 7 5 4 . j s                                         P          ~      o   5pv               < i e e e 7 5 4 . j s P          ~    P o   5pv              < i e e e 7 5 4 . j s P          ~     o   5pv                < i e e e 7 5 4 . j s P          ~     o   5pv               < i e e e 7 5 4 . j s `          ~    @!o   'v               " < i n d e x e d - o b j e c t . j s   `          ~    !o   'v              " < i n d e x e d - o b j e c t . j s   `          ~     "o   'v             " < i n d e x e d - o b j e c t . j s   `          ~    `"o   'v               " < i n d e x e d - o b j e c t . j s   `          ~    "o   'v              " < i n d e x e d - o b j e c t . j s   h          ~     #o   v               , < i n h e r i t - i f - r e q u i r e d . j s h          ~    #o   v              , < i n h e r i t - i f - r e q u i r e d . j s h          ~    #o   v             , < i n h e r i t - i f - r e q u i r e d . j s h          ~    X$o   v               , < i n h e r i t - i f - r e q u i r e d . j s h          ~    $o   v              , < i n h e r i t - i f - r e q u i r e d . j s `          ~    (%o   3v               " < i n s p e c t - s o u r c e . j s   `          ~    %o   Yv              " < i n s p e c t - s o u r c e . j s   `          ~    %o   Yv             " < i n s p e c t - s o u r c e . j s   `          ~    H&o   Yv               " < i n s p e c t - s o u r c e . j s   `          ~    &o   Yv              " < i n s p e c t - s o u r c e . j s   h          ~    'o   v               , < i n s t a l l - e r r o r - c a u s e . j s h          ~    p'o   v              , < i n s t a l l - e r r o r - c a u s e . j s h          ~    'o   v             , < i n s t a l l - e r r o r - c a u s e . j s h          ~    @(o   v               , < i n s t a l l - e r r o r - c a u s e . j s h          ~    (o   v              , < i n s t a l l - e r r o r - c a u s e . j s h          ~    )o   v               ( < i n t e r n a l - m e t a d a t a . j s     h          ~    x)o   v              ( < i n t e r n a l - m e t a d a t a . j s     h          ~    )o   v             ( < i n t e r n a l - m e t a d a t a . j s     h          ~    H*o   v               ( < i n t e r n a l - m e t a d a t a . j s     h          ~    *o   v              ( < i n t e r n a l - m e t a d a t a . j s     `          ~    +o   v               " < i n t e r n a l - s t a t e . j s   `          ~    x+o   Cv              " < i n t e r n a l - s t a t e . j s   `          ~    +o   Cv             " < i n t e r n a l - s t a t e . j s   `          ~    8,o   Cv               " < i n t e r n a l - s t a t e . j s   `          ~    ,o   Cv              " < i n t e r n a l - s t a t e . j s   x          ~    ,o   v               6 < i s - a r r a y - i t e r a t o r - m e t h o d . j s       x          ~    p-o   v              6 < i s - a r r a y - i t e r a t o r - m e t h o d . j s       x          ~    -o   v             6 < i s - a r r a y - i t e r a t o r - m e t h o d . j s       x          ~    `.o   v               6 < i s - a r r a y - i t e r a t o r - m e t h o d . j s       x          ~    .o   v              6 < i s - a r r a y - i t e r a t o r - m e t h o d . j s       X          ~    P/o   v                < i s - a r r a y . j s       X          ~    /o   v               < i s - a r r a y . j s       X          ~     0o   v              < i s - a r r a y . j s       X          ~    X0o   v                < i s - a r r a y . j s       X          ~    0o   v               < i s - a r r a y . j s       X          ~    1o   v                < i s - c a l l a b l e . j s X          ~    `1o   -v               < i s - c a l l a b l e . j s X          ~    1o   -v              < i s - c a l l a b l e . j s X          ~    2o   -v                < i s - c a l l a b l e . j s X          ~    h2o   -v               < i s - c a l l a b l e . j s `          ~    2o   sTv               " < i s - c o n s t r u c t o r . j s   `          ~     3o   sTv              " < i s - c o n s t r u c t o r . j s   `          ~    3o   sTv             " < i s - c o n s t r u c t o r . j s   `          ~    3o   sTv               " < i s - c o n s t r u c t o r . j s   `          ~    @4o   sTv              " < i s - c o n s t r u c t o r . j s   h          ~    4o   Uv               * < i s - d a t a - d e s c r i p t o r . j s   h          ~    5o   Uv              * < i s - d a t a - d e s c r i p t o r . j s   h          ~    p5o   Uv             * < i s - d a t a - d e s c r i p t o r . j s   h          ~    5o   Uv               * < i s - d a t a - d e s c r i p t o r . j s   h          ~    @6o   Uv              * < i s - d a t a - d e s c r i p t o r . j s   X          ~    6o   Iv                < i s - f o r c e d . j s     X          ~     7o   Fv               < i s - f o r c e d . j s     X          ~    X7o   Fv              < i s - f o r c e d . j s     X          ~    7o   Fv                < i s - f o r c e d . j s     X          ~    8o   Fv               < i s - f o r c e d . j s     h          ~    `8o   4v               * < i s - i n t e g r a l - n u m b e r . j s   h          ~    8o   4v              * < i s - i n t e g r a l - n u m b e r . j s   h          ~    09o   4v             * < i s - i n t e g r a l - n u m b e r . j s   h          ~    9o   4v               * < i s - i n t e g r a l - n u m b e r . j s   h          ~     :o   4v              * < i s - i n t e g r a l - n u m b e r . j s   X          ~    h:o   %ev                < i s - i t e r a b l e . j s X          ~    :o   %ev               < i s - i t e r a b l e . j s X          ~    ;o   %ev              < i s - i t e r a b l e . j s X          ~    p;o   %ev                < i s - i t e r a b l e . j s X          ~    ;o   %ev               < i s - i t e r a b l e . j s X          ~     <o   v                < i s - o b j e c t . j s     X          ~    x<o   v               < i s - o b j e c t . j s     X          ~    <o   v              < i s - o b j e c t . j s     X          ~    (=o   v                < i s - o b j e c t . j s     X          ~    =o   v               < i s - o b j e c t . j s     P          ~    =o   v                < i s - p u r e . j s P          ~    (>o   v               < i s - p u r e . j s P          ~    x>o   v              < i s - p u r e . j s P          ~    >o      v                < i s - p u r e . j s P          ~    ?o      v               < i s - p u r e . j s X          ~    h?o   '  v                < i s - r e g e x p . j s                                                                     X          ~     @o   '  v               < i s - r e g e x p . j s     X          ~    X@o   '  v              < i s - r e g e x p . j s     X          ~    @o   '  v                < i s - r e g e x p . j s     X          ~    Ao   '  v               < i s - r e g e x p . j s     X          ~    `Ao   u  v                < i s - s y m b o l . j s     X          ~    Ao   u  v               < i s - s y m b o l . j s     X          ~    Bo   u  v              < i s - s y m b o l . j s     X          ~    hBo   u  v                < i s - s y m b o l . j s     X          ~    Bo   u  v               < i s - s y m b o l . j s     P          ~    Co     v                < i t e r a t e . j s P          ~    hCo     v               < i t e r a t e . j s P          ~    Co     v              < i t e r a t e . j s P          ~    Do     v                < i t e r a t e . j s P          ~    XDo     v               < i t e r a t e . j s `           ~    Do     v               " < i t e r a t o r - c l o s e . j s   `           ~    Eo     v              " < i t e r a t o r - c l o s e . j s   `           ~    hEo     v             " < i t e r a t o r - c l o s e . j s   `           ~    Eo     v               " < i t e r a t o r - c l o s e . j s   `           ~    (Fo     v              " < i t e r a t o r - c l o s e . j s   p          ~    Fo    v               0 < i t e r a t o r - c r e a t e - p r o x y . j s     p          ~    Fo    v              0 < i t e r a t o r - c r e a t e - p r o x y . j s     p          ~    hGo    v             0 < i t e r a t o r - c r e a t e - p r o x y . j s     p          ~    Go    v               0 < i t e r a t o r - c r e a t e - p r o x y . j s     p          ~    HHo   8 v              0 < i t e r a t o r - c r e a t e - p r o x y . j s     `          ~    Ho   _ v               " < i t e r a t o r s - c o r e . j s   `          ~    Io   _ v              " < i t e r a t o r s - c o r e . j s   `          ~    xIo   _ v             " < i t e r a t o r s - c o r e . j s   `          ~    Io   _ v               " < i t e r a t o r s - c o r e . j s   `          ~    8Jo   _ v              " < i t e r a t o r s - c o r e . j s   X          ~    Jo    v                < i t e r a t o r s . j s     X          ~    Jo    v               < i t e r a t o r s . j s     X          ~    HKo    v              < i t e r a t o r s . j s     X          ~    Ko    v                < i t e r a t o r s . j s     X          ~    Ko    v               < i t e r a t o r s . j s     p          ~    PLo    v               . < l e n g t h - o f - a r r a y - l i k e . j s       p          ~    Lo    v              . < l e n g t h - o f - a r r a y - l i k e . j s       p          ~    0Mo    v             . < l e n g t h - o f - a r r a y - l i k e . j s       p          ~    Mo    v               . < l e n g t h - o f - a r r a y - l i k e . j s       p          ~    No    v              . < l e n g t h - o f - a r r a y - l i k e . j s       X          ~    No   ]" v                < m a p - e m p l a c e . j s X          ~    No   ]" v               < m a p - e m p l a c e . j s X          ~    0Oo   WI v              < m a p - e m p l a c e . j s X          ~    Oo   WI v                < m a p - e m p l a c e . j s                                 X          ~     Po   WI v               < m a p - e m p l a c e . j s X          ~    XPo   Hp v                < m a p - u p s e r t . j s   X          ~    Po   Hp v               < m a p - u p s e r t . j s   X          ~    Qo   Hp v              < m a p - u p s e r t . j s   X          ~    `Qo   Hp v                < m a p - u p s e r t . j s   X          ~    Qo   Hp v               < m a p - u p s e r t . j s   X          ~    Ro   A v                < m a t h - e x p m 1 . j s   X          ~    hRo   A v               < m a t h - e x p m 1 . j s   X          ~    Ro   : v              < m a t h - e x p m 1 . j s   X          ~    So   : v                < m a t h - e x p m 1 . j s   X          ~    pSo   : v               < m a t h - e x p m 1 . j s   X          ~    So   ' v                < m a t h - f r o u n d . j s X          ~     To   ' v               < m a t h - f r o u n d . j s X          ~    xTo   ' v              < m a t h - f r o u n d . j s X          ~    To   ' v                < m a t h - f r o u n d . j s X          ~    (Uo   ' v               < m a t h - f r o u n d . j s X      	    ~    Uo   # v                < m a t h - l o g 1 0 . j s   X      	    ~    Uo   3 v               < m a t h - l o g 1 0 . j s   X      	    ~    0Vo   3 v              < m a t h - l o g 1 0 . j s   X      	    ~    Vo   3 v                < m a t h - l o g 1 0 . j s   X      	    ~    Vo   3 v               < m a t h - l o g 1 0 . j s   X      
    ~    8Wo   Z v                < m a t h - l o g 1 p . j s   X      
    ~    Wo   Z v               < m a t h - l o g 1 p . j s   X      
    ~    Wo   Z v              < m a t h - l o g 1 p . j s   X      
    ~    @Xo    v                < m a t h - l o g 1 p . j s   X      
    ~    Xo    v               < m a t h - l o g 1 p . j s   X          ~    Xo    v                < m a t h - s c a l e . j s   X          ~    HYo    v               < m a t h - s c a l e . j s   X          ~    Yo    v              < m a t h - s c a l e . j s   X          ~    Yo    v                < m a t h - s c a l e . j s   X          ~    PZo    v               < m a t h - s c a l e . j s   X          ~    Zo    v                < m a t h - s i g n . j s     X          ~     [o    v               < m a t h - s i g n . j s     X          ~    X[o    v              < m a t h - s i g n . j s     X          ~    [o    v                < m a t h - s i g n . j s     X          ~    \o    v               < m a t h - s i g n . j s     X          ~    `\o   j v                < m i c r o t a s k . j s     X          ~    \o   j v               < m i c r o t a s k . j s     X          ~    ]o   j v              < m i c r o t a s k . j s     X          ~    h]o   j v                < m i c r o t a s k . j s     X          ~    ]o   j v               < m i c r o t a s k . j s     x          ~    ^o    v               : < n a t i v e - p r o m i s e - c o n s t r u c t o r . j s   x          ~    ^o    v              : < n a t i v e - p r o m i s e - c o n s t r u c t o r . j s   x          ~    _o    v             : < n a t i v e - p r o m i s e - c o n s t r u c t o r . j s   x          ~    _o    v               : < n a t i v e - p r o m i s e - c o n s t r u c t o r . j s           x          ~     `o    v              : < n a t i v e - p r o m i s e - c o n s t r u c t o r . j s   `          ~    x`o   |T v                 < n a t i v e - s y m b o l . j s     `          ~    `o   |T v                < n a t i v e - s y m b o l . j s     `          ~    8ao   |T v               < n a t i v e - s y m b o l . j s     `          ~    ao   |T v                 < n a t i v e - s y m b o l . j s     `          ~    ao   |T v                < n a t i v e - s y m b o l . j s     X          ~    Xbo   u{ v                < n a t i v e - u r l . j s   X          ~    bo   u{ v               < n a t i v e - u r l . j s   X          ~    co   u{ v              < n a t i v e - u r l . j s   X          ~    `co   u{ v                < n a t i v e - u r l . j s   X          ~    co   j v               < n a t i v e - u r l . j s   `          ~    do   c v               $ < n a t i v e - w e a k - m a p . j s `          ~    pdo   c v              $ < n a t i v e - w e a k - m a p . j s `          ~    do   c v             $ < n a t i v e - w e a k - m a p . j s `          ~    0eo   c v               $ < n a t i v e - w e a k - m a p . j s `          ~    eo   c v              $ < n a t i v e - w e a k - m a p . j s p          ~    eo   U v               2 < n e w - p r o m i s e - c a p a b i l i t y . j s   p          ~    `fo   H v              2 < n e w - p r o m i s e - c a p a b i l i t y . j s   p          ~    fo   H v             2 < n e w - p r o m i s e - c a p a b i l i t y . j s   p          ~    @go   H v               2 < n e w - p r o m i s e - c a p a b i l i t y . j s   p          ~    go   H v              2 < n e w - p r o m i s e - c a p a b i l i t y . j s   x          ~     ho   => v               8 < n o r m a l i z e - s t r i n g - a r g u m e n t . j s     x          ~    ho   => v              8 < n o r m a l i z e - s t r i n g - a r g u m e n t . j s     x          ~    io   => v             8 < n o r m a l i z e - s t r i n g - a r g u m e n t . j s     x          ~    io   => v               8 < n o r m a l i z e - s t r i n g - a r g u m e n t . j s     x          ~     jo   => v              8 < n o r m a l i z e - s t r i n g - a r g u m e n t . j s     `          ~    xjo   ' v                < n o t - a - r e g e x p . j s       `          ~    jo   ' v               < n o t - a - r e g e x p . j s       `          ~    8ko   ' v              < n o t - a - r e g e x p . j s       `          ~    ko   ' v                < n o t - a - r e g e x p . j s       `          ~    ko   ' v               < n o t - a - r e g e x p . j s       h          ~    Xlo    v               & < n u m b e r - i s - f i n i t e . j s       h          ~    lo    v              & < n u m b e r - i s - f i n i t e . j s       h          ~    (mo    v             & < n u m b e r - i s - f i n i t e . j s       h          ~    mo    v               & < n u m b e r - i s - f i n i t e . j s       h          ~    mo    v              & < n u m b e r - i s - f i n i t e . j s       h          ~    `no    ( v               * < n u m b e r - p a r s e - f l o a t . j s   h          ~    no    ( v              * < n u m b e r - p a r s e - f l o a t . j s   h          ~    0oo    ( v             * < n u m b e r - p a r s e - f l o a t . j s   h          ~    oo    ( v               * < n u m b e r - p a r s e - f l o a t . j s   h          ~     po    ( v              * < n u m b e r - p a r s e - f l o a t . j s   h          ~    hpo   N v               & < n u m b e r - p a r s e - i n t . j s       h          ~    po   u v              & < n u m b e r - p a r s e - i n t . j s       h          ~    8qo   u v             & < n u m b e r - p a r s e - i n t . j s       h          ~    qo   u v               & < n u m b e r - p a r s e - i n t . j s       h          ~    ro   u v              & < n u m b e r - p a r s e - i n t . j s       p          ~    pro    v               2 < n u m e r i c - r a n g e - i t e r a t o r . j s   p          ~    ro    v              2 < n u m e r i c - r a n g e - i t e r a t o r . j s   p          ~    Pso    v             2 < n u m e r i c - r a n g e - i t e r a t o r . j s   p          ~    so    v               2 < n u m e r i c - r a n g e - i t e r a t o r . j s   p          ~    0to    v              2 < n u m e r i c - r a n g e - i t e r a t o r . j s   `          ~    to    v                 < o b j e c t - a s s i g n . j s     `          ~     uo    v                < o b j e c t - a s s i g n . j s     `          ~    `uo    v               < o b j e c t - a s s i g n . j s     `          ~    uo    v                 < o b j e c t - a s s i g n . j s     `          ~     vo    v                < o b j e c t - a s s i g n . j s     `          ~    vo   8 v                 < o b j e c t - c r e a t e . j s     `          ~    vo   8 v                < o b j e c t - c r e a t e . j s     `          ~    @wo   8 v               < o b j e c t - c r e a t e . j s     `          ~    wo   8 v                 < o b j e c t - c r e a t e . j s     `          ~     xo   8 v                < o b j e c t - c r e a t e . j s     x          ~    `xo   _ v               6 < o b j e c t - d e f i n e - p r o p e r t i e s . j s       x          ~    xo   _ v              6 < o b j e c t - d e f i n e - p r o p e r t i e s . j s       x          ~    Pyo   _ v             6 < o b j e c t - d e f i n e - p r o p e r t i e s . j s       x          ~    yo   _ v               6 < o b j e c t - d e f i n e - p r o p e r t i e s . j s       x          ~    @zo   _ v              6 < o b j e c t - d e f i n e - p r o p e r t i e s . j s       p          ~    zo    v               2 < o b j e c t - d e f i n e - p r o p e r t y . j s   p          ~    ({o    v              2 < o b j e c t - d e f i n e - p r o p e r t y . j s   p          ~    {o    v             2 < o b j e c t - d e f i n e - p r o p e r t y . j s   p          ~    |o    v               2 < o b j e c t - d e f i n e - p r o p e r t y . j s   p          ~    x|o    v              2 < o b j e c t - d e f i n e - p r o p e r t y . j s             ~    |o    v               J < o b j e c t - g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             ~    p}o    v              J < o b j e c t - g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             ~    }o    v             J < o b j e c t - g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             ~    ~o   ]p	 v               J < o b j e c t - g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             ~    o   O	 v              J < o b j e c t - g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s                                                                                                                             ~     o   H	 v               R < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s - e x t e r n a l . j s             ~    o   H	 v              R < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s - e x t e r n a l . j s             ~     o   ;	 v             R < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s - e x t e r n a l . j s             ~    o   ;	 v               R < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s - e x t e r n a l . j s             ~    @o   ;	 v              R < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s - e x t e r n a l . j s             ~    o   4
 v               @ < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s . j s               ~    Po   4
 v              @ < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s . j s               ~    o   4
 v             @ < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s . j s               ~    Po   4
 v               @ < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s . j s               ~    o   )3
 v              @ < o b j e c t - g e t - o w n - p r o p e r t y - n a m e s . j s                ~    Po   Z
 v               D < o b j e c t - g e t - o w n - p r o p e r t y - s y m b o l s . j s            ~    o   Z
 v              D < o b j e c t - g e t - o w n - p r o p e r t y - s y m b o l s . j s            ~    Po   Z
 v             D < o b j e c t - g e t - o w n - p r o p e r t y - s y m b o l s . j s            ~    o   Z
 v               D < o b j e c t - g e t - o w n - p r o p e r t y - s y m b o l s . j s            ~    Po   Z
 v              D < o b j e c t - g e t - o w n - p r o p e r t y - s y m b o l s . j s p      !    ~    o   
 v               4 < o b j e c t - g e t - p r o t o t y p e - o f . j s p      !    ~    @o   
 v              4 < o b j e c t - g e t - p r o t o t y p e - o f . j s p      !    ~    o   
 v             4 < o b j e c t - g e t - p r o t o t y p e - o f . j s p      !    ~     o   
 v               4 < o b j e c t - g e t - p r o t o t y p e - o f . j s p      !    ~    o   
 v              4 < o b j e c t - g e t - p r o t o t y p e - o f . j s p      "    ~     o   
 v               . < o b j e c t - i s - e x t e n s i b l e . j s       p      "    ~    po   
 v              . < o b j e c t - i s - e x t e n s i b l e . j s       p      "    ~    o   
 v             . < o b j e c t - i s - e x t e n s i b l e . j s       p      "    ~    Po   
 v               . < o b j e c t - i s - e x t e n s i b l e . j s       p      "    ~    o   
 v              . < o b j e c t - i s - e x t e n s i b l e . j s       p      #    ~    0o    v               2 < o b j e c t - i s - p r o t o t y p e - o f . j s   p      #    ~    o    v              2 < o b j e c t - i s - p r o t o t y p e - o f . j s   p      #    ~    o    v             2 < o b j e c t - i s - p r o t o t y p e - o f . j s   p      #    ~    o    v               2 < o b j e c t - i s - p r o t o t y p e - o f . j s   p      #    ~    o    v              2 < o b j e c t - i s - p r o t o t y p e - o f . j s   `      $    ~    `o   C v               $ < o b j e c t - i t e r a t o r . j s `      $    ~    o   j v              $ < o b j e c t - i t e r a t o r . j s `      $    ~     o   j v             $ < o b j e c t - i t e r a t o r . j s `      $    ~    o   j v               $ < o b j e c t - i t e r a t o r . j s                                 `      $    ~     o   j v              $ < o b j e c t - i t e r a t o r . j s p      %    ~    `o    v               . < o b j e c t - k e y s - i n t e r n a l . j s       p      %    ~    o    v              . < o b j e c t - k e y s - i n t e r n a l . j s       p      %    ~    @o    v             . < o b j e c t - k e y s - i n t e r n a l . j s       p      %    ~    o    v               . < o b j e c t - k e y s - i n t e r n a l . j s       p      %    ~     o    v              . < o b j e c t - k e y s - i n t e r n a l . j s       X      &    ~    o    v                < o b j e c t - k e y s . j s X      &    ~    o    v               < o b j e c t - k e y s . j s X      &    ~    @o    v              < o b j e c t - k e y s . j s X      &    ~    o    v                < o b j e c t - k e y s . j s X      &    ~    o    v               < o b j e c t - k e y s . j s       '    ~    Ho    v               @ < o b j e c t - p r o p e r t y - i s - e n u m e r a b l e . j s     P      6          o    v                < e d b . j c p             '    ~    o   - v              @ < o b j e c t - p r o p e r t y - i s - e n u m e r a b l e . j s     P      6          o   T v               < e d b . j c p             '    ~    o   { v             @ < o b j e c t - p r o p e r t y - i s - e n u m e r a b l e . j s           '    ~    ho   { v               @ < o b j e c t - p r o p e r t y - i s - e n u m e r a b l e . j s           '    ~    o   { v              @ < o b j e c t - p r o p e r t y - i s - e n u m e r a b l e . j s           (    ~    ho   y v               H < o b j e c t - p r o t o t y p e - a c c e s s o r s - f o r c e d . j s           (    ~    o   y v              H < o b j e c t - p r o t o t y p e - a c c e s s o r s - f o r c e d . j s           (    ~    xo   y v             H < o b j e c t - p r o t o t y p e - a c c e s s o r s - f o r c e d . j s           (    ~     o   Ie v               H < o b j e c t - p r o t o t y p e - a c c e s s o r s - f o r c e d . j s           (    ~    o   Ie v              H < o b j e c t - p r o t o t y p e - a c c e s s o r s - f o r c e d . j s     p      )    ~    o   4 v               4 < o b j e c t - s e t - p r o t o t y p e - o f . j s p      )    ~    o   4 v              4 < o b j e c t - s e t - p r o t o t y p e - o f . j s p      )    ~    o   4 v             4 < o b j e c t - s e t - p r o t o t y p e - o f . j s p      )    ~    `o   4 v               4 < o b j e c t - s e t - p r o t o t y p e - o f . j s p      )    ~    o   4 v              4 < o b j e c t - s e t - p r o t o t y p e - o f . j s `      *    ~    @o   " v               $ < o b j e c t - t o - a r r a y . j s `      *    ~    o   " v              $ < o b j e c t - t o - a r r a y . j s `      *    ~     o   " v             $ < o b j e c t - t o - a r r a y . j s `      *    ~    `o   " v               $ < o b j e c t - t o - a r r a y . j s `      *    ~    o   " v              $ < o b j e c t - t o - a r r a y . j s h      +    ~     o    v               & < o b j e c t - t o - s t r i n g . j s       h      +    ~    o    v              & < o b j e c t - t o - s t r i n g . j s       h      +    ~    o    v             & < o b j e c t - t o - s t r i n g . j s       h      +    ~    Xo   ( v               & < o b j e c t - t o - s t r i n g . j s                                                                       h      +    ~     o   ( v              & < o b j e c t - t o - s t r i n g . j s       p      ,    ~    ho   O v               0 < o r d i n a r y - t o - p r i m i t i v e . j s     p      ,    ~    o   O v              0 < o r d i n a r y - t o - p r i m i t i v e . j s     p      ,    ~    Ho   O v             0 < o r d i n a r y - t o - p r i m i t i v e . j s     p      ,    ~    o   O v               0 < o r d i n a r y - t o - p r i m i t i v e . j s     p      ,    ~    (o   O v              0 < o r d i n a r y - t o - p r i m i t i v e . j s     X      -    ~    o   v v                < o w n - k e y s . j s       X      -    ~    o   v v               < o w n - k e y s . j s       X      -    ~    Ho   v v              < o w n - k e y s . j s       X      -    ~    o   v v                < o w n - k e y s . j s       X      -    ~    o   v v               < o w n - k e y s . j s       P      .    ~    Po    v                < p a t h . j s       P      .    ~    o    v               < p a t h . j s       P      .    ~    o    v              < p a t h . j s       P      .    ~    @o    v                < p a t h . j s       P      .    ~    o    v               < p a t h . j s       P      /    ~    o    v                < p e r f o r m . j s P      /    ~    0o    v               < p e r f o r m . j s P      /    ~    o    v              < p e r f o r m . j s P      /    ~    o    v                < p e r f o r m . j s P      /    ~     o    v               < p e r f o r m . j s `      0    ~    po   8 v               $ < p r o m i s e - r e s o l v e . j s `      0    ~    o   8 v              $ < p r o m i s e - r e s o l v e . j s `      0    ~    0o   8 v             $ < p r o m i s e - r e s o l v e . j s `      0    ~    o   8 v               $ < p r o m i s e - r e s o l v e . j s `      0    ~    o   8 v              $ < p r o m i s e - r e s o l v e . j s P      1    ~    Po   _ v                < q u e u e . j s     P      1    ~    o    v               < q u e u e . j s     P      1    ~    o    v              < q u e u e . j s     P      1    ~    @o    v                < q u e u e . j s     P      1    ~    o    v               < q u e u e . j s     P      2    ~    o    v                < R E A D M E . m d   P      2    ~    0o    v               < R E A D M E . m d   P      2    ~    o    v              < R E A D M E . m d   P      2    ~    o    v                < R E A D M E . m d   P      2    ~     o    v               < R E A D M E . m d   `      3    ~    po   " v                < r e d e f i n e - a l l . j s       `      3    ~    o   " v               < r e d e f i n e - a l l . j s       `      3    ~    0o   " v              < r e d e f i n e - a l l . j s       `      3    ~    o   " v                < r e d e f i n e - a l l . j s       `      3    ~    o   |I v               < r e d e f i n e - a l l . j s       X      4    ~    Po   |I v                < r e d e f i n e . j s       X      4    ~    o   np v               < r e d e f i n e . j s       X      4    ~     o   np v              < r e d e f i n e . j s       X      4    ~    Xo   np v                < r e d e f i n e . j s                                                                                       X      4    ~     o   np v               < r e d e f i n e . j s       h      5    ~    Xo   c v               & < r e f l e c t - m e t a d a t a . j s       h      5    ~    o   c v              & < r e f l e c t - m e t a d a t a . j s       h      5    ~    (o   c v             & < r e f l e c t - m e t a d a t a . j s       h      5    ~    o   c v               & < r e f l e c t - m e t a d a t a . j s       h      5    ~    o   c v              & < r e f l e c t - m e t a d a t a . j s       p      6    ~    `o   S v               . < r e g e x p - e x e c - a b s t r a c t . j s       p      6    ~    o   S v              . < r e g e x p - e x e c - a b s t r a c t . j s       p      6    ~    @o   S v             . < r e g e x p - e x e c - a b s t r a c t . j s       p      6    ~    o   S v               . < r e g e x p - e x e c - a b s t r a c t . j s       p      6    ~     o   S v              . < r e g e x p - e x e c - a b s t r a c t . j s       X      7    ~    o   ] v                < r e g e x p - e x e c . j s X      7    ~    o   ] v               < r e g e x p - e x e c . j s X      7    ~    @o   ] v              < r e g e x p - e x e c . j s X      7    ~    o   >3 v                < r e g e x p - e x e c . j s X      7    ~    o   >3 v               < r e g e x p - e x e c . j s `      8    ~    Ho   5Z v                < r e g e x p - f l a g s . j s       `      8    ~    o   5Z v               < r e g e x p - f l a g s . j s       `      8    ~    o   5Z v              < r e g e x p - f l a g s . j s       `      8    ~    ho   5Z v                < r e g e x p - f l a g s . j s       `      8    ~    o   5Z v               < r e g e x p - f l a g s . j s       p      9    ~    (o   & v               0 < r e g e x p - s t i c k y - h e l p e r s . j s     p      9    ~    o    v              0 < r e g e x p - s t i c k y - h e l p e r s . j s     p      9    ~    o    v             0 < r e g e x p - s t i c k y - h e l p e r s . j s     p      9    ~    xo    v               0 < r e g e x p - s t i c k y - h e l p e r s . j s     p      9    ~    o    v              0 < r e g e x p - s t i c k y - h e l p e r s . j s     x      :    ~    Xo    v               : < r e g e x p - u n s u p p o r t e d - d o t - a l l . j s   x      :    ~    o    v              : < r e g e x p - u n s u p p o r t e d - d o t - a l l . j s   x      :    ~    Ho    v             : < r e g e x p - u n s u p p o r t e d - d o t - a l l . j s   x      :    ~    o    v               : < r e g e x p - u n s u p p o r t e d - d o t - a l l . j s   x      :    ~    8o    v              : < r e g e x p - u n s u p p o r t e d - d o t - a l l . j s   p      ;    ~    o    v               2 < r e g e x p - u n s u p p o r t e d - n c g . j s   p      ;    ~     o    v              2 < r e g e x p - u n s u p p o r t e d - n c g . j s   p      ;    ~    o    v             2 < r e g e x p - u n s u p p o r t e d - n c g . j s   p      ;    ~     o    v               2 < r e g e x p - u n s u p p o r t e d - n c g . j s   p      ;    ~    po    v              2 < r e g e x p - u n s u p p o r t e d - n c g . j s   x      <    ~    o   j v               6 < r e q u i r e - o b j e c t - c o e r c i b l e . j s       x      <    ~    Xo   j v              6 < r e q u i r e - o b j e c t - c o e r c i b l e . j s                                                       x      <    ~     o   j v             6 < r e q u i r e - o b j e c t - c o e r c i b l e . j s       x      <    ~    xo   j v               6 < r e q u i r e - o b j e c t - c o e r c i b l e . j s       x      <    ~    o   j v              6 < r e q u i r e - o b j e c t - c o e r c i b l e . j s       `      =    ~    ho    v               $ < s a m e - v a l u e - z e r o . j s `      =    ~    o    v              $ < s a m e - v a l u e - z e r o . j s `      =    ~    (o    v             $ < s a m e - v a l u e - z e r o . j s `      =    ~    o    v               $ < s a m e - v a l u e - z e r o . j s `      =    ~    o    v              $ < s a m e - v a l u e - z e r o . j s X      >    ~    Ho    v                < s a m e - v a l u e . j s   X      >    ~    o    v               < s a m e - v a l u e . j s   X      >    ~    o    v              < s a m e - v a l u e . j s   X      >    ~    Po    v                < s a m e - v a l u e . j s   X      >    ~    o    v               < s a m e - v a l u e . j s   X      ?    ~     o   - v                < s e t - g l o b a l . j s   X      ?    ~    Xo   - v               < s e t - g l o b a l . j s   X      ?    ~    o   - v              < s e t - g l o b a l . j s   X      ?    ~    o   - v                < s e t - g l o b a l . j s   X      ?    ~    `o   - v               < s e t - g l o b a l . j s   X      @    ~    o   { v                < s e t - s p e c i e s . j s X      @    ~    o   { v               < s e t - s p e c i e s . j s X      @    ~    ho   { v              < s e t - s p e c i e s . j s X      @    ~    o   { v                < s e t - s p e c i e s . j s X      @    ~    o   { v               < s e t - s p e c i e s . j s h      A    ~    po    v               ( < s e t - t o - s t r i n g - t a g . j s     h      A    ~    o    v              ( < s e t - t o - s t r i n g - t a g . j s     h      A    ~    @o    v             ( < s e t - t o - s t r i n g - t a g . j s     h      A    ~    o    v               ( < s e t - t o - s t r i n g - t a g . j s     h      A    ~    o    v              ( < s e t - t o - s t r i n g - t a g . j s     X      B    ~    xo   x v                < s h a r e d - k e y . j s   X      B    ~    o   x v               < s h a r e d - k e y . j s   X      B    ~    (o   x v              < s h a r e d - k e y . j s   X      B    ~    o   x v                < s h a r e d - k e y . j s   X      B    ~    o   x v               < s h a r e d - k e y . j s   `      C    ~    0o   p v                < s h a r e d - s t o r e . j s       `      C    ~    o   i> v               < s h a r e d - s t o r e . j s       `      C    ~    o   i> v              < s h a r e d - s t o r e . j s       `      C    ~    Po   i> v                < s h a r e d - s t o r e . j s       `      C    ~    o   `e v               < s h a r e d - s t o r e . j s       P      D    ~    o   O v                < s h a r e d . j s   P      D    ~    `o   O v               < s h a r e d . j s   P      D    ~    o   O v              < s h a r e d . j s   P      D    ~     o   O v                < s h a r e d . j s   P      D    ~    Po   O v               < s h a r e d . j s                                                                                                   h      E    ~     o   6 v               , < s p e c i e s - c o n s t r u c t o r . j s h      E    ~    ho   6 v              , < s p e c i e s - c o n s t r u c t o r . j s h      E    ~    o   6 v             , < s p e c i e s - c o n s t r u c t o r . j s h      E    ~    8o   6 v               , < s p e c i e s - c o n s t r u c t o r . j s h      E    ~    o   6 v              , < s p e c i e s - c o n s t r u c t o r . j s h      F    ~    o   2 v               * < s t r i n g - h t m l - f o r c e d . j s   h      F    ~    po   (( v              * < s t r i n g - h t m l - f o r c e d . j s   h      F    ~    o   (( v             * < s t r i n g - h t m l - f o r c e d . j s   h      F    ~    @o   (( v               * < s t r i n g - h t m l - f o r c e d . j s   h      F    ~    o   (( v              * < s t r i n g - h t m l - f o r c e d . j s   h      G    ~    o   O v               & < s t r i n g - m u l t i b y t e . j s       h      G    ~    xo   O v              & < s t r i n g - m u l t i b y t e . j s       h      G    ~    o   O v             & < s t r i n g - m u l t i b y t e . j s       h      G    ~    Ho   O v               & < s t r i n g - m u l t i b y t e . j s       h      G    ~    o   O v              & < s t r i n g - m u l t i b y t e . j s       p      H    ~    o   !v v               0 < s t r i n g - p a d - w e b k i t - b u g . j s     p      H    ~    o   !v v              0 < s t r i n g - p a d - w e b k i t - b u g . j s     p      H    ~    o   !v v             0 < s t r i n g - p a d - w e b k i t - b u g . j s     p      H    ~    ho    v               0 < s t r i n g - p a d - w e b k i t - b u g . j s     p      H    ~    o    v              0 < s t r i n g - p a d - w e b k i t - b u g . j s     X      I    ~    Ho    v                < s t r i n g - p a d . j s   X      I    ~    o    v               < s t r i n g - p a d . j s   X      I    ~    o    v              < s t r i n g - p a d . j s   X      I    ~    Po    v                < s t r i n g - p a d . j s   X      I    ~    o    v               < s t r i n g - p a d . j s   x      J    ~     o    v               6 < s t r i n g - p u n y c o d e - t o - a s c i i . j s       x      J    ~    xo    v              6 < s t r i n g - p u n y c o d e - t o - a s c i i . j s       x      J    ~    o    v             6 < s t r i n g - p u n y c o d e - t o - a s c i i . j s       x      J    ~    ho    v               6 < s t r i n g - p u n y c o d e - t o - a s c i i . j s       x      J    ~    o    v              6 < s t r i n g - p u n y c o d e - t o - a s c i i . j s       `      K    ~    Xo   8 v                 < s t r i n g - r e p e a t . j s     `      K    ~    o   8 v                < s t r i n g - r e p e a t . j s     `      K    ~    o   8 v               < s t r i n g - r e p e a t . j s     `      K    ~    xo   8 v                 < s t r i n g - r e p e a t . j s     `      K    ~    o   8 v                < s t r i n g - r e p e a t . j s     h      L    ~    8o   _ v               * < s t r i n g - t r i m - f o r c e d . j s   h      L    ~    o   _ v              * < s t r i n g - t r i m - f o r c e d . j s   h      L    ~    o    v             * < s t r i n g - t r i m - f o r c e d . j s   h      L    ~    po    v               * < s t r i n g - t r i m - f o r c e d . j s                                           h      L    ~     o    v              * < s t r i n g - t r i m - f o r c e d . j s   X      M    ~    ho    v                < s t r i n g - t r i m . j s X      M    ~    o    v               < s t r i n g - t r i m . j s X      M    ~    o    v              < s t r i n g - t r i m . j s X      M    ~    po    v                < s t r i n g - t r i m . j s X      M    ~    o    v               < s t r i n g - t r i m . j s P      N    ~     o    v                < t a s k . j s       P      N    ~    po    v               < t a s k . j s       P      N    ~    o    v              < t a s k . j s       P      N    ~    o    v                < t a s k . j s       P      N    ~    `o    v               < t a s k . j s       h      O    ~    o   " v               ( < t h i s - n u m b e r - v a l u e . j s     h      O    ~    o   " v              ( < t h i s - n u m b e r - v a l u e . j s     h      O    ~    o   " v             ( < t h i s - n u m b e r - v a l u e . j s     h      O    ~    o   " v               ( < t h i s - n u m b e r - v a l u e . j s     h      O    ~    Po   " v              ( < t h i s - n u m b e r - v a l u e . j s     h      P    ~    o   I v               ( < t o - a b s o l u t e - i n d e x . j s     h      P    ~     o   I v              ( < t o - a b s o l u t e - i n d e x . j s     h      P    ~    o   p v             ( < t o - a b s o l u t e - i n d e x . j s     h      P    ~    o   p v               ( < t o - a b s o l u t e - i n d e x . j s     h      P    ~    Xo   p v              ( < t o - a b s o l u t e - i n d e x . j s     X      Q    ~    o   ~ v                < t o - i n d e x . j s       X      Q    ~    o   ~ v               < t o - i n d e x . j s       X      Q    ~    po   ~ v              < t o - i n d e x . j s       X      Q    ~    o   ~ v                < t o - i n d e x . j s       X      Q    ~     o   ~ v               < t o - i n d e x . j s       h      R    ~    xo   e v               ( < t o - i n d e x e d - o b j e c t . j s     h      R    ~    o   e v              ( < t o - i n d e x e d - o b j e c t . j s     h      R    ~    Ho   e v             ( < t o - i n d e x e d - o b j e c t . j s     h      R    ~    o   e v               ( < t o - i n d e x e d - o b j e c t . j s     h      R    ~    o   e v              ( < t o - i n d e x e d - o b j e c t . j s     p      S    ~    o   [ v               2 < t o - i n t e g e r - o r - i n f i n i t y . j s   p      S    ~    o   [ v              2 < t o - i n t e g e r - o r - i n f i n i t y . j s   p      S    ~    `o   V3 v             2 < t o - i n t e g e r - o r - i n f i n i t y . j s   p      S    ~    o   V3 v               2 < t o - i n t e g e r - o r - i n f i n i t y . j s   p      S    ~    @o   V3 v              2 < t o - i n t e g e r - o r - i n f i n i t y . j s   X      T    ~    o   CZ v                < t o - l e n g t h . j s     X      T    ~    o   CZ v               < t o - l e n g t h . j s     X      T    ~    `o   CZ v              < t o - l e n g t h . j s     X      T    ~    o   CZ v                < t o - l e n g t h . j s     X      T    ~    o   CZ v               < t o - l e n g t h . j s     X      U    ~    ho   @ v                < t o - o b j e c t . j s                                                                     X      U    ~     o   7 v               < t o - o b j e c t . j s     X      U    ~    Xo   7 v              < t o - o b j e c t . j s     X      U    ~    o   7 v                < t o - o b j e c t . j s     X      U    ~    o   7 v               < t o - o b j e c t . j s     X      V    ~    `o   # v                < t o - o f f s e t . j s     X      V    ~    o   # v               < t o - o f f s e t . j s     X      V    ~    o   # v              < t o - o f f s e t . j s     X      V    ~    ho   # v                < t o - o f f s e t . j s     X      V    ~    o    v               < t o - o f f s e t . j s     h      W    ~    o    v               , < t o - p o s i t i v e - i n t e g e r . j s h      W    ~    o    v              , < t o - p o s i t i v e - i n t e g e r . j s h      W    ~    o    v             , < t o - p o s i t i v e - i n t e g e r . j s h      W    ~    Po    v               , < t o - p o s i t i v e - i n t e g e r . j s h      W    ~    o    v              , < t o - p o s i t i v e - i n t e g e r . j s `      X    ~     o   
D v                < t o - p r i m i t i v e . j s       `      X    ~    o   k v               < t o - p r i m i t i v e . j s       `      X    ~    o   k v              < t o - p r i m i t i v e . j s       `      X    ~    @o   k v                < t o - p r i m i t i v e . j s       `      X    ~    o   k v               < t o - p r i m i t i v e . j s       `      Y    ~     o    v               $ < t o - p r o p e r t y - k e y . j s `      Y    ~    `o    v              $ < t o - p r o p e r t y - k e y . j s `      Y    ~    o    v             $ < t o - p r o p e r t y - k e y . j s `      Y    ~     o    v               $ < t o - p r o p e r t y - k e y . j s `      Y    ~    o    v              $ < t o - p r o p e r t y - k e y . j s p      Z    ~    o    v               0 < t o - s t r i n g - t a g - s u p p o r t . j s     p      Z    ~    Po    v              0 < t o - s t r i n g - t a g - s u p p o r t . j s     p      Z    ~    o    v             0 < t o - s t r i n g - t a g - s u p p o r t . j s     p      Z    ~    0o    v               0 < t o - s t r i n g - t a g - s u p p o r t . j s     p      Z    ~    o    v              0 < t o - s t r i n g - t a g - s u p p o r t . j s     X      [    ~    o    v                < t o - s t r i n g . j s     X      [    ~    ho    v               < t o - s t r i n g . j s     X      [    ~    o   - v              < t o - s t r i n g . j s     X      [    ~    o   - v                < t o - s t r i n g . j s     X      [    ~    po   - v               < t o - s t r i n g . j s     h      \    ~    o   T v               & < t r y - n o d e - r e q u i r e . j s       h      \    ~    0o   T v              & < t r y - n o d e - r e q u i r e . j s       h      \    ~    o   T v             & < t r y - n o d e - r e q u i r e . j s       h      \    ~     o   T v               & < t r y - n o d e - r e q u i r e . j s       h      \    ~    ho   T v              & < t r y - n o d e - r e q u i r e . j s       `      ]    ~    o   { v                 < t r y - t o - s t r i n g . j s     `      ]    ~    0o   { v                < t r y - t o - s t r i n g . j s     `      ]    ~    o   { v               < t r y - t o - s t r i n g . j s                     `      ]    ~      p    v                 < t r y - t o - s t r i n g . j s     `      ]    ~    ` p    v                < t r y - t o - s t r i n g . j s     p      ^    ~     p    v               4 < t y p e d - a r r a y - c o n s t r u c t o r . j s p      ^    ~    0p    v              4 < t y p e d - a r r a y - c o n s t r u c t o r . j s p      ^    ~    p    v             4 < t y p e d - a r r a y - c o n s t r u c t o r . j s p      ^    ~    p    v               4 < t y p e d - a r r a y - c o n s t r u c t o r . j s p      ^    ~    p    v              4 < t y p e d - a r r a y - c o n s t r u c t o r . j s       _    ~    p    v               X < t y p e d - a r r a y - c o n s t r u c t o r s - r e q u i r e - w r a p p e r s . j s           _    ~    p    v              X < t y p e d - a r r a y - c o n s t r u c t o r s - r e q u i r e - w r a p p e r s . j s           _    ~     p    v             X < t y p e d - a r r a y - c o n s t r u c t o r s - r e q u i r e - w r a p p e r s . j s           _    ~    p    v               X < t y p e d - a r r a y - c o n s t r u c t o r s - r e q u i r e - w r a p p e r s . j s           _    ~    Pp    v              X < t y p e d - a r r a y - c o n s t r u c t o r s - r e q u i r e - w r a p p e r s . j s           `    ~    p   b v               H < t y p e d - a r r a y - f r o m - s p e c i e s - a n d - l i s t . j s           `    ~    pp   b v              H < t y p e d - a r r a y - f r o m - s p e c i e s - a n d - l i s t . j s           `    ~    p   b v             H < t y p e d - a r r a y - f r o m - s p e c i e s - a n d - l i s t . j s           `    ~    p   b v               H < t y p e d - a r r a y - f r o m - s p e c i e s - a n d - l i s t . j s           `    ~    p   b v              H < t y p e d - a r r a y - f r o m - s p e c i e s - a n d - l i s t . j s     h      a    ~    p   _ v               & < t y p e d - a r r a y - f r o m . j s       h      a    ~    p   _ v              & < t y p e d - a r r a y - f r o m . j s       h      a    ~    `	p   _ v             & < t y p e d - a r r a y - f r o m . j s       h      a    ~    	p   _ v               & < t y p e d - a r r a y - f r o m . j s       h      a    ~    0
p   _ v              & < t y p e d - a r r a y - f r o m . j s             b    ~    
p   T v               D < t y p e d - a r r a y - s p e c i e s - c o n s t r u c t o r . j s       b    ~    p   T v              D < t y p e d - a r r a y - s p e c i e s - c o n s t r u c t o r . j s       b    ~    p   T v             D < t y p e d - a r r a y - s p e c i e s - c o n s t r u c t o r . j s       b    ~    p   T v               D < t y p e d - a r r a y - s p e c i e s - c o n s t r u c t o r . j s       b    ~    p   T v              D < t y p e d - a r r a y - s p e c i e s - c o n s t r u c t o r . j s H      c    ~    p   J v                < u i d . j s H      c    ~    `p   J v               < u i d . j s H      c    ~    p   8( v              < u i d . j s H      c    ~    p   8( v                < u i d . j s H      c    ~    8p   8( v               < u i d . j s h      d    ~    p   7O v               ( < u s e - s y m b o l - a s - u i d . j s     h      d    ~    p   7O v              ( < u s e - s y m b o l - a s - u i d . j s     h      d    ~    Pp   7O v             ( < u s e - s y m b o l - a s - u i d . j s                                                                             h      d    ~     p   7O v               ( < u s e - s y m b o l - a s - u i d . j s     h      d    ~    hp   7O v              ( < u s e - s y m b o l - a s - u i d . j s     p      e    ~    p   (v v               4 < v 8 - p r o t o t y p e - d e f i n e - b u g . j s p      e    ~    @p    v              4 < v 8 - p r o t o t y p e - d e f i n e - b u g . j s p      e    ~    p    v             4 < v 8 - p r o t o t y p e - d e f i n e - b u g . j s p      e    ~     p    v               4 < v 8 - p r o t o t y p e - d e f i n e - b u g . j s p      e    ~    p    v              4 < v 8 - p r o t o t y p e - d e f i n e - b u g . j s x      f    ~     p    v               8 < v a l i d a t e - a r g u m e n t s - l e n g t h . j s     x      f    ~    xp    v              8 < v a l i d a t e - a r g u m e n t s - l e n g t h . j s     x      f    ~    p    v             8 < v a l i d a t e - a r g u m e n t s - l e n g t h . j s     x      f    ~    hp    v               8 < v a l i d a t e - a r g u m e n t s - l e n g t h . j s     x      f    ~    p    v              8 < v a l i d a t e - a r g u m e n t s - l e n g t h . j s     x      g    ~    Xp   
 v               8 < w e l l - k n o w n - s y m b o l - w r a p p e d . j s     x      g    ~    p    v              8 < w e l l - k n o w n - s y m b o l - w r a p p e d . j s     x      g    ~    Hp    v             8 < w e l l - k n o w n - s y m b o l - w r a p p e d . j s     x      g    ~    p    v               8 < w e l l - k n o w n - s y m b o l - w r a p p e d . j s     x      g    ~    8p    v              8 < w e l l - k n o w n - s y m b o l - w r a p p e d . j s     h      h    ~    p   8 v               ( < w e l l - k n o w n - s y m b o l . j s     h      h    ~    p   _ v              ( < w e l l - k n o w n - s y m b o l . j s     h      h    ~    p   _ v             ( < w e l l - k n o w n - s y m b o l . j s     h      h    ~    p   _ v               ( < w e l l - k n o w n - s y m b o l . j s     h      h    ~    Pp   _ v              ( < w e l l - k n o w n - s y m b o l . j s     X      i    ~    p    v                < w h i t e s p a c e s . j s X      i    ~    p    v               < w h i t e s p a c e s . j s X      i    ~    hp    v              < w h i t e s p a c e s . j s X      i    ~    p    v                < w h i t e s p a c e s . j s X      i    ~    p    v               < w h i t e s p a c e s . j s       j    ~    pp    v               H < w r a p - e r r o r - c o n s t r u c t o r - w i t h - c a u s e . j s           j    ~    p    v              H < w r a p - e r r o r - c o n s t r u c t o r - w i t h - c a u s e . j s           j    ~    p    v             H < w r a p - e r r o r - c o n s t r u c t o r - w i t h - c a u s e . j s           j    ~    p    v               H < w r a p - e r r o r - c o n s t r u c t o r - w i t h - c a u s e . j s           j    ~    p    v              H < w r a p - e r r o r - c o n s t r u c t o r - w i t h - c a u s e . j s     P      k    q    p    v               < m o d u l e s       P      k    q    hp    v              < m o d u l e s       x      l    k    p    v               6 < e s . a g g r e g a t e - e r r o r . c a u s e . j s       x      l    k    0p    v              6 < e s . a g g r e g a t e - e r r o r . c a u s e . j s                                                                                               x      l    k      p    v             6 < e s . a g g r e g a t e - e r r o r . c a u s e . j s       x      l    k    x p    v               6 < e s . a g g r e g a t e - e r r o r . c a u s e . j s       x      l    k     p    v              6 < e s . a g g r e g a t e - e r r o r . c a u s e . j s       h      m    k    h!p   " v               * < e s . a g g r e g a t e - e r r o r . j s   h      m    k    !p   " v              * < e s . a g g r e g a t e - e r r o r . j s   h      m    k    8"p   " v             * < e s . a g g r e g a t e - e r r o r . j s   h      m    k    "p   I v               * < e s . a g g r e g a t e - e r r o r . j s   h      m    k    #p   I v              * < e s . a g g r e g a t e - e r r o r . j s   x      n    k    p#p   p v               < < e s . a r r a y - b u f f e r . c o n s t r u c t o r . j s x      n    k    #p   p v              < < e s . a r r a y - b u f f e r . c o n s t r u c t o r . j s x      n    k    `$p   p v             < < e s . a r r a y - b u f f e r . c o n s t r u c t o r . j s x      n    k    $p   p v               < < e s . a r r a y - b u f f e r . c o n s t r u c t o r . j s x      n    k    P%p   p v              < < e s . a r r a y - b u f f e r . c o n s t r u c t o r . j s p      o    k    %p    v               4 < e s . a r r a y - b u f f e r . i s - v i e w . j s p      o    k    8&p    v              4 < e s . a r r a y - b u f f e r . i s - v i e w . j s p      o    k    &p    v             4 < e s . a r r a y - b u f f e r . i s - v i e w . j s p      o    k    'p    v               4 < e s . a r r a y - b u f f e r . i s - v i e w . j s p      o    k    'p    v              4 < e s . a r r a y - b u f f e r . i s - v i e w . j s p      p    k    'p    v               0 < e s . a r r a y - b u f f e r . s l i c e . j s     p      p    k    h(p    v              0 < e s . a r r a y - b u f f e r . s l i c e . j s     p      p    k    (p   p v             0 < e s . a r r a y - b u f f e r . s l i c e . j s     p      p    k    H)p   p v               0 < e s . a r r a y - b u f f e r . s l i c e . j s     p      p    k    )p   p v              0 < e s . a r r a y - b u f f e r . s l i c e . j s     X      q    k    (*p   c3 v                < e s . a r r a y . a t . j s X      q    k    *p   c3 v               < e s . a r r a y . a t . j s X      q    k    *p   c3 v              < e s . a r r a y . a t . j s X      q    k    0+p   c3 v                < e s . a r r a y . a t . j s X      q    k    +p   c3 v               < e s . a r r a y . a t . j s `      r    k    +p   ZZ v               $ < e s . a r r a y . c o n c a t . j s `      r    k    @,p   ZZ v              $ < e s . a r r a y . c o n c a t . j s `      r    k    ,p   ZZ v             $ < e s . a r r a y . c o n c a t . j s `      r    k     -p   ZZ v               $ < e s . a r r a y . c o n c a t . j s `      r    k    `-p   ZZ v              $ < e s . a r r a y . c o n c a t . j s p      s    k    -p   Y v               . < e s . a r r a y . c o p y - w i t h i n . j s       p      s    k    0.p   E v              . < e s . a r r a y . c o p y - w i t h i n . j s       p      s    k    .p   E v             . < e s . a r r a y . c o p y - w i t h i n . j s       p      s    k    /p   E v               . < e s . a r r a y . c o p y - w i t h i n . j s       p      s    k    /p   E v              . < e s . a r r a y . c o p y - w i t h i n . j s                       `      t    k     0p   7 v               " < e s . a r r a y . e v e r y . j s   `      t    k    `0p   7 v              " < e s . a r r a y . e v e r y . j s   `      t    k    0p   7 v             " < e s . a r r a y . e v e r y . j s   `      t    k     1p   7 v               " < e s . a r r a y . e v e r y . j s   `      t    k    1p   7 v              " < e s . a r r a y . e v e r y . j s   `      u    k    1p   '  v                 < e s . a r r a y . f i l l . j s     `      u    k    @2p   '  v                < e s . a r r a y . f i l l . j s     `      u    k    2p   '  v               < e s . a r r a y . f i l l . j s     `      u    k     3p   '  v                 < e s . a r r a y . f i l l . j s     `      u    k    `3p   '  v                < e s . a r r a y . f i l l . j s     `      v    k    3p   D  v               $ < e s . a r r a y . f i l t e r . j s `      v    k     4p   D  v              $ < e s . a r r a y . f i l t e r . j s `      v    k    4p   D  v             $ < e s . a r r a y . f i l t e r . j s `      v    k    4p   k  v               $ < e s . a r r a y . f i l t e r . j s `      v    k    @5p   k  v              $ < e s . a r r a y . f i l t e r . j s h      w    k    5p      v               , < e s . a r r a y . f i n d - i n d e x . j s h      w    k    6p      v              , < e s . a r r a y . f i n d - i n d e x . j s h      w    k    p6p      v             , < e s . a r r a y . f i n d - i n d e x . j s h      w    k    6p      v               , < e s . a r r a y . f i n d - i n d e x . j s h      w    k    @7p      v              , < e s . a r r a y . f i n d - i n d e x . j s `      x    k    7p     v                 < e s . a r r a y . f i n d . j s     `      x    k    8p     v                < e s . a r r a y . f i n d . j s     `      x    k    h8p     v               < e s . a r r a y . f i n d . j s     `      x    k    8p     v                 < e s . a r r a y . f i n d . j s     `      x    k    (9p     v                < e s . a r r a y . f i n d . j s     h      y    k    9p     v               ( < e s . a r r a y . f l a t - m a p . j s     h      y    k    9p     v              ( < e s . a r r a y . f l a t - m a p . j s     h      y    k    X:p     v             ( < e s . a r r a y . f l a t - m a p . j s     h      y    k    :p     v               ( < e s . a r r a y . f l a t - m a p . j s     h      y    k    (;p     v              ( < e s . a r r a y . f l a t - m a p . j s     `      z    k    ;p   ! v                 < e s . a r r a y . f l a t . j s     `      z    k    ;p   ! v                < e s . a r r a y . f l a t . j s     `      z    k    P<p   ! v               < e s . a r r a y . f l a t . j s     `      z    k    <p   ! v                 < e s . a r r a y . f l a t . j s     `      z    k    =p   ! v                < e s . a r r a y . f l a t . j s     h      {    k    p=p   -! v               ( < e s . a r r a y . f o r - e a c h . j s     h      {    k    =p   -! v              ( < e s . a r r a y . f o r - e a c h . j s     h      {    k    @>p   -! v             ( < e s . a r r a y . f o r - e a c h . j s     h      {    k    >p   -! v               ( < e s . a r r a y . f o r - e a c h . j s     h      {    k    ?p   T! v              ( < e s . a r r a y . f o r - e a c h . j s     `      |    k    x?p   {! v                 < e s . a r r a y . f r o m . j s                                             `      |    k     @p   {! v                < e s . a r r a y . f r o m . j s     `      |    k    `@p   {! v               < e s . a r r a y . f r o m . j s     `      |    k    @p   {! v                 < e s . a r r a y . f r o m . j s     `      |    k     Ap   {! v                < e s . a r r a y . f r o m . j s     h      }    k    Ap   ! v               ( < e s . a r r a y . i n c l u d e s . j s     h      }    k    Ap   ! v              ( < e s . a r r a y . i n c l u d e s . j s     h      }    k    PBp   ! v             ( < e s . a r r a y . i n c l u d e s . j s     h      }    k    Bp   ! v               ( < e s . a r r a y . i n c l u d e s . j s     h      }    k     Cp   ! v              ( < e s . a r r a y . i n c l u d e s . j s     h      ~    k    Cp   ! v               ( < e s . a r r a y . i n d e x - o f . j s     h      ~    k    Cp   ! v              ( < e s . a r r a y . i n d e x - o f . j s     h      ~    k    XDp   ! v             ( < e s . a r r a y . i n d e x - o f . j s     h      ~    k    Dp   ! v               ( < e s . a r r a y . i n d e x - o f . j s     h      ~    k    (Ep   ! v              ( < e s . a r r a y . i n d e x - o f . j s     h          k    Ep   " v               ( < e s . a r r a y . i s - a r r a y . j s     h          k    Ep   >" v              ( < e s . a r r a y . i s - a r r a y . j s     h          k    `Fp   >" v             ( < e s . a r r a y . i s - a r r a y . j s     h          k    Fp   >" v               ( < e s . a r r a y . i s - a r r a y . j s     h          k    0Gp   >" v              ( < e s . a r r a y . i s - a r r a y . j s     h          k    Gp   e" v               ( < e s . a r r a y . i t e r a t o r . j s     h          k     Hp   e" v              ( < e s . a r r a y . i t e r a t o r . j s     h          k    hHp   e" v             ( < e s . a r r a y . i t e r a t o r . j s     h          k    Hp   e" v               ( < e s . a r r a y . i t e r a t o r . j s     h          k    8Ip   e" v              ( < e s . a r r a y . i t e r a t o r . j s     `          k    Ip   z" v                 < e s . a r r a y . j o i n . j s     `          k     Jp   b" v                < e s . a r r a y . j o i n . j s     `          k    `Jp   b" v               < e s . a r r a y . j o i n . j s     `          k    Jp   b" v                 < e s . a r r a y . j o i n . j s     `          k     Kp   b" v                < e s . a r r a y . j o i n . j s     p          k    Kp   ^# v               2 < e s . a r r a y . l a s t - i n d e x - o f . j s   p          k    Kp   ^# v              2 < e s . a r r a y . l a s t - i n d e x - o f . j s   p          k    `Lp   ^# v             2 < e s . a r r a y . l a s t - i n d e x - o f . j s   p          k    Lp   ^# v               2 < e s . a r r a y . l a s t - i n d e x - o f . j s   p          k    @Mp   ^# v              2 < e s . a r r a y . l a s t - i n d e x - o f . j s   `          k    Mp   U(# v                < e s . a r r a y . m a p . j s       `          k    Np   EO# v               < e s . a r r a y . m a p . j s       `          k    pNp   EO# v              < e s . a r r a y . m a p . j s       `          k    Np   EO# v                < e s . a r r a y . m a p . j s       `          k    0Op   EO# v               < e s . a r r a y . m a p . j s       X          k    Op   =v# v                < e s . a r r a y . o f . j s                         X          k     Pp   =v# v               < e s . a r r a y . o f . j s X          k    XPp   0# v              < e s . a r r a y . o f . j s X          k    Pp   0# v                < e s . a r r a y . o f . j s X          k    Qp   0# v               < e s . a r r a y . o f . j s p          k    `Qp   9$ v               0 < e s . a r r a y . r e d u c e - r i g h t . j s     p          k    Qp   9$ v              0 < e s . a r r a y . r e d u c e - r i g h t . j s     p          k    @Rp   9$ v             0 < e s . a r r a y . r e d u c e - r i g h t . j s     p          k    Rp   9$ v               0 < e s . a r r a y . r e d u c e - r i g h t . j s     p          k     Sp   9$ v              0 < e s . a r r a y . r e d u c e - r i g h t . j s     `          k    Sp   _$ v               $ < e s . a r r a y . r e d u c e . j s `          k    Sp   _$ v              $ < e s . a r r a y . r e d u c e . j s `          k    PTp   _$ v             $ < e s . a r r a y . r e d u c e . j s `          k    Tp   _$ v               $ < e s . a r r a y . r e d u c e . j s `          k    Up   _$ v              $ < e s . a r r a y . r e d u c e . j s h          k    pUp   $ v               & < e s . a r r a y . r e v e r s e . j s       h          k    Up   $ v              & < e s . a r r a y . r e v e r s e . j s       h          k    @Vp   $ v             & < e s . a r r a y . r e v e r s e . j s       h          k    Vp   $ v               & < e s . a r r a y . r e v e r s e . j s       h          k    Wp   $ v              & < e s . a r r a y . r e v e r s e . j s       `          k    xWp   $ v               " < e s . a r r a y . s l i c e . j s   `          k    Wp   $ v              " < e s . a r r a y . s l i c e . j s   `          k    8Xp   $ v             " < e s . a r r a y . s l i c e . j s   `          k    Xp   $ v               " < e s . a r r a y . s l i c e . j s   `          k    Xp   $ v              " < e s . a r r a y . s l i c e . j s   `          k    XYp   $ v                 < e s . a r r a y . s o m e . j s     `          k    Yp   $ v                < e s . a r r a y . s o m e . j s     `          k    Zp   $ v               < e s . a r r a y . s o m e . j s     `          k    xZp   $ v                 < e s . a r r a y . s o m e . j s     `          k    Zp   $ v                < e s . a r r a y . s o m e . j s     `          k    8[p   $ v                 < e s . a r r a y . s o r t . j s     `          k    [p   $ v                < e s . a r r a y . s o r t . j s     `          k    [p   "% v               < e s . a r r a y . s o r t . j s     `          k    X\p   "% v                 < e s . a r r a y . s o r t . j s     `          k    \p   "% v                < e s . a r r a y . s o r t . j s     h          k    ]p   I% v               & < e s . a r r a y . s p e c i e s . j s       h          k    ]p   I% v              & < e s . a r r a y . s p e c i e s . j s       h          k    ]p   I% v             & < e s . a r r a y . s p e c i e s . j s       h          k    P^p   I% v               & < e s . a r r a y . s p e c i e s . j s       h          k    ^p   I% v              & < e s . a r r a y . s p e c i e s . j s       `          k     _p   p% v               $ < e s . a r r a y . s p l i c e . j s `          k    _p   % v              $ < e s . a r r a y . s p l i c e . j s                                 `          k     `p   % v             $ < e s . a r r a y . s p l i c e . j s `          k    ``p   % v               $ < e s . a r r a y . s p l i c e . j s `          k    `p   % v              $ < e s . a r r a y . s p l i c e . j s           k     ap   % v               @ < e s . a r r a y . u n s c o p a b l e s . f l a t - m a p . j s               k    ap   % v              @ < e s . a r r a y . u n s c o p a b l e s . f l a t - m a p . j s               k     bp   % v             @ < e s . a r r a y . u n s c o p a b l e s . f l a t - m a p . j s               k    bp   % v               @ < e s . a r r a y . u n s c o p a b l e s . f l a t - m a p . j s               k     cp   % v              @ < e s . a r r a y . u n s c o p a b l e s . f l a t - m a p . j s     x          k    cp   % v               8 < e s . a r r a y . u n s c o p a b l e s . f l a t . j s     x          k    dp   % v              8 < e s . a r r a y . u n s c o p a b l e s . f l a t . j s     x          k    dp   % v             8 < e s . a r r a y . u n s c o p a b l e s . f l a t . j s     x          k    ep   % v               8 < e s . a r r a y . u n s c o p a b l e s . f l a t . j s     x          k    ep   & v              8 < e s . a r r a y . u n s c o p a b l e s . f l a t . j s     `          k    ep   & v                < e s . d a t a - v i e w . j s       `          k    Xfp   3& v               < e s . d a t a - v i e w . j s       `          k    fp   3& v              < e s . d a t a - v i e w . j s       `          k    gp   3& v                < e s . d a t a - v i e w . j s       `          k    xgp   3& v               < e s . d a t a - v i e w . j s       h          k    gp   mZ& v               & < e s . d a t e . g e t - y e a r . j s       h          k    @hp   mZ& v              & < e s . d a t e . g e t - y e a r . j s       h          k    hp   mZ& v             & < e s . d a t e . g e t - y e a r . j s       h          k    ip   mZ& v               & < e s . d a t e . g e t - y e a r . j s       h          k    xip   mZ& v              & < e s . d a t e . g e t - y e a r . j s       X          k    ip   X& v                < e s . d a t e . n o w . j s X          k    8jp   X& v               < e s . d a t e . n o w . j s X          k    jp   X& v              < e s . d a t e . n o w . j s X          k    jp   X& v                < e s . d a t e . n o w . j s X          k    @kp   X& v               < e s . d a t e . n o w . j s h          k    kp   O& v               & < e s . d a t e . s e t - y e a r . j s       h          k     lp   O& v              & < e s . d a t e . s e t - y e a r . j s       h          k    hlp   O& v             & < e s . d a t e . s e t - y e a r . j s       h          k    lp   O& v               & < e s . d a t e . s e t - y e a r . j s       h          k    8mp   O& v              & < e s . d a t e . s e t - y e a r . j s       p          k    mp   ;' v               0 < e s . d a t e . t o - g m t - s t r i n g . j s     p          k    np   ;' v              0 < e s . d a t e . t o - g m t - s t r i n g . j s     p          k    np   ;' v             0 < e s . d a t e . t o - g m t - s t r i n g . j s     p          k    np   1D' v               0 < e s . d a t e . t o - g m t - s t r i n g . j s     p          k    `op   1D' v              0 < e s . d a t e . t o - g m t - s t r i n g . j s                                                     p          k     pp   %k' v               0 < e s . d a t e . t o - i s o - s t r i n g . j s     p          k    ppp   %k' v              0 < e s . d a t e . t o - i s o - s t r i n g . j s     p          k    pp   %k' v             0 < e s . d a t e . t o - i s o - s t r i n g . j s     p          k    Pqp   %k' v               0 < e s . d a t e . t o - i s o - s t r i n g . j s     p          k    qp   %k' v              0 < e s . d a t e . t o - i s o - s t r i n g . j s     `          k    0rp   ' v               $ < e s . d a t e . t o - j s o n . j s `          k    rp   ' v              $ < e s . d a t e . t o - j s o n . j s `          k    rp   ' v             $ < e s . d a t e . t o - j s o n . j s `          k    Psp   ' v               $ < e s . d a t e . t o - j s o n . j s `          k    sp   ' v              $ < e s . d a t e . t o - j s o n . j s p          k    tp    ' v               . < e s . d a t e . t o - p r i m i t i v e . j s       p          k    tp    ' v              . < e s . d a t e . t o - p r i m i t i v e . j s       p          k    tp    ' v             . < e s . d a t e . t o - p r i m i t i v e . j s       p          k    `up    ' v               . < e s . d a t e . t o - p r i m i t i v e . j s       p          k    up    ' v              . < e s . d a t e . t o - p r i m i t i v e . j s       h          k    @vp   ( v               ( < e s . d a t e . t o - s t r i n g . j s     h          k    vp   -( v              ( < e s . d a t e . t o - s t r i n g . j s     h          k    wp   -( v             ( < e s . d a t e . t o - s t r i n g . j s     h          k    xwp   -( v               ( < e s . d a t e . t o - s t r i n g . j s     h          k    wp   -( v              ( < e s . d a t e . t o - s t r i n g . j s     `          k    Hxp   T( v               " < e s . e r r o r . c a u s e . j s   `          k    xp   T( v              " < e s . e r r o r . c a u s e . j s   `          k    yp   T( v             " < e s . e r r o r . c a u s e . j s   `          k    hyp   T( v               " < e s . e r r o r . c a u s e . j s   `          k    yp   T( v              " < e s . e r r o r . c a u s e . j s   h          k    (zp   {( v               * < e s . e r r o r . t o - s t r i n g . j s   h          k    zp   {( v              * < e s . e r r o r . t o - s t r i n g . j s   h          k    zp   {( v             * < e s . e r r o r . t o - s t r i n g . j s   h          k    `{p   {( v               * < e s . e r r o r . t o - s t r i n g . j s   h          k    {p   {( v              * < e s . e r r o r . t o - s t r i n g . j s   X          k    0|p   ( v                < e s . e s c a p e . j s     X          k    |p   ( v               < e s . e s c a p e . j s     X          k    |p   ( v              < e s . e s c a p e . j s     X          k    8}p   ( v                < e s . e s c a p e . j s     X          k    }p   ( v               < e s . e s c a p e . j s     h          k    }p   ( v               & < e s . f u n c t i o n . b i n d . j s       h          k    P~p   ( v              & < e s . f u n c t i o n . b i n d . j s       h          k    ~p   ( v             & < e s . f u n c t i o n . b i n d . j s       h          k     p   ( v               & < e s . f u n c t i o n . b i n d . j s       h          k    p   ( v              & < e s . f u n c t i o n . b i n d . j s                       x          k     p   >) v               6 < e s . f u n c t i o n . h a s - i n s t a n c e . j s       x          k    xp   >) v              6 < e s . f u n c t i o n . h a s - i n s t a n c e . j s       x          k    p   >) v             6 < e s . f u n c t i o n . h a s - i n s t a n c e . j s       x          k    hp   >) v               6 < e s . f u n c t i o n . h a s - i n s t a n c e . j s       x          k    p   >) v              6 < e s . f u n c t i o n . h a s - i n s t a n c e . j s       h          k    Xp   e) v               & < e s . f u n c t i o n . n a m e . j s       h          k    p   ) v              & < e s . f u n c t i o n . n a m e . j s       h          k    (p   ) v             & < e s . f u n c t i o n . n a m e . j s       h          k    p   ) v               & < e s . f u n c t i o n . n a m e . j s       h          k    p   ) v              & < e s . f u n c t i o n . n a m e . j s       `          k    `p   r) v               " < e s . g l o b a l - t h i s . j s   `          k    p   r) v              " < e s . g l o b a l - t h i s . j s   `          k     p   r) v             " < e s . g l o b a l - t h i s . j s   `          k    p   r) v               " < e s . g l o b a l - t h i s . j s   `          k    p   r) v              " < e s . g l o b a l - t h i s . j s   h          k    @p   i* v               ( < e s . j s o n . s t r i n g i f y . j s     h          k    p   i* v              ( < e s . j s o n . s t r i n g i f y . j s     h          k    p   `(* v             ( < e s . j s o n . s t r i n g i f y . j s     h          k    xp   `(* v               ( < e s . j s o n . s t r i n g i f y . j s     h          k    p   `(* v              ( < e s . j s o n . s t r i n g i f y . j s     p          k    Hp   VO* v               0 < e s . j s o n . t o - s t r i n g - t a g . j s     p          k    p   VO* v              0 < e s . j s o n . t o - s t r i n g - t a g . j s     p          k    (p   VO* v             0 < e s . j s o n . t o - s t r i n g - t a g . j s     p          k    p   VO* v               0 < e s . j s o n . t o - s t r i n g - t a g . j s     p          k    p   VO* v              0 < e s . j s o n . t o - s t r i n g - t a g . j s     P          k    xp   Zv* v                < e s . m a p . j s   P          k    p   E* v               < e s . m a p . j s   P          k    p   E* v              < e s . m a p . j s   P          k    hp   E* v                < e s . m a p . j s   P          k    p   E* v               < e s . m a p . j s   `          k    p   E* v                 < e s . m a t h . a c o s h . j s     `          k    hp   C* v                < e s . m a t h . a c o s h . j s     `          k    p   C* v               < e s . m a t h . a c o s h . j s     `          k    (p   C* v                 < e s . m a t h . a c o s h . j s     `          k    p   C* v                < e s . m a t h . a c o s h . j s     `          k    p   4* v                 < e s . m a t h . a s i n h . j s     `          k    Hp   4* v                < e s . m a t h . a s i n h . j s     `          k    p   4* v               < e s . m a t h . a s i n h . j s     `          k    p   4* v                 < e s . m a t h . a s i n h . j s     `          k    hp   4* v                < e s . m a t h . a s i n h . j s                                                             `          k     p   ,+ v                 < e s . m a t h . a t a n h . j s     `          k    `p   ,+ v                < e s . m a t h . a t a n h . j s     `          k    p   9+ v               < e s . m a t h . a t a n h . j s     `          k     p   9+ v                 < e s . m a t h . a t a n h . j s     `          k    p   9+ v                < e s . m a t h . a t a n h . j s     `          k    p   `+ v                < e s . m a t h . c b r t . j s       `          k    @p   `+ v               < e s . m a t h . c b r t . j s       `          k    p   `+ v              < e s . m a t h . c b r t . j s       `          k     p   `+ v                < e s . m a t h . c b r t . j s       `          k    `p   `+ v               < e s . m a t h . c b r t . j s       `          k    p   + v                 < e s . m a t h . c l z 3 2 . j s     `          k     p   + v                < e s . m a t h . c l z 3 2 . j s     `          k    p   + v               < e s . m a t h . c l z 3 2 . j s     `          k    p   + v                 < e s . m a t h . c l z 3 2 . j s     `          k    @p   + v                < e s . m a t h . c l z 3 2 . j s     `          k    p   + v                < e s . m a t h . c o s h . j s       `          k     p   + v               < e s . m a t h . c o s h . j s       `          k    `p   + v              < e s . m a t h . c o s h . j s       `          k    p   + v                < e s . m a t h . c o s h . j s       `          k     p   + v               < e s . m a t h . c o s h . j s       `          k    p   + v                 < e s . m a t h . e x p m 1 . j s     `          k    p   + v                < e s . m a t h . e x p m 1 . j s     `          k    @p   + v               < e s . m a t h . e x p m 1 . j s     `          k    p   + v                 < e s . m a t h . e x p m 1 . j s     `          k     p   + v                < e s . m a t h . e x p m 1 . j s     `          k    `p   ", v               " < e s . m a t h . f r o u n d . j s   `          k    p   ", v              " < e s . m a t h . f r o u n d . j s   `          k     p   ", v             " < e s . m a t h . f r o u n d . j s   `          k    p   I, v               " < e s . m a t h . f r o u n d . j s   `          k    p   I, v              " < e s . m a t h . f r o u n d . j s   `          k    @p   I, v                 < e s . m a t h . h y p o t . j s     `          k    p   I, v                < e s . m a t h . h y p o t . j s     `          k     p   p, v               < e s . m a t h . h y p o t . j s     `          k    `p   p, v                 < e s . m a t h . h y p o t . j s     `          k    p   p, v                < e s . m a t h . h y p o t . j s     `          k     p   , v                < e s . m a t h . i m u l . j s       `          k    p   , v               < e s . m a t h . i m u l . j s       `          k    p   , v              < e s . m a t h . i m u l . j s       `          k    @p   , v                < e s . m a t h . i m u l . j s       `          k    p   , v               < e s . m a t h . i m u l . j s       `          k     p   , v                 < e s . m a t h . l o g 1 0 . j s     `          k    `p   , v                < e s . m a t h . l o g 1 0 . j s                                                                     `          k     p   , v               < e s . m a t h . l o g 1 0 . j s     `          k    `p   , v                 < e s . m a t h . l o g 1 0 . j s     `          k    p   , v                < e s . m a t h . l o g 1 0 . j s     `          k     p   - v                 < e s . m a t h . l o g 1 p . j s     `          k    p   3- v                < e s . m a t h . l o g 1 p . j s     `          k    p   3- v               < e s . m a t h . l o g 1 p . j s     `          k    @p   3- v                 < e s . m a t h . l o g 1 p . j s     `          k    p   3- v                < e s . m a t h . l o g 1 p . j s     `          k     p   Z- v                < e s . m a t h . l o g 2 . j s       `          k    `p   }- v               < e s . m a t h . l o g 2 . j s       `          k    p   }- v              < e s . m a t h . l o g 2 . j s       `          k     p   }- v                < e s . m a t h . l o g 2 . j s       `          k    p   }- v               < e s . m a t h . l o g 2 . j s       `          k    p   l- v                < e s . m a t h . s i g n . j s       `          k    @p   s- v               < e s . m a t h . s i g n . j s       `          k    p   s- v              < e s . m a t h . s i g n . j s       `          k     p   s- v                < e s . m a t h . s i g n . j s       `          k    `p   s- v               < e s . m a t h . s i g n . j s       `          k    p   W- v                < e s . m a t h . s i n h . j s       `          k     p   W- v               < e s . m a t h . s i n h . j s       `          k    p   W- v              < e s . m a t h . s i n h . j s       `          k    p   W- v                < e s . m a t h . s i n h . j s       `          k    @p   W- v               < e s . m a t h . s i n h . j s       `          k    p   . v                < e s . m a t h . t a n h . j s       `          k     p   . v               < e s . m a t h . t a n h . j s       `          k    `p   . v              < e s . m a t h . t a n h . j s       `          k    p   / v                < e s . m a t h . t a n h . j s       `          k     p   / v               < e s . m a t h . t a n h . j s       p          k    p   ./ v               0 < e s . m a t h . t o - s t r i n g - t a g . j s     p          k    p   ./ v              0 < e s . m a t h . t o - s t r i n g - t a g . j s     p          k    `p   ./ v             0 < e s . m a t h . t o - s t r i n g - t a g . j s     p          k    p   ./ v               0 < e s . m a t h . t o - s t r i n g - t a g . j s     p          k    @p   T/ v              0 < e s . m a t h . t o - s t r i n g - t a g . j s     `          k    p   {/ v                 < e s . m a t h . t r u n c . j s     `          k    p   {/ v                < e s . m a t h . t r u n c . j s     `          k    pp   {/ v               < e s . m a t h . t r u n c . j s     `          k    p   {/ v                 < e s . m a t h . t r u n c . j s     `          k    0p   {/ v                < e s . m a t h . t r u n c . j s     p          k    p   / v               0 < e s . n u m b e r . c o n s t r u c t o r . j s     p          k     p   / v              0 < e s . n u m b e r . c o n s t r u c t o r . j s     p          k    pp   / v             0 < e s . n u m b e r . c o n s t r u c t o r . j s                                     p          k     p   / v               0 < e s . n u m b e r . c o n s t r u c t o r . j s     p          k    pp   / v              0 < e s . n u m b e r . c o n s t r u c t o r . j s     h          k    p   / v               ( < e s . n u m b e r . e p s i l o n . j s     h          k    Hp   / v              ( < e s . n u m b e r . e p s i l o n . j s     h          k    p   / v             ( < e s . n u m b e r . e p s i l o n . j s     h          k    p   / v               ( < e s . n u m b e r . e p s i l o n . j s     h          k    p   / v              ( < e s . n u m b e r . e p s i l o n . j s     h          k    p   0 v               , < e s . n u m b e r . i s - f i n i t e . j s h          k    Pp   0 v              , < e s . n u m b e r . i s - f i n i t e . j s h          k    p   0 v             , < e s . n u m b e r . i s - f i n i t e . j s h          k     p   >0 v               , < e s . n u m b e r . i s - f i n i t e . j s h          k    p   >0 v              , < e s . n u m b e r . i s - f i n i t e . j s p          k    p   e0 v               . < e s . n u m b e r . i s - i n t e g e r . j s       p          k    `p   e0 v              . < e s . n u m b e r . i s - i n t e g e r . j s       p          k    p   e0 v             . < e s . n u m b e r . i s - i n t e g e r . j s       p          k    @p   e0 v               . < e s . n u m b e r . i s - i n t e g e r . j s       p          k    p   e0 v              . < e s . n u m b e r . i s - i n t e g e r . j s       h          k     p   0 v               & < e s . n u m b e r . i s - n a n . j s       h          k    p   0 v              & < e s . n u m b e r . i s - n a n . j s       h          k    p   0 v             & < e s . n u m b e r . i s - n a n . j s       h          k    Xp   0 v               & < e s . n u m b e r . i s - n a n . j s       h          k    p   0 v              & < e s . n u m b e r . i s - n a n . j s       x          k    (p   0 v               8 < e s . n u m b e r . i s - s a f e - i n t e g e r . j s     x          k    p   0 v              8 < e s . n u m b e r . i s - s a f e - i n t e g e r . j s     x          k    p   0 v             8 < e s . n u m b e r . i s - s a f e - i n t e g e r . j s     x          k    p   0 v               8 < e s . n u m b e r . i s - s a f e - i n t e g e r . j s     x          k    p   0 v              8 < e s . n u m b e r . i s - s a f e - i n t e g e r . j s     x          k    p   1 v               : < e s . n u m b e r . m a x - s a f e - i n t e g e r . j s   x          k    p   z(1 v              : < e s . n u m b e r . m a x - s a f e - i n t e g e r . j s   x          k    pp   z(1 v             : < e s . n u m b e r . m a x - s a f e - i n t e g e r . j s   x          k    p   z(1 v               : < e s . n u m b e r . m a x - s a f e - i n t e g e r . j s   x          k    `p   z(1 v              : < e s . n u m b e r . m a x - s a f e - i n t e g e r . j s   x          k    p   sO1 v               : < e s . n u m b e r . m i n - s a f e - i n t e g e r . j s   x          k    Pp   sO1 v              : < e s . n u m b e r . m i n - s a f e - i n t e g e r . j s   x          k    p   ev1 v             : < e s . n u m b e r . m i n - s a f e - i n t e g e r . j s   x          k    @p   ev1 v               : < e s . n u m b e r . m i n - s a f e - i n t e g e r . j s                                                                           x          k     p   ev1 v              : < e s . n u m b e r . m i n - s a f e - i n t e g e r . j s   P          &L     xp   ev1 v               < f _ 0 0 0 8 6 5     p          k    p   \1 v               0 < e s . n u m b e r . p a r s e - f l o a t . j s     p          k    8p   \1 v              0 < e s . n u m b e r . p a r s e - f l o a t . j s     p          k    p   \1 v             0 < e s . n u m b e r . p a r s e - f l o a t . j s     p          k    p   \1 v               0 < e s . n u m b e r . p a r s e - f l o a t . j s     p          k    p   \1 v              0 < e s . n u m b e r . p a r s e - f l o a t . j s     h          k    p   H1 v               , < e s . n u m b e r . p a r s e - i n t . j s h          k    `p   H1 v              , < e s . n u m b e r . p a r s e - i n t . j s h          k    p   H1 v             , < e s . n u m b e r . p a r s e - i n t . j s h          k    0p   H1 v               , < e s . n u m b e r . p a r s e - i n t . j s h          k    p   H1 v              , < e s . n u m b e r . p a r s e - i n t . j s P          &L      p   H1 v                < f _ 0 0 0 8 6 6     P          &L     Pp   H1 v               < f _ 0 0 0 8 6 6     P          &L     p   :2 v                < f _ 0 0 0 8 6 6     P          &L     p   :2 v               < f _ 0 0 0 8 6 6     x          k    @p   :2 v               6 < e s . n u m b e r . t o - e x p o n e n t i a l . j s       x          k    p   :2 v              6 < e s . n u m b e r . t o - e x p o n e n t i a l . j s       x          k    0p   /92 v             6 < e s . n u m b e r . t o - e x p o n e n t i a l . j s       x          k    p   /92 v               6 < e s . n u m b e r . t o - e x p o n e n t i a l . j s       x          k     p   /92 v              6 < e s . n u m b e r . t o - e x p o n e n t i a l . j s       h          k    p   )`2 v               * < e s . n u m b e r . t o - f i x e d . j s   h          k     p   )`2 v              * < e s . n u m b e r . t o - f i x e d . j s   h          k    hp   )`2 v             * < e s . n u m b e r . t o - f i x e d . j s   h          k    p   )`2 v               * < e s . n u m b e r . t o - f i x e d . j s   h          k    8p   )`2 v              * < e s . n u m b e r . t o - f i x e d . j s   p          k    p   !2 v               2 < e s . n u m b e r . t o - p r e c i s i o n . j s   p          k    p   2 v              2 < e s . n u m b e r . t o - p r e c i s i o n . j s   p          k    p   2 v             2 < e s . n u m b e r . t o - p r e c i s i o n . j s   p          k    p   2 v               2 < e s . n u m b e r . t o - p r e c i s i o n . j s   p          k    `p   2 v              2 < e s . n u m b e r . t o - p r e c i s i o n . j s   h          k    p   2 v               & < e s . o b j e c t . a s s i g n . j s       h          k    8p   2 v              & < e s . o b j e c t . a s s i g n . j s       h          k    p   2 v             & < e s . o b j e c t . a s s i g n . j s       h          k    p   2 v               & < e s . o b j e c t . a s s i g n . j s       h          k    pp   2 v              & < e s . o b j e c t . a s s i g n . j s       h          k    p   "3 v               & < e s . o b j e c t . c r e a t e . j s       h          k    @p   "3 v              & < e s . o b j e c t . c r e a t e . j s                                                                                               h          k     p   "3 v             & < e s . o b j e c t . c r e a t e . j s       h          k    hp   "3 v               & < e s . o b j e c t . c r e a t e . j s       h          k    p   I3 v              & < e s . o b j e c t . c r e a t e . j s       p          k    8p   p3 v               4 < e s . o b j e c t . d e f i n e - g e t t e r . j s p          k    p   3 v              4 < e s . o b j e c t . d e f i n e - g e t t e r . j s p          k    p   3 v             4 < e s . o b j e c t . d e f i n e - g e t t e r . j s p          k    p   3 v               4 < e s . o b j e c t . d e f i n e - g e t t e r . j s p          k    p   3 v              4 < e s . o b j e c t . d e f i n e - g e t t e r . j s x          k    hp   3 v               < < e s . o b j e c t . d e f i n e - p r o p e r t i e s . j s x          k    p   3 v              < < e s . o b j e c t . d e f i n e - p r o p e r t i e s . j s x          k    Xp   3 v             < < e s . o b j e c t . d e f i n e - p r o p e r t i e s . j s x          k    p   3 v               < < e s . o b j e c t . d e f i n e - p r o p e r t i e s . j s x          k    Hp   3 v              < < e s . o b j e c t . d e f i n e - p r o p e r t i e s . j s x          k    p   4 v               8 < e s . o b j e c t . d e f i n e - p r o p e r t y . j s     x          k    8p   34 v              8 < e s . o b j e c t . d e f i n e - p r o p e r t y . j s     x          k    p   34 v             8 < e s . o b j e c t . d e f i n e - p r o p e r t y . j s     x          k    (p   34 v               8 < e s . o b j e c t . d e f i n e - p r o p e r t y . j s     x          k    p   34 v              8 < e s . o b j e c t . d e f i n e - p r o p e r t y . j s     p          k    p   Z4 v               4 < e s . o b j e c t . d e f i n e - s e t t e r . j s p          k    p   Z4 v              4 < e s . o b j e c t . d e f i n e - s e t t e r . j s p          k    p   Z4 v             4 < e s . o b j e c t . d e f i n e - s e t t e r . j s p          k    hp   Z4 v               4 < e s . o b j e c t . d e f i n e - s e t t e r . j s p          k    p   Z4 v              4 < e s . o b j e c t . d e f i n e - s e t t e r . j s h          k    Hp   4 v               ( < e s . o b j e c t . e n t r i e s . j s     h          k    p   4 v              ( < e s . o b j e c t . e n t r i e s . j s     h          k    p   4 v             ( < e s . o b j e c t . e n t r i e s . j s     h          k    p   4 v               ( < e s . o b j e c t . e n t r i e s . j s     h          k    p   4 v              ( < e s . o b j e c t . e n t r i e s . j s     h          k    Pp   {4 v               & < e s . o b j e c t . f r e e z e . j s       h          k    p   q4 v              & < e s . o b j e c t . f r e e z e . j s       h          k     p   q4 v             & < e s . o b j e c t . f r e e z e . j s       h          k    p   q4 v               & < e s . o b j e c t . f r e e z e . j s       h          k    p   q4 v              & < e s . o b j e c t . f r e e z e . j s       p          k    Xp   `5 v               2 < e s . o b j e c t . f r o m - e n t r i e s . j s   p          k    p   `5 v              2 < e s . o b j e c t . f r o m - e n t r i e s . j s   p          k    8p   YD5 v             2 < e s . o b j e c t . f r o m - e n t r i e s . j s                                                                                           p          k     p   YD5 v               2 < e s . o b j e c t . f r o m - e n t r i e s . j s   p          k    pp   YD5 v              2 < e s . o b j e c t . f r o m - e n t r i e s . j s             k    p   Qk5 v               P < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s               k    pp   Qk5 v              P < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s               k     p   Qk5 v             P < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s               k    p   Qk5 v               P < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s               k     p   Qk5 v              P < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s               k    p   @5 v               R < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r s . j s             k    @p   @5 v              R < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r s . j s             k    p   75 v             R < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r s . j s             k    `p   75 v               R < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r s . j s             k    p   75 v              R < e s . o b j e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r s . j s             k    p   )5 v               F < e s . o b j e c t . g e t - o w n - p r o p e r t y - n a m e s . j s                 k    p   )5 v              F < e s . o b j e c t . g e t - o w n - p r o p e r t y - n a m e s . j s                 k    p   )5 v             F < e s . o b j e c t . g e t - o w n - p r o p e r t y - n a m e s . j s                 k    p   )5 v               F < e s . o b j e c t . g e t - o w n - p r o p e r t y - n a m e s . j s                 k    p   )5 v              F < e s . o b j e c t . g e t - o w n - p r o p e r t y - n a m e s . j s       x          k    (p   (6 v               : < e s . o b j e c t . g e t - p r o t o t y p e - o f . j s   x          k    p   (6 v              : < e s . o b j e c t . g e t - p r o t o t y p e - o f . j s   x          k    p   .6 v             : < e s . o b j e c t . g e t - p r o t o t y p e - o f . j s   x          k    p   .6 v               : < e s . o b j e c t . g e t - p r o t o t y p e - o f . j s   x          k    p   .6 v              : < e s . o b j e c t . g e t - p r o t o t y p e - o f . j s   h          k    p   U6 v               ( < e s . o b j e c t . h a s - o w n . j s     h          k    p   U6 v              ( < e s . o b j e c t . h a s - o w n . j s     h          k    Pp   U6 v             ( < e s . o b j e c t . h a s - o w n . j s     h          k    p   U6 v               ( < e s . o b j e c t . h a s - o w n . j s     h          k     p   U6 v              ( < e s . o b j e c t . h a s - o w n . j s     p          k    p   6 v               4 < e s . o b j e c t . i s - e x t e n s i b l e . j s p          k    p   6 v              4 < e s . o b j e c t . i s - e x t e n s i b l e . j s p          k    hp   6 v             4 < e s . o b j e c t . i s - e x t e n s i b l e . j s p          k    p   6 v               4 < e s . o b j e c t . i s - e x t e n s i b l e . j s p          k    Hp   6 v              4 < e s . o b j e c t . i s - e x t e n s i b l e . j s                                                                         h          k     p   6 v               , < e s . o b j e c t . i s - f r o z e n . j s h          k    hp   6 v              , < e s . o b j e c t . i s - f r o z e n . j s h          k    p   6 v             , < e s . o b j e c t . i s - f r o z e n . j s h          k    8p   6 v               , < e s . o b j e c t . i s - f r o z e n . j s h          k    p   6 v              , < e s . o b j e c t . i s - f r o z e n . j s h          k    p   7 v               , < e s . o b j e c t . i s - s e a l e d . j s h          k    pp   7 v              , < e s . o b j e c t . i s - s e a l e d . j s h          k    p   >7 v             , < e s . o b j e c t . i s - s e a l e d . j s h          k    @p   >7 v               , < e s . o b j e c t . i s - s e a l e d . j s h          k    p   >7 v              , < e s . o b j e c t . i s - s e a l e d . j s `          k    p   (8 v                < e s . o b j e c t . i s . j s       `          k    pp   (8 v               < e s . o b j e c t . i s . j s       `          k    p   O8 v              < e s . o b j e c t . i s . j s       `          k    0p   O8 v                < e s . o b j e c t . i s . j s       `          k    p   O8 v               < e s . o b j e c t . i s . j s       `          k    p   n8 v               " < e s . o b j e c t . k e y s . j s   `          k    Pp   n8 v              " < e s . o b j e c t . k e y s . j s   `          k    p   n8 v             " < e s . o b j e c t . k e y s . j s   `          k    p   n8 v               " < e s . o b j e c t . k e y s . j s   `          k    pp   n8 v              " < e s . o b j e c t . k e y s . j s   p          k    p   _8 v               4 < e s . o b j e c t . l o o k u p - g e t t e r . j s p          k    @p   _8 v              4 < e s . o b j e c t . l o o k u p - g e t t e r . j s p          k    p   _8 v             4 < e s . o b j e c t . l o o k u p - g e t t e r . j s p          k     p   _8 v               4 < e s . o b j e c t . l o o k u p - g e t t e r . j s p          k    p   _8 v              4 < e s . o b j e c t . l o o k u p - g e t t e r . j s p          k     p   K9 v               4 < e s . o b j e c t . l o o k u p - s e t t e r . j s p          k    pp   K9 v              4 < e s . o b j e c t . l o o k u p - s e t t e r . j s p          k    p   K9 v             4 < e s . o b j e c t . l o o k u p - s e t t e r . j s p          k    Pp   K9 v               4 < e s . o b j e c t . l o o k u p - s e t t e r . j s p          k    p   C99 v              4 < e s . o b j e c t . l o o k u p - s e t t e r . j s           k    0p   8`9 v               > < e s . o b j e c t . p r e v e n t - e x t e n s i o n s . j s                 k    p   8`9 v              > < e s . o b j e c t . p r e v e n t - e x t e n s i o n s . j s                 k    0p   8`9 v             > < e s . o b j e c t . p r e v e n t - e x t e n s i o n s . j s                 k    p   8`9 v               > < e s . o b j e c t . p r e v e n t - e x t e n s i o n s . j s                 k    0p   8`9 v              > < e s . o b j e c t . p r e v e n t - e x t e n s i o n s . j s       `          k    p   >9 v               " < e s . o b j e c t . s e a l . j s   `          k    p   >9 v              " < e s . o b j e c t . s e a l . j s   `          k    pp   59 v             " < e s . o b j e c t . s e a l . j s                                                   `          k      q   59 v               " < e s . o b j e c t . s e a l . j s   `          k    ` q   59 v              " < e s . o b j e c t . s e a l . j s   x          k     q   9 v               : < e s . o b j e c t . s e t - p r o t o t y p e - o f . j s   x          k    8q   9 v              : < e s . o b j e c t . s e t - p r o t o t y p e - o f . j s   x          k    q   9 v             : < e s . o b j e c t . s e t - p r o t o t y p e - o f . j s   x          k    (q   9 v               : < e s . o b j e c t . s e t - p r o t o t y p e - o f . j s   x          k    q   9 v              : < e s . o b j e c t . s e t - p r o t o t y p e - o f . j s   h          k    q   #: v               , < e s . o b j e c t . t o - s t r i n g . j s h          k    q   #: v              , < e s . o b j e c t . t o - s t r i n g . j s h          k    q   #: v             , < e s . o b j e c t . t o - s t r i n g . j s h          k    Pq   #: v               , < e s . o b j e c t . t o - s t r i n g . j s h          k    q   #: v              , < e s . o b j e c t . t o - s t r i n g . j s h          k     q   p: v               & < e s . o b j e c t . v a l u e s . j s       h          k    q   p: v              & < e s . o b j e c t . v a l u e s . j s       h          k    q   p: v             & < e s . o b j e c t . v a l u e s . j s       h          k    Xq   p: v               & < e s . o b j e c t . v a l u e s . j s       h          k    q   p: v              & < e s . o b j e c t . v a l u e s . j s       `          k    (q   : v               " < e s . p a r s e - f l o a t . j s   `          k    q   : v              " < e s . p a r s e - f l o a t . j s   `          k    q   : v             " < e s . p a r s e - f l o a t . j s   `          k    Hq   : v               " < e s . p a r s e - f l o a t . j s   `          k    q   : v              " < e s . p a r s e - f l o a t . j s   `          k    	q   : v                < e s . p a r s e - i n t . j s       `          k    h	q   : v               < e s . p a r s e - i n t . j s       `          k    	q   : v              < e s . p a r s e - i n t . j s       `          k    (
q   : v                < e s . p a r s e - i n t . j s       `          k    
q   : v               < e s . p a r s e - i n t . j s       p          k    
q   3; v               2 < e s . p r o m i s e . a l l - s e t t l e d . j s   p          k    Xq   3; v              2 < e s . p r o m i s e . a l l - s e t t l e d . j s   p          k    q   3; v             2 < e s . p r o m i s e . a l l - s e t t l e d . j s   p          k    8q   3; v               2 < e s . p r o m i s e . a l l - s e t t l e d . j s   p          k    q   3; v              2 < e s . p r o m i s e . a l l - s e t t l e d . j s   `          k    q   Z; v               " < e s . p r o m i s e . a n y . j s   `          k    xq   ; v              " < e s . p r o m i s e . a n y . j s   `          k    q   ; v             " < e s . p r o m i s e . a n y . j s   `          k    8q   ; v               " < e s . p r o m i s e . a n y . j s   `          k    q   ; v              " < e s . p r o m i s e . a n y . j s   h          k    q   }; v               * < e s . p r o m i s e . f i n a l l y . j s   h          k    `q   }; v              * < e s . p r o m i s e . f i n a l l y . j s                                                           h          k     q   }; v             * < e s . p r o m i s e . f i n a l l y . j s   h          k    hq   }; v               * < e s . p r o m i s e . f i n a l l y . j s   h          k    q   }; v              * < e s . p r o m i s e . f i n a l l y . j s   X          k    8q   lD< v                < e s . p r o m i s e . j s   X          k    q   lD< v               < e s . p r o m i s e . j s   X          k    q   lD< v              < e s . p r o m i s e . j s   X          k    @q   lD< v                < e s . p r o m i s e . j s   X          k    q   lD< v               < e s . p r o m i s e . j s   h          k    q   ck< v               & < e s . r e f l e c t . a p p l y . j s       h          k    Xq   ck< v              & < e s . r e f l e c t . a p p l y . j s       h          k    q   ck< v             & < e s . r e f l e c t . a p p l y . j s       h          k    (q   ck< v               & < e s . r e f l e c t . a p p l y . j s       h          k    q   ck< v              & < e s . r e f l e c t . a p p l y . j s       p          k    q   V< v               . < e s . r e f l e c t . c o n s t r u c t . j s       p          k    hq   M< v              . < e s . r e f l e c t . c o n s t r u c t . j s       p          k    q   M< v             . < e s . r e f l e c t . c o n s t r u c t . j s       p          k    Hq   M< v               . < e s . r e f l e c t . c o n s t r u c t . j s       p          k    q   M< v              . < e s . r e f l e c t . c o n s t r u c t . j s       x          k    (q   _< v               : < e s . r e f l e c t . d e f i n e - p r o p e r t y . j s   x          k    q   F= v              : < e s . r e f l e c t . d e f i n e - p r o p e r t y . j s   x          k    q   F= v             : < e s . r e f l e c t . d e f i n e - p r o p e r t y . j s   x          k    q   F= v               : < e s . r e f l e c t . d e f i n e - p r o p e r t y . j s   x          k    q   F= v              : < e s . r e f l e c t . d e f i n e - p r o p e r t y . j s   x          k    q   -.= v               : < e s . r e f l e c t . d e l e t e - p r o p e r t y . j s   x          k    q   -.= v              : < e s . r e f l e c t . d e l e t e - p r o p e r t y . j s   x          k    pq   -.= v             : < e s . r e f l e c t . d e l e t e - p r o p e r t y . j s   x          k    q   -.= v               : < e s . r e f l e c t . d e l e t e - p r o p e r t y . j s   x          k    `q   -.= v              : < e s . r e f l e c t . d e l e t e - p r o p e r t y . j s             k    q   U= v               R < e s . r e f l e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             k    hq   |= v              R < e s . r e f l e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             k    q   |= v             R < e s . r e f l e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             k    q   |= v               R < e s . r e f l e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s             k    q   |= v              R < e s . r e f l e c t . g e t - o w n - p r o p e r t y - d e s c r i p t o r . j s   x          k    q   = v               < < e s . r e f l e c t . g e t - p r o t o t y p e - o f . j s x          k     q   = v              < < e s . r e f l e c t . g e t - p r o t o t y p e - o f . j s                                                                                                         x          k      q   = v             < < e s . r e f l e c t . g e t - p r o t o t y p e - o f . j s x          k    x q   = v               < < e s . r e f l e c t . g e t - p r o t o t y p e - o f . j s x          k     q   = v              < < e s . r e f l e c t . g e t - p r o t o t y p e - o f . j s `          k    h!q   = v               " < e s . r e f l e c t . g e t . j s   `          k    !q   = v              " < e s . r e f l e c t . g e t . j s   `          k    ("q   = v             " < e s . r e f l e c t . g e t . j s   `          k    "q   = v               " < e s . r e f l e c t . g e t . j s   `          k    "q   = v              " < e s . r e f l e c t . g e t . j s   `          k    H#q   > v               " < e s . r e f l e c t . h a s . j s   `          k    #q   > v              " < e s . r e f l e c t . h a s . j s   `          k    $q   > v             " < e s . r e f l e c t . h a s . j s   `          k    h$q   > v               " < e s . r e f l e c t . h a s . j s   `          k    $q   > v              " < e s . r e f l e c t . h a s . j s   x          k    (%q   e> v               6 < e s . r e f l e c t . i s - e x t e n s i b l e . j s       x          k    %q   e> v              6 < e s . r e f l e c t . i s - e x t e n s i b l e . j s       x          k    &q   e> v             6 < e s . r e f l e c t . i s - e x t e n s i b l e . j s       x          k    &q   e> v               6 < e s . r e f l e c t . i s - e x t e n s i b l e . j s       x          k    'q   e> v              6 < e s . r e f l e c t . i s - e x t e n s i b l e . j s       h          k    'q   > v               , < e s . r e f l e c t . o w n - k e y s . j s h          k    'q   > v              , < e s . r e f l e c t . o w n - k e y s . j s h          k    P(q   > v             , < e s . r e f l e c t . o w n - k e y s . j s h          k    (q   > v               , < e s . r e f l e c t . o w n - k e y s . j s h          k     )q   > v              , < e s . r e f l e c t . o w n - k e y s . j s           k    )q   > v               @ < e s . r e f l e c t . p r e v e n t - e x t e n s i o n s . j s               k    *q   > v              @ < e s . r e f l e c t . p r e v e n t - e x t e n s i o n s . j s               k    *q   ? v             @ < e s . r e f l e c t . p r e v e n t - e x t e n s i o n s . j s               k    +q   ? v               @ < e s . r e f l e c t . p r e v e n t - e x t e n s i o n s . j s               k    +q   ? v              @ < e s . r e f l e c t . p r e v e n t - e x t e n s i o n s . j s     x          k    ,q   (? v               < < e s . r e f l e c t . s e t - p r o t o t y p e - o f . j s x          k    ,q   (? v              < < e s . r e f l e c t . s e t - p r o t o t y p e - o f . j s x          k    ,q   (? v             < < e s . r e f l e c t . s e t - p r o t o t y p e - o f . j s x          k    p-q   (? v               < < e s . r e f l e c t . s e t - p r o t o t y p e - o f . j s x          k    -q   (? v              < < e s . r e f l e c t . s e t - p r o t o t y p e - o f . j s `          k    `.q   O? v               " < e s . r e f l e c t . s e t . j s   `          k    .q   O? v              " < e s . r e f l e c t . s e t . j s   `          k     /q   O? v             " < e s . r e f l e c t . s e t . j s   `          k    /q   O? v               " < e s . r e f l e c t . s e t . j s                                   `          k     0q   v? v              " < e s . r e f l e c t . s e t . j s   x          k    `0q   ? v               6 < e s . r e f l e c t . t o - s t r i n g - t a g . j s       x          k    0q   ? v              6 < e s . r e f l e c t . t o - s t r i n g - t a g . j s       x          k    P1q   ? v             6 < e s . r e f l e c t . t o - s t r i n g - t a g . j s       x          k    1q   ? v               6 < e s . r e f l e c t . t o - s t r i n g - t a g . j s       x          k    @2q   |? v              6 < e s . r e f l e c t . t o - s t r i n g - t a g . j s       p          k    2q   i? v               0 < e s . r e g e x p . c o n s t r u c t o r . j s     p          k    (3q   i? v              0 < e s . r e g e x p . c o n s t r u c t o r . j s     p          k    3q   i? v             0 < e s . r e g e x p . c o n s t r u c t o r . j s     p          k    4q   i? v               0 < e s . r e g e x p . c o n s t r u c t o r . j s     p          k    x4q   i? v              0 < e s . r e g e x p . c o n s t r u c t o r . j s     h          k    4q   Y9@ v               ( < e s . r e g e x p . d o t - a l l . j s     h          k    P5q   Y9@ v              ( < e s . r e g e x p . d o t - a l l . j s     h          k    5q   Y9@ v             ( < e s . r e g e x p . d o t - a l l . j s     h          k     6q   Y9@ v               ( < e s . r e g e x p . d o t - a l l . j s     h          k    6q   Y9@ v              ( < e s . r e g e x p . d o t - a l l . j s     `          k    6q   M`@ v               " < e s . r e g e x p . e x e c . j s   `          k    P7q   M`@ v              " < e s . r e g e x p . e x e c . j s   `          k    7q   @@ v             " < e s . r e g e x p . e x e c . j s   `          k    8q   @@ v               " < e s . r e g e x p . e x e c . j s   `          k    p8q   @@ v              " < e s . r e g e x p . e x e c . j s   `          k    8q   7@ v               $ < e s . r e g e x p . f l a g s . j s `          k    09q   7@ v              $ < e s . r e g e x p . f l a g s . j s `          k    9q   7@ v             $ < e s . r e g e x p . f l a g s . j s `          k    9q   7@ v               $ < e s . r e g e x p . f l a g s . j s `          k    P:q   7@ v              $ < e s . r e g e x p . f l a g s . j s h          k    :q   ,@ v               & < e s . r e g e x p . s t i c k y . j s       h          k    ;q   &@ v              & < e s . r e g e x p . s t i c k y . j s       h          k    ;q   #A v             & < e s . r e g e x p . s t i c k y . j s       h          k    ;q   #A v               & < e s . r e g e x p . s t i c k y . j s       h          k    P<q   #A v              & < e s . r e g e x p . s t i c k y . j s       `          k    <q   JA v               " < e s . r e g e x p . t e s t . j s   `          k    =q   JA v              " < e s . r e g e x p . t e s t . j s   `          k    x=q   JA v             " < e s . r e g e x p . t e s t . j s   `          k    =q   JA v               " < e s . r e g e x p . t e s t . j s   `          k    8>q   JA v              " < e s . r e g e x p . t e s t . j s   h          k    >q   qA v               , < e s . r e g e x p . t o - s t r i n g . j s h          k     ?q   qA v              , < e s . r e g e x p . t o - s t r i n g . j s h          k    h?q   qA v             , < e s . r e g e x p . t o - s t r i n g . j s                                                 h          k     @q   qA v               , < e s . r e g e x p . t o - s t r i n g . j s h          k    h@q   qA v              , < e s . r e g e x p . t o - s t r i n g . j s P          k    @q   A v                < e s . s e t . j s   P          k     Aq   A v               < e s . s e t . j s   P          k    pAq   A v              < e s . s e t . j s   P          k    Aq   A v                < e s . s e t . j s   P          k    Bq   A v               < e s . s e t . j s   h          k    `Bq   B v               & < e s . s t r i n g . a n c h o r . j s       h          k    Bq   B v              & < e s . s t r i n g . a n c h o r . j s       h          k    0Cq   B v             & < e s . s t r i n g . a n c h o r . j s       h          k    Cq   B v               & < e s . s t r i n g . a n c h o r . j s       h          k     Dq   B v              & < e s . s t r i n g . a n c h o r . j s       x          k    hDq   3B v               6 < e s . s t r i n g . a t - a l t e r n a t i v e . j s       x          k    Dq   ZB v              6 < e s . s t r i n g . a t - a l t e r n a t i v e . j s       x          k    XEq   ZB v             6 < e s . s t r i n g . a t - a l t e r n a t i v e . j s       x          k    Eq   ZB v               6 < e s . s t r i n g . a t - a l t e r n a t i v e . j s       x          k    HFq   ZB v              6 < e s . s t r i n g . a t - a l t e r n a t i v e . j s       `          k    Fq   B v                 < e s . s t r i n g . b i g . j s     `          k     Gq   B v                < e s . s t r i n g . b i g . j s     `          k    Gq   B v               < e s . s t r i n g . b i g . j s     `          k    Gq   B v                 < e s . s t r i n g . b i g . j s     `          k    @Hq   B v                < e s . s t r i n g . b i g . j s     `          k    Hq   B v               $ < e s . s t r i n g . b l i n k . j s `          k     Iq   B v              $ < e s . s t r i n g . b l i n k . j s `          k    `Iq   B v             $ < e s . s t r i n g . b l i n k . j s `          k    Iq   B v               $ < e s . s t r i n g . b l i n k . j s `          k     Jq   B v              $ < e s . s t r i n g . b l i n k . j s `          k    Jq   C v               " < e s . s t r i n g . b o l d . j s   `          k    Jq   C v              " < e s . s t r i n g . b o l d . j s   `          k    @Kq   C v             " < e s . s t r i n g . b o l d . j s   `          k    Kq   C v               " < e s . s t r i n g . b o l d . j s   `          k     Lq   C v              " < e s . s t r i n g . b o l d . j s   p          k    `Lq   DC v               4 < e s . s t r i n g . c o d e - p o i n t - a t . j s p          k    Lq   ykC v              4 < e s . s t r i n g . c o d e - p o i n t - a t . j s p          k    @Mq   ykC v             4 < e s . s t r i n g . c o d e - p o i n t - a t . j s p          k    Mq   ykC v               4 < e s . s t r i n g . c o d e - p o i n t - a t . j s p          k     Nq   ykC v              4 < e s . s t r i n g . c o d e - p o i n t - a t . j s h          k    Nq   qC v               , < e s . s t r i n g . e n d s - w i t h . j s h          k    Nq   qC v              , < e s . s t r i n g . e n d s - w i t h . j s h          k    `Oq   iC v             , < e s . s t r i n g . e n d s - w i t h . j s                                                         h          k     Pq   iC v               , < e s . s t r i n g . e n d s - w i t h . j s h          k    hPq   iC v              , < e s . s t r i n g . e n d s - w i t h . j s `          k    Pq   hC v               $ < e s . s t r i n g . f i x e d . j s `          k    0Qq   hC v              $ < e s . s t r i n g . f i x e d . j s `          k    Qq   hC v             $ < e s . s t r i n g . f i x e d . j s `          k    Qq   hC v               $ < e s . s t r i n g . f i x e d . j s `          k    PRq   hC v              $ < e s . s t r i n g . f i x e d . j s h          k    Rq   C.D v               , < e s . s t r i n g . f o n t c o l o r . j s h          k    Sq   C.D v              , < e s . s t r i n g . f o n t c o l o r . j s h          k    Sq   C.D v             , < e s . s t r i n g . f o n t c o l o r . j s h          k    Sq   C.D v               , < e s . s t r i n g . f o n t c o l o r . j s h          k    PTq   C.D v              , < e s . s t r i n g . f o n t c o l o r . j s h           k    Tq   6UD v               * < e s . s t r i n g . f o n t s i z e . j s   h           k     Uq   -|D v              * < e s . s t r i n g . f o n t s i z e . j s   h           k    Uq   -|D v             * < e s . s t r i n g . f o n t s i z e . j s   h           k    Uq   -|D v               * < e s . s t r i n g . f o n t s i z e . j s   h           k    XVq   -|D v              * < e s . s t r i n g . f o n t s i z e . j s   x          k    Vq   %D v               8 < e s . s t r i n g . f r o m - c o d e - p o i n t . j s     x          k    8Wq   D v              8 < e s . s t r i n g . f r o m - c o d e - p o i n t . j s     x          k    Wq   D v             8 < e s . s t r i n g . f r o m - c o d e - p o i n t . j s     x          k    (Xq   D v               8 < e s . s t r i n g . f r o m - c o d e - p o i n t . j s     x          k    Xq   D v              8 < e s . s t r i n g . f r o m - c o d e - p o i n t . j s     h          k    Yq   D v               * < e s . s t r i n g . i n c l u d e s . j s   h          k    Yq   D v              * < e s . s t r i n g . i n c l u d e s . j s   h          k    Yq   D v             * < e s . s t r i n g . i n c l u d e s . j s   h          k    PZq   D v               * < e s . s t r i n g . i n c l u d e s . j s   h          k    Zq   E v              * < e s . s t r i n g . i n c l u d e s . j s   h          k     [q   >E v               ( < e s . s t r i n g . i t a l i c s . j s     h          k    [q   >E v              ( < e s . s t r i n g . i t a l i c s . j s     h          k    [q   >E v             ( < e s . s t r i n g . i t a l i c s . j s     h          k    X\q   >E v               ( < e s . s t r i n g . i t a l i c s . j s     h          k    \q   >E v              ( < e s . s t r i n g . i t a l i c s . j s     h          k    (]q   E v               * < e s . s t r i n g . i t e r a t o r . j s   h          k    ]q   E v              * < e s . s t r i n g . i t e r a t o r . j s   h          k    ]q   E v             * < e s . s t r i n g . i t e r a t o r . j s   h          k    `^q   E v               * < e s . s t r i n g . i t e r a t o r . j s   h          k    ^q   E v              * < e s . s t r i n g . i t e r a t o r . j s   `          k    0_q   E v               " < e s . s t r i n g . l i n k . j s   `          k    _q   E v              " < e s . s t r i n g . l i n k . j s                   `          k     `q   E v             " < e s . s t r i n g . l i n k . j s   `          k    ``q   E v               " < e s . s t r i n g . l i n k . j s   `          k    `q   E v              " < e s . s t r i n g . l i n k . j s   h          k     aq   F v               , < e s . s t r i n g . m a t c h - a l l . j s h          k    aq   F v              , < e s . s t r i n g . m a t c h - a l l . j s h          k    aq   F v             , < e s . s t r i n g . m a t c h - a l l . j s h          k    Xbq   (F v               , < e s . s t r i n g . m a t c h - a l l . j s h          k    bq   (F v              , < e s . s t r i n g . m a t c h - a l l . j s `          k    (cq   OF v               $ < e s . s t r i n g . m a t c h . j s `          k    cq   OF v              $ < e s . s t r i n g . m a t c h . j s `          k    cq   OF v             $ < e s . s t r i n g . m a t c h . j s `          k    Hdq   OF v               $ < e s . s t r i n g . m a t c h . j s `          k    dq   OF v              $ < e s . s t r i n g . m a t c h . j s h          k    eq   vF v               ( < e s . s t r i n g . p a d - e n d . j s     h          k    peq   vF v              ( < e s . s t r i n g . p a d - e n d . j s     h          k    eq   F v             ( < e s . s t r i n g . p a d - e n d . j s     h          k    @fq   F v               ( < e s . s t r i n g . p a d - e n d . j s     h          k    fq   F v              ( < e s . s t r i n g . p a d - e n d . j s     h      	    k    gq   F v               , < e s . s t r i n g . p a d - s t a r t . j s h      	    k    xgq   F v              , < e s . s t r i n g . p a d - s t a r t . j s h      	    k    gq   F v             , < e s . s t r i n g . p a d - s t a r t . j s h      	    k    Hhq   F v               , < e s . s t r i n g . p a d - s t a r t . j s h      	    k    hq   F v              , < e s . s t r i n g . p a d - s t a r t . j s `      
    k    iq   vG v                 < e s . s t r i n g . r a w . j s     `      
    k    xiq   vG v                < e s . s t r i n g . r a w . j s     `      
    k    iq   vG v               < e s . s t r i n g . r a w . j s     `      
    k    8jq   vG v                 < e s . s t r i n g . r a w . j s     `      
    k    jq   vG v                < e s . s t r i n g . r a w . j s     h          k    jq   v`G v               & < e s . s t r i n g . r e p e a t . j s       h          k    `kq   v`G v              & < e s . s t r i n g . r e p e a t . j s       h          k    kq   v`G v             & < e s . s t r i n g . r e p e a t . j s       h          k    0lq   v`G v               & < e s . s t r i n g . r e p e a t . j s       h          k    lq   v`G v              & < e s . s t r i n g . r e p e a t . j s       p          k     mq   QG v               0 < e s . s t r i n g . r e p l a c e - a l l . j s     p          k    pmq   QG v              0 < e s . s t r i n g . r e p l a c e - a l l . j s     p          k    mq   QG v             0 < e s . s t r i n g . r e p l a c e - a l l . j s     p          k    Pnq   QG v               0 < e s . s t r i n g . r e p l a c e - a l l . j s     p          k    nq   QG v              0 < e s . s t r i n g . r e p l a c e - a l l . j s     h          k    0oq   CG v               ( < e s . s t r i n g . r e p l a c e . j s     h          k    oq   7G v              ( < e s . s t r i n g . r e p l a c e . j s     h          k     pq   5#H v             ( < e s . s t r i n g . r e p l a c e . j s     h          k    hpq   5#H v               ( < e s . s t r i n g . r e p l a c e . j s     h          k    pq   5#H v              ( < e s . s t r i n g . r e p l a c e . j s     h          k    8qq    JH v               & < e s . s t r i n g . s e a r c h . j s       h          k    qq    JH v              & < e s . s t r i n g . s e a r c h . j s       h          k    rq    JH v             & < e s . s t r i n g . s e a r c h . j s       h          k    prq    JH v               & < e s . s t r i n g . s e a r c h . j s       h          k    rq    JH v              & < e s . s t r i n g . s e a r c h . j s       `          k    @sq   qH v               $ < e s . s t r i n g . s m a l l . j s `          k    sq   H v              $ < e s . s t r i n g . s m a l l . j s `          k     tq   H v             $ < e s . s t r i n g . s m a l l . j s `          k    `tq   H v               $ < e s . s t r i n g . s m a l l . j s `          k    tq   H v              $ < e s . s t r i n g . s m a l l . j s `          k     uq   H v               $ < e s . s t r i n g . s p l i t . j s `          k    uq   H v              $ < e s . s t r i n g . s p l i t . j s `          k    uq   H v             $ < e s . s t r i n g . s p l i t . j s `          k    @vq   H v               $ < e s . s t r i n g . s p l i t . j s `          k    vq   H v              $ < e s . s t r i n g . s p l i t . j s p          k     wq   I v               0 < e s . s t r i n g . s t a r t s - w i t h . j s     p          k    pwq   I v              0 < e s . s t r i n g . s t a r t s - w i t h . j s     p          k    wq   I v             0 < e s . s t r i n g . s t a r t s - w i t h . j s     p          k    Pxq   I v               0 < e s . s t r i n g . s t a r t s - w i t h . j s     p          k    xq   I v              0 < e s . s t r i n g . s t a r t s - w i t h . j s     h          k    0yq   3I v               & < e s . s t r i n g . s t r i k e . j s       h          k    yq   ZI v              & < e s . s t r i n g . s t r i k e . j s       h          k     zq   ZI v             & < e s . s t r i n g . s t r i k e . j s       h          k    hzq   ZI v               & < e s . s t r i n g . s t r i k e . j s       h          k    zq   ZI v              & < e s . s t r i n g . s t r i k e . j s       `          k    8{q   I v                 < e s . s t r i n g . s u b . j s     `          k    {q   I v                < e s . s t r i n g . s u b . j s     `          k    {q   I v               < e s . s t r i n g . s u b . j s     `          k    X|q   I v                 < e s . s t r i n g . s u b . j s     `          k    |q   I v                < e s . s t r i n g . s u b . j s     h          k    }q   I v               & < e s . s t r i n g . s u b s t r . j s       h          k    }q   I v              & < e s . s t r i n g . s u b s t r . j s       h          k    }q   I v             & < e s . s t r i n g . s u b s t r . j s       h          k    P~q   I v               & < e s . s t r i n g . s u b s t r . j s       h          k    ~q   I v              & < e s . s t r i n g . s u b s t r . j s       `          k     q   I v                 < e s . s t r i n g . s u p . j s     `          k    q   J v                < e s . s t r i n g . s u p . j s                                     `          k     q   J v               < e s . s t r i n g . s u p . j s     `          k    `q   J v                 < e s . s t r i n g . s u p . j s     `          k    q   J v                < e s . s t r i n g . s u p . j s     h          k     q   DJ v               * < e s . s t r i n g . t r i m - e n d . j s   h          k    q   DJ v              * < e s . s t r i n g . t r i m - e n d . j s   h          k    q   DJ v             * < e s . s t r i n g . t r i m - e n d . j s   h          k    Xq   kJ v               * < e s . s t r i n g . t r i m - e n d . j s   h          k    q   kJ v              * < e s . s t r i n g . t r i m - e n d . j s   p          k    (q   J v               . < e s . s t r i n g . t r i m - s t a r t . j s       p          k    q   J v              . < e s . s t r i n g . t r i m - s t a r t . j s       p          k    q   J v             . < e s . s t r i n g . t r i m - s t a r t . j s       p          k    xq   J v               . < e s . s t r i n g . t r i m - s t a r t . j s       p          k    q   J v              . < e s . s t r i n g . t r i m - s t a r t . j s       `          k    Xq   'K v               " < e s . s t r i n g . t r i m . j s   `          k    q   'L v              " < e s . s t r i n g . t r i m . j s   `          k    q   'L v             " < e s . s t r i n g . t r i m . j s   `          k    xq   'L v               " < e s . s t r i n g . t r i m . j s   `          k    q   'L v              " < e s . s t r i n g . t r i m . j s   x          k    8q   ?L v               6 < e s . s y m b o l . a s y n c - i t e r a t o r . j s       x          k    q   ?L v              6 < e s . s y m b o l . a s y n c - i t e r a t o r . j s       x          k    (q   ?L v             6 < e s . s y m b o l . a s y n c - i t e r a t o r . j s       x          k    q   ?L v               6 < e s . s y m b o l . a s y n c - i t e r a t o r . j s       x          k    q   ?L v              6 < e s . s y m b o l . a s y n c - i t e r a t o r . j s       p          k    q   	fL v               0 < e s . s y m b o l . d e s c r i p t i o n . j s     p          k     q   	fL v              0 < e s . s y m b o l . d e s c r i p t i o n . j s     p          k    pq   	fL v             0 < e s . s y m b o l . d e s c r i p t i o n . j s     p          k    q   L v               0 < e s . s y m b o l . d e s c r i p t i o n . j s     p          k    Pq   L v              0 < e s . s y m b o l . d e s c r i p t i o n . j s     p          k    q   L v               2 < e s . s y m b o l . h a s - i n s t a n c e . j s   p          k    0q   L v              2 < e s . s y m b o l . h a s - i n s t a n c e . j s   p          k    q   L v             2 < e s . s y m b o l . h a s - i n s t a n c e . j s   p          k    q   L v               2 < e s . s y m b o l . h a s - i n s t a n c e . j s   p          k    q   L v              2 < e s . s y m b o l . h a s - i n s t a n c e . j s             k    q   L v               B < e s . s y m b o l . i s - c o n c a t - s p r e a d a b l e . j s             k    pq   M v              B < e s . s y m b o l . i s - c o n c a t - s p r e a d a b l e . j s             k    q   M v             B < e s . s y m b o l . i s - c o n c a t - s p r e a d a b l e . j s             k    pq   M v               B < e s . s y m b o l . i s - c o n c a t - s p r e a d a b l e . j s                             k     q   M v              B < e s . s y m b o l . i s - c o n c a t - s p r e a d a b l e . j s   h          k    q   (M v               * < e s . s y m b o l . i t e r a t o r . j s   h          k    q   OM v              * < e s . s y m b o l . i t e r a t o r . j s   h          k    Pq   OM v             * < e s . s y m b o l . i t e r a t o r . j s   h          k    q   OM v               * < e s . s y m b o l . i t e r a t o r . j s   h          k     q   OM v              * < e s . s y m b o l . i t e r a t o r . j s   X          k    q   vM v                < e s . s y m b o l . j s     X          k    q   vM v               < e s . s y m b o l . j s     X          k    8q   M v              < e s . s y m b o l . j s     X          k    q   M v                < e s . s y m b o l . j s     X          k    q   M v               < e s . s y m b o l . j s     h          k    @q   M v               , < e s . s y m b o l . m a t c h - a l l . j s h          k    q   M v              , < e s . s y m b o l . m a t c h - a l l . j s h          k    q   M v             , < e s . s y m b o l . m a t c h - a l l . j s h          k    xq   M v               , < e s . s y m b o l . m a t c h - a l l . j s h          k    q   M v              , < e s . s y m b o l . m a t c h - a l l . j s `           k    Hq   N v               $ < e s . s y m b o l . m a t c h . j s `           k    q   N v              $ < e s . s y m b o l . m a t c h . j s `           k    q   N v             $ < e s . s y m b o l . m a t c h . j s `           k    hq   9N v               $ < e s . s y m b o l . m a t c h . j s `           k    q   9N v              $ < e s . s y m b o l . m a t c h . j s h      !    k    (q   u`N v               ( < e s . s y m b o l . r e p l a c e . j s     h      !    k    q   u`N v              ( < e s . s y m b o l . r e p l a c e . j s     h      !    k    q   u`N v             ( < e s . s y m b o l . r e p l a c e . j s     h      !    k    `q   u`N v               ( < e s . s y m b o l . r e p l a c e . j s     h      !    k    q   u`N v              ( < e s . s y m b o l . r e p l a c e . j s     h      "    k    0q   `N v               & < e s . s y m b o l . s e a r c h . j s       h      "    k    q   `N v              & < e s . s y m b o l . s e a r c h . j s       h      "    k     q   `N v             & < e s . s y m b o l . s e a r c h . j s       h      "    k    hq   `N v               & < e s . s y m b o l . s e a r c h . j s       h      "    k    q   `N v              & < e s . s y m b o l . s e a r c h . j s       h      #    k    8q   KN v               ( < e s . s y m b o l . s p e c i e s . j s     h      #    k    q   KN v              ( < e s . s y m b o l . s p e c i e s . j s     h      #    k    q   KN v             ( < e s . s y m b o l . s p e c i e s . j s     h      #    k    pq   KN v               ( < e s . s y m b o l . s p e c i e s . j s     h      #    k    q   KN v              ( < e s . s y m b o l . s p e c i e s . j s     `      $    k    @q   5JO v               $ < e s . s y m b o l . s p l i t . j s `      $    k    q   5JO v              $ < e s . s y m b o l . s p l i t . j s `      $    k     q   5JO v             $ < e s . s y m b o l . s p l i t . j s `      $    k    `q   5JO v               $ < e s . s y m b o l . s p l i t . j s                                                                 `      $    k     q   5JO v              $ < e s . s y m b o l . s p l i t . j s p      %    k    `q   (qO v               2 < e s . s y m b o l . t o - p r i m i t i v e . j s   p      %    k    q   "O v              2 < e s . s y m b o l . t o - p r i m i t i v e . j s   p      %    k    @q   "O v             2 < e s . s y m b o l . t o - p r i m i t i v e . j s   p      %    k    q   "O v               2 < e s . s y m b o l . t o - p r i m i t i v e . j s   p      %    k     q   "O v              2 < e s . s y m b o l . t o - p r i m i t i v e . j s   p      &    k    q   O v               4 < e s . s y m b o l . t o - s t r i n g - t a g . j s p      &    k     q   O v              4 < e s . s y m b o l . t o - s t r i n g - t a g . j s p      &    k    pq   3P v             4 < e s . s y m b o l . t o - s t r i n g - t a g . j s p      &    k    q   ZP v               4 < e s . s y m b o l . t o - s t r i n g - t a g . j s p      &    k    Pq   ZP v              4 < e s . s y m b o l . t o - s t r i n g - t a g . j s p      '    k    q   P v               0 < e s . s y m b o l . u n s c o p a b l e s . j s     p      '    k    0q   P v              0 < e s . s y m b o l . u n s c o p a b l e s . j s     p      '    k    q   P v             0 < e s . s y m b o l . u n s c o p a b l e s . j s     p      '    k    q   P v               0 < e s . s y m b o l . u n s c o p a b l e s . j s     p      '    k    q   P v              0 < e s . s y m b o l . u n s c o p a b l e s . j s     h      (    k    q   P v               ( < e s . t y p e d - a r r a y . a t . j s     h      (    k    Xq   P v              ( < e s . t y p e d - a r r a y . a t . j s     h      (    k    q   P v             ( < e s . t y p e d - a r r a y . a t . j s     h      (    k    (q   P v               ( < e s . t y p e d - a r r a y . a t . j s     h      (    k    q   P v              ( < e s . t y p e d - a r r a y . a t . j s     x      )    k    q   P v               : < e s . t y p e d - a r r a y . c o p y - w i t h i n . j s   x      )    k    pq   Q v              : < e s . t y p e d - a r r a y . c o p y - w i t h i n . j s   x      )    k    q   Q v             : < e s . t y p e d - a r r a y . c o p y - w i t h i n . j s   x      )    k    `q   Q v               : < e s . t y p e d - a r r a y . c o p y - w i t h i n . j s   x      )    k    q   Q v              : < e s . t y p e d - a r r a y . c o p y - w i t h i n . j s   p      *    k    Pq   DQ v               . < e s . t y p e d - a r r a y . e v e r y . j s       p      *    k    q   kQ v              . < e s . t y p e d - a r r a y . e v e r y . j s       p      *    k    0q   kQ v             . < e s . t y p e d - a r r a y . e v e r y . j s       p      *    k    q   kQ v               . < e s . t y p e d - a r r a y . e v e r y . j s       p      *    k    q   kQ v              . < e s . t y p e d - a r r a y . e v e r y . j s       h      +    k    q   Q v               , < e s . t y p e d - a r r a y . f i l l . j s h      +    k    q   Q v              , < e s . t y p e d - a r r a y . f i l l . j s h      +    k    Pq   Q v             , < e s . t y p e d - a r r a y . f i l l . j s h      +    k    q   Q v               , < e s . t y p e d - a r r a y . f i l l . j s h      +    k     q   Q v              , < e s . t y p e d - a r r a y . f i l l . j s p      ,    k    q   Q v               0 < e s . t y p e d - a r r a y . f i l t e r . j s             p      ,    k     q   Q v              0 < e s . t y p e d - a r r a y . f i l t e r . j s     p      ,    k    pq   Q v             0 < e s . t y p e d - a r r a y . f i l t e r . j s     p      ,    k    q   Q v               0 < e s . t y p e d - a r r a y . f i l t e r . j s     p      ,    k    Pq   Q v              0 < e s . t y p e d - a r r a y . f i l t e r . j s     x      -    k    q   i.R v               8 < e s . t y p e d - a r r a y . f i n d - i n d e x . j s     x      -    k    8q   i.R v              8 < e s . t y p e d - a r r a y . f i n d - i n d e x . j s     x      -    k    q   i.R v             8 < e s . t y p e d - a r r a y . f i n d - i n d e x . j s     x      -    k    (q   i.R v               8 < e s . t y p e d - a r r a y . f i n d - i n d e x . j s     x      -    k    q   i.R v              8 < e s . t y p e d - a r r a y . f i n d - i n d e x . j s     h      .    k    q   `UR v               , < e s . t y p e d - a r r a y . f i n d . j s h      .    k    q   `UR v              , < e s . t y p e d - a r r a y . f i n d . j s h      .    k    q   S|R v             , < e s . t y p e d - a r r a y . f i n d . j s h      .    k    Pq   S|R v               , < e s . t y p e d - a r r a y . f i n d . j s h      .    k    q   S|R v              , < e s . t y p e d - a r r a y . f i n d . j s       /    k     q   IR v               > < e s . t y p e d - a r r a y . f l o a t 3 2 - a r r a y . j s             /    k    q   IR v              > < e s . t y p e d - a r r a y . f l o a t 3 2 - a r r a y . j s             /    k     q   IR v             > < e s . t y p e d - a r r a y . f l o a t 3 2 - a r r a y . j s             /    k    q   IR v               > < e s . t y p e d - a r r a y . f l o a t 3 2 - a r r a y . j s             /    k     q   IR v              > < e s . t y p e d - a r r a y . f l o a t 3 2 - a r r a y . j s             0    k    q   7R v               > < e s . t y p e d - a r r a y . f l o a t 6 4 - a r r a y . j s             0    k     q   7R v              > < e s . t y p e d - a r r a y . f l o a t 6 4 - a r r a y . j s             0    k    q   7R v             > < e s . t y p e d - a r r a y . f l o a t 6 4 - a r r a y . j s             0    k     q   7R v               > < e s . t y p e d - a r r a y . f l o a t 6 4 - a r r a y . j s             0    k    q   7R v              > < e s . t y p e d - a r r a y . f l o a t 6 4 - a r r a y . j s       p      1    k     q   (S v               4 < e s . t y p e d - a r r a y . f o r - e a c h . j s p      1    k    q   ?S v              4 < e s . t y p e d - a r r a y . f o r - e a c h . j s p      1    k     q   ?S v             4 < e s . t y p e d - a r r a y . f o r - e a c h . j s p      1    k    pq   ?S v               4 < e s . t y p e d - a r r a y . f o r - e a c h . j s p      1    k    q   ?S v              4 < e s . t y p e d - a r r a y . f o r - e a c h . j s h      2    k    Pq   fS v               , < e s . t y p e d - a r r a y . f r o m . j s h      2    k    q   S v              , < e s . t y p e d - a r r a y . f r o m . j s h      2    k     q   S v             , < e s . t y p e d - a r r a y . f r o m . j s h      2    k    q   S v               , < e s . t y p e d - a r r a y . f r o m . j s h      2    k    q   S v              , < e s . t y p e d - a r r a y . f r o m . j s p      3    k    Xq   S v               4 < e s . t y p e d - a r r a y . i n c l u d e s . j s                                                         p      3    k     q   S v              4 < e s . t y p e d - a r r a y . i n c l u d e s . j s p      3    k    pq   S v             4 < e s . t y p e d - a r r a y . i n c l u d e s . j s p      3    k    q   S v               4 < e s . t y p e d - a r r a y . i n c l u d e s . j s p      3    k    Pq   S v              4 < e s . t y p e d - a r r a y . i n c l u d e s . j s p      4    k    q   T v               4 < e s . t y p e d - a r r a y . i n d e x - o f . j s p      4    k    0q   T v              4 < e s . t y p e d - a r r a y . i n d e x - o f . j s p      4    k    q   T v             4 < e s . t y p e d - a r r a y . i n d e x - o f . j s p      4    k    q   T v               4 < e s . t y p e d - a r r a y . i n d e x - o f . j s p      4    k    q   T v              4 < e s . t y p e d - a r r a y . i n d e x - o f . j s x      5    k    q   (T v               : < e s . t y p e d - a r r a y . i n t 1 6 - a r r a y . j s   x      5    k    hq   OT v              : < e s . t y p e d - a r r a y . i n t 1 6 - a r r a y . j s   x      5    k    q   OT v             : < e s . t y p e d - a r r a y . i n t 1 6 - a r r a y . j s   x      5    k    Xq   OT v               : < e s . t y p e d - a r r a y . i n t 1 6 - a r r a y . j s   x      5    k    q   OT v              : < e s . t y p e d - a r r a y . i n t 1 6 - a r r a y . j s   x      6    k    Hq   vT v               : < e s . t y p e d - a r r a y . i n t 3 2 - a r r a y . j s   x      6    k    q   vT v              : < e s . t y p e d - a r r a y . i n t 3 2 - a r r a y . j s   x      6    k    8q   vT v             : < e s . t y p e d - a r r a y . i n t 3 2 - a r r a y . j s   x      6    k    q   vT v               : < e s . t y p e d - a r r a y . i n t 3 2 - a r r a y . j s   x      6    k    (q   vT v              : < e s . t y p e d - a r r a y . i n t 3 2 - a r r a y . j s   x      7    k    q   T v               8 < e s . t y p e d - a r r a y . i n t 8 - a r r a y . j s     x      7    k    q   T v              8 < e s . t y p e d - a r r a y . i n t 8 - a r r a y . j s     x      7    k    q   T v             8 < e s . t y p e d - a r r a y . i n t 8 - a r r a y . j s     x      7    k    q   T v               8 < e s . t y p e d - a r r a y . i n t 8 - a r r a y . j s     x      7    k    q   T v              8 < e s . t y p e d - a r r a y . i n t 8 - a r r a y . j s     p      8    k    q   T v               4 < e s . t y p e d - a r r a y . i t e r a t o r . j s p      8    k    hq   T v              4 < e s . t y p e d - a r r a y . i t e r a t o r . j s p      8    k    q   T v             4 < e s . t y p e d - a r r a y . i t e r a t o r . j s p      8    k    Hq   T v               4 < e s . t y p e d - a r r a y . i t e r a t o r . j s p      8    k    q   T v              4 < e s . t y p e d - a r r a y . i t e r a t o r . j s h      9    k    (q   U v               , < e s . t y p e d - a r r a y . j o i n . j s h      9    k    q   U v              , < e s . t y p e d - a r r a y . j o i n . j s h      9    k    q   U v             , < e s . t y p e d - a r r a y . j o i n . j s h      9    k    `q   U v               , < e s . t y p e d - a r r a y . j o i n . j s h      9    k    q   U v              , < e s . t y p e d - a r r a y . j o i n . j s       :    k    0q   `U v               > < e s . t y p e d - a r r a y . l a s t - i n d e x - o f . j s                                                                                             :    k     q   `U v              > < e s . t y p e d - a r r a y . l a s t - i n d e x - o f . j s             :    k    q   `U v             > < e s . t y p e d - a r r a y . l a s t - i n d e x - o f . j s             :    k     q   `U v               > < e s . t y p e d - a r r a y . l a s t - i n d e x - o f . j s             :    k    q   `U v              > < e s . t y p e d - a r r a y . l a s t - i n d e x - o f . j s       h      ;    k     q   |U v               * < e s . t y p e d - a r r a y . m a p . j s   h      ;    k    hq   |U v              * < e s . t y p e d - a r r a y . m a p . j s   h      ;    k    q   |U v             * < e s . t y p e d - a r r a y . m a p . j s   h      ;    k    8q   |U v               * < e s . t y p e d - a r r a y . m a p . j s   h      ;    k    q   |U v              * < e s . t y p e d - a r r a y . m a p . j s   h      <    k    q   qU v               ( < e s . t y p e d - a r r a y . o f . j s     h      <    k    pq   qU v              ( < e s . t y p e d - a r r a y . o f . j s     h      <    k    q   lU v             ( < e s . t y p e d - a r r a y . o f . j s     h      <    k    @q   lU v               ( < e s . t y p e d - a r r a y . o f . j s     h      <    k    q   lU v              ( < e s . t y p e d - a r r a y . o f . j s     x      =    k    q   `U v               < < e s . t y p e d - a r r a y . r e d u c e - r i g h t . j s x      =    k    q   `U v              < < e s . t y p e d - a r r a y . r e d u c e - r i g h t . j s x      =    k     q   `U v             < < e s . t y p e d - a r r a y . r e d u c e - r i g h t . j s x      =    k    xq   `U v               < < e s . t y p e d - a r r a y . r e d u c e - r i g h t . j s x      =    k    q   `U v              < < e s . t y p e d - a r r a y . r e d u c e - r i g h t . j s p      >    k    hq   Q#V v               0 < e s . t y p e d - a r r a y . r e d u c e . j s     p      >    k    q   Q#V v              0 < e s . t y p e d - a r r a y . r e d u c e . j s     p      >    k    Hq   Q#V v             0 < e s . t y p e d - a r r a y . r e d u c e . j s     p      >    k    q   Q#V v               0 < e s . t y p e d - a r r a y . r e d u c e . j s     p      >    k    (q   Q#V v              0 < e s . t y p e d - a r r a y . r e d u c e . j s     p      ?    k    q   FJV v               2 < e s . t y p e d - a r r a y . r e v e r s e . j s   p      ?    k    q   FJV v              2 < e s . t y p e d - a r r a y . r e v e r s e . j s   p      ?    k    xq   =qV v             2 < e s . t y p e d - a r r a y . r e v e r s e . j s   p      ?    k    q   =qV v               2 < e s . t y p e d - a r r a y . r e v e r s e . j s   p      ?    k    Xq   =qV v              2 < e s . t y p e d - a r r a y . r e v e r s e . j s   h      @    k    q   3V v               * < e s . t y p e d - a r r a y . s e t . j s   h      @    k    0q   3V v              * < e s . t y p e d - a r r a y . s e t . j s   h      @    k    q   3V v             * < e s . t y p e d - a r r a y . s e t . j s   h      @    k     q   .V v               * < e s . t y p e d - a r r a y . s e t . j s   h      @    k    hq   .V v              * < e s . t y p e d - a r r a y . s e t . j s   p      A    k    q   .V v               . < e s . t y p e d - a r r a y . s l i c e . j s       p      A    k    @q   .V v              . < e s . t y p e d - a r r a y . s l i c e . j s                                                                                       p      A    k     q   V v             . < e s . t y p e d - a r r a y . s l i c e . j s       p      A    k    pq   V v               . < e s . t y p e d - a r r a y . s l i c e . j s       p      A    k    q   V v              . < e s . t y p e d - a r r a y . s l i c e . j s       h      B    k    Pq   V v               , < e s . t y p e d - a r r a y . s o m e . j s h      B    k    q   W v              , < e s . t y p e d - a r r a y . s o m e . j s h      B    k     q   W v             , < e s . t y p e d - a r r a y . s o m e . j s h      B    k    q   W v               , < e s . t y p e d - a r r a y . s o m e . j s h      B    k    q   W v              , < e s . t y p e d - a r r a y . s o m e . j s h      C    k    Xq   4W v               , < e s . t y p e d - a r r a y . s o r t . j s h      C    k    q   4W v              , < e s . t y p e d - a r r a y . s o r t . j s h      C    k    (q   4W v             , < e s . t y p e d - a r r a y . s o r t . j s h      C    k    q   ZW v               , < e s . t y p e d - a r r a y . s o r t . j s h      C    k    q   ZW v              , < e s . t y p e d - a r r a y . s o r t . j s p      D    k    `q   ZW v               4 < e s . t y p e d - a r r a y . s u b a r r a y . j s p      D    k    q   W v              4 < e s . t y p e d - a r r a y . s u b a r r a y . j s p      D    k    @q   W v             4 < e s . t y p e d - a r r a y . s u b a r r a y . j s p      D    k    q   W v               4 < e s . t y p e d - a r r a y . s u b a r r a y . j s p      D    k     q   W v              4 < e s . t y p e d - a r r a y . s u b a r r a y . j s       E    k    q   W v               D < e s . t y p e d - a r r a y . t o - l o c a l e - s t r i n g . j s       E    k    q   W v              D < e s . t y p e d - a r r a y . t o - l o c a l e - s t r i n g . j s       E    k    q   W v             D < e s . t y p e d - a r r a y . t o - l o c a l e - s t r i n g . j s       E    k    q   W v               D < e s . t y p e d - a r r a y . t o - l o c a l e - s t r i n g . j s       E    k    q   W v              D < e s . t y p e d - a r r a y . t o - l o c a l e - s t r i n g . j s x      F    k    q   W v               6 < e s . t y p e d - a r r a y . t o - s t r i n g . j s       x      F    k    q   W v              6 < e s . t y p e d - a r r a y . t o - s t r i n g . j s       x      F    k     q   W v             6 < e s . t y p e d - a r r a y . t o - s t r i n g . j s       x      F    k    xq   W v               6 < e s . t y p e d - a r r a y . t o - s t r i n g . j s       x      F    k    q   W v              6 < e s . t y p e d - a r r a y . t o - s t r i n g . j s       x      G    k    hq   X v               < < e s . t y p e d - a r r a y . u i n t 1 6 - a r r a y . j s x      G    k    q   X v              < < e s . t y p e d - a r r a y . u i n t 1 6 - a r r a y . j s x      G    k    Xq   X v             < < e s . t y p e d - a r r a y . u i n t 1 6 - a r r a y . j s x      G    k    q   DX v               < < e s . t y p e d - a r r a y . u i n t 1 6 - a r r a y . j s x      G    k    Hq   DX v              < < e s . t y p e d - a r r a y . u i n t 1 6 - a r r a y . j s x      H    k    q   kX v               < < e s . t y p e d - a r r a y . u i n t 3 2 - a r r a y . j s x      H    k    8q   kX v              < < e s . t y p e d - a r r a y . u i n t 3 2 - a r r a y . j s                                                                                 x      H    k     q   kX v             < < e s . t y p e d - a r r a y . u i n t 3 2 - a r r a y . j s x      H    k    xq   X v               < < e s . t y p e d - a r r a y . u i n t 3 2 - a r r a y . j s x      H    k    q   X v              < < e s . t y p e d - a r r a y . u i n t 3 2 - a r r a y . j s x      I    k    hq   X v               : < e s . t y p e d - a r r a y . u i n t 8 - a r r a y . j s   x      I    k    q   X v              : < e s . t y p e d - a r r a y . u i n t 8 - a r r a y . j s   x      I    k    Xq   X v             : < e s . t y p e d - a r r a y . u i n t 8 - a r r a y . j s   x      I    k    q   X v               : < e s . t y p e d - a r r a y . u i n t 8 - a r r a y . j s   x      I    k    Hq   X v              : < e s . t y p e d - a r r a y . u i n t 8 - a r r a y . j s         J    k    q   Y v               J < e s . t y p e d - a r r a y . u i n t 8 - c l a m p e d - a r r a y . j s         J    k    Hq   Y v              J < e s . t y p e d - a r r a y . u i n t 8 - c l a m p e d - a r r a y . j s         J    k    q   Y v             J < e s . t y p e d - a r r a y . u i n t 8 - c l a m p e d - a r r a y . j s         J    k    Xq   Y v               J < e s . t y p e d - a r r a y . u i n t 8 - c l a m p e d - a r r a y . j s         J    k    q   Y v              J < e s . t y p e d - a r r a y . u i n t 8 - c l a m p e d - a r r a y . j s   X      K    k    hq   .Y v                < e s . u n e s c a p e . j s X      K    k    q   xUY v               < e s . u n e s c a p e . j s X      K    k    q   xUY v              < e s . u n e s c a p e . j s X      K    k    pq   xUY v                < e s . u n e s c a p e . j s X      K    k    q   xUY v               < e s . u n e s c a p e . j s X      L    k     q   g|Y v                < e s . w e a k - m a p . j s X      L    k    xq   g|Y v               < e s . w e a k - m a p . j s X      L    k    q   g|Y v              < e s . w e a k - m a p . j s X      L    k    (q   g|Y v                < e s . w e a k - m a p . j s X      L    k    q   g|Y v               < e s . w e a k - m a p . j s X      M    k    q   :Z v                < e s . w e a k - s e t . j s X      M    k    0q   :Z v               < e s . w e a k - s e t . j s X      M    k    q   :Z v              < e s . w e a k - s e t . j s X      M    k    q   :Z v                < e s . w e a k - s e t . j s X      M    k    8q   :Z v               < e s . w e a k - s e t . j s p      N    k    q   +fZ v               2 < e s n e x t . a g g r e g a t e - e r r o r . j s   p      N    k     q   +fZ v              2 < e s n e x t . a g g r e g a t e - e r r o r . j s   p      N    k    pq   +fZ v             2 < e s n e x t . a g g r e g a t e - e r r o r . j s   p      N    k    q   +fZ v               2 < e s n e x t . a g g r e g a t e - e r r o r . j s   p      N    k    Pq   +fZ v              2 < e s n e x t . a g g r e g a t e - e r r o r . j s   `      O    k    q   Z v               $ < e s n e x t . a r r a y . a t . j s `      O    k     q   Z v              $ < e s n e x t . a r r a y . a t . j s `      O    k    q   Z v             $ < e s n e x t . a r r a y . a t . j s `      O    k    q   Z v               $ < e s n e x t . a r r a y . a t . j s `      O    k    @q   Z v              $ < e s n e x t . a r r a y . a t . j s                                                                                                 declare module 'fs' {
    import * as stream from 'stream';
    import EventEmitter = require('events');
    import { URL } from 'url';

    /**
     * Valid types for path values in "fs".
     */
    type PathLike = string | Buffer | URL;

    type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;

    interface StatsBase<T> {
        isFile(): boolean;
        isDirectory(): boolean;
        isBlockDevice(): boolean;
        isCharacterDevice(): boolean;
        isSymbolicLink(): boolean;
        isFIFO(): boolean;
        isSocket(): boolean;

        dev: T;
        ino: T;
        mode: T;
        nlink: T;
        uid: T;
        gid: T;
        rdev: T;
        size: T;
        blksize: T;
        blocks: T;
        atimeMs: T;
        mtimeMs: T;
        ctimeMs: T;
        birthtimeMs: T;
        atime: Date;
        mtime: Date;
        ctime: Date;
        birthtime: Date;
    }

    interface Stats extends StatsBase<number> {
    }

    class Stats {
    }

    class Dirent {
        isFile(): boolean;
        isDirectory(): boolean;
        isBlockDevice(): boolean;
        isCharacterDevice(): boolean;
        isSymbolicLink(): boolean;
        isFIFO(): boolean;
        isSocket(): boolean;
        name: string;
    }

    /**
     * A class representing a directory stream.
     */
    class Dir {
        readonly path: string;

        /**
         * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
         */
        [Symbol.asyncIterator](): AsyncIterableIterator<Dirent>;

        /**
         * Asynchronously close the directory's underlying resource handle.
         * Subsequent reads will result in errors.
         */
        close(): Promise<void>;
        close(cb: NoParamCallback): void;

        /**
         * Synchronously close the directory's underlying resource handle.
         * Subsequent reads will result in errors.
         */
        closeSync(): void;

        /**
         * Asynchronously read the next directory entry via `readdir(3)` as an `Dirent`.
         * After the read is completed, a value is returned that will be resolved with an `Dirent`, or `null` if there are no more directory entries to read.
         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
         */
        read(): Promise<Dirent | null>;
        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;

        /**
         * Synchronously read the next directory entry via `readdir(3)` as a `Dirent`.
         * If there are no more directory entries to read, null will be returned.
         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.
         */
        readSync(): Dirent;
    }

    interface FSWatcher extends EventEmitter {
        close(): void;

        /**
         * events.EventEmitter
         *   1. change
         *   2. error
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        addListener(event: "close", listener: () => void): this;

        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "close", listener: () => void): this;

        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        once(event: "close", listener: () => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependListener(event: "close", listener: () => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
    }

    class ReadStream extends stream.Readable {
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        bytesRead: number;
        path: string | Buffer;

        /**
         * events.EventEmitter
         *   1. open
         *   2. close
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "open", listener: (fd: number) => void): this;
        addListener(event: "close", listener: () => void): this;

        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "open", listener: (fd: number) => void): this;
        on(event: "close", listener: () => void): this;

        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "open", listener: (fd: number) => void): this;
        once(event: "close", listener: () => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "open", listener: (fd: number) => void): this;
        prependListener(event: "close", listener: () => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "open", listener: (fd: number) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
    }

    class WriteStream extends stream.Writable {
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        bytesWritten: number;
        path: string | Buffer;

        /**
         * events.EventEmitter
         *   1. open
         *   2. close
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "open", listener: (fd: number) => void): this;
        addListener(event: "close", listener: () => void): this;

        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "open", listener: (fd: number) => void): this;
        on(event: "close", listener: () => void): this;

        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "open", listener: (fd: number) => void): this;
        once(event: "close", listener: () => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "open", listener: (fd: number) => void): this;
        prependListener(event: "close", listener: () => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "open", listener: (fd: number) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
    }

    /**
     * Asynchronous rename(2) - Change the name or location of a file or directory.
     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace rename {
        /**
         * Asynchronous rename(2) - Change the name or location of a file or directory.
         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;
    }

    /**
     * Synchronous rename(2) - Change the name or location of a file or directory.
     * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function renameSync(oldPath: PathLike, newPath: PathLike): void;

    /**
     * Asynchronous truncate(2) - Truncate a file to a specified length.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param len If not specified, defaults to `0`.
     */
    function truncate(path: PathLike, len: number | undefined | null, callback: NoParamCallback): void;

    /**
     * Asynchronous truncate(2) - Truncate a file to a specified length.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function truncate(path: PathLike, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace truncate {
        /**
         * Asynchronous truncate(2) - Truncate a file to a specified length.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param len If not specified, defaults to `0`.
         */
        function __promisify__(path: PathLike, len?: number | null): Promise<void>;
    }

    /**
     * Synchronous truncate(2) - Truncate a file to a specified length.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param len If not specified, defaults to `0`.
     */
    function truncateSync(path: PathLike, len?: number | null): void;

    /**
     * Asynchronous ftruncate(2) - Truncate a file to a specified length.
     * @param fd A file descriptor.
     * @param len If not specified, defaults to `0`.
     */
    function ftruncate(fd: number, len: number | undefined | null, callback: NoParamCallback): void;

    /**
     * Asynchronous ftruncate(2) - Truncate a file to a specified length.
     * @param fd A file descriptor.
     */
    function ftruncate(fd: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace ftruncate {
        /**
         * Asynchronous ftruncate(2) - Truncate a file to a specified length.
         * @param fd A file descriptor.
         * @param len If not specified, defaults to `0`.
         */
        function __promisify__(fd: number, len?: number | null): Promise<void>;
    }

    /**
     * Synchronous ftruncate(2) - Truncate a file to a specified length.
     * @param fd A file descriptor.
     * @param len If not specified, defaults to `0`.
     */
    function ftruncateSync(fd: number, len?: number | null): void;

    /**
     * Asynchronous chown(2) - Change ownership of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace chown {
        /**
         * Asynchronous chown(2) - Change ownership of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }

    /**
     * Synchronous chown(2) - Change ownership of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function chownSync(path: PathLike, uid: number, gid: number): void;

    /**
     * Asynchronous fchown(2) - Change ownership of a file.
     * @param fd A file descriptor.
     */
    function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace fchown {
        /**
         * Asynchronous fchown(2) - Change ownership of a file.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;
    }

    /**
     * Synchronous fchown(2) - Change ownership of a file.
     * @param fd A file descriptor.
     */
    function fchownSync(fd: number, uid: number, gid: number): void;

    /**
     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace lchown {
        /**
         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }

    /**
     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function lchownSync(path: PathLike, uid: number, gid: number): void;

    /**
     * Changes the access and modification times of a file in the same way as `fs.utimes()`,
     * with the difference that if the path refers to a symbolic link, then the link is not
     * dereferenced: instead, the timestamps of the symbolic link itself are changed.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param atime The last access time. If a string is provided, it will be coerced to number.
     * @param mtime The last modified time. If a string is provided, it will be coerced to number.
     */
    function lutimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace lutimes {
        /**
         * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
         * with the difference that if the path refers to a symbolic link, then the link is not
         * dereferenced: instead, the timestamps of the symbolic link itself are changed.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;
    }

    /**
     * Change the file system timestamps of the symbolic link referenced by `path`. Returns `undefined`,
     * or throws an exception when parameters are incorrect or the operation fails.
     * This is the synchronous version of `fs.lutimes()`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param atime The last access time. If a string is provided, it will be coerced to number.
     * @param mtime The last modified time. If a string is provided, it will be coerced to number.
     */
    function lutimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;

    /**
     * Asynchronous chmod(2) - Change permissions of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
     */
    function chmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace chmod {
        /**
         * Asynchronous chmod(2) - Change permissions of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(path: PathLike, mode: string | number): Promise<void>;
    }

    /**
     * Synchronous chmod(2) - Change permissions of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
     */
    function chmodSync(path: PathLike, mode: string | number): void;

    /**
     * Asynchronous fchmod(2) - Change permissions of a file.
     * @param fd A file descriptor.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
     */
    function fchmod(fd: number, mode: string | number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace fchmod {
        /**
         * Asynchronous fchmod(2) - Change permissions of a file.
         * @param fd A file descriptor.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(fd: number, mode: string | number): Promise<void>;
    }

    /**
     * Synchronous fchmod(2) - Change permissions of a file.
     * @param fd A file descriptor.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
     */
    function fchmodSync(fd: number, mode: string | number): void;

    /**
     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
     */
    function lchmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace lchmod {
        /**
         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(path: PathLike, mode: string | number): Promise<void>;
    }

    /**
     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
     */
    function lchmodSync(path: PathLike, mode: string | number): void;

    /**
     * Asynchronous stat(2) - Get file status.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    function stat(path: PathLike, options: StatOptions & { bigint?: false | undefined } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    function stat(path: PathLike, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;
    function stat(path: PathLike, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace stat {
        /**
         * Asynchronous stat(2) - Get file status.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, options?: StatOptions & { bigint?: false | undefined }): Promise<Stats>;
        function __promisify__(path: PathLike, options: StatOptions & { bigint: true }): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }

    /**
     * Synchronous stat(2) - Get file status.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function statSync(path: PathLike, options?: StatOptions & { bigint?: false | undefined }): Stats;
    function statSync(path: PathLike, options: StatOptions & { bigint: true }): BigIntStats;
    function statSync(path: PathLike, options?: StatOptions): Stats | BigIntStats;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace fstat {
        /**
         * Asynchronous fstat(2) - Get file status.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number, options?: StatOptions & { bigint?: false | undefined }): Promise<Stats>;
        function __promisify__(fd: number, options: StatOptions & { bigint: true }): Promise<BigIntStats>;
        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;
    }

    /**
     * Synchronous fstat(2) - Get file status.
     * @param fd A file descriptor.
     */
    function fstatSync(fd: number, options?: StatOptions & { bigint?: false | undefined }): Stats;
    function fstatSync(fd: number, options: StatOptions & { bigint: true }): BigIntStats;
    function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;

    /**
     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    function lstat(path: PathLike, options: StatOptions & { bigint?: false | undefined } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    function lstat(path: PathLike, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;
    function lstat(path: PathLike, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace lstat {
        /**
         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, options?: StatOptions & { bigint?: false | undefined }): Promise<Stats>;
        function __promisify__(path: PathLike, options: StatOptions & { bigint: true }): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }

    /**
     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function lstatSync(path: PathLike, options?: StatOptions & { bigint?: false | undefined }): Stats;
    function lstatSync(path: PathLike, options: StatOptions & { bigint: true }): BigIntStats;
    function lstatSync(path: PathLike, options?: StatOptions): Stats | BigIntStats;

    /**
     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace link {
        /**
         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;
    }

    /**
     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.
     * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function linkSync(existingPath: PathLike, newPath: PathLike): void;

    /**
     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
     */
    function symlink(target: PathLike, path: PathLike, type: symlink.Type | undefined | null, callback: NoParamCallback): void;

    /**
     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
     */
    function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace symlink {
        /**
         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
         */
        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;

        type Type = "dir" | "file" | "junction";
    }

    /**
     * Synchronous symlink(2) - Create a new symbolic link to an existing file.
     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
     * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
     * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
     */
    function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;

    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlink(
        path: PathLike,
        options: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void
    ): void;

    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlink(path: PathLike, options: { encoding: "buffer" } | "buffer", callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void): void;

    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlink(
        path: PathLike,
        options: { encoding?: string | null | undefined } | string | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void
    ): void;

    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException | null, linkString: string) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace readlink {
        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): Promise<string>;

        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;

        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: { encoding?: string | null | undefined } | string | null): Promise<string | Buffer>;
    }

    /**
     * Synchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): string;

    /**
     * Synchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlinkSync(path: PathLike, options: { encoding: "buffer" } | "buffer"): Buffer;

    /**
     * Synchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readlinkSync(path: PathLike, options?: { encoding?: string | null | undefined } | string | null): string | Buffer;

    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpath(
        path: PathLike,
        options: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void
    ): void;

    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpath(path: PathLike, options: { encoding: "buffer" } | "buffer", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;

    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpath(
        path: PathLike,
        options: { encoding?: string | null | undefined } | string | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void
    ): void;

    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace realpath {
        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): Promise<string>;

        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;

        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: { encoding?: string | null | undefined } | string | null): Promise<string | Buffer>;

        function native(
            path: PathLike,
            options: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | undefined | null,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void
        ): void;
        function native(path: PathLike, options: { encoding: "buffer" } | "buffer", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;
        function native(
            path: PathLike,
            options: { encoding?: string | null | undefined } | string | undefined | null,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void
        ): void;
        function native(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;
    }

    /**
     * Synchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): string;

    /**
     * Synchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpathSync(path: PathLike, options: { encoding: "buffer" } | "buffer"): Buffer;

    /**
     * Synchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function realpathSync(path: PathLike, options?: { encoding?: string | null | undefined } | string | null): string | Buffer;

    namespace realpathSync {
        function native(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): string;
        function native(path: PathLike, options: { encoding: "buffer" } | "buffer"): Buffer;
        function native(path: PathLike, options?: { encoding?: string | null | undefined } | string | null): string | Buffer;
    }

    /**
     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function unlink(path: PathLike, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace unlink {
        /**
         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike): Promise<void>;
    }

    /**
     * Synchronous unlink(2) - delete a name and possibly the file it refers to.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function unlinkSync(path: PathLike): void;

    interface RmDirOptions {
        /**
         * If an `EBUSY`, `ENOTEMPTY`, or `EPERM` error is
         * encountered, Node.js will retry the operation with a linear backoff wait of
         * 100ms longer on each try. This option represents the number of retries. This
         * option is ignored if the `recursive` option is not `true`.
         * @default 3
         */
        maxRetries?: number | undefined;
        /**
         * If `true`, perform a recursive directory removal. In
         * recursive mode, errors are not reported if `path` does not exist, and
         * operations are retried on failure.
         * @experimental
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * If an `EMFILE` error is encountered, Node.js will
         * retry the operation with a linear backoff of 1ms longer on each try until the
         * timeout duration passes this limit. This option is ignored if the `recursive`
         * option is not `true`.
         * @default 1000
         */
        emfileWait?: number | undefined;
    }

    /**
     * Asynchronous rmdir(2) - delete a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function rmdir(path: PathLike, callback: NoParamCallback): void;
    function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace rmdir {
        /**
         * Asynchronous rmdir(2) - delete a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;
    }

    /**
     * Synchronous rmdir(2) - delete a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function rmdirSync(path: PathLike, options?: RmDirOptions): void;

    interface MakeDirectoryOptions {
        /**
         * Indicates whether parent folders should be created.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified
         * @default 0o777.
         */
        mode?: number | string | undefined;
    }

    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    function mkdir(path: PathLike, options: number | string | MakeDirectoryOptions | undefined | null, callback: NoParamCallback): void;

    /**
     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function mkdir(path: PathLike, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace mkdir {
        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function __promisify__(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<void>;
    }

    /**
     * Synchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    function mkdirSync(path: PathLike, options?: number | string | MakeDirectoryOptions | null): void;

    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtemp(
        prefix: string,
        options: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, folder: string) => void
    ): void;

    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtemp(prefix: string, options: "buffer" | { encoding: "buffer" }, callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void): void;

    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtemp(
        prefix: string,
        options: { encoding?: string | null | undefined } | string | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void
    ): void;

    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     */
    function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException | null, folder: string) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace mkdtemp {
        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): Promise<string>;

        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;

        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options?: { encoding?: string | null | undefined } | string | null): Promise<string | Buffer>;
    }

    /**
     * Synchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): string;

    /**
     * Synchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtempSync(prefix: string, options: { encoding: "buffer" } | "buffer"): Buffer;

    /**
     * Synchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function mkdtempSync(prefix: string, options?: { encoding?: string | null | undefined } | string | null): string | Buffer;

    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdir(
        path: PathLike,
        options: { encoding: BufferEncoding | null; withFileTypes?: false | undefined } | BufferEncoding | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
    ): void;

    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdir(path: PathLike, options: { encoding: "buffer"; withFileTypes?: false | undefined } | "buffer", callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void): void;

    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdir(
        path: PathLike,
        options: { encoding?: string | null | undefined; withFileTypes?: false | undefined } | string | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,
    ): void;

    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException | null, files: string[]) => void): void;

    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    function readdir(path: PathLike, options: { encoding?: string | null | undefined; withFileTypes: true }, callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace readdir {
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false | undefined } | BufferEncoding | null): Promise<string[]>;

        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options: "buffer" | { encoding: "buffer"; withFileTypes?: false | undefined }): Promise<Buffer[]>;

        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: { encoding?: string | null | undefined; withFileTypes?: false | undefined } | string | null): Promise<string[] | Buffer[]>;

        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent
         */
        function __promisify__(path: PathLike, options: { encoding?: string | null | undefined; withFileTypes: true }): Promise<Dirent[]>;
    }

    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false | undefined } | BufferEncoding | null): string[];

    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdirSync(path: PathLike, options: { encoding: "buffer"; withFileTypes?: false | undefined } | "buffer"): Buffer[];

    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    function readdirSync(path: PathLike, options?: { encoding?: string | null | undefined; withFileTypes?: false | undefined } | string | null): string[] | Buffer[];

    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    function readdirSync(path: PathLike, options: { encoding?: string | null | undefined; withFileTypes: true }): Dirent[];

    /**
     * Asynchronous close(2) - close a file descriptor.
     * @param fd A file descriptor.
     */
    function close(fd: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace close {
        /**
         * Asynchronous close(2) - close a file descriptor.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }

    /**
     * Synchronous close(2) - close a file descriptor.
     * @param fd A file descriptor.
     */
    function closeSync(fd: number): void;

    /**
     * Asynchronous open(2) - open and possibly create a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
     */
    function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;

    /**
     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace open {
        /**
         * Asynchronous open(2) - open and possibly create a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
         */
        function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;
    }

    /**
     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
     */
    function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;

    /**
     * Asynchronously change file timestamps of the file referenced by the supplied path.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param atime The last access time. If a string is provided, it will be coerced to number.
     * @param mtime The last modified time. If a string is provided, it will be coerced to number.
     */
    function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace utimes {
        /**
         * Asynchronously change file timestamps of the file referenced by the supplied path.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;
    }

    /**
     * Synchronously change file timestamps of the file referenced by the supplied path.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param atime The last access time. If a string is provided, it will be coerced to number.
     * @param mtime The last modified time. If a string is provided, it will be coerced to number.
     */
    function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;

    /**
     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param atime The last access time. If a string is provided, it will be coerced to number.
     * @param mtime The last modified time. If a string is provided, it will be coerced to number.
     */
    function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace futimes {
        /**
         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;
    }

    /**
     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param atime The last access time. If a string is provided, it will be coerced to number.
     * @param mtime The last modified time. If a string is provided, it will be coerced to number.
     */
    function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;

    /**
     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
     * @param fd A file descriptor.
     */
    function fsync(fd: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace fsync {
        /**
         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }

    /**
     * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
     * @param fd A file descriptor.
     */
    function fsyncSync(fd: number): void;

    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     */
    function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        position: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;

    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
     */
    function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;

    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     */
    function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void
    ): void;

    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     */
    function write<TBuffer extends NodeJS.ArrayBufferView>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void): void;

    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     * @param encoding The expected string encoding.
     */
    function write(
        fd: number,
        string: any,
        position: number | undefined | null,
        encoding: string | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
    ): void;

    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     */
    function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;

    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.
     */
    function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace write {
        /**
         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         */
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer?: TBuffer,
            offset?: number,
            length?: number,
            position?: number | null,
        ): Promise<{ bytesWritten: number, buffer: TBuffer }>;

        /**
         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         * @param encoding The expected string encoding.
         */
        function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;
    }

    /**
     * Synchronously writes `buffer` to the file referenced by the supplied file descriptor, returning the number of bytes written.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     */
    function writeSync(fd: number, buffer: NodeJS.ArrayBufferView, offset?: number | null, length?: number | null, position?: number | null): number;

    /**
     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
     * @param fd A file descriptor.
     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     * @param encoding The expected string encoding.
     */
    function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;

    /**
     * Asynchronously reads data from the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param buffer The buffer that the data will be written to.
     * @param offset The offset in the buffer at which to start writing.
     * @param length The number of bytes to read.
     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
     */
    function read<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number,
        length: number,
        position: number | null,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
    ): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace read {
        /**
         * @param fd A file descriptor.
         * @param buffer The buffer that the data will be written to.
         * @param offset The offset in the buffer at which to start writing.
         * @param length The number of bytes to read.
         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
         */
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer: TBuffer,
            offset: number,
            length: number,
            position: number | null
        ): Promise<{ bytesRead: number, buffer: TBuffer }>;
    }

    /**
     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.
     * @param fd A file descriptor.
     * @param buffer The buffer that the data will be written to.
     * @param offset The offset in the buffer at which to start writing.
     * @param length The number of bytes to read.
     * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
     */
    function readSync(fd: number, buffer: NodeJS.ArrayBufferView, offset: number, length: number, position: number | null): number;

    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options An object that may contain an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    function readFile(
        path: PathLike | number,
        options: { encoding?: null | undefined; flag?: string | undefined; } | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void
    ): void;

    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    function readFile(path: PathLike | number, options: { encoding: string; flag?: string | undefined; } | string, callback: (err: NodeJS.ErrnoException | null, data: string) => void): void;

    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    function readFile(
        path: PathLike | number,
        options: { encoding?: string | null | undefined; flag?: string | undefined; } | string | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, data: string | Buffer) => void,
    ): void;

    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     */
    function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace readFile {
        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(path: PathLike | number, options?: { encoding?: null | undefined; flag?: string | undefined; } | null): Promise<Buffer>;

        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string | undefined; } | string): Promise<string>;

        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(path: PathLike | number, options?: { encoding?: string | null | undefined; flag?: string | undefined; } | string | null): Promise<string | Buffer>;
    }

    /**
     * Synchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to `'r'`.
     */
    function readFileSync(path: PathLike | number, options?: { encoding?: null | undefined; flag?: string | undefined; } | null): Buffer;

    /**
     * Synchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string | undefined; } | string): string;

    /**
     * Synchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    function readFileSync(path: PathLike | number, options?: { encoding?: string | null | undefined; flag?: string | undefined; } | string | null): string | Buffer;

    type WriteFileOptions = { encoding?: string | null | undefined; mode?: number | string | undefined; flag?: string | undefined; } | string | null;

    /**
     * Asynchronously writes data to a file, replacing the file if it already exists.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `mode` is not supplied, the default of `0o666` is used.
     * If `mode` is a string, it is parsed as an octal integer.
     * If `flag` is not supplied, the default of `'w'` is used.
     */
    function writeFile(path: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;

    /**
     * Asynchronously writes data to a file, replacing the file if it already exists.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     */
    function writeFile(path: PathLike | number, data: any, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace writeFile {
        /**
         * Asynchronously writes data to a file, replacing the file if it already exists.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'w'` is used.
         */
        function __promisify__(path: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;
    }

    /**
     * Synchronously writes data to a file, replacing the file if it already exists.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `mode` is not supplied, the default of `0o666` is used.
     * If `mode` is a string, it is parsed as an octal integer.
     * If `flag` is not supplied, the default of `'w'` is used.
     */
    function writeFileSync(path: PathLike | number, data: any, options?: WriteFileOptions): void;

    /**
     * Asynchronously append data to a file, creating the file if it does not exist.
     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `mode` is not supplied, the default of `0o666` is used.
     * If `mode` is a string, it is parsed as an octal integer.
     * If `flag` is not supplied, the default of `'a'` is used.
     */
    function appendFile(file: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;

    /**
     * Asynchronously append data to a file, creating the file if it does not exist.
     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     */
    function appendFile(file: PathLike | number, data: any, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace appendFile {
        /**
         * Asynchronously append data to a file, creating the file if it does not exist.
         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'a'` is used.
         */
        function __promisify__(file: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;
    }

    /**
     * Synchronously append data to a file, creating the file if it does not exist.
     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `mode` is not supplied, the default of `0o666` is used.
     * If `mode` is a string, it is parsed as an octal integer.
     * If `flag` is not supplied, the default of `'a'` is used.
     */
    function appendFileSync(file: PathLike | number, data: any, options?: WriteFileOptions): void;

    /**
     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
     */
    function watchFile(filename: PathLike, options: { persistent?: boolean | undefined; interval?: number | undefined; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;

    /**
     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;

    /**
     * Stop watching for changes on `filename`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;

    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */
    function watch(
        filename: PathLike,
        options: { encoding?: BufferEncoding | null | undefined, persistent?: boolean | undefined, recursive?: boolean | undefined } | BufferEncoding | undefined | null,
        listener?: (event: string, filename: string) => void,
    ): FSWatcher;

    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */
    function watch(
        filename: PathLike,
        options: { encoding: "buffer", persistent?: boolean | undefined, recursive?: boolean | undefined } | "buffer",
        listener?: (event: string, filename: Buffer) => void
    ): FSWatcher;

    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
     * If `encoding` is not supplied, the default of `'utf8'` is used.
     * If `persistent` is not supplied, the default of `true` is used.
     * If `recursive` is not supplied, the default of `false` is used.
     */
    function watch(
        filename: PathLike,
        options: { encoding?: string | null | undefined, persistent?: boolean | undefined, recursive?: boolean | undefined } | string | null,
        listener?: (event: string, filename: string | Buffer) => void,
    ): FSWatcher;

    /**
     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;

    /**
     * Asynchronously tests whether or not the given path exists by checking with the file system.
     * @deprecated
     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function exists(path: PathLike, callback: (exists: boolean) => void): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace exists {
        /**
         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(path: PathLike): Promise<boolean>;
    }

    /**
     * Synchronously tests whether or not the given path exists by checking with the file system.
     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function existsSync(path: PathLike): boolean;

    namespace constants {
        // File Access Constants

        /** Constant for fs.access(). File is visible to the calling process. */
        const F_OK: number;

        /** Constant for fs.access(). File can be read by the calling process. */
        const R_OK: number;

        /** Constant for fs.access(). File can be written by the calling process. */
        const W_OK: number;

        /** Constant for fs.access(). File can be executed by the calling process. */
        const X_OK: number;

        // File Copy Constants

        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */
        const COPYFILE_EXCL: number;

        /**
         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
         */
        const COPYFILE_FICLONE: number;

        /**
         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.
         */
        const COPYFILE_FICLONE_FORCE: number;

        // File Open Constants

        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */
        const O_RDONLY: number;

        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */
        const O_WRONLY: number;

        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */
        const O_RDWR: number;

        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */
        const O_CREAT: number;

        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */
        const O_EXCL: number;

        /**
         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,
         * opening the path shall not cause that terminal to become the controlling terminal for the process
         * (if the process does not already have one).
         */
        const O_NOCTTY: number;

        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */
        const O_TRUNC: number;

        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */
        const O_APPEND: number;

        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */
        const O_DIRECTORY: number;

        /**
         * constant for fs.open().
         * Flag indicating reading accesses to the file system will no longer result in
         * an update to the atime information associated with the file.
         * This flag is available on Linux operating systems only.
         */
        const O_NOATIME: number;

        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */
        const O_NOFOLLOW: number;

        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */
        const O_SYNC: number;

        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */
        const O_DSYNC: number;

        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */
        const O_SYMLINK: number;

        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */
        const O_DIRECT: number;

        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */
        const O_NONBLOCK: number;

        // File Type Constants

        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */
        const S_IFMT: number;

        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */
        const S_IFREG: number;

        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */
        const S_IFDIR: number;

        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */
        const S_IFCHR: number;

        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */
        const S_IFBLK: number;

        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */
        const S_IFIFO: number;

        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */
        const S_IFLNK: number;

        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */
        const S_IFSOCK: number;

        // File Mode Constants

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */
        const S_IRWXU: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */
        const S_IRUSR: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */
        const S_IWUSR: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */
        const S_IXUSR: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */
        const S_IRWXG: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */
        const S_IRGRP: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */
        const S_IWGRP: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */
        const S_IXGRP: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */
        const S_IRWXO: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */
        const S_IROTH: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */
        const S_IWOTH: number;

        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */
        const S_IXOTH: number;

        /**
         * When set, a memory file mapping is used to access the file. This flag
         * is available on Windows operating systems only. On other operating systems,
         * this flag is ignored.
         */
        const UV_FS_O_FILEMAP: number;
    }

    /**
     * Asynchronously tests a user's permissions for the file specified by path.
     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;

    /**
     * Asynchronously tests a user's permissions for the file specified by path.
     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function access(path: PathLike, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace access {
        /**
         * Asynchronously tests a user's permissions for the file specified by path.
         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(path: PathLike, mode?: number): Promise<void>;
    }

    /**
     * Synchronously tests a user's permissions for the file specified by path.
     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function accessSync(path: PathLike, mode?: number): void;

    /**
     * Returns a new `ReadStream` object.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function createReadStream(path: PathLike, options?: string | {
        flags?: string | undefined;
        encoding?: string | undefined;
        fd?: number | undefined;
        mode?: number | undefined;
        autoClose?: boolean | undefined;
        /**
         * @default false
         */
        emitClose?: boolean | undefined;
        start?: number | undefined;
        end?: number | undefined;
        highWaterMark?: number | undefined;
    }): ReadStream;

    /**
     * Returns a new `WriteStream` object.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * URL support is _experimental_.
     */
    function createWriteStream(path: PathLike, options?: string | {
        flags?: string | undefined;
        encoding?: string | undefined;
        fd?: number | undefined;
        mode?: number | undefined;
        autoClose?: boolean | undefined;
        emitClose?: boolean | undefined;
        start?: number | undefined;
        highWaterMark?: number | undefined;
    }): WriteStream;

    /**
     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
     * @param fd A file descriptor.
     */
    function fdatasync(fd: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace fdatasync {
        /**
         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }

    /**
     * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.
     * @param fd A file descriptor.
     */
    function fdatasyncSync(fd: number): void;

    /**
     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
     * No arguments other than a possible exception are given to the callback function.
     * Node.js makes no guarantees about the atomicity of the copy operation.
     * If an error occurs after the destination file has been opened for writing, Node.js will attempt
     * to remove the destination.
     * @param src A path to the source file.
     * @param dest A path to the destination file.
     */
    function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;
    /**
     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
     * No arguments other than a possible exception are given to the callback function.
     * Node.js makes no guarantees about the atomicity of the copy operation.
     * If an error occurs after the destination file has been opened for writing, Node.js will attempt
     * to remove the destination.
     * @param src A path to the source file.
     * @param dest A path to the destination file.
     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.
     */
    function copyFile(src: PathLike, dest: PathLike, flags: number, callback: NoParamCallback): void;

    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.
    namespace copyFile {
        /**
         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.
         * No arguments other than a possible exception are given to the callback function.
         * Node.js makes no guarantees about the atomicity of the copy operation.
         * If an error occurs after the destination file has been opened for writing, Node.js will attempt
         * to remove the destination.
         * @param src A path to the source file.
         * @param dest A path to the destination file.
         * @param flags An optional integer that specifies the behavior of the copy operation.
         * The only supported flag is fs.constants.COPYFILE_EXCL,
         * which causes the copy operation to fail if dest already exists.
         */
        function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;
    }

    /**
     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.
     * Node.js makes no guarantees about the atomicity of the copy operation.
     * If an error occurs after the destination file has been opened for writing, Node.js will attempt
     * to remove the destination.
     * @param src A path to the source file.
     * @param dest A path to the destination file.
     * @param flags An optional integer that specifies the behavior of the copy operation.
     * The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.
     */
    function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;

    /**
     * Write an array of ArrayBufferViews to the file specified by fd using writev().
     * position is the offset from the beginning of the file where this data should be written.
     * It is unsafe to use fs.writev() multiple times on the same file without waiting for the callback. For this scenario, use fs.createWriteStream().
     * On Linux, positional writes don't work when the file is opened in append mode.
     * The kernel ignores the position argument and always appends the data to the end of the file.
     */
    function writev(
        fd: number,
        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,
        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void
    ): void;
    function writev(
        fd: number,
        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,
        position: number,
        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void
    ): void;

    interface WriteVResult {
        bytesWritten: number;
        buffers: NodeJS.ArrayBufferView[];
    }

    namespace writev {
        function __promisify__(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<WriteVResult>;
    }

    /**
     * See `writev`.
     */
    function writevSync(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): number;

    interface OpenDirOptions {
        encoding?: BufferEncoding | undefined;
    }

    function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;

    function opendir(path: PathLike, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;
    function opendir(path: PathLike, options: OpenDirOptions, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;

    namespace opendir {
        function __promisify__(path: PathLike, options?: OpenDirOptions): Promise<Dir>;
    }

    namespace promises {
        interface FileHandle {
            /**
             * Gets the file descriptor for this file handle.
             */
            readonly fd: number;

            /**
             * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.
             * The `FileHandle` must have been opened for appending.
             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
             * If `encoding` is not supplied, the default of `'utf8'` is used.
             * If `mode` is not supplied, the default of `0o666` is used.
             * If `mode` is a string, it is parsed as an octal integer.
             * If `flag` is not supplied, the default of `'a'` is used.
             */
            appendFile(data: any, options?: { encoding?: string | null | undefined, mode?: string | number | undefined, flag?: string | number | undefined } | string | null): Promise<void>;

            /**
             * Asynchronous fchown(2) - Change ownership of a file.
             */
            chown(uid: number, gid: number): Promise<void>;

            /**
             * Asynchronous fchmod(2) - Change permissions of a file.
             * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
             */
            chmod(mode: string | number): Promise<void>;

            /**
             * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
             */
            datasync(): Promise<void>;

            /**
             * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
             */
            sync(): Promise<void>;

            /**
             * Asynchronously reads data from the file.
             * The `FileHandle` must have been opened for reading.
             * @param buffer The buffer that the data will be written to.
             * @param offset The offset in the buffer at which to start writing.
             * @param length The number of bytes to read.
             * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
             */
            read<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;

            /**
             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
             * The `FileHandle` must have been opened for reading.
             * @param options An object that may contain an optional flag.
             * If a flag is not provided, it defaults to `'r'`.
             */
            readFile(options?: { encoding?: null | undefined, flag?: string | number | undefined } | null): Promise<Buffer>;

            /**
             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
             * The `FileHandle` must have been opened for reading.
             * @param options An object that may contain an optional flag.
             * If a flag is not provided, it defaults to `'r'`.
             */
            readFile(options: { encoding: BufferEncoding, flag?: string | number | undefined } | BufferEncoding): Promise<string>;

            /**
             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.
             * The `FileHandle` must have been opened for reading.
             * @param options An object that may contain an optional flag.
             * If a flag is not provided, it defaults to `'r'`.
             */
            readFile(options?: { encoding?: string | null | undefined, flag?: string | number | undefined } | string | null): Promise<string | Buffer>;

            /**
             * Asynchronous fstat(2) - Get file status.
             */
            stat(opts?: StatOptions & { bigint?: false | undefined }): Promise<Stats>;
            stat(opts: StatOptions & { bigint: true }): Promise<BigIntStats>;
            stat(opts: StatOptions): Promise<Stats | BigIntStats>;

            /**
             * Asynchronous ftruncate(2) - Truncate a file to a specified length.
             * @param len If not specified, defaults to `0`.
             */
            truncate(len?: number): Promise<void>;

            /**
             * Asynchronously change file timestamps of the file.
             * @param atime The last access time. If a string is provided, it will be coerced to number.
             * @param mtime The last modified time. If a string is provided, it will be coerced to number.
             */
            utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void>;

            /**
             * Asynchronously writes `buffer` to the file.
             * The `FileHandle` must have been opened for writing.
             * @param buffer The buffer that the data will be written to.
             * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
             * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
             */
            write<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;

            /**
             * Asynchronously writes `string` to the file.
             * The `FileHandle` must have been opened for writing.
             * It is unsafe to call `write()` multiple times on the same file without waiting for the `Promise`
             * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.
             * @param string A string to write. If something other than a string is supplied it will be coerced to a string.
             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
             * @param encoding The expected string encoding.
             */
            write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;

            /**
             * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.
             * The `FileHandle` must have been opened for writing.
             * It is unsafe to call `writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).
             * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
             * If `encoding` is not supplied, the default of `'utf8'` is used.
             * If `mode` is not supplied, the default of `0o666` is used.
             * If `mode` is a string, it is parsed as an octal integer.
             * If `flag` is not supplied, the default of `'w'` is used.
             */
            writeFile(data: any, options?: { encoding?: string | null | undefined, mode?: string | number | undefined, flag?: string | number | undefined } | string | null): Promise<void>;

            /**
             * See `fs.writev` promisified version.
             */
            writev(buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<WriteVResult>;

            /**
             * Asynchronous close(2) - close a `FileHandle`.
             */
            close(): Promise<void>;
        }

        /**
         * Asynchronously tests a user's permissions for the file specified by path.
         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function access(path: PathLike, mode?: number): Promise<void>;

        /**
         * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it already exists.
         * Node.js makes no guarantees about the atomicity of the copy operation.
         * If an error occurs after the destination file has been opened for writing, Node.js will attempt
         * to remove the destination.
         * @param src A path to the source file.
         * @param dest A path to the destination file.
         * @param flags An optional integer that specifies the behavior of the copy operation. The only
         * supported flag is `fs.constants.COPYFILE_EXCL`, which causes the copy operation to fail if
         * `dest` already exists.
         */
        function copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;

        /**
         * Asynchronous open(2) - open and possibly create a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not
         * supplied, defaults to `0o666`.
         */
        function open(path: PathLike, flags: string | number, mode?: string | number): Promise<FileHandle>;

        /**
         * Asynchronously reads data from the file referenced by the supplied `FileHandle`.
         * @param handle A `FileHandle`.
         * @param buffer The buffer that the data will be written to.
         * @param offset The offset in the buffer at which to start writing.
         * @param length The number of bytes to read.
         * @param position The offset from the beginning of the file from which data should be read. If
         * `null`, data will be read from the current position.
         */
        function read<TBuffer extends Uint8Array>(
            handle: FileHandle,
            buffer: TBuffer,
            offset?: number | null,
            length?: number | null,
            position?: number | null,
        ): Promise<{ bytesRead: number, buffer: TBuffer }>;

        /**
         * Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`.
         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`
         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.
         * @param handle A `FileHandle`.
         * @param buffer The buffer that the data will be written to.
         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         */
        function write<TBuffer extends Uint8Array>(
            handle: FileHandle,
            buffer: TBuffer,
            offset?: number | null,
            length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;

        /**
         * Asynchronously writes `string` to the file referenced by the supplied `FileHandle`.
         * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`
         * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.
         * @param handle A `FileHandle`.
         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         * @param encoding The expected string encoding.
         */
        function write(handle: FileHandle, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;

        /**
         * Asynchronous rename(2) - Change the name or location of a file or directory.
         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;

        /**
         * Asynchronous truncate(2) - Truncate a file to a specified length.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param len If not specified, defaults to `0`.
         */
        function truncate(path: PathLike, len?: number): Promise<void>;

        /**
         * Asynchronous ftruncate(2) - Truncate a file to a specified length.
         * @param handle A `FileHandle`.
         * @param len If not specified, defaults to `0`.
         */
        function ftruncate(handle: FileHandle, len?: number): Promise<void>;

        /**
         * Asynchronous rmdir(2) - delete a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function rmdir(path: PathLike, options?: RmDirOptions): Promise<void>;

        /**
         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
         * @param handle A `FileHandle`.
         */
        function fdatasync(handle: FileHandle): Promise<void>;

        /**
         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
         * @param handle A `FileHandle`.
         */
        function fsync(handle: FileHandle): Promise<void>;

        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function mkdir(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<void>;

        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function readdir(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined; withFileTypes?: false | undefined } | BufferEncoding | null): Promise<string[]>;

        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function readdir(path: PathLike, options: { encoding: "buffer"; withFileTypes?: false | undefined } | "buffer"): Promise<Buffer[]>;

        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function readdir(path: PathLike, options?: { encoding?: string | null | undefined; withFileTypes?: false | undefined } | string | null): Promise<string[] | Buffer[]>;

        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
         */
        function readdir(path: PathLike, options: { encoding?: string | null | undefined; withFileTypes: true }): Promise<Dirent[]>;

        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function readlink(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): Promise<string>;

        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function readlink(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;

        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function readlink(path: PathLike, options?: { encoding?: string | null | undefined } | string | null): Promise<string | Buffer>;

        /**
         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
         */
        function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;

        /**
         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function lstat(path: PathLike, opts?: StatOptions & { bigint?: false | undefined }): Promise<Stats>;
        function lstat(path: PathLike, opts: StatOptions & { bigint: true }): Promise<BigIntStats>;
        function lstat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;

        /**
         * Asynchronous stat(2) - Get file status.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function stat(path: PathLike, opts?: StatOptions & { bigint?: false | undefined }): Promise<Stats>;
        function stat(path: PathLike, opts: StatOptions & { bigint: true }): Promise<BigIntStats>;
        function stat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;

        /**
         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;

        /**
         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function unlink(path: PathLike): Promise<void>;

        /**
         * Asynchronous fchmod(2) - Change permissions of a file.
         * @param handle A `FileHandle`.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function fchmod(handle: FileHandle, mode: string | number): Promise<void>;

        /**
         * Asynchronous chmod(2) - Change permissions of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function chmod(path: PathLike, mode: string | number): Promise<void>;

        /**
         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function lchmod(path: PathLike, mode: string | number): Promise<void>;

        /**
         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function lchown(path: PathLike, uid: number, gid: number): Promise<void>;

        /**
         * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
         * with the difference that if the path refers to a symbolic link, then the link is not
         * dereferenced: instead, the timestamps of the symbolic link itself are changed.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function lutimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;

        /**
         * Asynchronous fchown(2) - Change ownership of a file.
         * @param handle A `FileHandle`.
         */
        function fchown(handle: FileHandle, uid: number, gid: number): Promise<void>;

        /**
         * Asynchronous chown(2) - Change ownership of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function chown(path: PathLike, uid: number, gid: number): Promise<void>;

        /**
         * Asynchronously change file timestamps of the file referenced by the supplied path.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;

        /**
         * Asynchronously change file timestamps of the file referenced by the supplied `FileHandle`.
         * @param handle A `FileHandle`.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function futimes(handle: FileHandle, atime: string | number | Date, mtime: string | number | Date): Promise<void>;

        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function realpath(path: PathLike, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): Promise<string>;

        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function realpath(path: PathLike, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;

        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function realpath(path: PathLike, options?: { encoding?: string | null | undefined } | string | null): Promise<string | Buffer>;

        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function mkdtemp(prefix: string, options?: { encoding?: BufferEncoding | null | undefined } | BufferEncoding | null): Promise<string>;

        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function mkdtemp(prefix: string, options: { encoding: "buffer" } | "buffer"): Promise<Buffer>;

        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function mkdtemp(prefix: string, options?: { encoding?: string | null | undefined } | string | null): Promise<string | Buffer>;

        /**
         * Asynchronously writes data to a file, replacing the file if it already exists.
         * It is unsafe to call `fsPromises.writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'w'` is used.
         */
        function writeFile(
            path: PathLike | FileHandle,
            data: any,
            options?: { encoding?: string | null | undefined, mode?: string | number | undefined, flag?: string | number | undefined } | string | null
        ): Promise<void>;

        /**
         * Asynchronously append data to a file, creating the file if it does not exist.
         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'a'` is used.
         */
        function appendFile(
            path: PathLike | FileHandle,
            data: any,
            options?: { encoding?: string | null | undefined, mode?: string | number | undefined, flag?: string | number | undefined } | string | null
        ): Promise<void>;

        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function readFile(path: PathLike | FileHandle, options?: { encoding?: null | undefined, flag?: string | number | undefined } | null): Promise<Buffer>;

        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function readFile(path: PathLike | FileHandle, options: { encoding: BufferEncoding, flag?: string | number | undefined } | BufferEncoding): Promise<string>;

        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function readFile(path: PathLike | FileHandle, options?: { encoding?: string | null | undefined, flag?: string | number | undefined } | string | null): Promise<string | Buffer>;

        function opendir(path: PathLike, options?: OpenDirOptions): Promise<Dir>;
    }

    interface BigIntStats extends StatsBase<bigint> {
    }

    class BigIntStats {
        atimeNs: bigint;
        mtimeNs: bigint;
        ctimeNs: bigint;
        birthtimeNs: bigint;
    }

    interface BigIntOptions {
        bigint: true;
    }

    interface StatOptions {
        bigint: boolean;
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // tslint:disable-next-line:dt-header
// Type definitions for inspector

// These definitions are auto-generated.
// Please see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/19330
// for more information.

// tslint:disable:max-line-length

/**
 * The inspector module provides an API for interacting with the V8 inspector.
 */
declare module 'inspector' {
    import EventEmitter = require('events');

    interface InspectorNotification<T> {
        method: string;
        params: T;
    }

    namespace Schema {
        /**
         * Description of the protocol domain.
         */
        interface Domain {
            /**
             * Domain name.
             */
            name: string;
            /**
             * Domain version.
             */
            version: string;
        }

        interface GetDomainsReturnType {
            /**
             * List of supported domains.
             */
            domains: Domain[];
        }
    }

    namespace Runtime {
        /**
         * Unique script identifier.
         */
        type ScriptId = string;

        /**
         * Unique object identifier.
         */
        type RemoteObjectId = string;

        /**
         * Primitive value which cannot be JSON-stringified.
         */
        type UnserializableValue = string;

        /**
         * Mirror object referencing original JavaScript object.
         */
        interface RemoteObject {
            /**
             * Object type.
             */
            type: string;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
            /**
             * Object class (constructor) name. Specified for <code>object</code> type values only.
             */
            className?: string | undefined;
            /**
             * Remote object value in case of primitive values or JSON values (if it was requested).
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property.
             */
            unserializableValue?: UnserializableValue | undefined;
            /**
             * String representation of the object.
             */
            description?: string | undefined;
            /**
             * Unique object identifier (for non-primitive values).
             */
            objectId?: RemoteObjectId | undefined;
            /**
             * Preview containing abbreviated property values. Specified for <code>object</code> type values only.
             * @experimental
             */
            preview?: ObjectPreview | undefined;
            /**
             * @experimental
             */
            customPreview?: CustomPreview | undefined;
        }

        /**
         * @experimental
         */
        interface CustomPreview {
            header: string;
            hasBody: boolean;
            formatterObjectId: RemoteObjectId;
            bindRemoteObjectFunctionId: RemoteObjectId;
            configObjectId?: RemoteObjectId | undefined;
        }

        /**
         * Object containing abbreviated remote object value.
         * @experimental
         */
        interface ObjectPreview {
            /**
             * Object type.
             */
            type: string;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
            /**
             * String representation of the object.
             */
            description?: string | undefined;
            /**
             * True iff some of the properties or entries of the original object did not fit.
             */
            overflow: boolean;
            /**
             * List of the properties.
             */
            properties: PropertyPreview[];
            /**
             * List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only.
             */
            entries?: EntryPreview[] | undefined;
        }

        /**
         * @experimental
         */
        interface PropertyPreview {
            /**
             * Property name.
             */
            name: string;
            /**
             * Object type. Accessor means that the property itself is an accessor property.
             */
            type: string;
            /**
             * User-friendly property value string.
             */
            value?: string | undefined;
            /**
             * Nested value preview.
             */
            valuePreview?: ObjectPreview | undefined;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
        }

        /**
         * @experimental
         */
        interface EntryPreview {
            /**
             * Preview of the key. Specified for map-like collection entries.
             */
            key?: ObjectPreview | undefined;
            /**
             * Preview of the value.
             */
            value: ObjectPreview;
        }

        /**
         * Object property descriptor.
         */
        interface PropertyDescriptor {
            /**
             * Property name or symbol description.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject | undefined;
            /**
             * True if the value associated with the property may be changed (data descriptors only).
             */
            writable?: boolean | undefined;
            /**
             * A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only).
             */
            get?: RemoteObject | undefined;
            /**
             * A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only).
             */
            set?: RemoteObject | undefined;
            /**
             * True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.
             */
            configurable: boolean;
            /**
             * True if this property shows up during enumeration of the properties on the corresponding object.
             */
            enumerable: boolean;
            /**
             * True if the result was thrown during the evaluation.
             */
            wasThrown?: boolean | undefined;
            /**
             * True if the property is owned for the object.
             */
            isOwn?: boolean | undefined;
            /**
             * Property symbol object, if the property is of the <code>symbol</code> type.
             */
            symbol?: RemoteObject | undefined;
        }

        /**
         * Object internal property descriptor. This property isn't normally visible in JavaScript code.
         */
        interface InternalPropertyDescriptor {
            /**
             * Conventional property name.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject | undefined;
        }

        /**
         * Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.
         */
        interface CallArgument {
            /**
             * Primitive value or serializable javascript object.
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified.
             */
            unserializableValue?: UnserializableValue | undefined;
            /**
             * Remote object handle.
             */
            objectId?: RemoteObjectId | undefined;
        }

        /**
         * Id of an execution context.
         */
        type ExecutionContextId = number;

        /**
         * Description of an isolated world.
         */
        interface ExecutionContextDescription {
            /**
             * Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.
             */
            id: ExecutionContextId;
            /**
             * Execution context origin.
             */
            origin: string;
            /**
             * Human readable name describing given context.
             */
            name: string;
            /**
             * Embedder-specific auxiliary data.
             */
            auxData?: {} | undefined;
        }

        /**
         * Detailed information about exception (or error) that was thrown during script compilation or execution.
         */
        interface ExceptionDetails {
            /**
             * Exception id.
             */
            exceptionId: number;
            /**
             * Exception text, which should be used together with exception object when available.
             */
            text: string;
            /**
             * Line number of the exception location (0-based).
             */
            lineNumber: number;
            /**
             * Column number of the exception location (0-based).
             */
            columnNumber: number;
            /**
             * Script ID of the exception location.
             */
            scriptId?: ScriptId | undefined;
            /**
             * URL of the exception location, to be used when the script was not reported.
             */
            url?: string | undefined;
            /**
             * JavaScript stack trace if available.
             */
            stackTrace?: StackTrace | undefined;
            /**
             * Exception object if available.
             */
            exception?: RemoteObject | undefined;
            /**
             * Identifier of the context where exception happened.
             */
            executionContextId?: ExecutionContextId | undefined;
        }

        /**
         * Number of milliseconds since epoch.
         */
        type Timestamp = number;

        /**
         * Stack entry for runtime errors and assertions.
         */
        interface CallFrame {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * JavaScript script id.
             */
            scriptId: ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * JavaScript script line number (0-based).
             */
            lineNumber: number;
            /**
             * JavaScript script column number (0-based).
             */
            columnNumber: number;
        }

        /**
         * Call frames for assertions or error messages.
         */
        interface StackTrace {
            /**
             * String label of this stack trace. For async traces this may be a name of the function that initiated the async call.
             */
            description?: string | undefined;
            /**
             * JavaScript function name.
             */
            callFrames: CallFrame[];
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             */
            parent?: StackTrace | undefined;
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             * @experimental
             */
            parentId?: StackTraceId | undefined;
        }

        /**
         * Unique identifier of current debugger.
         * @experimental
         */
        type UniqueDebuggerId = string;

        /**
         * If <code>debuggerId</code> is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See <code>Runtime.StackTrace</code> and <code>Debugger.paused</code> for usages.
         * @experimental
         */
        interface StackTraceId {
            id: string;
            debuggerId?: UniqueDebuggerId | undefined;
        }

        interface EvaluateParameterType {
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            contextId?: ExecutionContextId | undefined;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
        }

        interface AwaitPromiseParameterType {
            /**
             * Identifier of the promise.
             */
            promiseObjectId: RemoteObjectId;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean | undefined;
        }

        interface CallFunctionOnParameterType {
            /**
             * Declaration of the function to call.
             */
            functionDeclaration: string;
            /**
             * Identifier of the object to call function on. Either objectId or executionContextId should be specified.
             */
            objectId?: RemoteObjectId | undefined;
            /**
             * Call arguments. All call arguments must belong to the same JavaScript world as the target object.
             */
            arguments?: CallArgument[] | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
            /**
             * Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
             */
            executionContextId?: ExecutionContextId | undefined;
            /**
             * Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
             */
            objectGroup?: string | undefined;
        }

        interface GetPropertiesParameterType {
            /**
             * Identifier of the object to return properties for.
             */
            objectId: RemoteObjectId;
            /**
             * If true, returns properties belonging only to the element itself, not to its prototype chain.
             */
            ownProperties?: boolean | undefined;
            /**
             * If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
             * @experimental
             */
            accessorPropertiesOnly?: boolean | undefined;
            /**
             * Whether preview should be generated for the results.
             * @experimental
             */
            generatePreview?: boolean | undefined;
        }

        interface ReleaseObjectParameterType {
            /**
             * Identifier of the object to release.
             */
            objectId: RemoteObjectId;
        }

        interface ReleaseObjectGroupParameterType {
            /**
             * Symbolic object group name.
             */
            objectGroup: string;
        }

        interface SetCustomObjectFormatterEnabledParameterType {
            enabled: boolean;
        }

        interface CompileScriptParameterType {
            /**
             * Expression to compile.
             */
            expression: string;
            /**
             * Source url to be set for the script.
             */
            sourceURL: string;
            /**
             * Specifies whether the compiled script should be persisted.
             */
            persistScript: boolean;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId | undefined;
        }

        interface RunScriptParameterType {
            /**
             * Id of the script to run.
             */
            scriptId: ScriptId;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId | undefined;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
        }

        interface QueryObjectsParameterType {
            /**
             * Identifier of the prototype to return objects for.
             */
            prototypeObjectId: RemoteObjectId;
        }

        interface GlobalLexicalScopeNamesParameterType {
            /**
             * Specifies in which execution context to lookup global scope variables.
             */
            executionContextId?: ExecutionContextId | undefined;
        }

        interface EvaluateReturnType {
            /**
             * Evaluation result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }

        interface AwaitPromiseReturnType {
            /**
             * Promise result. Will contain rejected value if promise was rejected.
             */
            result: RemoteObject;
            /**
             * Exception details if stack strace is available.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }

        interface CallFunctionOnReturnType {
            /**
             * Call result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }

        interface GetPropertiesReturnType {
            /**
             * Object properties.
             */
            result: PropertyDescriptor[];
            /**
             * Internal object properties (only of the element itself).
             */
            internalProperties?: InternalPropertyDescriptor[] | undefined;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }

        interface CompileScriptReturnType {
            /**
             * Id of the script.
             */
            scriptId?: ScriptId | undefined;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }

        interface RunScriptReturnType {
            /**
             * Run result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }

        interface QueryObjectsReturnType {
            /**
             * Array with objects.
             */
            objects: RemoteObject;
        }

        interface GlobalLexicalScopeNamesReturnType {
            names: string[];
        }

        interface ExecutionContextCreatedEventDataType {
            /**
             * A newly created execution context.
             */
            context: ExecutionContextDescription;
        }

        interface ExecutionContextDestroyedEventDataType {
            /**
             * Id of the destroyed context
             */
            executionContextId: ExecutionContextId;
        }

        interface ExceptionThrownEventDataType {
            /**
             * Timestamp of the exception.
             */
            timestamp: Timestamp;
            exceptionDetails: ExceptionDetails;
        }

        interface ExceptionRevokedEventDataType {
            /**
             * Reason describing why exception was revoked.
             */
            reason: string;
            /**
             * The id of revoked exception, as reported in <code>exceptionThrown</code>.
             */
            exceptionId: number;
        }

        interface ConsoleAPICalledEventDataType {
            /**
             * Type of the call.
             */
            type: string;
            /**
             * Call arguments.
             */
            args: RemoteObject[];
            /**
             * Identifier of the context where the call was made.
             */
            executionContextId: ExecutionContextId;
            /**
             * Call timestamp.
             */
            timestamp: Timestamp;
            /**
             * Stack trace captured when the call was made.
             */
            stackTrace?: StackTrace | undefined;
            /**
             * Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.
             * @experimental
             */
            context?: string | undefined;
        }

        interface InspectRequestedEventDataType {
            object: RemoteObject;
            hints: {};
        }
    }

    namespace Debugger {
        /**
         * Breakpoint identifier.
         */
        type BreakpointId = string;

        /**
         * Call frame identifier.
         */
        type CallFrameId = string;

        /**
         * Location in the source code.
         */
        interface Location {
            /**
             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: number;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: number | undefined;
        }

        /**
         * Location in the source code.
         * @experimental
         */
        interface ScriptPosition {
            lineNumber: number;
            columnNumber: number;
        }

        /**
         * JavaScript call frame. Array of call frames form the call stack.
         */
        interface CallFrame {
            /**
             * Call frame identifier. This identifier is only valid while the virtual machine is paused.
             */
            callFrameId: CallFrameId;
            /**
             * Name of the JavaScript function called on this call frame.
             */
            functionName: string;
            /**
             * Location in the source code.
             */
            functionLocation?: Location | undefined;
            /**
             * Location in the source code.
             */
            location: Location;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Scope chain for this call frame.
             */
            scopeChain: Scope[];
            /**
             * <code>this</code> object for this call frame.
             */
            this: Runtime.RemoteObject;
            /**
             * The value being returned, if the function is at return point.
             */
            returnValue?: Runtime.RemoteObject | undefined;
        }

        /**
         * Scope description.
         */
        interface Scope {
            /**
             * Scope type.
             */
            type: string;
            /**
             * Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.
             */
            object: Runtime.RemoteObject;
            name?: string | undefined;
            /**
             * Location in the source code where scope starts
             */
            startLocation?: Location | undefined;
            /**
             * Location in the source code where scope ends
             */
            endLocation?: Location | undefined;
        }

        /**
         * Search match for resource.
         */
        interface SearchMatch {
            /**
             * Line number in resource content.
             */
            lineNumber: number;
            /**
             * Line with match content.
             */
            lineContent: string;
        }

        interface BreakLocation {
            /**
             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: number;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: number | undefined;
            type?: string | undefined;
        }

        interface SetBreakpointsActiveParameterType {
            /**
             * New value for breakpoints active state.
             */
            active: boolean;
        }

        interface SetSkipAllPausesParameterType {
            /**
             * New value for skip pauses state.
             */
            skip: boolean;
        }

        interface SetBreakpointByUrlParameterType {
            /**
             * Line number to set breakpoint at.
             */
            lineNumber: number;
            /**
             * URL of the resources to set breakpoint on.
             */
            url?: string | undefined;
            /**
             * Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified.
             */
            urlRegex?: string | undefined;
            /**
             * Script hash of the resources to set breakpoint on.
             */
            scriptHash?: string | undefined;
            /**
             * Offset in the line to set breakpoint at.
             */
            columnNumber?: number | undefined;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
             */
            condition?: string | undefined;
        }

        interface SetBreakpointParameterType {
            /**
             * Location to set breakpoint in.
             */
            location: Location;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
             */
            condition?: string | undefined;
        }

        interface RemoveBreakpointParameterType {
            breakpointId: BreakpointId;
        }

        interface GetPossibleBreakpointsParameterType {
            /**
             * Start of range to search possible breakpoint locations in.
             */
            start: Location;
            /**
             * End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
             */
            end?: Location | undefined;
            /**
             * Only consider locations which are in the same (non-nested) function as start.
             */
            restrictToFunction?: boolean | undefined;
        }

        interface ContinueToLocationParameterType {
            /**
             * Location to continue to.
             */
            location: Location;
            targetCallFrames?: string | undefined;
        }

        interface PauseOnAsyncCallParameterType {
            /**
             * Debugger will pause when async call with given stack trace is started.
             */
            parentStackTraceId: Runtime.StackTraceId;
        }

        interface StepIntoParameterType {
            /**
             * Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.
             * @experimental
             */
            breakOnAsyncCall?: boolean | undefined;
        }

        interface GetStackTraceParameterType {
            stackTraceId: Runtime.StackTraceId;
        }

        interface SearchInContentParameterType {
            /**
             * Id of the script to search in.
             */
            scriptId: Runtime.ScriptId;
            /**
             * String to search for.
             */
            query: string;
            /**
             * If true, search is case sensitive.
             */
            caseSensitive?: boolean | undefined;
            /**
             * If true, treats string parameter as regex.
             */
            isRegex?: boolean | undefined;
        }

        interface SetScriptSourceParameterType {
            /**
             * Id of the script to edit.
             */
            scriptId: Runtime.ScriptId;
            /**
             * New content of the script.
             */
            scriptSource: string;
            /**
             *  If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
             */
            dryRun?: boolean | undefined;
        }

        interface RestartFrameParameterType {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
        }

        interface GetScriptSourceParameterType {
            /**
             * Id of the script to get source for.
             */
            scriptId: Runtime.ScriptId;
        }

        interface SetPauseOnExceptionsParameterType {
            /**
             * Pause on exceptions mode.
             */
            state: string;
        }

        interface EvaluateOnCallFrameParameterType {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>).
             */
            objectGroup?: string | undefined;
            /**
             * Specifies whether command line API should be available to the evaluated expression, defaults to false.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether to throw an exception if side effect cannot be ruled out during evaluation.
             */
            throwOnSideEffect?: boolean | undefined;
        }

        interface SetVariableValueParameterType {
            /**
             * 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
             */
            scopeNumber: number;
            /**
             * Variable name.
             */
            variableName: string;
            /**
             * New variable value.
             */
            newValue: Runtime.CallArgument;
            /**
             * Id of callframe that holds variable.
             */
            callFrameId: CallFrameId;
        }

        interface SetReturnValueParameterType {
            /**
             * New return value.
             */
            newValue: Runtime.CallArgument;
        }

        interface SetAsyncCallStackDepthParameterType {
            /**
             * Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default).
             */
            maxDepth: number;
        }

        interface SetBlackboxPatternsParameterType {
            /**
             * Array of regexps that will be used to check script url for blackbox state.
             */
            patterns: string[];
        }

        interface SetBlackboxedRangesParameterType {
            /**
             * Id of the script.
             */
            scriptId: Runtime.ScriptId;
            positions: ScriptPosition[];
        }

        interface EnableReturnType {
            /**
             * Unique identifier of the debugger.
             * @experimental
             */
            debuggerId: Runtime.UniqueDebuggerId;
        }

        interface SetBreakpointByUrlReturnType {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * List of the locations this breakpoint resolved into upon addition.
             */
            locations: Location[];
        }

        interface SetBreakpointReturnType {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * Location this breakpoint resolved into.
             */
            actualLocation: Location;
        }

        interface GetPossibleBreakpointsReturnType {
            /**
             * List of the possible breakpoint locations.
             */
            locations: BreakLocation[];
        }

        interface GetStackTraceReturnType {
            stackTrace: Runtime.StackTrace;
        }

        interface SearchInContentReturnType {
            /**
             * List of search matches.
             */
            result: SearchMatch[];
        }

        interface SetScriptSourceReturnType {
            /**
             * New stack trace in case editing has happened while VM was stopped.
             */
            callFrames?: CallFrame[] | undefined;
            /**
             * Whether current call stack  was modified after applying the changes.
             */
            stackChanged?: boolean | undefined;
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
            /**
             * Exception details if any.
             */
            exceptionDetails?: Runtime.ExceptionDetails | undefined;
        }

        interface RestartFrameReturnType {
            /**
             * New stack trace.
             */
            callFrames: CallFrame[];
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
        }

        interface GetScriptSourceReturnType {
            /**
             * Script source.
             */
            scriptSource: string;
        }

        interface EvaluateOnCallFrameReturnType {
            /**
             * Object wrapper for the evaluation result.
             */
            result: Runtime.RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: Runtime.ExceptionDetails | undefined;
        }

        interface ScriptParsedEventDataType {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: number;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: number;
            /**
             * Last line of the script.
             */
            endLine: number;
            /**
             * Length of the last line of the script.
             */
            endColumn: number;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data.
             */
            executionContextAuxData?: {} | undefined;
            /**
             * True, if this script is generated as a result of the live edit operation.
             * @experimental
             */
            isLiveEdit?: boolean | undefined;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string | undefined;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean | undefined;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean | undefined;
            /**
             * This script length.
             */
            length?: number | undefined;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             * @experimental
             */
            stackTrace?: Runtime.StackTrace | undefined;
        }

        interface ScriptFailedToParseEventDataType {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: number;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: number;
            /**
             * Last line of the script.
             */
            endLine: number;
            /**
             * Length of the last line of the script.
             */
            endColumn: number;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data.
             */
            executionContextAuxData?: {} | undefined;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string | undefined;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean | undefined;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean | undefined;
            /**
             * This script length.
             */
            length?: number | undefined;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             * @experimental
             */
            stackTrace?: Runtime.StackTrace | undefined;
        }

        interface BreakpointResolvedEventDataType {
            /**
             * Breakpoint unique identifier.
             */
            breakpointId: BreakpointId;
            /**
             * Actual breakpoint location.
             */
            location: Location;
        }

        interface PausedEventDataType {
            /**
             * Call stack the virtual machine stopped on.
             */
            callFrames: CallFrame[];
            /**
             * Pause reason.
             */
            reason: string;
            /**
             * Object containing break-specific auxiliary properties.
             */
            data?: {} | undefined;
            /**
             * Hit breakpoints IDs
             */
            hitBreakpoints?: string[] | undefined;
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
            /**
             * Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag.
             * @experimental
             */
            asyncCallStackTraceId?: Runtime.StackTraceId | undefined;
        }
    }

    namespace Console {
        /**
         * Console message.
         */
        interface ConsoleMessage {
            /**
             * Message source.
             */
            source: string;
            /**
             * Message severity.
             */
            level: string;
            /**
             * Message text.
             */
            text: string;
            /**
             * URL of the message origin.
             */
            url?: string | undefined;
            /**
             * Line number in the resource that generated this message (1-based).
             */
            line?: number | undefined;
            /**
             * Column number in the resource that generated this message (1-based).
             */
            column?: number | undefined;
        }

        interface MessageAddedEventDataType {
            /**
             * Console message that has been added.
             */
            message: ConsoleMessage;
        }
    }

    namespace Profiler {
        /**
         * Profile node. Holds callsite information, execution statistics and child nodes.
         */
        interface ProfileNode {
            /**
             * Unique id of the node.
             */
            id: number;
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Number of samples where this node was on top of the call stack.
             */
            hitCount?: number | undefined;
            /**
             * Child node ids.
             */
            children?: number[] | undefined;
            /**
             * The reason of being not optimized. The function may be deoptimized or marked as don't optimize.
             */
            deoptReason?: string | undefined;
            /**
             * An array of source position ticks.
             */
            positionTicks?: PositionTickInfo[] | undefined;
        }

        /**
         * Profile.
         */
        interface Profile {
            /**
             * The list of profile nodes. First item is the root node.
             */
            nodes: ProfileNode[];
            /**
             * Profiling start timestamp in microseconds.
             */
            startTime: number;
            /**
             * Profiling end timestamp in microseconds.
             */
            endTime: number;
            /**
             * Ids of samples top nodes.
             */
            samples?: number[] | undefined;
            /**
             * Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime.
             */
            timeDeltas?: number[] | undefined;
        }

        /**
         * Specifies a number of samples attributed to a certain source position.
         */
        interface PositionTickInfo {
            /**
             * Source line number (1-based).
             */
            line: number;
            /**
             * Number of samples attributed to the source line.
             */
            ticks: number;
        }

        /**
         * Coverage data for a source range.
         */
        interface CoverageRange {
            /**
             * JavaScript script source offset for the range start.
             */
            startOffset: number;
            /**
             * JavaScript script source offset for the range end.
             */
            endOffset: number;
            /**
             * Collected execution count of the source range.
             */
            count: number;
        }

        /**
         * Coverage data for a JavaScript function.
         */
        interface FunctionCoverage {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * Source ranges inside the function with coverage data.
             */
            ranges: CoverageRange[];
            /**
             * Whether coverage data for this function has block granularity.
             */
            isBlockCoverage: boolean;
        }

        /**
         * Coverage data for a JavaScript script.
         */
        interface ScriptCoverage {
            /**
             * JavaScript script id.
             */
            scriptId: Runtime.ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Functions contained in the script that has coverage data.
             */
            functions: FunctionCoverage[];
        }

        /**
         * Describes a type collected during runtime.
         * @experimental
         */
        interface TypeObject {
            /**
             * Name of a type collected with type profiling.
             */
            name: string;
        }

        /**
         * Source offset and types for a parameter or return value.
         * @experimental
         */
        interface TypeProfileEntry {
            /**
             * Source offset of the parameter or end of function for return values.
             */
            offset: number;
            /**
             * The types for this parameter or return value.
             */
            types: TypeObject[];
        }

        /**
         * Type profile data collected during runtime for a JavaScript script.
         * @experimental
         */
        interface ScriptTypeProfile {
            /**
             * JavaScript script id.
             */
            scriptId: Runtime.ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Type profile entries for parameters and return values of the functions in the script.
             */
            entries: TypeProfileEntry[];
        }

        interface SetSamplingIntervalParameterType {
            /**
             * New sampling interval in microseconds.
             */
            interval: number;
        }

        interface StartPreciseCoverageParameterType {
            /**
             * Collect accurate call counts beyond simple 'covered' or 'not covered'.
             */
            callCount?: boolean | undefined;
            /**
             * Collect block-based coverage.
             */
            detailed?: boolean | undefined;
        }

        interface StopReturnType {
            /**
             * Recorded profile.
             */
            profile: Profile;
        }

        interface TakePreciseCoverageReturnType {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }

        interface GetBestEffortCoverageReturnType {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }

        interface TakeTypeProfileReturnType {
            /**
             * Type profile for all scripts since startTypeProfile() was turned on.
             */
            result: ScriptTypeProfile[];
        }

        interface ConsoleProfileStartedEventDataType {
            id: string;
            /**
             * Location of console.profile().
             */
            location: Debugger.Location;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string | undefined;
        }

        interface ConsoleProfileFinishedEventDataType {
            id: string;
            /**
             * Location of console.profileEnd().
             */
            location: Debugger.Location;
            profile: Profile;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string | undefined;
        }
    }

    namespace HeapProfiler {
        /**
         * Heap snapshot object id.
         */
        type HeapSnapshotObjectId = string;

        /**
         * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
         */
        interface SamplingHeapProfileNode {
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Allocations size in bytes for the node excluding children.
             */
            selfSize: number;
            /**
             * Child nodes.
             */
            children: SamplingHeapProfileNode[];
        }

        /**
         * Profile.
         */
        interface SamplingHeapProfile {
            head: SamplingHeapProfileNode;
        }

        interface StartTrackingHeapObjectsParameterType {
            trackAllocations?: boolean | undefined;
        }

        interface StopTrackingHeapObjectsParameterType {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
             */
            reportProgress?: boolean | undefined;
        }

        interface TakeHeapSnapshotParameterType {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
             */
            reportProgress?: boolean | undefined;
        }

        interface GetObjectByHeapObjectIdParameterType {
            objectId: HeapSnapshotObjectId;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
        }

        interface AddInspectedHeapObjectParameterType {
            /**
             * Heap snapshot object id to be accessible by means of $x command line API.
             */
            heapObjectId: HeapSnapshotObjectId;
        }

        interface GetHeapObjectIdParameterType {
            /**
             * Identifier of the object to get heap object id for.
             */
            objectId: Runtime.RemoteObjectId;
        }

        interface StartSamplingParameterType {
            /**
             * Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
             */
            samplingInterval?: number | undefined;
        }

        interface GetObjectByHeapObjectIdReturnType {
            /**
             * Evaluation result.
             */
            result: Runtime.RemoteObject;
        }

        interface GetHeapObjectIdReturnType {
            /**
             * Id of the heap snapshot object corresponding to the passed remote object id.
             */
            heapSnapshotObjectId: HeapSnapshotObjectId;
        }

        interface StopSamplingReturnType {
            /**
             * Recorded sampling heap profile.
             */
            profile: SamplingHeapProfile;
        }

        interface GetSamplingProfileReturnType {
            /**
             * Return the sampling profile being collected.
             */
            profile: SamplingHeapProfile;
        }

        interface AddHeapSnapshotChunkEventDataType {
            chunk: string;
        }

        interface ReportHeapSnapshotProgressEventDataType {
            done: number;
            total: number;
            finished?: boolean | undefined;
        }

        interface LastSeenObjectIdEventDataType {
            lastSeenObjectId: number;
            timestamp: number;
        }

        interface HeapStatsUpdateEventDataType {
            /**
             * An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment.
             */
            statsUpdate: number[];
        }
    }

    namespace NodeTracing {
        interface TraceConfig {
            /**
             * Controls how the trace buffer stores data.
             */
            recordMode?: string | undefined;
            /**
             * Included category filters.
             */
            includedCategories: string[];
        }

        interface StartParameterType {
            traceConfig: TraceConfig;
        }

        interface GetCategoriesReturnType {
            /**
             * A list of supported tracing categories.
             */
            categories: string[];
        }

        interface DataCollectedEventDataType {
            value: Array<{}>;
        }
    }

    namespace NodeWorker {
        type WorkerID = string;

        /**
         * Unique identifier of attached debugging session.
         */
        type SessionID = string;

        interface WorkerInfo {
            workerId: WorkerID;
            type: string;
            title: string;
            url: string;
        }

        interface SendMessageToWorkerParameterType {
            message: string;
            /**
             * Identifier of the session.
             */
            sessionId: SessionID;
        }

        interface EnableParameterType {
            /**
             * Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`
             * message to run them.
             */
            waitForDebuggerOnStart: boolean;
        }

        interface DetachParameterType {
            sessionId: SessionID;
        }

        interface AttachedToWorkerEventDataType {
            /**
             * Identifier assigned to the session used to send/receive messages.
             */
            sessionId: SessionID;
            workerInfo: WorkerInfo;
            waitingForDebugger: boolean;
        }

        interface DetachedFromWorkerEventDataType {
            /**
             * Detached session identifier.
             */
            sessionId: SessionID;
        }

        interface ReceivedMessageFromWorkerEventDataType {
            /**
             * Identifier of a session which sends a message.
             */
            sessionId: SessionID;
            message: string;
        }
    }

    namespace NodeRuntime {
        interface NotifyWhenWaitingForDisconnectParameterType {
            enabled: boolean;
        }
    }

    /**
     * The inspector.Session is used for dispatching messages to the V8 inspector back-end and receiving message responses and notifications.
     */
    class Session extends EventEmitter {
        /**
         * Create a new instance of the inspector.Session class.
         * The inspector session needs to be connected through session.connect() before the messages can be dispatched to the inspector backend.
         */
        constructor();

        /**
         * Connects a session to the inspector back-end.
         */
        connect(): void;

        /**
         * Connects a session to the main thread inspector back-end.
         * An exception will be thrown if this API was not called on a Worker
         * thread.
         * @since v12.11.0
         */
        connectToMainThread(): void;

        /**
         * Immediately close the session. All pending message callbacks will be called with an error.
         * session.connect() will need to be called to be able to send messages again.
         * Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.
         */
        disconnect(): void;

        /**
         * Posts a message to the inspector back-end. callback will be notified when a response is received.
         * callback is a function that accepts two optional arguments - error and message-specific result.
         */
        post(method: string, params?: {}, callback?: (err: Error | null, params?: {}) => void): void;
        post(method: string, callback?: (err: Error | null, params?: {}) => void): void;

        /**
         * Returns supported domains.
         */
        post(method: "Schema.getDomains", callback?: (err: Error | null, params: Schema.GetDomainsReturnType) => void): void;

        /**
         * Evaluates expression on global object.
         */
        post(method: "Runtime.evaluate", params?: Runtime.EvaluateParameterType, callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;
        post(method: "Runtime.evaluate", callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;

        /**
         * Add handler to promise with given promise object id.
         */
        post(method: "Runtime.awaitPromise", params?: Runtime.AwaitPromiseParameterType, callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;
        post(method: "Runtime.awaitPromise", callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;

        /**
         * Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
         */
        post(method: "Runtime.callFunctionOn", params?: Runtime.CallFunctionOnParameterType, callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;
        post(method: "Runtime.callFunctionOn", callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;

        /**
         * Returns properties of a given object. Object group of the result is inherited from the target object.
         */
        post(method: "Runtime.getProperties", params?: Runtime.GetPropertiesParameterType, callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;
        post(method: "Runtime.getProperties", callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;

        /**
         * Releases remote object with given id.
         */
        post(method: "Runtime.releaseObject", params?: Runtime.ReleaseObjectParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Runtime.releaseObject", callback?: (err: Error | null) => void): void;

        /**
         * Releases all remote objects that belong to a given group.
         */
        post(method: "Runtime.releaseObjectGroup", params?: Runtime.ReleaseObjectGroupParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Runtime.releaseObjectGroup", callback?: (err: Error | null) => void): void;

        /**
         * Tells inspected instance to run if it was waiting for debugger to attach.
         */
        post(method: "Runtime.runIfWaitingForDebugger", callback?: (err: Error | null) => void): void;

        /**
         * Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
         */
        post(method: "Runtime.enable", callback?: (err: Error | null) => void): void;

        /**
         * Disables reporting of execution contexts creation.
         */
        post(method: "Runtime.disable", callback?: (err: Error | null) => void): void;

        /**
         * Discards collected exceptions and console API calls.
         */
        post(method: "Runtime.discardConsoleEntries", callback?: (err: Error | null) => void): void;

        /**
         * @experimental
         */
        post(method: "Runtime.setCustomObjectFormatterEnabled", params?: Runtime.SetCustomObjectFormatterEnabledParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Runtime.setCustomObjectFormatterEnabled", callback?: (err: Error | null) => void): void;

        /**
         * Compiles expression.
         */
        post(method: "Runtime.compileScript", params?: Runtime.CompileScriptParameterType, callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;
        post(method: "Runtime.compileScript", callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;

        /**
         * Runs script with given id in a given context.
         */
        post(method: "Runtime.runScript", params?: Runtime.RunScriptParameterType, callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;
        post(method: "Runtime.runScript", callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;

        post(method: "Runtime.queryObjects", params?: Runtime.QueryObjectsParameterType, callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;
        post(method: "Runtime.queryObjects", callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;

        /**
         * Returns all let, const and class variables from global scope.
         */
        post(
            method: "Runtime.globalLexicalScopeNames",
            params?: Runtime.GlobalLexicalScopeNamesParameterType,
            callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void
        ): void;
        post(method: "Runtime.globalLexicalScopeNames", callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void): void;

        /**
         * Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
         */
        post(method: "Debugger.enable", callback?: (err: Error | null, params: Debugger.EnableReturnType) => void): void;

        /**
         * Disables debugger for given page.
         */
        post(method: "Debugger.disable", callback?: (err: Error | null) => void): void;

        /**
         * Activates / deactivates all breakpoints on the page.
         */
        post(method: "Debugger.setBreakpointsActive", params?: Debugger.SetBreakpointsActiveParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setBreakpointsActive", callback?: (err: Error | null) => void): void;

        /**
         * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
         */
        post(method: "Debugger.setSkipAllPauses", params?: Debugger.SetSkipAllPausesParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setSkipAllPauses", callback?: (err: Error | null) => void): void;

        /**
         * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
         */
        post(method: "Debugger.setBreakpointByUrl", params?: Debugger.SetBreakpointByUrlParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;
        post(method: "Debugger.setBreakpointByUrl", callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;

        /**
         * Sets JavaScript breakpoint at a given location.
         */
        post(method: "Debugger.setBreakpoint", params?: Debugger.SetBreakpointParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;
        post(method: "Debugger.setBreakpoint", callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;

        /**
         * Removes JavaScript breakpoint.
         */
        post(method: "Debugger.removeBreakpoint", params?: Debugger.RemoveBreakpointParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.removeBreakpoint", callback?: (err: Error | null) => void): void;

        /**
         * Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
         */
        post(
            method: "Debugger.getPossibleBreakpoints",
            params?: Debugger.GetPossibleBreakpointsParameterType,
            callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void
        ): void;
        post(method: "Debugger.getPossibleBreakpoints", callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void): void;

        /**
         * Continues execution until specific location is reached.
         */
        post(method: "Debugger.continueToLocation", params?: Debugger.ContinueToLocationParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.continueToLocation", callback?: (err: Error | null) => void): void;

        /**
         * @experimental
         */
        post(method: "Debugger.pauseOnAsyncCall", params?: Debugger.PauseOnAsyncCallParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.pauseOnAsyncCall", callback?: (err: Error | null) => void): void;

        /**
         * Steps over the statement.
         */
        post(method: "Debugger.stepOver", callback?: (err: Error | null) => void): void;

        /**
         * Steps into the function call.
         */
        post(method: "Debugger.stepInto", params?: Debugger.StepIntoParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.stepInto", callback?: (err: Error | null) => void): void;

        /**
         * Steps out of the function call.
         */
        post(method: "Debugger.stepOut", callback?: (err: Error | null) => void): void;

        /**
         * Stops on the next JavaScript statement.
         */
        post(method: "Debugger.pause", callback?: (err: Error | null) => void): void;

        /**
         * This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
         * @experimental
         */
        post(method: "Debugger.scheduleStepIntoAsync", callback?: (err: Error | null) => void): void;

        /**
         * Resumes JavaScript execution.
         */
        post(method: "Debugger.resume", callback?: (err: Error | null) => void): void;

        /**
         * Returns stack trace with given <code>stackTraceId</code>.
         * @experimental
         */
        post(method: "Debugger.getStackTrace", params?: Debugger.GetStackTraceParameterType, callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;
        post(method: "Debugger.getStackTrace", callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;

        /**
         * Searches for given string in script content.
         */
        post(method: "Debugger.searchInContent", params?: Debugger.SearchInContentParameterType, callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;
        post(method: "Debugger.searchInContent", callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;

        /**
         * Edits JavaScript source live.
         */
        post(method: "Debugger.setScriptSource", params?: Debugger.SetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;
        post(method: "Debugger.setScriptSource", callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;

        /**
         * Restarts particular call frame from the beginning.
         */
        post(method: "Debugger.restartFrame", params?: Debugger.RestartFrameParameterType, callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;
        post(method: "Debugger.restartFrame", callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;

        /**
         * Returns source for the script with given id.
         */
        post(method: "Debugger.getScriptSource", params?: Debugger.GetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;
        post(method: "Debugger.getScriptSource", callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;

        /**
         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
         */
        post(method: "Debugger.setPauseOnExceptions", params?: Debugger.SetPauseOnExceptionsParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setPauseOnExceptions", callback?: (err: Error | null) => void): void;

        /**
         * Evaluates expression on a given call frame.
         */
        post(method: "Debugger.evaluateOnCallFrame", params?: Debugger.EvaluateOnCallFrameParameterType, callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;
        post(method: "Debugger.evaluateOnCallFrame", callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;

        /**
         * Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
         */
        post(method: "Debugger.setVariableValue", params?: Debugger.SetVariableValueParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setVariableValue", callback?: (err: Error | null) => void): void;

        /**
         * Changes return value in top frame. Available only at return break position.
         * @experimental
         */
        post(method: "Debugger.setReturnValue", params?: Debugger.SetReturnValueParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setReturnValue", callback?: (err: Error | null) => void): void;

        /**
         * Enables or disables async call stacks tracking.
         */
        post(method: "Debugger.setAsyncCallStackDepth", params?: Debugger.SetAsyncCallStackDepthParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setAsyncCallStackDepth", callback?: (err: Error | null) => void): void;

        /**
         * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
         * @experimental
         */
        post(method: "Debugger.setBlackboxPatterns", params?: Debugger.SetBlackboxPatternsParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setBlackboxPatterns", callback?: (err: Error | null) => void): void;

        /**
         * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
         * @experimental
         */
        post(method: "Debugger.setBlackboxedRanges", params?: Debugger.SetBlackboxedRangesParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Debugger.setBlackboxedRanges", callback?: (err: Error | null) => void): void;

        /**
         * Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
         */
        post(method: "Console.enable", callback?: (err: Error | null) => void): void;

        /**
         * Disables console domain, prevents further console messages from being reported to the client.
         */
        post(method: "Console.disable", callback?: (err: Error | null) => void): void;

        /**
         * Does nothing.
         */
        post(method: "Console.clearMessages", callback?: (err: Error | null) => void): void;

        post(method: "Profiler.enable", callback?: (err: Error | null) => void): void;

        post(method: "Profiler.disable", callback?: (err: Error | null) => void): void;

        /**
         * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
         */
        post(method: "Profiler.setSamplingInterval", params?: Profiler.SetSamplingIntervalParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Profiler.setSamplingInterval", callback?: (err: Error | null) => void): void;

        post(method: "Profiler.start", callback?: (err: Error | null) => void): void;

        post(method: "Profiler.stop", callback?: (err: Error | null, params: Profiler.StopReturnType) => void): void;

        /**
         * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
         */
        post(method: "Profiler.startPreciseCoverage", params?: Profiler.StartPreciseCoverageParameterType, callback?: (err: Error | null) => void): void;
        post(method: "Profiler.startPreciseCoverage", callback?: (err: Error | null) => void): void;

        /**
         * Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
         */
        post(method: "Profiler.stopPreciseCoverage", callback?: (err: Error | null) => void): void;

        /**
         * Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
         */
        post(method: "Profiler.takePreciseCoverage", callback?: (err: Error | null, params: Profiler.TakePreciseCoverageReturnType) => void): void;

        /**
         * Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
         */
        post(method: "Profiler.getBestEffortCoverage", callback?: (err: Error | null, params: Profiler.GetBestEffortCoverageReturnType) => void): void;

        /**
         * Enable type profile.
         * @experimental
         */
        post(method: "Profiler.startTypeProfile", callback?: (err: Error | null) => void): void;

        /**
         * Disable type profile. Disabling releases type profile data collected so far.
         * @experimental
         */
        post(method: "Profiler.stopTypeProfile", callback?: (err: Error | null) => void): void;

        /**
         * Collect type profile.
         * @experimental
         */
        post(method: "Profiler.takeTypeProfile", callback?: (err: Error | null, params: Profiler.TakeTypeProfileReturnType) => void): void;

        post(method: "HeapProfiler.enable", callback?: (err: Error | null) => void): void;

        post(method: "HeapProfiler.disable", callback?: (err: Error | null) => void): void;

        post(method: "HeapProfiler.startTrackingHeapObjects", params?: HeapProfiler.StartTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;
        post(method: "HeapProfiler.startTrackingHeapObjects", callback?: (err: Error | null) => void): void;

        post(method: "HeapProfiler.stopTrackingHeapObjects", params?: HeapProfiler.StopTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;
        post(method: "HeapProfiler.stopTrackingHeapObjects", callback?: (err: Error | null) => void): void;

        post(method: "HeapProfiler.takeHeapSnapshot", params?: HeapProfiler.TakeHeapSnapshotParameterType, callback?: (err: Error | null) => void): void;
        post(method: "HeapProfiler.takeHeapSnapshot", callback?: (err: Error | null) => void): void;

        post(method: "HeapProfiler.collectGarbage", callback?: (err: Error | null) => void): void;

        post(
            method: "HeapProfiler.getObjectByHeapObjectId",
            params?: HeapProfiler.GetObjectByHeapObjectIdParameterType,
            callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void
        ): void;
        post(method: "HeapProfiler.getObjectByHeapObjectId", callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void): void;

        /**
         * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
         */
        post(method: "HeapProfiler.addInspectedHeapObject", params?: HeapProfiler.AddInspectedHeapObjectParameterType, callback?: (err: Error | null) => void): void;
        post(method: "HeapProfiler.addInspectedHeapObject", callback?: (err: Error | null) => void): void;

        post(method: "HeapProfiler.getHeapObjectId", params?: HeapProfiler.GetHeapObjectIdParameterType, callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;
        post(method: "HeapProfiler.getHeapObjectId", callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;

        post(method: "HeapProfiler.startSampling", params?: HeapProfiler.StartSamplingParameterType, callback?: (err: Error | null) => void): void;
        post(method: "HeapProfiler.startSampling", callback?: (err: Error | null) => void): void;

        post(method: "HeapProfiler.stopSampling", callback?: (err: Error | null, params: HeapProfiler.StopSamplingReturnType) => void): void;

        post(method: "HeapProfiler.getSamplingProfile", callback?: (err: Error | null, params: HeapProfiler.GetSamplingProfileReturnType) => void): void;

        /**
         * Gets supported tracing categories.
         */
        post(method: "NodeTracing.getCategories", callback?: (err: Error | null, params: NodeTracing.GetCategoriesReturnType) => void): void;

        /**
         * Start trace events collection.
         */
        post(method: "NodeTracing.start", params?: NodeTracing.StartParameterType, callback?: (err: Error | null) => void): void;
        post(method: "NodeTracing.start", callback?: (err: Error | null) => void): void;

        /**
         * Stop trace events collection. Remaining collected events will be sent as a sequence of
         * dataCollected events followed by tracingComplete event.
         */
        post(method: "NodeTracing.stop", callback?: (err: Error | null) => void): void;

        /**
         * Sends protocol message over session with given id.
         */
        post(method: "NodeWorker.sendMessageToWorker", params?: NodeWorker.SendMessageToWorkerParameterType, callback?: (err: Error | null) => void): void;
        post(method: "NodeWorker.sendMessageToWorker", callback?: (err: Error | null) => void): void;

        /**
         * Instructs the inspector to attach to running workers. Will also attach to new workers
         * as they start
         */
        post(method: "NodeWorker.enable", params?: NodeWorker.EnableParameterType, callback?: (err: Error | null) => void): void;
        post(method: "NodeWorker.enable", callback?: (err: Error | null) => void): void;

        /**
         * Detaches from all running workers and disables attaching to new workers as they are started.
         */
        post(method: "NodeWorker.disable", callback?: (err: Error | null) => void): void;

        /**
         * Detached from the worker with given sessionId.
         */
        post(method: "NodeWorker.detach", params?: NodeWorker.DetachParameterType, callback?: (err: Error | null) => void): void;
        post(method: "NodeWorker.detach", callback?: (err: Error | null) => void): void;

        /**
         * Enable the `NodeRuntime.waitingForDisconnect`.
         */
        post(method: "NodeRuntime.notifyWhenWaitingForDisconnect", params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType, callback?: (err: Error | null) => void): void;
        post(method: "NodeRuntime.notifyWhenWaitingForDisconnect", callback?: (err: Error | null) => void): void;

        // Events

        addListener(event: string, listener: (...args: any[]) => void): this;

        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        addListener(event: "inspectorNotification", listener: (message: InspectorNotification<{}>) => void): this;

        /**
         * Issued when new execution context is created.
         */
        addListener(event: "Runtime.executionContextCreated", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;

        /**
         * Issued when execution context is destroyed.
         */
        addListener(event: "Runtime.executionContextDestroyed", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;

        /**
         * Issued when all executionContexts were cleared in browser
         */
        addListener(event: "Runtime.executionContextsCleared", listener: () => void): this;

        /**
         * Issued when exception was thrown and unhandled.
         */
        addListener(event: "Runtime.exceptionThrown", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;

        /**
         * Issued when unhandled exception was revoked.
         */
        addListener(event: "Runtime.exceptionRevoked", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;

        /**
         * Issued when console API was called.
         */
        addListener(event: "Runtime.consoleAPICalled", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;

        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        addListener(event: "Runtime.inspectRequested", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;

        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        addListener(event: "Debugger.scriptParsed", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;

        /**
         * Fired when virtual machine fails to parse the script.
         */
        addListener(event: "Debugger.scriptFailedToParse", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;

        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        addListener(event: "Debugger.breakpointResolved", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        addListener(event: "Debugger.paused", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine resumed execution.
         */
        addListener(event: "Debugger.resumed", listener: () => void): this;

        /**
         * Issued when new console message is added.
         */
        addListener(event: "Console.messageAdded", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;

        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        addListener(event: "Profiler.consoleProfileStarted", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;

        addListener(event: "Profiler.consoleProfileFinished", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        addListener(event: "HeapProfiler.addHeapSnapshotChunk", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        addListener(event: "HeapProfiler.resetProfiles", listener: () => void): this;
        addListener(event: "HeapProfiler.reportHeapSnapshotProgress", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        addListener(event: "HeapProfiler.lastSeenObjectId", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        addListener(event: "HeapProfiler.heapStatsUpdate", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;

        /**
         * Contains an bucket of collected trace events.
         */
        addListener(event: "NodeTracing.dataCollected", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;

        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        addListener(event: "NodeTracing.tracingComplete", listener: () => void): this;

        /**
         * Issued when attached to a worker.
         */
        addListener(event: "NodeWorker.attachedToWorker", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;

        /**
         * Issued when detached from the worker.
         */
        addListener(event: "NodeWorker.detachedFromWorker", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;

        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        addListener(event: "NodeWorker.receivedMessageFromWorker", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;

        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        addListener(event: "NodeRuntime.waitingForDisconnect", listener: () => void): this;

        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "inspectorNotification", message: InspectorNotification<{}>): boolean;
        emit(event: "Runtime.executionContextCreated", message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>): boolean;
        emit(event: "Runtime.executionContextDestroyed", message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>): boolean;
        emit(event: "Runtime.executionContextsCleared"): boolean;
        emit(event: "Runtime.exceptionThrown", message: InspectorNotification<Runtime.ExceptionThrownEventDataType>): boolean;
        emit(event: "Runtime.exceptionRevoked", message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>): boolean;
        emit(event: "Runtime.consoleAPICalled", message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>): boolean;
        emit(event: "Runtime.inspectRequested", message: InspectorNotification<Runtime.InspectRequestedEventDataType>): boolean;
        emit(event: "Debugger.scriptParsed", message: InspectorNotification<Debugger.ScriptParsedEventDataType>): boolean;
        emit(event: "Debugger.scriptFailedToParse", message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>): boolean;
        emit(event: "Debugger.breakpointResolved", message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>): boolean;
        emit(event: "Debugger.paused", message: InspectorNotification<Debugger.PausedEventDataType>): boolean;
        emit(event: "Debugger.resumed"): boolean;
        emit(event: "Console.messageAdded", message: InspectorNotification<Console.MessageAddedEventDataType>): boolean;
        emit(event: "Profiler.consoleProfileStarted", message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>): boolean;
        emit(event: "Profiler.consoleProfileFinished", message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>): boolean;
        emit(event: "HeapProfiler.addHeapSnapshotChunk", message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>): boolean;
        emit(event: "HeapProfiler.resetProfiles"): boolean;
        emit(event: "HeapProfiler.reportHeapSnapshotProgress", message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>): boolean;
        emit(event: "HeapProfiler.lastSeenObjectId", message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>): boolean;
        emit(event: "HeapProfiler.heapStatsUpdate", message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>): boolean;
        emit(event: "NodeTracing.dataCollected", message: InspectorNotification<NodeTracing.DataCollectedEventDataType>): boolean;
        emit(event: "NodeTracing.tracingComplete"): boolean;
        emit(event: "NodeWorker.attachedToWorker", message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>): boolean;
        emit(event: "NodeWorker.detachedFromWorker", message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>): boolean;
        emit(event: "NodeWorker.receivedMessageFromWorker", message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>): boolean;
        emit(event: "NodeRuntime.waitingForDisconnect"): boolean;

        on(event: string, listener: (...args: any[]) => void): this;

        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        on(event: "inspectorNotification", listener: (message: InspectorNotification<{}>) => void): this;

        /**
         * Issued when new execution context is created.
         */
        on(event: "Runtime.executionContextCreated", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;

        /**
         * Issued when execution context is destroyed.
         */
        on(event: "Runtime.executionContextDestroyed", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;

        /**
         * Issued when all executionContexts were cleared in browser
         */
        on(event: "Runtime.executionContextsCleared", listener: () => void): this;

        /**
         * Issued when exception was thrown and unhandled.
         */
        on(event: "Runtime.exceptionThrown", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;

        /**
         * Issued when unhandled exception was revoked.
         */
        on(event: "Runtime.exceptionRevoked", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;

        /**
         * Issued when console API was called.
         */
        on(event: "Runtime.consoleAPICalled", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;

        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        on(event: "Runtime.inspectRequested", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;

        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        on(event: "Debugger.scriptParsed", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;

        /**
         * Fired when virtual machine fails to parse the script.
         */
        on(event: "Debugger.scriptFailedToParse", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;

        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        on(event: "Debugger.breakpointResolved", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        on(event: "Debugger.paused", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine resumed execution.
         */
        on(event: "Debugger.resumed", listener: () => void): this;

        /**
         * Issued when new console message is added.
         */
        on(event: "Console.messageAdded", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;

        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        on(event: "Profiler.consoleProfileStarted", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;

        on(event: "Profiler.consoleProfileFinished", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        on(event: "HeapProfiler.addHeapSnapshotChunk", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        on(event: "HeapProfiler.resetProfiles", listener: () => void): this;
        on(event: "HeapProfiler.reportHeapSnapshotProgress", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        on(event: "HeapProfiler.lastSeenObjectId", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        on(event: "HeapProfiler.heapStatsUpdate", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;

        /**
         * Contains an bucket of collected trace events.
         */
        on(event: "NodeTracing.dataCollected", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;

        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        on(event: "NodeTracing.tracingComplete", listener: () => void): this;

        /**
         * Issued when attached to a worker.
         */
        on(event: "NodeWorker.attachedToWorker", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;

        /**
         * Issued when detached from the worker.
         */
        on(event: "NodeWorker.detachedFromWorker", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;

        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        on(event: "NodeWorker.receivedMessageFromWorker", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;

        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        on(event: "NodeRuntime.waitingForDisconnect", listener: () => void): this;

        once(event: string, listener: (...args: any[]) => void): this;

        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        once(event: "inspectorNotification", listener: (message: InspectorNotification<{}>) => void): this;

        /**
         * Issued when new execution context is created.
         */
        once(event: "Runtime.executionContextCreated", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;

        /**
         * Issued when execution context is destroyed.
         */
        once(event: "Runtime.executionContextDestroyed", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;

        /**
         * Issued when all executionContexts were cleared in browser
         */
        once(event: "Runtime.executionContextsCleared", listener: () => void): this;

        /**
         * Issued when exception was thrown and unhandled.
         */
        once(event: "Runtime.exceptionThrown", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;

        /**
         * Issued when unhandled exception was revoked.
         */
        once(event: "Runtime.exceptionRevoked", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;

        /**
         * Issued when console API was called.
         */
        once(event: "Runtime.consoleAPICalled", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;

        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        once(event: "Runtime.inspectRequested", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;

        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        once(event: "Debugger.scriptParsed", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;

        /**
         * Fired when virtual machine fails to parse the script.
         */
        once(event: "Debugger.scriptFailedToParse", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;

        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        once(event: "Debugger.breakpointResolved", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        once(event: "Debugger.paused", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine resumed execution.
         */
        once(event: "Debugger.resumed", listener: () => void): this;

        /**
         * Issued when new console message is added.
         */
        once(event: "Console.messageAdded", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;

        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        once(event: "Profiler.consoleProfileStarted", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;

        once(event: "Profiler.consoleProfileFinished", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        once(event: "HeapProfiler.addHeapSnapshotChunk", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        once(event: "HeapProfiler.resetProfiles", listener: () => void): this;
        once(event: "HeapProfiler.reportHeapSnapshotProgress", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        once(event: "HeapProfiler.lastSeenObjectId", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        once(event: "HeapProfiler.heapStatsUpdate", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;

        /**
         * Contains an bucket of collected trace events.
         */
        once(event: "NodeTracing.dataCollected", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;

        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        once(event: "NodeTracing.tracingComplete", listener: () => void): this;

        /**
         * Issued when attached to a worker.
         */
        once(event: "NodeWorker.attachedToWorker", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;

        /**
         * Issued when detached from the worker.
         */
        once(event: "NodeWorker.detachedFromWorker", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;

        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        once(event: "NodeWorker.receivedMessageFromWorker", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;

        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        once(event: "NodeRuntime.waitingForDisconnect", listener: () => void): this;

        prependListener(event: string, listener: (...args: any[]) => void): this;

        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependListener(event: "inspectorNotification", listener: (message: InspectorNotification<{}>) => void): this;

        /**
         * Issued when new execution context is created.
         */
        prependListener(event: "Runtime.executionContextCreated", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;

        /**
         * Issued when execution context is destroyed.
         */
        prependListener(event: "Runtime.executionContextDestroyed", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;

        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependListener(event: "Runtime.executionContextsCleared", listener: () => void): this;

        /**
         * Issued when exception was thrown and unhandled.
         */
        prependListener(event: "Runtime.exceptionThrown", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;

        /**
         * Issued when unhandled exception was revoked.
         */
        prependListener(event: "Runtime.exceptionRevoked", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;

        /**
         * Issued when console API was called.
         */
        prependListener(event: "Runtime.consoleAPICalled", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;

        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependListener(event: "Runtime.inspectRequested", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;

        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependListener(event: "Debugger.scriptParsed", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;

        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependListener(event: "Debugger.scriptFailedToParse", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;

        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependListener(event: "Debugger.breakpointResolved", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependListener(event: "Debugger.paused", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine resumed execution.
         */
        prependListener(event: "Debugger.resumed", listener: () => void): this;

        /**
         * Issued when new console message is added.
         */
        prependListener(event: "Console.messageAdded", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;

        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependListener(event: "Profiler.consoleProfileStarted", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;

        prependListener(event: "Profiler.consoleProfileFinished", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependListener(event: "HeapProfiler.addHeapSnapshotChunk", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependListener(event: "HeapProfiler.resetProfiles", listener: () => void): this;
        prependListener(event: "HeapProfiler.reportHeapSnapshotProgress", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependListener(event: "HeapProfiler.lastSeenObjectId", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependListener(event: "HeapProfiler.heapStatsUpdate", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;

        /**
         * Contains an bucket of collected trace events.
         */
        prependListener(event: "NodeTracing.dataCollected", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;

        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependListener(event: "NodeTracing.tracingComplete", listener: () => void): this;

        /**
         * Issued when attached to a worker.
         */
        prependListener(event: "NodeWorker.attachedToWorker", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;

        /**
         * Issued when detached from the worker.
         */
        prependListener(event: "NodeWorker.detachedFromWorker", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;

        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependListener(event: "NodeWorker.receivedMessageFromWorker", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;

        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependListener(event: "NodeRuntime.waitingForDisconnect", listener: () => void): this;

        prependOnceListener(event: string, listener: (...args: any[]) => void): this;

        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependOnceListener(event: "inspectorNotification", listener: (message: InspectorNotification<{}>) => void): this;

        /**
         * Issued when new execution context is created.
         */
        prependOnceListener(event: "Runtime.executionContextCreated", listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;

        /**
         * Issued when execution context is destroyed.
         */
        prependOnceListener(event: "Runtime.executionContextDestroyed", listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;

        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependOnceListener(event: "Runtime.executionContextsCleared", listener: () => void): this;

        /**
         * Issued when exception was thrown and unhandled.
         */
        prependOnceListener(event: "Runtime.exceptionThrown", listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;

        /**
         * Issued when unhandled exception was revoked.
         */
        prependOnceListener(event: "Runtime.exceptionRevoked", listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;

        /**
         * Issued when console API was called.
         */
        prependOnceListener(event: "Runtime.consoleAPICalled", listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;

        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependOnceListener(event: "Runtime.inspectRequested", listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;

        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependOnceListener(event: "Debugger.scriptParsed", listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;

        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependOnceListener(event: "Debugger.scriptFailedToParse", listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;

        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependOnceListener(event: "Debugger.breakpointResolved", listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependOnceListener(event: "Debugger.paused", listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;

        /**
         * Fired when the virtual machine resumed execution.
         */
        prependOnceListener(event: "Debugger.resumed", listener: () => void): this;

        /**
         * Issued when new console message is added.
         */
        prependOnceListener(event: "Console.messageAdded", listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;

        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependOnceListener(event: "Profiler.consoleProfileStarted", listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;

        prependOnceListener(event: "Profiler.consoleProfileFinished", listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependOnceListener(event: "HeapProfiler.addHeapSnapshotChunk", listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependOnceListener(event: "HeapProfiler.resetProfiles", listener: () => void): this;
        prependOnceListener(event: "HeapProfiler.reportHeapSnapshotProgress", listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependOnceListener(event: "HeapProfiler.lastSeenObjectId", listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;

        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependOnceListener(event: "HeapProfiler.heapStatsUpdate", listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;

        /**
         * Contains an bucket of collected trace events.
         */
        prependOnceListener(event: "NodeTracing.dataCollected", listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;

        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependOnceListener(event: "NodeTracing.tracingComplete", listener: () => void): this;

        /**
         * Issued when attached to a worker.
         */
        prependOnceListener(event: "NodeWorker.attachedToWorker", listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;

        /**
         * Issued when detached from the worker.
         */
        prependOnceListener(event: "NodeWorker.detachedFromWorker", listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;

        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependOnceListener(event: "NodeWorker.receivedMessageFromWorker", listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;

        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependOnceListener(event: "NodeRuntime.waitingForDisconnect", listener: () => void): this;
    }

    // Top Level API

    /**
     * Activate inspector on host and port. Equivalent to node --inspect=[[host:]port], but can be done programatically after node has started.
     * If wait is true, will block until a client has connected to the inspect port and flow control has been passed to the debugger client.
     * @param port Port to listen on for inspector connections. Optional, defaults to what was specified on the CLI.
     * @param host Host to listen on for inspector connections. Optional, defaults to what was specified on the CLI.
     * @param wait Block until a client has connected. Optional, defaults to false.
     */
    function open(port?: number, host?: string, wait?: boolean): void;

    /**
     * Deactivate the inspector. Blocks until there are no active connections.
     */
    function close(): void;

    /**
     * Return the URL of the active inspector, or `undefined` if there is none.
     */
    function url(): string | undefined;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 14);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _promise = __webpack_require__(173);

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
class MessageError extends Error {
  constructor(msg, code) {
    super(msg);
    this.code = code;
  }

}

exports.MessageError = MessageError;
class ProcessSpawnError extends MessageError {
  constructor(msg, code, process) {
    super(msg, code);
    this.process = process;
  }

}

exports.ProcessSpawnError = ProcessSpawnError;
class SecurityError extends MessageError {}

exports.SecurityError = SecurityError;
class ProcessTermError extends MessageError {}

exports.ProcessTermError = ProcessTermError;
class ResponseError extends Error {
  constructor(msg, responseCode) {
    super(msg);
    this.responseCode = responseCode;
  }

}
exports.ResponseError = ResponseError;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFirstSuitableFolder = exports.readFirstAvailableStream = exports.makeTempDir = exports.hardlinksWork = exports.writeFilePreservingEol = exports.getFileSizeOnDisk = exports.walk = exports.symlink = exports.find = exports.readJsonAndFile = exports.readJson = exports.readFileAny = exports.hardlinkBulk = exports.copyBulk = exports.unlink = exports.glob = exports.link = exports.chmod = exports.lstat = exports.exists = exports.mkdirp = exports.stat = exports.access = exports.rename = exports.readdir = exports.realpath = exports.readlink = exports.writeFile = exports.open = exports.readFileBuffer = exports.lockQueue = exports.constants = undefined;

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));
}

let buildActionsForCopy = (() => {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {

    //
    let build = (() => {
      var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
        const src = data.src,
              dest = data.dest,
              type = data.type;

        const onFresh = data.onFresh || noop;
        const onDone = data.onDone || noop;

        // TODO https://github.com/yarnpkg/yarn/issues/3751
        // related to bundled dependencies handling
        if (files.has(dest.toLowerCase())) {
          reporter.verbose(`The case-insensitive file ${dest} shouldn't be copied twice in one bulk copy`);
        } else {
          files.add(dest.toLowerCase());
        }

        if (type === 'symlink') {
          yield mkdirp((_path || _load_path()).default.dirname(dest));
          onFresh();
          actions.symlink.push({
            dest,
            linkname: src
          });
          onDone();
          return;
        }

        if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {
          // ignored file
          return;
        }

        const srcStat = yield lstat(src);
        let srcFiles;

        if (srcStat.isDirectory()) {
          srcFiles = yield readdir(src);
        }

        let destStat;
        try {
          // try accessing the destination
          destStat = yield lstat(dest);
        } catch (e) {
          // proceed if destination doesn't exist, otherwise error
          if (e.code !== 'ENOENT') {
            throw e;
          }
        }

        // if destination exists
        if (destStat) {
          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();
          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();
          const bothFiles = srcStat.isFile() && destStat.isFile();

          // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving
          // us modes that aren't valid. investigate this, it's generally safe to proceed.

          /* if (srcStat.mode !== destStat.mode) {
            try {
              await access(dest, srcStat.mode);
            } catch (err) {}
          } */

          if (bothFiles && artifactFiles.has(dest)) {
            // this file gets changed during build, likely by a custom install script. Don't bother checking it.
            onDone();
            reporter.verbose(reporter.lang('verboseFileSkipArtifact', src));
            return;
          }

          if (bothFiles && srcStat.size === destStat.size && (0, (_fsNormalized || _load_fsNormalized()).fileDatesEqual)(srcStat.mtime, destStat.mtime)) {
            // we can safely assume this is the same file
            onDone();
            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.size, +srcStat.mtime));
            return;
          }

          if (bothSymlinks) {
            const srcReallink = yield readlink(src);
            if (srcReallink === (yield readlink(dest))) {
              // if both symlinks are the same then we can continue on
              onDone();
              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));
              return;
            }
          }

          if (bothFolders) {
            // mark files that aren't in this folder as possibly extraneous
            const destFiles = yield readdir(dest);
            invariant(srcFiles, 'src files not initialised');

            for (var _iterator4 = destFiles, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
              var _ref6;

              if (_isArray4) {
                if (_i4 >= _iterator4.length) break;
                _ref6 = _iterator4[_i4++];
              } else {
                _i4 = _iterator4.next();
                if (_i4.done) break;
                _ref6 = _i4.value;
              }

              const file = _ref6;

              if (srcFiles.indexOf(file) < 0) {
                const loc = (_path || _load_path()).default.join(dest, file);
                possibleExtraneous.add(loc);

                if ((yield lstat(loc)).isDirectory()) {
                  for (var _iterator5 = yield readdir(loc), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
                    var _ref7;

                    if (_isArray5) {
                      if (_i5 >= _iterator5.length) break;
                      _ref7 = _iterator5[_i5++];
                    } else {
                      _i5 = _iterator5.next();
                      if (_i5.done) break;
                      _ref7 = _i5.value;
                    }

                    const file = _ref7;

                    possibleExtraneous.add((_path || _load_path()).default.join(loc, file));
                  }
                }
              }
            }
          }
        }

        if (destStat && destStat.isSymbolicLink()) {
          yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);
          destStat = null;
        }

        if (srcStat.isSymbolicLink()) {
          onFresh();
          const linkname = yield readlink(src);
          actions.symlink.push({
            dest,
            linkname
          });
          onDone();
        } else if (srcStat.isDirectory()) {
          if (!destStat) {
            reporter.verbose(reporter.lang('verboseFileFolder', dest));
            yield mkdirp(dest);
          }

          const destParts = dest.split((_path || _load_path()).default.sep);
          while (destParts.length) {
            files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());
            destParts.pop();
          }

          // push all files to queue
          invariant(srcFiles, 'src files not initialised');
          let remaining = srcFiles.length;
          if (!remaining) {
            onDone();
          }
          for (var _iterator6 = srcFiles, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
            var _ref8;

            if (_isArray6) {
              if (_i6 >= _iterator6.length) break;
              _ref8 = _iterator6[_i6++];
            } else {
              _i6 = _iterator6.next();
              if (_i6.done) break;
              _ref8 = _i6.value;
            }

            const file = _ref8;

            queue.push({
              dest: (_path || _load_path()).default.join(dest, file),
              onFresh,
              onDone: function (_onDone) {
                function onDone() {
                  return _onDone.apply(this, arguments);
                }

                onDone.toString = function () {
                  return _onDone.toString();
                };

                return onDone;
              }(function () {
                if (--remaining === 0) {
                  onDone();
                }
              }),
              src: (_path || _load_path()).default.join(src, file)
            });
          }
        } else if (srcStat.isFile()) {
          onFresh();
          actions.file.push({
            src,
            dest,
            atime: srcStat.atime,
            mtime: srcStat.mtime,
            mode: srcStat.mode
          });
          onDone();
        } else {
          throw new Error(`unsure how to copy this: ${src}`);
        }
      });

      return function build(_x5) {
        return _ref5.apply(this, arguments);
      };
    })();

    const artifactFiles = new Set(events.artifactFiles || []);
    const files = new Set();

    // initialise events
    for (var _iterator = queue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      const item = _ref2;

      const onDone = item.onDone;
      item.onDone = function () {
        events.onProgress(item.dest);
        if (onDone) {
          onDone();
        }
      };
    }
    events.onStart(queue.length);

    // start building actions
    const actions = {
      file: [],
      symlink: [],
      link: []
    };

    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items
    // at a time due to the requirement to push items onto the queue
    while (queue.length) {
      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);
      yield Promise.all(items.map(build));
    }

    // simulate the existence of some files to prevent considering them extraneous
    for (var _iterator2 = artifactFiles, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref3 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref3 = _i2.value;
      }

      const file = _ref3;

      if (possibleExtraneous.has(file)) {
        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));
        possibleExtraneous.delete(file);
      }
    }

    for (var _iterator3 = possibleExtraneous, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref4 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref4 = _i3.value;
      }

      const loc = _ref4;

      if (files.has(loc.toLowerCase())) {
        possibleExtraneous.delete(loc);
      }
    }

    return actions;
  });

  return function buildActionsForCopy(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
})();

let buildActionsForHardlink = (() => {
  var _ref9 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {

    //
    let build = (() => {
      var _ref13 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
        const src = data.src,
              dest = data.dest;

        const onFresh = data.onFresh || noop;
        const onDone = data.onDone || noop;
        if (files.has(dest.toLowerCase())) {
          // Fixes issue https://github.com/yarnpkg/yarn/issues/2734
          // When bulk hardlinking we have A -> B structure that we want to hardlink to A1 -> B1,
          // package-linker passes that modules A1 and B1 need to be hardlinked,
          // the recursive linking algorithm of A1 ends up scheduling files in B1 to be linked twice which will case
          // an exception.
          onDone();
          return;
        }
        files.add(dest.toLowerCase());

        if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {
          // ignored file
          return;
        }

        const srcStat = yield lstat(src);
        let srcFiles;

        if (srcStat.isDirectory()) {
          srcFiles = yield readdir(src);
        }

        const destExists = yield exists(dest);
        if (destExists) {
          const destStat = yield lstat(dest);

          const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();
          const bothFolders = srcStat.isDirectory() && destStat.isDirectory();
          const bothFiles = srcStat.isFile() && destStat.isFile();

          if (srcStat.mode !== destStat.mode) {
            try {
              yield access(dest, srcStat.mode);
            } catch (err) {
              // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving
              // us modes that aren't valid. investigate this, it's generally safe to proceed.
              reporter.verbose(err);
            }
          }

          if (bothFiles && artifactFiles.has(dest)) {
            // this file gets changed during build, likely by a custom install script. Don't bother checking it.
            onDone();
            reporter.verbose(reporter.lang('verboseFileSkipArtifact', src));
            return;
          }

          // correct hardlink
          if (bothFiles && srcStat.ino !== null && srcStat.ino === destStat.ino) {
            onDone();
            reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.ino));
            return;
          }

          if (bothSymlinks) {
            const srcReallink = yield readlink(src);
            if (srcReallink === (yield readlink(dest))) {
              // if both symlinks are the same then we can continue on
              onDone();
              reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));
              return;
            }
          }

          if (bothFolders) {
            // mark files that aren't in this folder as possibly extraneous
            const destFiles = yield readdir(dest);
            invariant(srcFiles, 'src files not initialised');

            for (var _iterator10 = destFiles, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
              var _ref14;

              if (_isArray10) {
                if (_i10 >= _iterator10.length) break;
                _ref14 = _iterator10[_i10++];
              } else {
                _i10 = _iterator10.next();
                if (_i10.done) break;
                _ref14 = _i10.value;
              }

              const file = _ref14;

              if (srcFiles.indexOf(file) < 0) {
                const loc = (_path || _load_path()).default.join(dest, file);
                possibleExtraneous.add(loc);

                if ((yield lstat(loc)).isDirectory()) {
                  for (var _iterator11 = yield readdir(loc), _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {
                    var _ref15;

                    if (_isArray11) {
                      if (_i11 >= _iterator11.length) break;
                      _ref15 = _iterator11[_i11++];
                    } else {
                      _i11 = _iterator11.next();
                      if (_i11.done) break;
                      _ref15 = _i11.value;
                    }

                    const file = _ref15;

                    possibleExtraneous.add((_path || _load_path()).default.join(loc, file));
                  }
                }
              }
            }
          }
        }

        if (srcStat.isSymbolicLink()) {
          onFresh();
          const linkname = yield readlink(src);
          actions.symlink.push({
            dest,
            linkname
          });
          onDone();
        } else if (srcStat.isDirectory()) {
          reporter.verbose(reporter.lang('verboseFileFolder', dest));
          yield mkdirp(dest);

          const destParts = dest.split((_path || _load_path()).default.sep);
          while (destParts.length) {
            files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());
            destParts.pop();
          }

          // push all files to queue
          invariant(srcFiles, 'src files not initialised');
          let remaining = srcFiles.length;
          if (!remaining) {
            onDone();
          }
          for (var _iterator12 = srcFiles, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {
            var _ref16;

            if (_isArray12) {
              if (_i12 >= _iterator12.length) break;
              _ref16 = _iterator12[_i12++];
            } else {
              _i12 = _iterator12.next();
              if (_i12.done) break;
              _ref16 = _i12.value;
            }

            const file = _ref16;

            queue.push({
              onFresh,
              src: (_path || _load_path()).default.join(src, file),
              dest: (_path || _load_path()).default.join(dest, file),
              onDone: function (_onDone2) {
                function onDone() {
                  return _onDone2.apply(this, arguments);
                }

                onDone.toString = function () {
                  return _onDone2.toString();
                };

                return onDone;
              }(function () {
                if (--remaining === 0) {
                  onDone();
                }
              })
            });
          }
        } else if (srcStat.isFile()) {
          onFresh();
          actions.link.push({
            src,
            dest,
            removeDest: destExists
          });
          onDone();
        } else {
          throw new Error(`unsure how to copy this: ${src}`);
        }
      });

      return function build(_x10) {
        return _ref13.apply(this, arguments);
      };
    })();

    const artifactFiles = new Set(events.artifactFiles || []);
    const files = new Set();

    // initialise events
    for (var _iterator7 = queue, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
      var _ref10;

      if (_isArray7) {
        if (_i7 >= _iterator7.length) break;
        _ref10 = _iterator7[_i7++];
      } else {
        _i7 = _iterator7.next();
        if (_i7.done) break;
        _ref10 = _i7.value;
      }

      const item = _ref10;

      const onDone = item.onDone || noop;
      item.onDone = function () {
        events.onProgress(item.dest);
        onDone();
      };
    }
    events.onStart(queue.length);

    // start building actions
    const actions = {
      file: [],
      symlink: [],
      link: []
    };

    // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items
    // at a time due to the requirement to push items onto the queue
    while (queue.length) {
      const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);
      yield Promise.all(items.map(build));
    }

    // simulate the existence of some files to prevent considering them extraneous
    for (var _iterator8 = artifactFiles, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
      var _ref11;

      if (_isArray8) {
        if (_i8 >= _iterator8.length) break;
        _ref11 = _iterator8[_i8++];
      } else {
        _i8 = _iterator8.next();
        if (_i8.done) break;
        _ref11 = _i8.value;
      }

      const file = _ref11;

      if (possibleExtraneous.has(file)) {
        reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));
        possibleExtraneous.delete(file);
      }
    }

    for (var _iterator9 = possibleExtraneous, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
      var _ref12;

      if (_isArray9) {
        if (_i9 >= _iterator9.length) break;
        _ref12 = _iterator9[_i9++];
      } else {
        _i9 = _iterator9.next();
        if (_i9.done) break;
        _ref12 = _i9.value;
      }

      const loc = _ref12;

      if (files.has(loc.toLowerCase())) {
        possibleExtraneous.delete(loc);
      }
    }

    return actions;
  });

  return function buildActionsForHardlink(_x6, _x7, _x8, _x9) {
    return _ref9.apply(this, arguments);
  };
})();

let copyBulk = exports.copyBulk = (() => {
  var _ref17 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {
    const events = {
      onStart: _events && _events.onStart || noop,
      onProgress: _events && _events.onProgress || noop,
      possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),
      ignoreBasenames: _events && _events.ignoreBasenames || [],
      artifactFiles: _events && _events.artifactFiles || []
    };

    const actions = yield buildActionsForCopy(queue, events, events.possibleExtraneous, reporter);
    events.onStart(actions.file.length + actions.symlink.length + actions.link.length);

    const fileActions = actions.file;

    const currentlyWriting = new Map();

    yield (_promise || _load_promise()).queue(fileActions, (() => {
      var _ref18 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
        let writePromise;
        while (writePromise = currentlyWriting.get(data.dest)) {
          yield writePromise;
        }

        reporter.verbose(reporter.lang('verboseFileCopy', data.src, data.dest));
        const copier = (0, (_fsNormalized || _load_fsNormalized()).copyFile)(data, function () {
          return currentlyWriting.delete(data.dest);
        });
        currentlyWriting.set(data.dest, copier);
        events.onProgress(data.dest);
        return copier;
      });

      return function (_x14) {
        return _ref18.apply(this, arguments);
      };
    })(), CONCURRENT_QUEUE_ITEMS);

    // we need to copy symlinks last as they could reference files we were copying
    const symlinkActions = actions.symlink;
    yield (_promise || _load_promise()).queue(symlinkActions, function (data) {
      const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);
      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));
      return symlink(linkname, data.dest);
    });
  });

  return function copyBulk(_x11, _x12, _x13) {
    return _ref17.apply(this, arguments);
  };
})();

let hardlinkBulk = exports.hardlinkBulk = (() => {
  var _ref19 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {
    const events = {
      onStart: _events && _events.onStart || noop,
      onProgress: _events && _events.onProgress || noop,
      possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),
      artifactFiles: _events && _events.artifactFiles || [],
      ignoreBasenames: []
    };

    const actions = yield buildActionsForHardlink(queue, events, events.possibleExtraneous, reporter);
    events.onStart(actions.file.length + actions.symlink.length + actions.link.length);

    const fileActions = actions.link;

    yield (_promise || _load_promise()).queue(fileActions, (() => {
      var _ref20 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {
        reporter.verbose(reporter.lang('verboseFileLink', data.src, data.dest));
        if (data.removeDest) {
          yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(data.dest);
        }
        yield link(data.src, data.dest);
      });

      return function (_x18) {
        return _ref20.apply(this, arguments);
      };
    })(), CONCURRENT_QUEUE_ITEMS);

    // we need to copy symlinks last as they could reference files we were copying
    const symlinkActions = actions.symlink;
    yield (_promise || _load_promise()).queue(symlinkActions, function (data) {
      const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);
      reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));
      return symlink(linkname, data.dest);
    });
  });

  return function hardlinkBulk(_x15, _x16, _x17) {
    return _ref19.apply(this, arguments);
  };
})();

let readFileAny = exports.readFileAny = (() => {
  var _ref21 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (files) {
    for (var _iterator13 = files, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {
      var _ref22;

      if (_isArray13) {
        if (_i13 >= _iterator13.length) break;
        _ref22 = _iterator13[_i13++];
      } else {
        _i13 = _iterator13.next();
        if (_i13.done) break;
        _ref22 = _i13.value;
      }

      const file = _ref22;

      if (yield exists(file)) {
        return readFile(file);
      }
    }
    return null;
  });

  return function readFileAny(_x19) {
    return _ref21.apply(this, arguments);
  };
})();

let readJson = exports.readJson = (() => {
  var _ref23 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {
    return (yield readJsonAndFile(loc)).object;
  });

  return function readJson(_x20) {
    return _ref23.apply(this, arguments);
  };
})();

let readJsonAndFile = exports.readJsonAndFile = (() => {
  var _ref24 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {
    const file = yield readFile(loc);
    try {
      return {
        object: (0, (_map || _load_map()).default)(JSON.parse(stripBOM(file))),
        content: file
      };
    } catch (err) {
      err.message = `${loc}: ${err.message}`;
      throw err;
    }
  });

  return function readJsonAndFile(_x21) {
    return _ref24.apply(this, arguments);
  };
})();

let find = exports.find = (() => {
  var _ref25 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (filename, dir) {
    const parts = dir.split((_path || _load_path()).default.sep);

    while (parts.length) {
      const loc = parts.concat(filename).join((_path || _load_path()).default.sep);

      if (yield exists(loc)) {
        return loc;
      } else {
        parts.pop();
      }
    }

    return false;
  });

  return function find(_x22, _x23) {
    return _ref25.apply(this, arguments);
  };
})();

let symlink = exports.symlink = (() => {
  var _ref26 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {
    try {
      const stats = yield lstat(dest);
      if (stats.isSymbolicLink()) {
        const resolved = yield realpath(dest);
        if (resolved === src) {
          return;
        }
      }
    } catch (err) {
      if (err.code !== 'ENOENT') {
        throw err;
      }
    }
    // We use rimraf for unlink which never throws an ENOENT on missing target
    yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);

    if (process.platform === 'win32') {
      // use directory junctions if possible on win32, this requires absolute paths
      yield fsSymlink(src, dest, 'junction');
    } else {
      // use relative paths otherwise which will be retained if the directory is moved
      let relative;
      try {
        relative = (_path || _load_path()).default.relative((_fs || _load_fs()).default.realpathSync((_path || _load_path()).default.dirname(dest)), (_fs || _load_fs()).default.realpathSync(src));
      } catch (err) {
        if (err.code !== 'ENOENT') {
          throw err;
        }
        relative = (_path || _load_path()).default.relative((_path || _load_path()).default.dirname(dest), src);
      }
      // When path.relative returns an empty string for the current directory, we should instead use
      // '.', which is a valid fs.symlink target.
      yield fsSymlink(relative || '.', dest);
    }
  });

  return function symlink(_x24, _x25) {
    return _ref26.apply(this, arguments);
  };
})();

let walk = exports.walk = (() => {
  var _ref27 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir, relativeDir, ignoreBasenames = new Set()) {
    let files = [];

    let filenames = yield readdir(dir);
    if (ignoreBasenames.size) {
      filenames = filenames.filter(function (name) {
        return !ignoreBasenames.has(name);
      });
    }

    for (var _iterator14 = filenames, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {
      var _ref28;

      if (_isArray14) {
        if (_i14 >= _iterator14.length) break;
        _ref28 = _iterator14[_i14++];
      } else {
        _i14 = _iterator14.next();
        if (_i14.done) break;
        _ref28 = _i14.value;
      }

      const name = _ref28;

      const relative = relativeDir ? (_path || _load_path()).default.join(relativeDir, name) : name;
      const loc = (_path || _load_path()).default.join(dir, name);
      const stat = yield lstat(loc);

      files.push({
        relative,
        basename: name,
        absolute: loc,
        mtime: +stat.mtime
      });

      if (stat.isDirectory()) {
        files = files.concat((yield walk(loc, relative, ignoreBasenames)));
      }
    }

    return files;
  });

  return function walk(_x26, _x27) {
    return _ref27.apply(this, arguments);
  };
})();

let getFileSizeOnDisk = exports.getFileSizeOnDisk = (() => {
  var _ref29 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {
    const stat = yield lstat(loc);
    const size = stat.size,
          blockSize = stat.blksize;


    return Math.ceil(size / blockSize) * blockSize;
  });

  return function getFileSizeOnDisk(_x28) {
    return _ref29.apply(this, arguments);
  };
})();

let getEolFromFile = (() => {
  var _ref30 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path) {
    if (!(yield exists(path))) {
      return undefined;
    }

    const buffer = yield readFileBuffer(path);

    for (let i = 0; i < buffer.length; ++i) {
      if (buffer[i] === cr) {
        return '\r\n';
      }
      if (buffer[i] === lf) {
        return '\n';
      }
    }
    return undefined;
  });

  return function getEolFromFile(_x29) {
    return _ref30.apply(this, arguments);
  };
})();

let writeFilePreservingEol = exports.writeFilePreservingEol = (() => {
  var _ref31 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path, data) {
    const eol = (yield getEolFromFile(path)) || (_os || _load_os()).default.EOL;
    if (eol !== '\n') {
      data = data.replace(/\n/g, eol);
    }
    yield writeFile(path, data);
  });

  return function writeFilePreservingEol(_x30, _x31) {
    return _ref31.apply(this, arguments);
  };
})();

let hardlinksWork = exports.hardlinksWork = (() => {
  var _ref32 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir) {
    const filename = 'test-file' + Math.random();
    const file = (_path || _load_path()).default.join(dir, filename);
    const fileLink = (_path || _load_path()).default.join(dir, filename + '-link');
    try {
      yield writeFile(file, 'test');
      yield link(file, fileLink);
    } catch (err) {
      return false;
    } finally {
      yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(file);
      yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(fileLink);
    }
    return true;
  });

  return function hardlinksWork(_x32) {
    return _ref32.apply(this, arguments);
  };
})();

// not a strict polyfill for Node's fs.mkdtemp


let makeTempDir = exports.makeTempDir = (() => {
  var _ref33 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (prefix) {
    const dir = (_path || _load_path()).default.join((_os || _load_os()).default.tmpdir(), `yarn-${prefix || ''}-${Date.now()}-${Math.random()}`);
    yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dir);
    yield mkdirp(dir);
    return dir;
  });

  return function makeTempDir(_x33) {
    return _ref33.apply(this, arguments);
  };
})();

let readFirstAvailableStream = exports.readFirstAvailableStream = (() => {
  var _ref34 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths) {
    for (var _iterator15 = paths, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {
      var _ref35;

      if (_isArray15) {
        if (_i15 >= _iterator15.length) break;
        _ref35 = _iterator15[_i15++];
      } else {
        _i15 = _iterator15.next();
        if (_i15.done) break;
        _ref35 = _i15.value;
      }

      const path = _ref35;

      try {
        const fd = yield open(path, 'r');
        return (_fs || _load_fs()).default.createReadStream(path, { fd });
      } catch (err) {
        // Try the next one
      }
    }
    return null;
  });

  return function readFirstAvailableStream(_x34) {
    return _ref34.apply(this, arguments);
  };
})();

let getFirstSuitableFolder = exports.getFirstSuitableFolder = (() => {
  var _ref36 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths, mode = constants.W_OK | constants.X_OK) {
    const result = {
      skipped: [],
      folder: null
    };

    for (var _iterator16 = paths, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {
      var _ref37;

      if (_isArray16) {
        if (_i16 >= _iterator16.length) break;
        _ref37 = _iterator16[_i16++];
      } else {
        _i16 = _iterator16.next();
        if (_i16.done) break;
        _ref37 = _i16.value;
      }

      const folder = _ref37;

      try {
        yield mkdirp(folder);
        yield access(folder, mode);

        result.folder = folder;

        return result;
      } catch (error) {
        result.skipped.push({
          error,
          folder
        });
      }
    }
    return result;
  });

  return function getFirstSuitableFolder(_x35) {
    return _ref36.apply(this, arguments);
  };
})();

exports.copy = copy;
exports.readFile = readFile;
exports.readFileRaw = readFileRaw;
exports.normalizeOS = normalizeOS;

var _fs;

function _load_fs() {
  return _fs = _interopRequireDefault(__webpack_require__(3));
}

var _glob;

function _load_glob() {
  return _glob = _interopRequireDefault(__webpack_require__(75));
}

var _os;

function _load_os() {
  return _os = _interopRequireDefault(__webpack_require__(36));
}

var _path;

function _load_path() {
  return _path = _interopRequireDefault(__webpack_require__(0));
}

var _blockingQueue;

function _load_blockingQueue() {
  return _blockingQueue = _interopRequireDefault(__webpack_require__(84));
}

var _promise;

function _load_promise() {
  return _promise = _interopRequireWildcard(__webpack_require__(40));
}

var _promise2;

function _load_promise2() {
  return _promise2 = __webpack_require__(40);
}

var _map;

function _load_map() {
  return _map = _interopRequireDefault(__webpack_require__(20));
}

var _fsNormalized;

function _load_fsNormalized() {
  return _fsNormalized = __webpack_require__(164);
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const constants = exports.constants = typeof (_fs || _load_fs()).default.constants !== 'undefined' ? (_fs || _load_fs()).default.constants : {
  R_OK: (_fs || _load_fs()).default.R_OK,
  W_OK: (_fs || _load_fs()).default.W_OK,
  X_OK: (_fs || _load_fs()).default.X_OK
};

const lockQueue = exports.lockQueue = new (_blockingQueue || _load_blockingQueue()).default('fs lock');

const readFileBuffer = exports.readFileBuffer = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readFile);
const open = exports.open = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.open);
const writeFile = exports.writeFile = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.writeFile);
const readlink = exports.readlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readlink);
const realpath = exports.realpath = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.realpath);
const readdir = exports.readdir = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readdir);
const rename = exports.rename = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.rename);
const access = exports.access = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.access);
const stat = exports.stat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.stat);
const mkdirp = exports.mkdirp = (0, (_promise2 || _load_promise2()).promisify)(__webpack_require__(116));
const exists = exports.exists = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.exists, true);
const lstat = exports.lstat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.lstat);
const chmod = exports.chmod = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.chmod);
const link = exports.link = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.link);
const glob = exports.glob = (0, (_promise2 || _load_promise2()).promisify)((_glob || _load_glob()).default);
exports.unlink = (_fsNormalized || _load_fsNormalized()).unlink;

// fs.copyFile uses the native file copying instructions on the system, performing much better
// than any JS-based solution and consumes fewer resources. Repeated testing to fine tune the
// concurrency level revealed 128 as the sweet spot on a quad-core, 16 CPU Intel system with SSD.

const CONCURRENT_QUEUE_ITEMS = (_fs || _load_fs()).default.copyFile ? 128 : 4;

const fsSymlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.symlink);
const invariant = __webpack_require__(7);
const stripBOM = __webpack_require__(122);

const noop = () => {};

function copy(src, dest, reporter) {
  return copyBulk([{ src, dest }], reporter);
}

function _readFile(loc, encoding) {
  return new Promise((resolve, reject) => {
    (_fs || _load_fs()).default.readFile(loc, encoding, function (err, content) {
      if (err) {
        reject(err);
      } else {
        resolve(content);
      }
    });
  });
}

function readFile(loc) {
  return _readFile(loc, 'utf8').then(normalizeOS);
}

function readFileRaw(loc) {
  return _readFile(loc, 'binary');
}

function normalizeOS(body) {
  return body.replace(/\r\n/g, '\n');
}

const cr = '\r'.charCodeAt(0);
const lf = '\n'.charCodeAt(0);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPathKey = getPathKey;
const os = __webpack_require__(36);
const path = __webpack_require__(0);
const userHome = __webpack_require__(45).default;

var _require = __webpack_require__(171);

const getCacheDir = _require.getCacheDir,
      getConfigDir = _require.getConfigDir,
      getDataDir = _require.getDataDir;

const isWebpackBundle = __webpack_require__(227);

const DEPENDENCY_TYPES = exports.DEPENDENCY_TYPES = ['devDependencies', 'dependencies', 'optionalDependencies', 'peerDependencies'];
const RESOLUTIONS = exports.RESOLUTIONS = 'resolutions';
const MANIFEST_FIELDS = exports.MANIFEST_FIELDS = [RESOLUTIONS, ...DEPENDENCY_TYPES];

const SUPPORTED_NODE_VERSIONS = exports.SUPPORTED_NODE_VERSIONS = '^4.8.0 || ^5.7.0 || ^6.2.2 || >=8.0.0';

const YARN_REGISTRY = exports.YARN_REGISTRY = 'https://registry.yarnpkg.com';

const YARN_DOCS = exports.YARN_DOCS = 'https://yarnpkg.com/en/docs/cli/';
const YARN_INSTALLER_SH = exports.YARN_INSTALLER_SH = 'https://yarnpkg.com/install.sh';
const YARN_INSTALLER_MSI = exports.YARN_INSTALLER_MSI = 'https://yarnpkg.com/latest.msi';

const SELF_UPDATE_VERSION_URL = exports.SELF_UPDATE_VERSION_URL = 'https://yarnpkg.com/latest-version';

// cache version, bump whenever we make backwards incompatible changes
const CACHE_VERSION = exports.CACHE_VERSION = 2;

// lockfile version, bump whenever we make backwards incompatible changes
const LOCKFILE_VERSION = exports.LOCKFILE_VERSION = 1;

// max amount of network requests to perform concurrently
const NETWORK_CONCURRENCY = exports.NETWORK_CONCURRENCY = 8;

// HTTP timeout used when downloading packages
const NETWORK_TIMEOUT = exports.NETWORK_TIMEOUT = 30 * 1000; // in milliseconds

// max amount of child processes to execute concurrently
const CHILD_CONCURRENCY = exports.CHILD_CONCURRENCY = 5;

const REQUIRED_PACKAGE_KEYS = exports.REQUIRED_PACKAGE_KEYS = ['name', 'version', '_uid'];

function getPreferredCacheDirectories() {
  const preferredCacheDirectories = [getCacheDir()];

  if (process.getuid) {
    // $FlowFixMe: process.getuid exists, dammit
    preferredCacheDirectories.push(path.join(os.tmpdir(), `.yarn-cache-${process.getuid()}`));
  }

  preferredCacheDirectories.push(path.join(os.tmpdir(), `.yarn-cache`));

  return preferredCacheDirectories;
}

const PREFERRED_MODULE_CACHE_DIRECTORIES = exports.PREFERRED_MODULE_CACHE_DIRECTORIES = getPreferredCacheDirectories();
const CONFIG_DIRECTORY = exports.CONFIG_DIRECTORY = getConfigDir();
const DATA_DIRECTORY = exports.DATA_DIRECTORY = getDataDir();
const LINK_REGISTRY_DIRECTORY = exports.LINK_REGISTRY_DIRECTORY = path.join(DATA_DIRECTORY, 'link');
const GLOBAL_MODULE_DIRECTORY = exports.GLOBAL_MODULE_DIRECTORY = path.join(DATA_DIRECTORY, 'global');

const NODE_BIN_PATH = exports.NODE_BIN_PATH = process.execPath;
const YARN_BIN_PATH = exports.YARN_BIN_PATH = getYarnBinPath();

// Webpack needs to be configured with node.__dirname/__filename = false
function getYarnBinPath() {
  if (isWebpackBundle) {
    return __filename;
  } else {
    return path.join(__dirname, '..', 'bin', 'yarn.js');
  }
}

const NODE_MODULES_FOLDER = exports.NODE_MODULES_FOLDER = 'node_modules';
const NODE_PACKAGE_JSON = exports.NODE_PACKAGE_JSON = 'package.json';

const POSIX_GLOBAL_PREFIX = exports.POSIX_GLOBAL_PREFIX = `${process.env.DESTDIR || ''}/usr/local`;
const FALLBACK_GLOBAL_PREFIX = exports.FALLBACK_GLOBAL_PREFIX = path.join(userHome, '.yarn');

const META_FOLDER = exports.META_FOLDER = '.yarn-meta';
const INTEGRITY_FILENAME = exports.INTEGRITY_FILENAME = '.yarn-integrity';
const LOCKFILE_FILENAME = exports.LOCKFILE_FILENAME = 'yarn.lock';
const METADATA_FILENAME = exports.METADATA_FILENAME = '.yarn-metadata.json';
const TARBALL_FILENAME = exports.TARBALL_FILENAME = '.yarn-tarball.tgz';
const CLEAN_FILENAME = exports.CLEAN_FILENAME = '.yarnclean';

const NPM_LOCK_FILENAME = exports.NPM_LOCK_FILENAME = 'package-lock.json';
const NPM_SHRINKWRAP_FILENAME = exports.NPM_SHRINKWRAP_FILENAME = 'npm-shrinkwrap.json';

const DEFAULT_INDENT = exports.DEFAULT_INDENT = '  ';
const SINGLE_INSTANCE_PORT = exports.SINGLE_INSTANCE_PORT = 31997;
const SINGLE_INSTANCE_FILENAME = exports.SINGLE_INSTANCE_FILENAME = '.yarn-single-instance';

const ENV_PATH_KEY = exports.ENV_PATH_KEY = getPathKey(process.platform, process.env);

function getPathKey(platform, env) {
  let pathKey = 'PATH';

  // windows calls its path "Path" usually, but this is not guaranteed.
  if (platform === 'win32') {
    pathKey = 'Path';

    for (const key in env) {
      if (key.toLowerCase() === 'path') {
        pathKey = key;
      }
    }
  }

  return pathKey;
}

const VERSION_COLOR_SCHEME = exports.VERSION_COLOR_SCHEME = {
  major: 'red',
  premajor: 'red',
  minor: 'yellow',
  preminor: 'yellow',
  patch: 'green',
  prepatch: 'green',
  prerelease: 'red',
  unchanged: 'white',
  unknown: 'red'
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var NODE_ENV = process.env.NODE_ENV;

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),
/* 8 */,
/* 9 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sortAlpha = sortAlpha;
exports.entries = entries;
exports.removePrefix = removePrefix;
exports.removeSuffix = removeSuffix;
exports.addSuffix = addSuffix;
exports.hyphenate = hyphenate;
exports.camelCase = camelCase;
exports.compareSortedArrays = compareSortedArrays;
exports.sleep = sleep;
const _camelCase = __webpack_require__(176);

function sortAlpha(a, b) {
  // sort alphabetically in a deterministic way
  const shortLen = Math.min(a.length, b.length);
  for (let i = 0; i < shortLen; i++) {
    const aChar = a.charCodeAt(i);
    const bChar = b.charCodeAt(i);
    if (aChar !== bChar) {
      return aChar - bChar;
    }
  }
  return a.length - b.length;
}

function entries(obj) {
  const entries = [];
  if (obj) {
    for (const key in obj) {
      entries.push([key, obj[key]]);
    }
  }
  return entries;
}

function removePrefix(pattern, prefix) {
  if (pattern.startsWith(prefix)) {
    pattern = pattern.slice(prefix.length);
  }

  return pattern;
}

function removeSuffix(pattern, suffix) {
  if (pattern.endsWith(suffix)) {
    return pattern.slice(0, -suffix.length);
  }

  return pattern;
}

function addSuffix(pattern, suffix) {
  if (!pattern.endsWith(suffix)) {
    return pattern + suffix;
  }

  return pattern;
}

function hyphenate(str) {
  return str.replace(/[A-Z]/g, match => {
    return '-' + match.charAt(0).toLowerCase();
  });
}

function camelCase(str) {
  if (/[A-Z]/.test(str)) {
    return null;
  } else {
    return _camelCase(str);
  }
}

function compareSortedArrays(array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }
  for (let i = 0, len = array1.length; i < len; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}

function sleep(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(107)('wks');
var uid = __webpack_require__(111);
var Symbol = __webpack_require__(11).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stringify = exports.parse = undefined;

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));
}

var _parse;

function _load_parse() {
  return _parse = __webpack_require__(81);
}

Object.defineProperty(exports, 'parse', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_parse || _load_parse()).default;
  }
});

var _stringify;

function _load_stringify() {
  return _stringify = __webpack_require__(150);
}

Object.defineProperty(exports, 'stringify', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_stringify || _load_stringify()).default;
  }
});
exports.implodeEntry = implodeEntry;
exports.explodeEntry = explodeEntry;

var _misc;

function _load_misc() {
  return _misc = __webpack_require__(12);
}

var _normalizePattern;

function _load_normalizePattern() {
  return _normalizePattern = __webpack_require__(29);
}

var _parse2;

function _load_parse2() {
  return _parse2 = _interopRequireDefault(__webpack_require__(81));
}

var _constants;

function _load_constants() {
  return _constants = __webpack_require__(6);
}

var _fs;

function _load_fs() {
  return _fs = _interopRequireWildcard(__webpack_require__(5));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const invariant = __webpack_require__(7);

const path = __webpack_require__(0);
const ssri = __webpack_require__(55);

function getName(pattern) {
  return (0, (_normalizePattern || _load_normalizePattern()).normalizePattern)(pattern).name;
}

function blankObjectUndefined(obj) {
  return obj && Object.keys(obj).length ? obj : undefined;
}

function keyForRemote(remote) {
  return remote.resolved || (remote.reference && remote.hash ? `${remote.reference}#${remote.hash}` : null);
}

function serializeIntegrity(integrity) {
  // We need this because `Integrity.toString()` does not use sorting to ensure a stable string output
  // See https://git.io/vx2Hy
  return integrity.toString().split(' ').sort().join(' ');
}

function implodeEntry(pattern, obj) {
  const inferredName = getName(pattern);
  const integrity = obj.integrity ? serializeIntegrity(obj.integrity) : '';
  const imploded = {
    name: inferredName === obj.name ? undefined : obj.name,
    version: obj.version,
    uid: obj.uid === obj.version ? undefined : obj.uid,
    resolved: obj.resolved,
    registry: obj.registry === 'npm' ? undefined : obj.registry,
    dependencies: blankObjectUndefined(obj.dependencies),
    optionalDependencies: blankObjectUndefined(obj.optionalDependencies),
    permissions: blankObjectUndefined(obj.permissions),
    prebuiltVariants: blankObjectUndefined(obj.prebuiltVariants)
  };
  if (integrity) {
    imploded.integrity = integrity;
  }
  return imploded;
}

function explodeEntry(pattern, obj) {
  obj.optionalDependencies = obj.optionalDependencies || {};
  obj.dependencies = obj.dependencies || {};
  obj.uid = obj.uid || obj.version;
  obj.permissions = obj.permissions || {};
  obj.registry = obj.registry || 'npm';
  obj.name = obj.name || getName(pattern);
  const integrity = obj.integrity;
  if (integrity && integrity.isIntegrity) {
    obj.integrity = ssri.parse(integrity);
  }
  return obj;
}

class Lockfile {
  constructor({ cache, source, parseResultType } = {}) {
    this.source = source || '';
    this.cache = cache;
    this.parseResultType = parseResultType;
  }

  // source string if the `cache` was parsed


  // if true, we're parsing an old yarn file and need to update integrity fields
  hasEntriesExistWithoutIntegrity() {
    if (!this.cache) {
      return false;
    }

    for (const key in this.cache) {
      // $FlowFixMe - `this.cache` is clearly defined at this point
      if (!/^.*@(file:|http)/.test(key) && this.cache[key] && !this.cache[key].integrity) {
        return true;
      }
    }

    return false;
  }

  static fromDirectory(dir, reporter) {
    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      // read the manifest in this directory
      const lockfileLoc = path.join(dir, (_constants || _load_constants()).LOCKFILE_FILENAME);

      let lockfile;
      let rawLockfile = '';
      let parseResult;

      if (yield (_fs || _load_fs()).exists(lockfileLoc)) {
        rawLockfile = yield (_fs || _load_fs()).readFile(lockfileLoc);
        parseResult = (0, (_parse2 || _load_parse2()).default)(rawLockfile, lockfileLoc);

        if (reporter) {
          if (parseResult.type === 'merge') {
            reporter.info(reporter.lang('lockfileMerged'));
          } else if (parseResult.type === 'conflict') {
            reporter.warn(reporter.lang('lockfileConflict'));
          }
        }

        lockfile = parseResult.object;
      } else if (reporter) {
        reporter.info(reporter.lang('noLockfileFound'));
      }

      return new Lockfile({ cache: lockfile, source: rawLockfile, parseResultType: parseResult && parseResult.type });
    })();
  }

  getLocked(pattern) {
    const cache = this.cache;
    if (!cache) {
      return undefined;
    }

    const shrunk = pattern in cache && cache[pattern];

    if (typeof shrunk === 'string') {
      return this.getLocked(shrunk);
    } else if (shrunk) {
      explodeEntry(pattern, shrunk);
      return shrunk;
    }

    return undefined;
  }

  removePattern(pattern) {
    const cache = this.cache;
    if (!cache) {
      return;
    }
    delete cache[pattern];
  }

  getLockfile(patterns) {
    const lockfile = {};
    const seen = new Map();

    // order by name so that lockfile manifest is assigned to the first dependency with this manifest
    // the others that have the same remoteKey will just refer to the first
    // ordering allows for consistency in lockfile when it is serialized
    const sortedPatternsKeys = Object.keys(patterns).sort((_misc || _load_misc()).sortAlpha);

    for (var _iterator = sortedPatternsKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      const pattern = _ref;

      const pkg = patterns[pattern];
      const remote = pkg._remote,
            ref = pkg._reference;

      invariant(ref, 'Package is missing a reference');
      invariant(remote, 'Package is missing a remote');

      const remoteKey = keyForRemote(remote);
      const seenPattern = remoteKey && seen.get(remoteKey);
      if (seenPattern) {
        // no point in duplicating it
        lockfile[pattern] = seenPattern;

        // if we're relying on our name being inferred and two of the patterns have
        // different inferred names then we need to set it
        if (!seenPattern.name && getName(pattern) !== pkg.name) {
          seenPattern.name = pkg.name;
        }
        continue;
      }
      const obj = implodeEntry(pattern, {
        name: pkg.name,
        version: pkg.version,
        uid: pkg._uid,
        resolved: remote.resolved,
        integrity: remote.integrity,
        registry: remote.registry,
        dependencies: pkg.dependencies,
        peerDependencies: pkg.peerDependencies,
        optionalDependencies: pkg.optionalDependencies,
        permissions: ref.permissions,
        prebuiltVariants: pkg.prebuiltVariants
      });

      lockfile[pattern] = obj;

      if (remoteKey) {
        seen.set(remoteKey, obj);
      }
    }

    return lockfile;
  }
}
exports.default = Lockfile;

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 18 */,
/* 19 */,
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nullify;
function nullify(obj = {}) {
  if (Array.isArray(obj)) {
    for (var _iterator = obj, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      const item = _ref;

      nullify(item);
    }
  } else if (obj !== null && typeof obj === 'object' || typeof obj === 'function') {
    Object.setPrototypeOf(obj, null);

    // for..in can only be applied to 'object', not 'function'
    if (typeof obj === 'object') {
      for (const key in obj) {
        nullify(obj[key]);
      }
    }
  }

  return obj;
}

/***/ }),
/* 21 */,
/* 22 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(34);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 28 */,
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizePattern = normalizePattern;

/**
 * Explode and normalize a pattern into its name and range.
 */

function normalizePattern(pattern) {
  let hasVersion = false;
  let range = 'latest';
  let name = pattern;

  // if we're a scope then remove the @ and add it back later
  let isScoped = false;
  if (name[0] === '@') {
    isScoped = true;
    name = name.slice(1);
  }

  // take first part as the name
  const parts = name.split('@');
  if (parts.length > 1) {
    name = parts.shift();
    range = parts.join('@');

    if (range) {
      hasVersion = true;
    } else {
      range = '*';
    }
  }

  // add back @ scope suffix
  if (isScoped) {
    name = `@${name}`;
  }

  return { name, range, hasVersion };
}

/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(50);
var createDesc = __webpack_require__(106);
module.exports = __webpack_require__(33) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(63)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(85)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wait = wait;
exports.promisify = promisify;
exports.queue = queue;
function wait(delay) {
  return new Promise(resolve => {
    setTimeout(resolve, delay);
  });
}

function promisify(fn, firstData) {
  return function (...args) {
    return new Promise(function (resolve, reject) {
      args.push(function (err, ...result) {
        let res = result;

        if (result.length <= 1) {
          res = result[0];
        }

        if (firstData) {
          res = err;
          err = null;
        }

        if (err) {
          reject(err);
        } else {
          resolve(res);
        }
      });

      fn.apply(null, args);
    });
  };
}

function queue(arr, promiseProducer, concurrency = Infinity) {
  concurrency = Math.min(concurrency, arr.length);

  // clone
  arr = arr.slice();

  const results = [];
  let total = arr.length;
  if (!total) {
    return Promise.resolve(results);
  }

  return new Promise((resolve, reject) => {
    for (let i = 0; i < concurrency; i++) {
      next();
    }

    function next() {
      const item = arr.shift();
      const promise = promiseProducer(item);

      promise.then(function (result) {
        results.push(result);

        total--;
        if (total === 0) {
          resolve(results);
        } else {
          if (arr.length) {
            next();
          }
        }
      }, reject);
    }
  });
}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(11);
var core = __webpack_require__(23);
var ctx = __webpack_require__(48);
var hide = __webpack_require__(31);
var has = __webpack_require__(49);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(2);
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(224);
}


/***/ }),
/* 43 */,
/* 44 */,
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.home = undefined;

var _rootUser;

function _load_rootUser() {
  return _rootUser = _interopRequireDefault(__webpack_require__(169));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const path = __webpack_require__(0);

const home = exports.home = __webpack_require__(36).homedir();

const userHomeDir = (_rootUser || _load_rootUser()).default ? path.resolve('/usr/local/share') : home;

exports.default = userHomeDir;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 47 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(46);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(27);
var IE8_DOM_DEFINE = __webpack_require__(184);
var toPrimitive = __webpack_require__(201);
var dP = Object.defineProperty;

exports.f = __webpack_require__(33) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Buffer = __webpack_require__(32).Buffer

const crypto = __webpack_require__(9)
const Transform = __webpack_require__(17).Transform

const SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']

const BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i
const SRI_REGEX = /^([^-]+)-([^?]+)([?\S*]*)$/
const STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)*$/
const VCHAR_REGEX = /^[\x21-\x7E]+$/

class Hash {
  get isHash () { return true }
  constructor (hash, opts) {
    const strict = !!(opts && opts.strict)
    this.source = hash.trim()
    // 3.1. Integrity metadata (called "Hash" by ssri)
    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description
    const match = this.source.match(
      strict
      ? STRICT_SRI_REGEX
      : SRI_REGEX
    )
    if (!match) { return }
    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }
    this.algorithm = match[1]
    this.digest = match[2]

    const rawOpts = match[3]
    this.options = rawOpts ? rawOpts.slice(1).split('?') : []
  }
  hexDigest () {
    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')
  }
  toJSON () {
    return this.toString()
  }
  toString (opts) {
    if (opts && opts.strict) {
      // Strict mode enforces the standard as close to the foot of the
      // letter as it can.
      if (!(
        // The spec has very restricted productions for algorithms.
        // https://www.w3.org/TR/CSP2/#source-list-syntax
        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&
        // Usually, if someone insists on using a "different" base64, we
        // leave it as-is, since there's multiple standards, and the
        // specified is not a URL-safe variant.
        // https://www.w3.org/TR/CSP2/#base64_value
        this.digest.match(BASE64_REGEX) &&
        // Option syntax is strictly visual chars.
        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression
        // https://tools.ietf.org/html/rfc5234#appendix-B.1
        (this.options || []).every(opt => opt.match(VCHAR_REGEX))
      )) {
        return ''
      }
    }
    const options = this.options && this.options.length
    ? `?${this.options.join('?')}`
    : ''
    return `${this.algorithm}-${this.digest}${options}`
  }
}

class Integrity {
  get isIntegrity () { return true }
  toJSON () {
    return this.toString()
  }
  toString (opts) {
    opts = opts || {}
    let sep = opts.sep || ' '
    if (opts.strict) {
      // Entries must be separated by whitespace, according to spec.
      sep = sep.replace(/\S+/g, ' ')
    }
    return Object.keys(this).map(k => {
      return this[k].map(hash => {
        return Hash.prototype.toString.call(hash, opts)
      }).filter(x => x.length).join(sep)
    }).filter(x => x.length).join(sep)
  }
  concat (integrity, opts) {
    const other = typeof integrity === 'string'
    ? integrity
    : stringify(integrity, opts)
    return parse(`${this.toString(opts)} ${other}`, opts)
  }
  hexDigest () {
    return parse(this, {single: true}).hexDigest()
  }
  match (integrity, opts) {
    const other = parse(integrity, opts)
    const algo = other.pickAlgorithm(opts)
    return (
      this[algo] &&
      other[algo] &&
      this[algo].find(hash =>
        other[algo].find(otherhash =>
          hash.digest === otherhash.digest
        )
      )
    ) || false
  }
  pickAlgorithm (opts) {
    const pickAlgorithm = (opts && opts.pickAlgorithm) || getPrioritizedHash
    const keys = Object.keys(this)
    if (!keys.length) {
      throw new Error(`No algorithms available for ${
        JSON.stringify(this.toString())
      }`)
    }
    return keys.reduce((acc, algo) => {
      return pickAlgorithm(acc, algo) || acc
    })
  }
}

module.exports.parse = parse
function parse (sri, opts) {
  opts = opts || {}
  if (typeof sri === 'string') {
    return _parse(sri, opts)
  } else if (sri.algorithm && sri.digest) {
    const fullSri = new Integrity()
    fullSri[sri.algorithm] = [sri]
    return _parse(stringify(fullSri, opts), opts)
  } else {
    return _parse(stringify(sri, opts), opts)
  }
}

function _parse (integrity, opts) {
  // 3.4.3. Parse metadata
  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
  if (opts.single) {
    return new Hash(integrity, opts)
  }
  return integrity.trim().split(/\s+/).reduce((acc, string) => {
    const hash = new Hash(string, opts)
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      if (!acc[algo]) { acc[algo] = [] }
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

module.exports.stringify = stringify
function stringify (obj, opts) {
  if (obj.algorithm && obj.digest) {
    return Hash.prototype.toString.call(obj, opts)
  } else if (typeof obj === 'string') {
    return stringify(parse(obj, opts), opts)
  } else {
    return Integrity.prototype.toString.call(obj, opts)
  }
}

module.exports.fromHex = fromHex
function fromHex (hexDigest, algorithm, opts) {
  const optString = (opts && opts.options && opts.options.length)
  ? `?${opts.options.join('?')}`
  : ''
  return parse(
    `${algorithm}-${
      Buffer.from(hexDigest, 'hex').toString('base64')
    }${optString}`, opts
  )
}

module.exports.fromData = fromData
function fromData (data, opts) {
  opts = opts || {}
  const algorithms = opts.algorithms || ['sha512']
  const optString = opts.options && opts.options.length
  ? `?${opts.options.join('?')}`
  : ''
  return algorithms.reduce((acc, algo) => {
    const digest = crypto.createHash(algo).update(data).digest('base64')
    const hash = new Hash(
      `${algo}-${digest}${optString}`,
       opts
    )
    if (hash.algorithm && hash.digest) {
      const algo = hash.algorithm
      if (!acc[algo]) { acc[algo] = [] }
      acc[algo].push(hash)
    }
    return acc
  }, new Integrity())
}

module.exports.fromStream = fromStream
function fromStream (stream, opts) {
  opts = opts || {}
  const P = opts.Promise || Promise
  const istream = integrityStream(opts)
  return new P((resolve, reject) => {
    stream.pipe(istream)
    stream.on('error', reject)
    istream.on('error', reject)
    let sri
    istream.on('integrity', s => { sri = s })
    istream.on('end', () => resolve(sri))
    istream.on('data', () => {})
  })
}

module.exports.checkData = checkData
function checkData (data, sri, opts) {
  opts = opts || {}
  sri = parse(sri, opts)
  if (!Object.keys(sri).length) {
    if (opts.error) {
      throw Object.assign(
        new Error('No valid integrity hashes to check against'), {
          code: 'EINTEGRITY'
        }
      )
    } else {
      return false
    }
  }
  const algorithm = sri.pickAlgorithm(opts)
  const digest = crypto.createHash(algorithm).update(data).digest('base64')
  const newSri = parse({algorithm, digest})
  const match = newSri.match(sri, opts)
  if (match || !opts.error) {
    return match
  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {
    const err = new Error(`data size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${data.length}`)
    err.code = 'EBADSIZE'
    err.found = data.length
    err.expected = opts.size
    err.sri = sri
    throw err
  } else {
    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)
    err.code = 'EINTEGRITY'
    err.found = newSri
    err.expected = sri
    err.algorithm = algorithm
    err.sri = sri
    throw err
  }
}

module.exports.checkStream = checkStream
function checkStream (stream, sri, opts) {
  opts = opts || {}
  const P = opts.Promise || Promise
  const checker = integrityStream(Object.assign({}, opts, {
    integrity: sri
  }))
  return new P((resolve, reject) => {
    stream.pipe(checker)
    stream.on('error', reject)
    checker.on('error', reject)
    let sri
    checker.on('verified', s => { sri = s })
    checker.on('end', () => resolve(sri))
    checker.on('data', () => {})
  })
}

module.exports.integrityStream = integrityStream
function integrityStream (opts) {
  opts = opts || {}
  // For verification
  const sri = opts.integrity && parse(opts.integrity, opts)
  const goodSri = sri && Object.keys(sri).length
  const algorithm = goodSri && sri.pickAlgorithm(opts)
  const digests = goodSri && sri[algorithm]
  // Calculating stream
  const algorithms = Array.from(
    new Set(
      (opts.algorithms || ['sha512'])
      .concat(algorithm ? [algorithm] : [])
    )
  )
  const hashes = algorithms.map(crypto.createHash)
  let streamSize = 0
  const stream = new Transform({
    transform (chunk, enc, cb) {
      streamSize += chunk.length
      hashes.forEach(h => h.update(chunk, enc))
      cb(null, chunk, enc)
    }
  }).on('end', () => {
    const optString = (opts.options && opts.options.length)
    ? `?${opts.options.join('?')}`
    : ''
    const newSri = parse(hashes.map((h, i) => {
      return `${algorithms[i]}-${h.digest('base64')}${optString}`
    }).join(' '), opts)
    // Integrity verification mode
    const match = goodSri && newSri.match(sri, opts)
    if (typeof opts.size === 'number' && streamSize !== opts.size) {
      const err = new Error(`stream size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${streamSize}`)
      err.code = 'EBADSIZE'
      err.found = streamSize
      err.expected = opts.size
      err.sri = sri
      stream.emit('error', err)
    } else if (opts.integrity && !match) {
      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)
      err.code = 'EINTEGRITY'
      err.found = newSri
      err.expected = digests
      err.algorithm = algorithm
      err.sri = sri
      stream.emit('error', err)
    } else {
      stream.emit('size', streamSize)
      stream.emit('integrity', newSri)
      match && stream.emit('verified', match)
    }
  })
  return stream
}

module.exports.create = createIntegrity
function createIntegrity (opts) {
  opts = opts || {}
  const algorithms = opts.algorithms || ['sha512']
  const optString = opts.options && opts.options.length
  ? `?${opts.options.join('?')}`
  : ''

  const hashes = algorithms.map(crypto.createHash)

  return {
    update: function (chunk, enc) {
      hashes.forEach(h => h.update(chunk, enc))
      return this
    },
    digest: function (enc) {
      const integrity = algorithms.reduce((acc, algo) => {
        const digest = hashes.shift().digest('base64')
        const hash = new Hash(
          `${algo}-${digest}${optString}`,
          opts
        )
        if (hash.algorithm && hash.digest) {
          const algo = hash.algorithm
          if (!acc[algo]) { acc[algo] = [] }
          acc[algo].push(hash)
        }
        return acc
      }, new Integrity())

      return integrity
    }
  }
}

const NODE_HASHES = new Set(crypto.getHashes())

// This is a Best Effort at a reasonable priority for hash algos
const DEFAULT_PRIORITY = [
  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',
  // TODO - it's unclear _which_ of these Node will actually use as its name
  //        for the algorithm, so we guesswork it based on the OpenSSL names.
  'sha3',
  'sha3-256', 'sha3-384', 'sha3-512',
  'sha3_256', 'sha3_384', 'sha3_512'
].filter(algo => NODE_HASHES.has(algo))

function getPrioritizedHash (algo1, algo2) {
  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())
  ? algo1
  : algo2
}


/***/ }),
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(0)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(175)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(123)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),
/* 62 */,
/* 63 */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(34);
var document = __webpack_require__(11).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(46);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(50).f;
var has = __webpack_require__(49);
var TAG = __webpack_require__(13)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(107)('keys');
var uid = __webpack_require__(111);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 73 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(131);
var defined = __webpack_require__(67);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __webpack_require__(3)
var rp = __webpack_require__(114)
var minimatch = __webpack_require__(60)
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(42)
var EE = __webpack_require__(54).EventEmitter
var path = __webpack_require__(0)
var assert = __webpack_require__(22)
var isAbsolute = __webpack_require__(76)
var globSync = __webpack_require__(218)
var common = __webpack_require__(115)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(223)
var util = __webpack_require__(2)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(61)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),
/* 77 */,
/* 78 */,
/* 79 */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),
/* 80 */,
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (str, fileLoc = 'lockfile') {
  str = (0, (_stripBom || _load_stripBom()).default)(str);
  return hasMergeConflicts(str) ? parseWithConflict(str, fileLoc) : { type: 'success', object: parse(str, fileLoc) };
};

var _util;

function _load_util() {
  return _util = _interopRequireDefault(__webpack_require__(2));
}

var _invariant;

function _load_invariant() {
  return _invariant = _interopRequireDefault(__webpack_require__(7));
}

var _stripBom;

function _load_stripBom() {
  return _stripBom = _interopRequireDefault(__webpack_require__(122));
}

var _constants;

function _load_constants() {
  return _constants = __webpack_require__(6);
}

var _errors;

function _load_errors() {
  return _errors = __webpack_require__(4);
}

var _map;

function _load_map() {
  return _map = _interopRequireDefault(__webpack_require__(20));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint quotes: 0 */

const VERSION_REGEX = /^yarn lockfile v(\d+)$/;

const TOKEN_TYPES = {
  boolean: 'BOOLEAN',
  string: 'STRING',
  identifier: 'IDENTIFIER',
  eof: 'EOF',
  colon: 'COLON',
  newline: 'NEWLINE',
  comment: 'COMMENT',
  indent: 'INDENT',
  invalid: 'INVALID',
  number: 'NUMBER',
  comma: 'COMMA'
};

const VALID_PROP_VALUE_TOKENS = [TOKEN_TYPES.boolean, TOKEN_TYPES.string, TOKEN_TYPES.number];

function isValidPropValueToken(token) {
  return VALID_PROP_VALUE_TOKENS.indexOf(token.type) >= 0;
}

function* tokenise(input) {
  let lastNewline = false;
  let line = 1;
  let col = 0;

  function buildToken(type, value) {
    return { line, col, type, value };
  }

  while (input.length) {
    let chop = 0;

    if (input[0] === '\n' || input[0] === '\r') {
      chop++;
      // If this is a \r\n line, ignore both chars but only add one new line
      if (input[1] === '\n') {
        chop++;
      }
      line++;
      col = 0;
      yield buildToken(TOKEN_TYPES.newline);
    } else if (input[0] === '#') {
      chop++;

      let val = '';
      while (input[chop] !== '\n') {
        val += input[chop];
        chop++;
      }
      yield buildToken(TOKEN_TYPES.comment, val);
    } else if (input[0] === ' ') {
      if (lastNewline) {
        let indent = '';
        for (let i = 0; input[i] === ' '; i++) {
          indent += input[i];
        }

        if (indent.length % 2) {
          throw new TypeError('Invalid number of spaces');
        } else {
          chop = indent.length;
          yield buildToken(TOKEN_TYPES.indent, indent.length / 2);
        }
      } else {
        chop++;
      }
    } else if (input[0] === '"') {
      let val = '';

      for (let i = 0;; i++) {
        const currentChar = input[i];
        val += currentChar;

        if (i > 0 && currentChar === '"') {
          const isEscaped = input[i - 1] === '\\' && input[i - 2] !== '\\';
          if (!isEscaped) {
            break;
          }
        }
      }

      chop = val.length;

      try {
        yield buildToken(TOKEN_TYPES.string, JSON.parse(val));
      } catch (err) {
        if (err instanceof SyntaxError) {
          yield buildToken(TOKEN_TYPES.invalid);
        } else {
          throw err;
        }
      }
    } else if (/^[0-9]/.test(input)) {
      let val = '';
      for (let i = 0; /^[0-9]$/.test(input[i]); i++) {
        val += input[i];
      }
      chop = val.length;

      yield buildToken(TOKEN_TYPES.number, +val);
    } else if (/^true/.test(input)) {
      yield buildToken(TOKEN_TYPES.boolean, true);
      chop = 4;
    } else if (/^false/.test(input)) {
      yield buildToken(TOKEN_TYPES.boolean, false);
      chop = 5;
    } else if (input[0] === ':') {
      yield buildToken(TOKEN_TYPES.colon);
      chop++;
    } else if (input[0] === ',') {
      yield buildToken(TOKEN_TYPES.comma);
      chop++;
    } else if (/^[a-zA-Z\/-]/g.test(input)) {
      let name = '';
      for (let i = 0; i < input.length; i++) {
        const char = input[i];
        if (char === ':' || char === ' ' || char === '\n' || char === '\r' || char === ',') {
          break;
        } else {
          name += char;
        }
      }
      chop = name.length;

      yield buildToken(TOKEN_TYPES.string, name);
    } else {
      yield buildToken(TOKEN_TYPES.invalid);
    }

    if (!chop) {
      // will trigger infinite recursion
      yield buildToken(TOKEN_TYPES.invalid);
    }

    col += chop;
    lastNewline = input[0] === '\n' || input[0] === '\r' && input[1] === '\n';
    input = input.slice(chop);
  }

  yield buildToken(TOKEN_TYPES.eof);
}

class Parser {
  constructor(input, fileLoc = 'lockfile') {
    this.comments = [];
    this.tokens = tokenise(input);
    this.fileLoc = fileLoc;
  }

  onComment(token) {
    const value = token.value;
    (0, (_invariant || _load_invariant()).default)(typeof value === 'string', 'expected token value to be a string');

    const comment = value.trim();

    const versionMatch = comment.match(VERSION_REGEX);
    if (versionMatch) {
      const version = +versionMatch[1];
      if (version > (_constants || _load_constants()).LOCKFILE_VERSION) {
        throw new (_errors || _load_errors()).MessageError(`Can't install from a lockfile of version ${version} as you're on an old yarn version that only supports ` + `versions up to ${(_constants || _load_constants()).LOCKFILE_VERSION}. Run \`$ yarn self-update\` to upgrade to the latest version.`);
      }
    }

    this.comments.push(comment);
  }

  next() {
    const item = this.tokens.next();
    (0, (_invariant || _load_invariant()).default)(item, 'expected a token');

    const done = item.done,
          value = item.value;

    if (done || !value) {
      throw new Error('No more tokens');
    } else if (value.type === TOKEN_TYPES.comment) {
      this.onComment(value);
      return this.next();
    } else {
      return this.token = value;
    }
  }

  unexpected(msg = 'Unexpected token') {
    throw new SyntaxError(`${msg} ${this.token.line}:${this.token.col} in ${this.fileLoc}`);
  }

  expect(tokType) {
    if (this.token.type === tokType) {
      this.next();
    } else {
      this.unexpected();
    }
  }

  eat(tokType) {
    if (this.token.type === tokType) {
      this.next();
      return true;
    } else {
      return false;
    }
  }

  parse(indent = 0) {
    const obj = (0, (_map || _load_map()).default)();

    while (true) {
      const propToken = this.token;

      if (propToken.type === TOKEN_TYPES.newline) {
        const nextToken = this.next();
        if (!indent) {
          // if we have 0 indentation then the next token doesn't matter
          continue;
        }

        if (nextToken.type !== TOKEN_TYPES.indent) {
          // if we have no indentation after a newline then we've gone down a level
          break;
        }

        if (nextToken.value === indent) {
          // all is good, the indent is on our level
          this.next();
        } else {
          // the indentation is less than our level
          break;
        }
      } else if (propToken.type === TOKEN_TYPES.indent) {
        if (propToken.value === indent) {
          this.next();
        } else {
          break;
        }
      } else if (propToken.type === TOKEN_TYPES.eof) {
        break;
      } else if (propToken.type === TOKEN_TYPES.string) {
        // property key
        const key = propToken.value;
        (0, (_invariant || _load_invariant()).default)(key, 'Expected a key');

        const keys = [key];
        this.next();

        // support multiple keys
        while (this.token.type === TOKEN_TYPES.comma) {
          this.next(); // skip comma

          const keyToken = this.token;
          if (keyToken.type !== TOKEN_TYPES.string) {
            this.unexpected('Expected string');
          }

          const key = keyToken.value;
          (0, (_invariant || _load_invariant()).default)(key, 'Expected a key');
          keys.push(key);
          this.next();
        }

        const valToken = this.token;

        if (valToken.type === TOKEN_TYPES.colon) {
          // object
          this.next();

          // parse object
          const val = this.parse(indent + 1);

          for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
              if (_i >= _iterator.length) break;
              _ref = _iterator[_i++];
            } else {
              _i = _iterator.next();
              if (_i.done) break;
              _ref = _i.value;
            }

            const key = _ref;

            obj[key] = val;
          }

          if (indent && this.token.type !== TOKEN_TYPES.indent) {
            break;
          }
        } else if (isValidPropValueToken(valToken)) {
          // plain value
          for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
              if (_i2 >= _iterator2.length) break;
              _ref2 = _iterator2[_i2++];
            } else {
              _i2 = _iterator2.next();
              if (_i2.done) break;
              _ref2 = _i2.value;
            }

            const key = _ref2;

            obj[key] = valToken.value;
          }

          this.next();
        } else {
          this.unexpected('Invalid value type');
        }
      } else {
        this.unexpected(`Unknown token: ${(_util || _load_util()).default.inspect(propToken)}`);
      }
    }

    return obj;
  }
}

const MERGE_CONFLICT_ANCESTOR = '|||||||';
const MERGE_CONFLICT_END = '>>>>>>>';
const MERGE_CONFLICT_SEP = '=======';
const MERGE_CONFLICT_START = '<<<<<<<';

/**
 * Extract the two versions of the lockfile from a merge conflict.
 */
function extractConflictVariants(str) {
  const variants = [[], []];
  const lines = str.split(/\r?\n/g);
  let skip = false;

  while (lines.length) {
    const line = lines.shift();
    if (line.startsWith(MERGE_CONFLICT_START)) {
      // get the first variant
      while (lines.length) {
        const conflictLine = lines.shift();
        if (conflictLine === MERGE_CONFLICT_SEP) {
          skip = false;
          break;
        } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR)) {
          skip = true;
          continue;
        } else {
          variants[0].push(conflictLine);
        }
      }

      // get the second variant
      while (lines.length) {
        const conflictLine = lines.shift();
        if (conflictLine.startsWith(MERGE_CONFLICT_END)) {
          break;
        } else {
          variants[1].push(conflictLine);
        }
      }
    } else {
      variants[0].push(line);
      variants[1].push(line);
    }
  }

  return [variants[0].join('\n'), variants[1].join('\n')];
}

/**
 * Check if a lockfile has merge conflicts.
 */
function hasMergeConflicts(str) {
  return str.includes(MERGE_CONFLICT_START) && str.includes(MERGE_CONFLICT_SEP) && str.includes(MERGE_CONFLICT_END);
}

/**
 * Parse the lockfile.
 */
function parse(str, fileLoc) {
  const parser = new Parser(str, fileLoc);
  parser.next();
  return parser.parse();
}

/**
 * Parse and merge the two variants in a conflicted lockfile.
 */
function parseWithConflict(str, fileLoc) {
  const variants = extractConflictVariants(str);
  try {
    return { type: 'merge', object: Object.assign({}, parse(variants[0], fileLoc), parse(variants[1], fileLoc)) };
  } catch (err) {
    if (err instanceof SyntaxError) {
      return { type: 'conflict', object: {} };
    } else {
      throw err;
    }
  }
}

/***/ }),
/* 82 */,
/* 83 */,
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map;

function _load_map() {
  return _map = _interopRequireDefault(__webpack_require__(20));
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = __webpack_require__(212)('yarn');

class BlockingQueue {
  constructor(alias, maxConcurrency = Infinity) {
    this.concurrencyQueue = [];
    this.maxConcurrency = maxConcurrency;
    this.runningCount = 0;
    this.warnedStuck = false;
    this.alias = alias;
    this.first = true;

    this.running = (0, (_map || _load_map()).default)();
    this.queue = (0, (_map || _load_map()).default)();

    this.stuckTick = this.stuckTick.bind(this);
  }

  stillActive() {
    if (this.stuckTimer) {
      clearTimeout(this.stuckTimer);
    }

    this.stuckTimer = setTimeout(this.stuckTick, 5000);

    // We need to check the existence of unref because of https://github.com/facebook/jest/issues/4559
    // $FlowFixMe: Node's setInterval returns a Timeout, not a Number
    this.stuckTimer.unref && this.stuckTimer.unref();
  }

  stuckTick() {
    if (this.runningCount === 1) {
      this.warnedStuck = true;
      debug(`The ${JSON.stringify(this.alias)} blocking queue may be stuck. 5 seconds ` + `without any activity with 1 worker: ${Object.keys(this.running)[0]}`);
    }
  }

  push(key, factory) {
    if (this.first) {
      this.first = false;
    } else {
      this.stillActive();
    }

    return new Promise((resolve, reject) => {
      // we're already running so push ourselves to the queue
      const queue = this.queue[key] = this.queue[key] || [];
      queue.push({ factory, resolve, reject });

      if (!this.running[key]) {
        this.shift(key);
      }
    });
  }

  shift(key) {
    if (this.running[key]) {
      delete this.running[key];
      this.runningCount--;

      if (this.stuckTimer) {
        clearTimeout(this.stuckTimer);
        this.stuckTimer = null;
      }

      if (this.warnedStuck) {
        this.warnedStuck = false;
        debug(`${JSON.stringify(this.alias)} blocking queue finally resolved. Nothing to worry about.`);
      }
    }

    const queue = this.queue[key];
    if (!queue) {
      return;
    }

    var _queue$shift = queue.shift();

    const resolve = _queue$shift.resolve,
          reject = _queue$shift.reject,
          factory = _queue$shift.factory;

    if (!queue.length) {
      delete this.queue[key];
    }

    const next = () => {
      this.shift(key);
      this.shiftConcurrencyQueue();
    };

    const run = () => {
      this.running[key] = true;
      this.runningCount++;

      factory().then(function (val) {
        resolve(val);
        next();
        return null;
      }).catch(function (err) {
        reject(err);
        next();
      });
    };

    this.maybePushConcurrencyQueue(run);
  }

  maybePushConcurrencyQueue(run) {
    if (this.runningCount < this.maxConcurrency) {
      run();
    } else {
      this.concurrencyQueue.push(run);
    }
  }

  shiftConcurrencyQueue() {
    if (this.runningCount < this.maxConcurrency) {
      const fn = this.concurrencyQueue.shift();
      if (fn) {
        fn();
      }
    }
  }
}
exports.default = BlockingQueue;

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(47);
var TAG = __webpack_require__(13)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 101 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(11).document;
module.exports = document && document.documentElement;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(69);
var $export = __webpack_require__(41);
var redefine = __webpack_require__(197);
var hide = __webpack_require__(31);
var Iterators = __webpack_require__(35);
var $iterCreate = __webpack_require__(188);
var setToStringTag = __webpack_require__(71);
var getPrototypeOf = __webpack_require__(194);
var ITERATOR = __webpack_require__(13)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(27);
var isObject = __webpack_require__(34);
var newPromiseCapability = __webpack_require__(70);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(23);
var global = __webpack_require__(11);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(69) ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(27);
var aFunction = __webpack_require__(46);
var SPECIES = __webpack_require__(13)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(48);
var invoke = __webpack_require__(185);
var html = __webpack_require__(102);
var cel = __webpack_require__(68);
var global = __webpack_require__(11);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(47)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(73);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 111 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(229);

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 113 */,
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __webpack_require__(3)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __webpack_require__(217)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __webpack_require__(0)
var minimatch = __webpack_require__(60)
var isAbsolute = __webpack_require__(76)
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(0);
var fs = __webpack_require__(3);
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = x => {
	if (typeof x !== 'string') {
		throw new TypeError('Expected a string, got ' + typeof x);
	}

	// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
	// conversion translates it to FEFF (UTF-16 BOM)
	if (x.charCodeAt(0) === 0xFEFF) {
		return x.slice(1);
	}

	return x;
};


/***/ }),
/* 123 */
/***/ (function(module, exports) {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(47);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(195);
var enumBugKeys = __webpack_require__(101);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(67);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */
/***/ (function(module, exports) {

module.exports = {"name":"yarn","installationMethod":"unknown","version":"1.10.0-0","license":"BSD-2-Clause","preferGlobal":true,"description":" Fast, reliable, and secure dependency management.","dependencies":{"@zkochan/cmd-shim":"^2.2.4","babel-runtime":"^6.26.0","bytes":"^3.0.0","camelcase":"^4.0.0","chalk":"^2.1.0","commander":"^2.9.0","death":"^1.0.0","debug":"^3.0.0","deep-equal":"^1.0.1","detect-indent":"^5.0.0","dnscache":"^1.0.1","glob":"^7.1.1","gunzip-maybe":"^1.4.0","hash-for-dep":"^1.2.3","imports-loader":"^0.8.0","ini":"^1.3.4","inquirer":"^3.0.1","invariant":"^2.2.0","is-builtin-module":"^2.0.0","is-ci":"^1.0.10","is-webpack-bundle":"^1.0.0","leven":"^2.0.0","loud-rejection":"^1.2.0","micromatch":"^2.3.11","mkdirp":"^0.5.1","node-emoji":"^1.6.1","normalize-url":"^2.0.0","npm-logical-tree":"^1.2.1","object-path":"^0.11.2","proper-lockfile":"^2.0.0","puka":"^1.0.0","read":"^1.0.7","request":"^2.87.0","request-capture-har":"^1.2.2","rimraf":"^2.5.0","semver":"^5.1.0","ssri":"^5.3.0","strip-ansi":"^4.0.0","strip-bom":"^3.0.0","tar-fs":"^1.16.0","tar-stream":"^1.6.1","uuid":"^3.0.1","v8-compile-cache":"^2.0.0","validate-npm-package-license":"^3.0.3","yn":"^2.0.0"},"devDependencies":{"babel-core":"^6.26.0","babel-eslint":"^7.2.3","babel-loader":"^6.2.5","babel-plugin-array-includes":"^2.0.3","babel-plugin-transform-builtin-extend":"^1.1.2","babel-plugin-transform-inline-imports-commonjs":"^1.0.0","babel-plugin-transform-runtime":"^6.4.3","babel-preset-env":"^1.6.0","babel-preset-flow":"^6.23.0","babel-preset-stage-0":"^6.0.0","babylon":"^6.5.0","commitizen":"^2.9.6","cz-conventional-changelog":"^2.0.0","eslint":"^4.3.0","eslint-config-fb-strict":"^22.0.0","eslint-plugin-babel":"^5.0.0","eslint-plugin-flowtype":"^2.35.0","eslint-plugin-jasmine":"^2.6.2","eslint-plugin-jest":"^21.0.0","eslint-plugin-jsx-a11y":"^6.0.2","eslint-plugin-prefer-object-spread":"^1.2.1","eslint-plugin-prettier":"^2.1.2","eslint-plugin-react":"^7.1.0","eslint-plugin-relay":"^0.0.24","eslint-plugin-yarn-internal":"file:scripts/eslint-rules","execa":"^0.10.0","flow-bin":"^0.66.0","git-release-notes":"^3.0.0","gulp":"^3.9.0","gulp-babel":"^7.0.0","gulp-if":"^2.0.1","gulp-newer":"^1.0.0","gulp-plumber":"^1.0.1","gulp-sourcemaps":"^2.2.0","gulp-util":"^3.0.7","gulp-watch":"^5.0.0","jest":"^22.4.4","jsinspect":"^0.12.6","minimatch":"^3.0.4","mock-stdin":"^0.3.0","prettier":"^1.5.2","temp":"^0.8.3","webpack":"^2.1.0-beta.25","yargs":"^6.3.0"},"resolutions":{"sshpk":"^1.14.2"},"engines":{"node":">=4.0.0"},"repository":"yarnpkg/yarn","bin":{"yarn":"./bin/yarn.js","yarnpkg":"./bin/yarn.js"},"scripts":{"build":"gulp build","build-bundle":"node ./scripts/build-webpack.js","build-chocolatey":"powershell ./scripts/build-chocolatey.ps1","build-deb":"./scripts/build-deb.sh","build-dist":"bash ./scripts/build-dist.sh","build-win-installer":"scripts\\build-windows-installer.bat","changelog":"git-release-notes $(git describe --tags --abbrev=0 $(git describe --tags --abbrev=0)^)..$(git describe --tags --abbrev=0) scripts/changelog.md","dupe-check":"yarn jsinspect ./src","lint":"eslint . && flow check","pkg-tests":"yarn --cwd packages/pkg-tests jest yarn.test.js","prettier":"eslint src __tests__ --fix","release-branch":"./scripts/release-branch.sh","test":"yarn lint && yarn test-only","test-only":"node --max_old_space_size=4096 node_modules/jest/bin/jest.js --verbose","test-only-debug":"node --inspect-brk --max_old_space_size=4096 node_modules/jest/bin/jest.js --runInBand --verbose","test-coverage":"node --max_old_space_size=4096 node_modules/jest/bin/jest.js --coverage --verbose","watch":"gulp watch","commit":"git-cz"},"jest":{"collectCoverageFrom":["src/**/*.js"],"testEnvironment":"node","modulePathIgnorePatterns":["__tests__/fixtures/","packages/pkg-tests/pkg-tests-fixtures","dist/"],"testPathIgnorePatterns":["__tests__/(fixtures|__mocks__)/","updates/","_(temp|mock|install|init|helpers).js$","packages/pkg-tests"]},"config":{"commitizen":{"path":"./node_modules/cz-conventional-changelog"}}}

/***/ }),
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = stringify;

var _misc;

function _load_misc() {
  return _misc = __webpack_require__(12);
}

var _constants;

function _load_constants() {
  return _constants = __webpack_require__(6);
}

var _package;

function _load_package() {
  return _package = __webpack_require__(145);
}

const NODE_VERSION = process.version;

function shouldWrapKey(str) {
  return str.indexOf('true') === 0 || str.indexOf('false') === 0 || /[:\s\n\\",\[\]]/g.test(str) || /^[0-9]/g.test(str) || !/^[a-zA-Z]/g.test(str);
}

function maybeWrap(str) {
  if (typeof str === 'boolean' || typeof str === 'number' || shouldWrapKey(str)) {
    return JSON.stringify(str);
  } else {
    return str;
  }
}

const priorities = {
  name: 1,
  version: 2,
  uid: 3,
  resolved: 4,
  integrity: 5,
  registry: 6,
  dependencies: 7
};

function priorityThenAlphaSort(a, b) {
  if (priorities[a] || priorities[b]) {
    return (priorities[a] || 100) > (priorities[b] || 100) ? 1 : -1;
  } else {
    return (0, (_misc || _load_misc()).sortAlpha)(a, b);
  }
}

function _stringify(obj, options) {
  if (typeof obj !== 'object') {
    throw new TypeError();
  }

  const indent = options.indent;
  const lines = [];

  // Sorting order needs to be consistent between runs, we run native sort by name because there are no
  // problems with it being unstable because there are no to keys the same
  // However priorities can be duplicated and native sort can shuffle things from run to run
  const keys = Object.keys(obj).sort(priorityThenAlphaSort);

  let addedKeys = [];

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const val = obj[key];
    if (val == null || addedKeys.indexOf(key) >= 0) {
      continue;
    }

    const valKeys = [key];

    // get all keys that have the same value equality, we only want this for objects
    if (typeof val === 'object') {
      for (let j = i + 1; j < keys.length; j++) {
        const key = keys[j];
        if (val === obj[key]) {
          valKeys.push(key);
        }
      }
    }

    const keyLine = valKeys.sort((_misc || _load_misc()).sortAlpha).map(maybeWrap).join(', ');

    if (typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number') {
      lines.push(`${keyLine} ${maybeWrap(val)}`);
    } else if (typeof val === 'object') {
      lines.push(`${keyLine}:\n${_stringify(val, { indent: indent + '  ' })}` + (options.topLevel ? '\n' : ''));
    } else {
      throw new TypeError();
    }

    addedKeys = addedKeys.concat(valKeys);
  }

  return indent + lines.join(`\n${indent}`);
}

function stringify(obj, noHeader, enableVersions) {
  const val = _stringify(obj, {
    indent: '',
    topLevel: true
  });
  if (noHeader) {
    return val;
  }

  const lines = [];
  lines.push('# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.');
  lines.push(`# yarn lockfile v${(_constants || _load_constants()).LOCKFILE_VERSION}`);
  if (enableVersions) {
    lines.push(`# yarn v${(_package || _load_package()).version}`);
    lines.push(`# node ${NODE_VERSION}`);
  }
  lines.push('\n');
  lines.push(val);

  return lines.join('\n');
}

/***/ }),
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fileDatesEqual = exports.copyFile = exports.unlink = undefined;

var _asyncToGenerator2;

function _load_asyncToGenerator() {
  return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));
}

// We want to preserve file timestamps when copying a file, since yarn uses them to decide if a file has
// changed compared to the cache.
// There are some OS specific cases here:
// * On linux, fs.copyFile does not preserve timestamps, but does on OSX and Win.
// * On windows, you must open a file with write permissions to call `fs.futimes`.
// * On OSX you can open with read permissions and still call `fs.futimes`.
let fixTimes = (() => {
  var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (fd, dest, data) {
    const doOpen = fd === undefined;
    let openfd = fd ? fd : -1;

    if (disableTimestampCorrection === undefined) {
      // if timestamps match already, no correction is needed.
      // the need to correct timestamps varies based on OS and node versions.
      const destStat = yield lstat(dest);
      disableTimestampCorrection = fileDatesEqual(destStat.mtime, data.mtime);
    }

    if (disableTimestampCorrection) {
      return;
    }

    if (doOpen) {
      try {
        openfd = yield open(dest, 'a', data.mode);
      } catch (er) {
        // file is likely read-only
        try {
          openfd = yield open(dest, 'r', data.mode);
        } catch (err) {
          // We can't even open this file for reading.
          return;
        }
      }
    }

    try {
      if (openfd) {
        yield futimes(openfd, data.atime, data.mtime);
      }
    } catch (er) {
      // If `futimes` throws an exception, we probably have a case of a read-only file on Windows.
      // In this case we can just return. The incorrect timestamp will just cause that file to be recopied
      // on subsequent installs, which will effect yarn performance but not break anything.
    } finally {
      if (doOpen && openfd) {
        yield close(openfd);
      }
    }
  });

  return function fixTimes(_x7, _x8, _x9) {
    return _ref3.apply(this, arguments);
  };
})();

// Compare file timestamps.
// Some versions of Node on windows zero the milliseconds when utime is used.


var _fs;

function _load_fs() {
  return _fs = _interopRequireDefault(__webpack_require__(3));
}

var _promise;

function _load_promise() {
  return _promise = __webpack_require__(40);
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This module serves as a wrapper for file operations that are inconsistant across node and OS versions.

let disableTimestampCorrection = undefined; // OS dependent. will be detected on first file copy.

const readFileBuffer = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.readFile);
const close = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.close);
const lstat = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.lstat);
const open = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.open);
const futimes = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.futimes);

const write = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.write);

const unlink = exports.unlink = (0, (_promise || _load_promise()).promisify)(__webpack_require__(233));

/**
 * Unlinks the destination to force a recreation. This is needed on case-insensitive file systems
 * to force the correct naming when the filename has changed only in character-casing. (Jest -> jest).
 */
const copyFile = exports.copyFile = (() => {
  var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data, cleanup) {
    try {
      yield unlink(data.dest);
      yield copyFilePoly(data.src, data.dest, 0, data);
    } finally {
      if (cleanup) {
        cleanup();
      }
    }
  });

  return function copyFile(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

// Node 8.5.0 introduced `fs.copyFile` which is much faster, so use that when available.
// Otherwise we fall back to reading and writing files as buffers.
const copyFilePoly = (src, dest, flags, data) => {
  if ((_fs || _load_fs()).default.copyFile) {
    return new Promise((resolve, reject) => (_fs || _load_fs()).default.copyFile(src, dest, flags, err => {
      if (err) {
        reject(err);
      } else {
        fixTimes(undefined, dest, data).then(() => resolve()).catch(ex => reject(ex));
      }
    }));
  } else {
    return copyWithBuffer(src, dest, flags, data);
  }
};

const copyWithBuffer = (() => {
  var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest, flags, data) {
    // Use open -> write -> futimes -> close sequence to avoid opening the file twice:
    // one with writeFile and one with utimes
    const fd = yield open(dest, 'w', data.mode);
    try {
      const buffer = yield readFileBuffer(src);
      yield write(fd, buffer, 0, buffer.length);
      yield fixTimes(fd, dest, data);
    } finally {
      yield close(fd);
    }
  });

  return function copyWithBuffer(_x3, _x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();const fileDatesEqual = exports.fileDatesEqual = (a, b) => {
  const aTime = a.getTime();
  const bTime = b.getTime();

  if (process.platform !== 'win32') {
    return aTime === bTime;
  }

  // See https://github.com/nodejs/node/pull/12607
  // Submillisecond times from stat and utimes are truncated on Windows,
  // causing a file with mtime 8.0079998 and 8.0081144 to become 8.007 and 8.008
  // and making it impossible to update these files to their correct timestamps.
  if (Math.abs(aTime - bTime) <= 1) {
    return true;
  }

  const aTimeSec = Math.floor(aTime / 1000);
  const bTimeSec = Math.floor(bTime / 1000);

  // See https://github.com/nodejs/node/issues/2069
  // Some versions of Node on windows zero the milliseconds when utime is used
  // So if any of the time has a milliseconds part of zero we suspect that the
  // bug is present and compare only seconds.
  if (aTime - aTimeSec * 1000 === 0 || bTime - bTimeSec * 1000 === 0) {
    return aTimeSec === bTimeSec;
  }

  return aTime === bTime;
};

/***/ }),
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFakeRoot = isFakeRoot;
exports.isRootUser = isRootUser;
function getUid() {
  if (process.platform !== 'win32' && process.getuid) {
    return process.getuid();
  }
  return null;
}

exports.default = isRootUser(getUid()) && !isFakeRoot();
function isFakeRoot() {
  return Boolean(process.env.FAKEROOTKEY);
}

function isRootUser(uid) {
  return uid === 0;
}

/***/ }),
/* 170 */,
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataDir = getDataDir;
exports.getCacheDir = getCacheDir;
exports.getConfigDir = getConfigDir;
const path = __webpack_require__(0);
const userHome = __webpack_require__(45).default;

const FALLBACK_CONFIG_DIR = path.join(userHome, '.config', 'yarn');
const FALLBACK_CACHE_DIR = path.join(userHome, '.cache', 'yarn');

function getDataDir() {
  if (process.platform === 'win32') {
    const WIN32_APPDATA_DIR = getLocalAppDataDir();
    return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, 'Data');
  } else if (process.env.XDG_DATA_HOME) {
    return path.join(process.env.XDG_DATA_HOME, 'yarn');
  } else {
    // This could arguably be ~/Library/Application Support/Yarn on Macs,
    // but that feels unintuitive for a cli tool

    // Instead, use our prior fallback. Some day this could be
    // path.join(userHome, '.local', 'share', 'yarn')
    // or return path.join(WIN32_APPDATA_DIR, 'Data') on win32
    return FALLBACK_CONFIG_DIR;
  }
}

function getCacheDir() {
  if (process.platform === 'win32') {
    // process.env.TEMP also exists, but most apps put caches here
    return path.join(getLocalAppDataDir() || path.join(userHome, 'AppData', 'Local', 'Yarn'), 'Cache');
  } else if (process.env.XDG_CACHE_HOME) {
    return path.join(process.env.XDG_CACHE_HOME, 'yarn');
  } else if (process.platform === 'darwin') {
    return path.join(userHome, 'Library', 'Caches', 'Yarn');
  } else {
    return FALLBACK_CACHE_DIR;
  }
}

function getConfigDir() {
  if (process.platform === 'win32') {
    // Use our prior fallback. Some day this could be
    // return path.join(WIN32_APPDATA_DIR, 'Config')
    const WIN32_APPDATA_DIR = getLocalAppDataDir();
    return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, 'Config');
  } else if (process.env.XDG_CONFIG_HOME) {
    return path.join(process.env.XDG_CONFIG_HOME, 'yarn');
  } else {
    return FALLBACK_CONFIG_DIR;
  }
}

function getLocalAppDataDir() {
  return process.env.LOCALAPPDATA ? path.join(process.env.LOCALAPPDATA, 'Yarn') : null;
}

/***/ }),
/* 172 */,
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(179), __esModule: true };

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var concatMap = __webpack_require__(178);
var balanced = __webpack_require__(174);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function preserveCamelCase(str) {
	let isLastCharLower = false;
	let isLastCharUpper = false;
	let isLastLastCharUpper = false;

	for (let i = 0; i < str.length; i++) {
		const c = str[i];

		if (isLastCharLower && /[a-zA-Z]/.test(c) && c.toUpperCase() === c) {
			str = str.substr(0, i) + '-' + str.substr(i);
			isLastCharLower = false;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = true;
			i++;
		} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(c) && c.toLowerCase() === c) {
			str = str.substr(0, i - 1) + '-' + str.substr(i - 1);
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = false;
			isLastCharLower = true;
		} else {
			isLastCharLower = c.toLowerCase() === c;
			isLastLastCharUpper = isLastCharUpper;
			isLastCharUpper = c.toUpperCase() === c;
		}
	}

	return str;
}

module.exports = function (str) {
	if (arguments.length > 1) {
		str = Array.from(arguments)
			.map(x => x.trim())
			.filter(x => x.length)
			.join('-');
	} else {
		str = str.trim();
	}

	if (str.length === 0) {
		return '';
	}

	if (str.length === 1) {
		return str.toLowerCase();
	}

	if (/^[a-z0-9]+$/.test(str)) {
		return str;
	}

	const hasUpperCase = str !== str.toLowerCase();

	if (hasUpperCase) {
		str = preserveCamelCase(str);
	}

	return str
		.replace(/^[_.\- ]+/, '')
		.toLowerCase()
		.replace(/[_.\- ]+(\w|$)/g, (m, p1) => p1.toUpperCase());
};


/***/ }),
/* 177 */,
/* 178 */
/***/ (function(module, exports) {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(205);
__webpack_require__(207);
__webpack_require__(210);
__webpack_require__(206);
__webpack_require__(208);
__webpack_require__(209);
module.exports = __webpack_require__(23).Promise;


/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 181 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(74);
var toLength = __webpack_require__(110);
var toAbsoluteIndex = __webpack_require__(200);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(48);
var call = __webpack_require__(187);
var isArrayIter = __webpack_require__(186);
var anObject = __webpack_require__(27);
var toLength = __webpack_require__(110);
var getIterFn = __webpack_require__(203);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(33) && !__webpack_require__(85)(function () {
  return Object.defineProperty(__webpack_require__(68)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 185 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(35);
var ITERATOR = __webpack_require__(13)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(27);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(192);
var descriptor = __webpack_require__(106);
var setToStringTag = __webpack_require__(71);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(31)(IteratorPrototype, __webpack_require__(13)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(13)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 190 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(11);
var macrotask = __webpack_require__(109).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(47)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(27);
var dPs = __webpack_require__(193);
var enumBugKeys = __webpack_require__(101);
var IE_PROTO = __webpack_require__(72)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(68)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(102).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(50);
var anObject = __webpack_require__(27);
var getKeys = __webpack_require__(132);

module.exports = __webpack_require__(33) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(49);
var toObject = __webpack_require__(133);
var IE_PROTO = __webpack_require__(72)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(49);
var toIObject = __webpack_require__(74);
var arrayIndexOf = __webpack_require__(182)(false);
var IE_PROTO = __webpack_require__(72)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(31);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31);


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(11);
var core = __webpack_require__(23);
var dP = __webpack_require__(50);
var DESCRIPTORS = __webpack_require__(33);
var SPECIES = __webpack_require__(13)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(73);
var defined = __webpack_require__(67);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(73);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(34);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(11);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(100);
var ITERATOR = __webpack_require__(13)('iterator');
var Iterators = __webpack_require__(35);
module.exports = __webpack_require__(23).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(180);
var step = __webpack_require__(190);
var Iterators = __webpack_require__(35);
var toIObject = __webpack_require__(74);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(103)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 205 */
/***/ (function(module, exports) {



/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(69);
var global = __webpack_require__(11);
var ctx = __webpack_require__(48);
var classof = __webpack_require__(100);
var $export = __webpack_require__(41);
var isObject = __webpack_require__(34);
var aFunction = __webpack_require__(46);
var anInstance = __webpack_require__(181);
var forOf = __webpack_require__(183);
var speciesConstructor = __webpack_require__(108);
var task = __webpack_require__(109).set;
var microtask = __webpack_require__(191)();
var newPromiseCapabilityModule = __webpack_require__(70);
var perform = __webpack_require__(104);
var userAgent = __webpack_require__(202);
var promiseResolve = __webpack_require__(105);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(13)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(196)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(71)($Promise, PROMISE);
__webpack_require__(198)(PROMISE);
Wrapper = __webpack_require__(23)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(189)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(199)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(103)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(41);
var core = __webpack_require__(23);
var global = __webpack_require__(11);
var speciesConstructor = __webpack_require__(108);
var promiseResolve = __webpack_require__(105);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(41);
var newPromiseCapability = __webpack_require__(70);
var perform = __webpack_require__(104);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(204);
var global = __webpack_require__(11);
var hide = __webpack_require__(31);
var Iterators = __webpack_require__(35);
var TO_STRING_TAG = __webpack_require__(13)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(112);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = __webpack_require__(211);
} else {
  module.exports = __webpack_require__(213);
}


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var tty = __webpack_require__(79);
var util = __webpack_require__(2);

/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(112);
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [ 6, 2, 3, 4, 5, 1 ];

try {
  var supportsColor = __webpack_require__(239);
  if (supportsColor && supportsColor.level >= 2) {
    exports.colors = [
      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,
      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,
      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,
      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,
      205, 206, 207, 208, 209, 214, 215, 220, 221
    ];
  }
} catch (err) {
  // swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // camel-case
  var prop = key
    .substring(6)
    .toLowerCase()
    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
  else if (val === 'null') val = null;
  else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts
    ? Boolean(exports.inspectOpts.colors)
    : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts)
    .split('\n').map(function(str) {
      return str.trim()
    }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function(v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init (debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());


/***/ }),
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __webpack_require__(0);
var isWindows = process.platform === 'win32';
var fs = __webpack_require__(3);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __webpack_require__(3)
var rp = __webpack_require__(114)
var minimatch = __webpack_require__(60)
var Minimatch = minimatch.Minimatch
var Glob = __webpack_require__(75).Glob
var util = __webpack_require__(2)
var path = __webpack_require__(0)
var assert = __webpack_require__(22)
var isAbsolute = __webpack_require__(76)
var common = __webpack_require__(115)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),
/* 219 */,
/* 220 */,
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (flag, argv) {
	argv = argv || process.argv;

	var terminatorPos = argv.indexOf('--');
	var prefix = /^--/.test(flag) ? '' : '--';
	var pos = argv.indexOf(prefix + flag);

	return pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);
};


/***/ }),
/* 222 */,
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(123)
var reqs = Object.create(null)
var once = __webpack_require__(61)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),
/* 224 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 225 */,
/* 226 */,
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

// @flow

/*::
declare var __webpack_require__: mixed;
*/

module.exports = typeof __webpack_require__ !== "undefined";


/***/ }),
/* 228 */,
/* 229 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = rimraf
rimraf.sync = rimrafSync

var assert = __webpack_require__(22)
var path = __webpack_require__(0)
var fs = __webpack_require__(3)
var glob = __webpack_require__(75)
var _0666 = parseInt('666', 8)

var defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
var timeout = 0

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  var busyTries = 0
  var errState = null
  var n = 0

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

  function next (er) {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            var time = busyTries * 100
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, _0666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, _0666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  var retries = isWindows ? 100 : 1
  var i = 0
  do {
    var threw = true
    try {
      var ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}


/***/ }),
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hasFlag = __webpack_require__(221);

var support = function (level) {
	if (level === 0) {
		return false;
	}

	return {
		level: level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
};

var supportLevel = (function () {
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return 1;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return 0;
	}

	if (process.platform === 'win32') {
		return 1;
	}

	if ('CI' in process.env) {
		if ('TRAVIS' in process.env || process.env.CI === 'Travis') {
			return 1;
		}

		return 0;
	}

	if ('TEAMCITY_VERSION' in process.env) {
		return process.env.TEAMCITY_VERSION.match(/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/) === null ? 0 : 1;
	}

	if (/^(screen|xterm)-256(?:color)?/.test(process.env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in process.env) {
		return 1;
	}

	if (process.env.TERM === 'dumb') {
		return 0;
	}

	return 0;
})();

if (supportLevel === 0 && 'FORCE_COLOR' in process.env) {
	supportLevel = 1;
}

module.exports = process && support(supportLevel);


/***/ })
/******/ ]);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  "use strict";
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */!function(e){"function"==typeof define&&define.amd?define(e):e()}((function(){
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
!function(e){var t=e.performance;function n(e){t&&t.mark&&t.mark(e)}function r(e,n){t&&t.measure&&t.measure(e,n)}n("Zone");var o=e.__Zone_symbol_prefix||"__zone_symbol__";function a(e){return o+e}var i=!0===e[a("forceDuplicateZoneCheck")];if(e.Zone){if(i||"function"!=typeof e.Zone.__symbol__)throw new Error("Zone already loaded.");return e.Zone}var c=function(){function t(e,t){this._parent=e,this._name=t?t.name||"unnamed":"<root>",this._properties=t&&t.properties||{},this._zoneDelegate=new l(this,this._parent&&this._parent._zoneDelegate,t)}return t.assertZonePatched=function(){if(e.Promise!==j.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")},Object.defineProperty(t,"root",{get:function(){for(var e=t.current;e.parent;)e=e.parent;return e},enumerable:!1,configurable:!0}),Object.defineProperty(t,"current",{get:function(){return I.zone},enumerable:!1,configurable:!0}),Object.defineProperty(t,"currentTask",{get:function(){return z},enumerable:!1,configurable:!0}),t.__load_patch=function(o,a,c){if(void 0===c&&(c=!1),j.hasOwnProperty(o)){if(!c&&i)throw Error("Already loaded patch: "+o)}else if(!e["__Zone_disable_"+o]){var s="Zone:"+o;n(s),j[o]=a(e,t,C),r(s,s)}},Object.defineProperty(t.prototype,"parent",{get:function(){return this._parent},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"name",{get:function(){return this._name},enumerable:!1,configurable:!0}),t.prototype.get=function(e){var t=this.getZoneWith(e);if(t)return t._properties[e]},t.prototype.getZoneWith=function(e){for(var t=this;t;){if(t._properties.hasOwnProperty(e))return t;t=t._parent}return null},t.prototype.fork=function(e){if(!e)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,e)},t.prototype.wrap=function(e,t){if("function"!=typeof e)throw new Error("Expecting function got: "+e);var n=this._zoneDelegate.intercept(this,e,t),r=this;return function(){return r.runGuarded(n,this,arguments,t)}},t.prototype.run=function(e,t,n,r){I={parent:I,zone:this};try{return this._zoneDelegate.invoke(this,e,t,n,r)}finally{I=I.parent}},t.prototype.runGuarded=function(e,t,n,r){void 0===t&&(t=null),I={parent:I,zone:this};try{try{return this._zoneDelegate.invoke(this,e,t,n,r)}catch(e){if(this._zoneDelegate.handleError(this,e))throw e}}finally{I=I.parent}},t.prototype.runTask=function(e,t,n){if(e.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(e.zone||m).name+"; Execution: "+this.name+")");if(e.state!==T||e.type!==D&&e.type!==O){var r=e.state!=w;r&&e._transitionTo(w,E),e.runCount++;var o=z;z=e,I={parent:I,zone:this};try{e.type==O&&e.data&&!e.data.isPeriodic&&(e.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,e,t,n)}catch(e){if(this._zoneDelegate.handleError(this,e))throw e}}finally{e.state!==T&&e.state!==S&&(e.type==D||e.data&&e.data.isPeriodic?r&&e._transitionTo(E,w):(e.runCount=0,this._updateTaskCount(e,-1),r&&e._transitionTo(T,w,T))),I=I.parent,z=o}}},t.prototype.scheduleTask=function(e){if(e.zone&&e.zone!==this)for(var t=this;t;){if(t===e.zone)throw Error("can not reschedule task to ".concat(this.name," which is descendants of the original zone ").concat(e.zone.name));t=t.parent}e._transitionTo(b,T);var n=[];e._zoneDelegates=n,e._zone=this;try{e=this._zoneDelegate.scheduleTask(this,e)}catch(t){throw e._transitionTo(S,b,T),this._zoneDelegate.handleError(this,t),t}return e._zoneDelegates===n&&this._updateTaskCount(e,1),e.state==b&&e._transitionTo(E,b),e},t.prototype.scheduleMicroTask=function(e,t,n,r){return this.scheduleTask(new f(P,e,t,n,r,void 0))},t.prototype.scheduleMacroTask=function(e,t,n,r,o){return this.scheduleTask(new f(O,e,t,n,r,o))},t.prototype.scheduleEventTask=function(e,t,n,r,o){return this.scheduleTask(new f(D,e,t,n,r,o))},t.prototype.cancelTask=function(e){if(e.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(e.zone||m).name+"; Execution: "+this.name+")");e._transitionTo(Z,E,w);try{this._zoneDelegate.cancelTask(this,e)}catch(t){throw e._transitionTo(S,Z),this._zoneDelegate.handleError(this,t),t}return this._updateTaskCount(e,-1),e._transitionTo(T,Z),e.runCount=0,e},t.prototype._updateTaskCount=function(e,t){var n=e._zoneDelegates;-1==t&&(e._zoneDelegates=null);for(var r=0;r<n.length;r++)n[r]._updateTaskCount(e.type,t)},t}();c.__symbol__=a;var s,u={name:"",onHasTask:function(e,t,n,r){return e.hasTask(n,r)},onScheduleTask:function(e,t,n,r){return e.scheduleTask(n,r)},onInvokeTask:function(e,t,n,r,o,a){return e.invokeTask(n,r,o,a)},onCancelTask:function(e,t,n,r){return e.cancelTask(n,r)}},l=function(){function e(e,t,n){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=e,this._parentDelegate=t,this._forkZS=n&&(n&&n.onFork?n:t._forkZS),this._forkDlgt=n&&(n.onFork?t:t._forkDlgt),this._forkCurrZone=n&&(n.onFork?this.zone:t._forkCurrZone),this._interceptZS=n&&(n.onIntercept?n:t._interceptZS),this._interceptDlgt=n&&(n.onIntercept?t:t._interceptDlgt),this._interceptCurrZone=n&&(n.onIntercept?this.zone:t._interceptCurrZone),this._invokeZS=n&&(n.onInvoke?n:t._invokeZS),this._invokeDlgt=n&&(n.onInvoke?t:t._invokeDlgt),this._invokeCurrZone=n&&(n.onInvoke?this.zone:t._invokeCurrZone),this._handleErrorZS=n&&(n.onHandleError?n:t._handleErrorZS),this._handleErrorDlgt=n&&(n.onHandleError?t:t._handleErrorDlgt),this._handleErrorCurrZone=n&&(n.onHandleError?this.zone:t._handleErrorCurrZone),this._scheduleTaskZS=n&&(n.onScheduleTask?n:t._scheduleTaskZS),this._scheduleTaskDlgt=n&&(n.onScheduleTask?t:t._scheduleTaskDlgt),this._scheduleTaskCurrZone=n&&(n.onScheduleTask?this.zone:t._scheduleTaskCurrZone),this._invokeTaskZS=n&&(n.onInvokeTask?n:t._invokeTaskZS),this._invokeTaskDlgt=n&&(n.onInvokeTask?t:t._invokeTaskDlgt),this._invokeTaskCurrZone=n&&(n.onInvokeTask?this.zone:t._invokeTaskCurrZone),this._cancelTaskZS=n&&(n.onCancelTask?n:t._cancelTaskZS),this._cancelTaskDlgt=n&&(n.onCancelTask?t:t._cancelTaskDlgt),this._cancelTaskCurrZone=n&&(n.onCancelTask?this.zone:t._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;var r=n&&n.onHasTask;(r||t&&t._hasTaskZS)&&(this._hasTaskZS=r?n:u,this._hasTaskDlgt=t,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=e,n.onScheduleTask||(this._scheduleTaskZS=u,this._scheduleTaskDlgt=t,this._scheduleTaskCurrZone=this.zone),n.onInvokeTask||(this._invokeTaskZS=u,this._invokeTaskDlgt=t,this._invokeTaskCurrZone=this.zone),n.onCancelTask||(this._cancelTaskZS=u,this._cancelTaskDlgt=t,this._cancelTaskCurrZone=this.zone))}return e.prototype.fork=function(e,t){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,e,t):new c(e,t)},e.prototype.intercept=function(e,t,n){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,e,t,n):t},e.prototype.invoke=function(e,t,n,r,o){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,e,t,n,r,o):t.apply(n,r)},e.prototype.handleError=function(e,t){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,e,t)},e.prototype.scheduleTask=function(e,t){var n=t;if(this._scheduleTaskZS)this._hasTaskZS&&n._zoneDelegates.push(this._hasTaskDlgtOwner),(n=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,e,t))||(n=t);else if(t.scheduleFn)t.scheduleFn(t);else{if(t.type!=P)throw new Error("Task is missing scheduleFn.");g(t)}return n},e.prototype.invokeTask=function(e,t,n,r){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,e,t,n,r):t.callback.apply(n,r)},e.prototype.cancelTask=function(e,t){var n;if(this._cancelTaskZS)n=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,e,t);else{if(!t.cancelFn)throw Error("Task is not cancelable");n=t.cancelFn(t)}return n},e.prototype.hasTask=function(e,t){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,e,t)}catch(t){this.handleError(e,t)}},e.prototype._updateTaskCount=function(e,t){var n=this._taskCounts,r=n[e],o=n[e]=r+t;if(o<0)throw new Error("More tasks executed then were scheduled.");0!=r&&0!=o||this.hasTask(this.zone,{microTask:n.microTask>0,macroTask:n.macroTask>0,eventTask:n.eventTask>0,change:e})},e}(),f=function(){function t(n,r,o,a,i,c){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=n,this.source=r,this.data=a,this.scheduleFn=i,this.cancelFn=c,!o)throw new Error("callback is not defined");this.callback=o;var s=this;this.invoke=n===D&&a&&a.useG?t.invokeTask:function(){return t.invokeTask.call(e,s,this,arguments)}}return t.invokeTask=function(e,t,n){e||(e=this),R++;try{return e.runCount++,e.zone.runTask(e,t,n)}finally{1==R&&k(),R--}},Object.defineProperty(t.prototype,"zone",{get:function(){return this._zone},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"state",{get:function(){return this._state},enumerable:!1,configurable:!0}),t.prototype.cancelScheduleRequest=function(){this._transitionTo(T,b)},t.prototype._transitionTo=function(e,t,n){if(this._state!==t&&this._state!==n)throw new Error("".concat(this.type," '").concat(this.source,"': can not transition to '").concat(e,"', expecting state '").concat(t,"'").concat(n?" or '"+n+"'":"",", was '").concat(this._state,"'."));this._state=e,e==T&&(this._zoneDelegates=null)},t.prototype.toString=function(){return this.data&&void 0!==this.data.handleId?this.data.handleId.toString():Object.prototype.toString.call(this)},t.prototype.toJSON=function(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}},t}(),h=a("setTimeout"),p=a("Promise"),d=a("then"),v=[],_=!1;function y(t){if(s||e[p]&&(s=e[p].resolve(0)),s){var n=s[d];n||(n=s.then),n.call(s,t)}else e[h](t,0)}function g(e){0===R&&0===v.length&&y(k),e&&v.push(e)}function k(){if(!_){for(_=!0;v.length;){var e=v;v=[];for(var t=0;t<e.length;t++){var n=e[t];try{n.zone.runTask(n,null,null)}catch(e){C.onUnhandledError(e)}}}C.microtaskDrainDone(),_=!1}}var m={name:"NO ZONE"},T="notScheduled",b="scheduling",E="scheduled",w="running",Z="canceling",S="unknown",P="microTask",O="macroTask",D="eventTask",j={},C={symbol:a,currentZoneFrame:function(){return I},onUnhandledError:M,microtaskDrainDone:M,scheduleMicroTask:g,showUncaughtError:function(){return!c[a("ignoreConsoleErrorUncaughtError")]},patchEventTarget:function(){return[]},patchOnProperties:M,patchMethod:function(){return M},bindArguments:function(){return[]},patchThen:function(){return M},patchMacroTask:function(){return M},patchEventPrototype:function(){return M},isIEOrEdge:function(){return!1},getGlobalObjects:function(){},ObjectDefineProperty:function(){return M},ObjectGetOwnPropertyDescriptor:function(){},ObjectCreate:function(){},ArraySlice:function(){return[]},patchClass:function(){return M},wrapWithCurrentZone:function(){return M},filterProperties:function(){return[]},attachOriginToPatched:function(){return M},_redefineProperty:function(){return M},patchCallbacks:function(){return M},nativeScheduleMicroTask:y},I={parent:null,zone:new c(null,null)},z=null,R=0;function M(){}r("Zone","Zone"),e.Zone=c}("undefined"!=typeof window&&window||"undefined"!=typeof self&&self||global);
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
var e=Object.getOwnPropertyDescriptor,t=Object.defineProperty,n=Object.getPrototypeOf,r=Object.create,o=Array.prototype.slice,a="addEventListener",i="removeEventListener",c=Zone.__symbol__(a),s=Zone.__symbol__(i),u="true",l="false",f=Zone.__symbol__("");function h(e,t){return Zone.current.wrap(e,t)}function p(e,t,n,r,o){return Zone.current.scheduleMacroTask(e,t,n,r,o)}var d=Zone.__symbol__,v="undefined"!=typeof window,_=v?window:void 0,y=v&&_||"object"==typeof self&&self||global;function g(e,t){for(var n=e.length-1;n>=0;n--)"function"==typeof e[n]&&(e[n]=h(e[n],t+"_"+n));return e}function k(e){return!e||!1!==e.writable&&!("function"==typeof e.get&&void 0===e.set)}var m="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope,T=!("nw"in y)&&void 0!==y.process&&"[object process]"==={}.toString.call(y.process),b=!T&&!m&&!(!v||!_.HTMLElement),E=void 0!==y.process&&"[object process]"==={}.toString.call(y.process)&&!m&&!(!v||!_.HTMLElement),w={},Z=function(e){if(e=e||y.event){var t=w[e.type];t||(t=w[e.type]=d("ON_PROPERTY"+e.type));var n,r=this||e.target||y,o=r[t];if(b&&r===_&&"error"===e.type){var a=e;!0===(n=o&&o.call(this,a.message,a.filename,a.lineno,a.colno,a.error))&&e.preventDefault()}else null==(n=o&&o.apply(this,arguments))||n||e.preventDefault();return n}};function S(n,r,o){var a=e(n,r);if(!a&&o&&e(o,r)&&(a={enumerable:!0,configurable:!0}),a&&a.configurable){var i=d("on"+r+"patched");if(!n.hasOwnProperty(i)||!n[i]){delete a.writable,delete a.value;var c=a.get,s=a.set,u=r.substr(2),l=w[u];l||(l=w[u]=d("ON_PROPERTY"+u)),a.set=function(e){var t=this;t||n!==y||(t=y),t&&("function"==typeof t[l]&&t.removeEventListener(u,Z),s&&s.call(t,null),t[l]=e,"function"==typeof e&&t.addEventListener(u,Z,!1))},a.get=function(){var e=this;if(e||n!==y||(e=y),!e)return null;var t=e[l];if(t)return t;if(c){var o=c.call(this);if(o)return a.set.call(this,o),"function"==typeof e.removeAttribute&&e.removeAttribute(r),o}return null},t(n,r,a),n[i]=!0}}}function P(e,t,n){if(t)for(var r=0;r<t.length;r++)S(e,"on"+t[r],n);else{var o=[];for(var a in e)"on"==a.substr(0,2)&&o.push(a);for(var i=0;i<o.length;i++)S(e,o[i],n)}}var O=d("originalInstance");function D(e){var n=y[e];if(n){y[d(e)]=n,y[e]=function(){var t=g(arguments,e);switch(t.length){case 0:this[O]=new n;break;case 1:this[O]=new n(t[0]);break;case 2:this[O]=new n(t[0],t[1]);break;case 3:this[O]=new n(t[0],t[1],t[2]);break;case 4:this[O]=new n(t[0],t[1],t[2],t[3]);break;default:throw new Error("Arg list too long.")}},z(y[e],n);var r,o=new n((function(){}));for(r in o)"XMLHttpRequest"===e&&"responseBlob"===r||function(n){"function"==typeof o[n]?y[e].prototype[n]=function(){return this[O][n].apply(this[O],arguments)}:t(y[e].prototype,n,{set:function(t){"function"==typeof t?(this[O][n]=h(t,e+"."+n),z(this[O][n],t)):this[O][n]=t},get:function(){return this[O][n]}})}(r);for(r in n)"prototype"!==r&&n.hasOwnProperty(r)&&(y[e][r]=n[r])}}var j=!1;function C(t,r,o){for(var a=t;a&&!a.hasOwnProperty(r);)a=n(a);!a&&t[r]&&(a=t);var i=d(r),c=null;if(a&&(!(c=a[i])||!a.hasOwnProperty(i))&&(c=a[i]=a[r],k(a&&e(a,r)))){var s=o(c,i,r);a[r]=function(){return s(this,arguments)},z(a[r],c),j&&function e(t,n){"function"==typeof Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(t).forEach((function(e){var r=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(n,e,{get:function(){return t[e]},set:function(n){(!r||r.writable&&"function"==typeof r.set)&&(t[e]=n)},enumerable:!r||r.enumerable,configurable:!r||r.configurable})}))}(c,a[r])}return c}function I(e,t,n){var r=null;function o(e){var t=e.data;return t.args[t.cbIdx]=function(){e.invoke.apply(this,arguments)},r.apply(t.target,t.args),e}r=C(e,t,(function(e){return function(t,r){var a=n(t,r);return a.cbIdx>=0&&"function"==typeof r[a.cbIdx]?p(a.name,r[a.cbIdx],a,o):e.apply(t,r)}}))}function z(e,t){e[d("OriginalDelegate")]=t}var R=!1,M=!1;function N(){if(R)return M;R=!0;try{var e=_.navigator.userAgent;-1===e.indexOf("MSIE ")&&-1===e.indexOf("Trident/")&&-1===e.indexOf("Edge/")||(M=!0)}catch(e){}return M}
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */Zone.__load_patch("ZoneAwarePromise",(function(e,t,n){var r=Object.getOwnPropertyDescriptor,o=Object.defineProperty,a=n.symbol,i=[],c=!0===e[a("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],s=a("Promise"),u=a("then");n.onUnhandledError=function(e){if(n.showUncaughtError()){var t=e&&e.rejection;t?console.error("Unhandled Promise rejection:",t instanceof Error?t.message:t,"; Zone:",e.zone.name,"; Task:",e.task&&e.task.source,"; Value:",t,t instanceof Error?t.stack:void 0):console.error(e)}},n.microtaskDrainDone=function(){for(var e=function(){var e=i.shift();try{e.zone.runGuarded((function(){if(e.throwOriginal)throw e.rejection;throw e}))}catch(e){!function r(e){n.onUnhandledError(e);try{var r=t[l];"function"==typeof r&&r.call(this,e)}catch(e){}}(e)}};i.length;)e()};var l=a("unhandledPromiseRejectionHandler");function f(e){return e&&e.then}function h(e){return e}function p(e){return j.reject(e)}var d=a("state"),v=a("value"),_=a("finally"),y=a("parentPromiseValue"),g=a("parentPromiseState"),k=null,m=!0,T=!1;function b(e,t){return function(n){try{w(e,t,n)}catch(t){w(e,!1,t)}}}var E=a("currentTaskTrace");function w(e,r,a){var s,u=(s=!1,function e(t){return function(){s||(s=!0,t.apply(null,arguments))}});if(e===a)throw new TypeError("Promise resolved with itself");if(e[d]===k){var l=null;try{"object"!=typeof a&&"function"!=typeof a||(l=a&&a.then)}catch(t){return u((function(){w(e,!1,t)}))(),e}if(r!==T&&a instanceof j&&a.hasOwnProperty(d)&&a.hasOwnProperty(v)&&a[d]!==k)S(a),w(e,a[d],a[v]);else if(r!==T&&"function"==typeof l)try{l.call(a,u(b(e,r)),u(b(e,!1)))}catch(t){u((function(){w(e,!1,t)}))()}else{e[d]=r;var f=e[v];if(e[v]=a,e[_]===_&&r===m&&(e[d]=e[g],e[v]=e[y]),r===T&&a instanceof Error){var h=t.currentTask&&t.currentTask.data&&t.currentTask.data.__creationTrace__;h&&o(a,E,{configurable:!0,enumerable:!1,writable:!0,value:h})}for(var p=0;p<f.length;)P(e,f[p++],f[p++],f[p++],f[p++]);if(0==f.length&&r==T){e[d]=0;var Z=a;try{throw new Error("Uncaught (in promise): "+function e(t){return t&&t.toString===Object.prototype.toString?(t.constructor&&t.constructor.name||"")+": "+JSON.stringify(t):t?t.toString():Object.prototype.toString.call(t)}(a)+(a&&a.stack?"\n"+a.stack:""))}catch(e){Z=e}c&&(Z.throwOriginal=!0),Z.rejection=a,Z.promise=e,Z.zone=t.current,Z.task=t.currentTask,i.push(Z),n.scheduleMicroTask()}}}return e}var Z=a("rejectionHandledHandler");function S(e){if(0===e[d]){try{var n=t[Z];n&&"function"==typeof n&&n.call(this,{rejection:e[v],promise:e})}catch(e){}e[d]=T;for(var r=0;r<i.length;r++)e===i[r].promise&&i.splice(r,1)}}function P(e,t,n,r,o){S(e);var a=e[d],i=a?"function"==typeof r?r:h:"function"==typeof o?o:p;t.scheduleMicroTask("Promise.then",(function(){try{var r=e[v],o=!!n&&_===n[_];o&&(n[y]=r,n[g]=a);var c=t.run(i,void 0,o&&i!==p&&i!==h?[]:[r]);w(n,!0,c)}catch(e){w(n,!1,e)}}),n)}var O=function(){},D=e.AggregateError,j=function(){function e(t){var n=this;if(!(n instanceof e))throw new Error("Must be an instanceof Promise.");n[d]=k,n[v]=[];try{t&&t(b(n,m),b(n,T))}catch(e){w(n,!1,e)}}return e.toString=function(){return"function ZoneAwarePromise() { [native code] }"},e.resolve=function(e){return w(new this(null),m,e)},e.reject=function(e){return w(new this(null),T,e)},e.any=function(t){if(!t||"function"!=typeof t[Symbol.iterator])return Promise.reject(new D([],"All promises were rejected"));var n=[],r=0;try{for(var o=0,a=t;o<a.length;o++)r++,n.push(e.resolve(a[o]))}catch(e){return Promise.reject(new D([],"All promises were rejected"))}if(0===r)return Promise.reject(new D([],"All promises were rejected"));var i=!1,c=[];return new e((function(e,t){for(var o=0;o<n.length;o++)n[o].then((function(t){i||(i=!0,e(t))}),(function(e){c.push(e),0==--r&&(i=!0,t(new D(c,"All promises were rejected")))}))}))},e.race=function(e){var t,n,r=new this((function(e,r){t=e,n=r}));function o(e){t(e)}function a(e){n(e)}for(var i=0,c=e;i<c.length;i++){var s=c[i];f(s)||(s=this.resolve(s)),s.then(o,a)}return r},e.all=function(t){return e.allWithCallback(t)},e.allSettled=function(t){return(this&&this.prototype instanceof e?this:e).allWithCallback(t,{thenCallback:function(e){return{status:"fulfilled",value:e}},errorCallback:function(e){return{status:"rejected",reason:e}}})},e.allWithCallback=function(e,t){for(var n,r,o=new this((function(e,t){n=e,r=t})),a=2,i=0,c=[],s=function(e){f(e)||(e=u.resolve(e));var o=i;try{e.then((function(e){c[o]=t?t.thenCallback(e):e,0==--a&&n(c)}),(function(e){t?(c[o]=t.errorCallback(e),0==--a&&n(c)):r(e)}))}catch(e){r(e)}a++,i++},u=this,l=0,h=e;l<h.length;l++)s(h[l]);return 0==(a-=2)&&n(c),o},Object.defineProperty(e.prototype,Symbol.toStringTag,{get:function(){return"Promise"},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,Symbol.species,{get:function(){return e},enumerable:!1,configurable:!0}),e.prototype.then=function(n,r){var o=this.constructor[Symbol.species];o&&"function"==typeof o||(o=this.constructor||e);var a=new o(O),i=t.current;return this[d]==k?this[v].push(i,a,n,r):P(this,i,a,n,r),a},e.prototype.catch=function(e){return this.then(null,e)},e.prototype.finally=function(n){var r=this.constructor[Symbol.species];r&&"function"==typeof r||(r=e);var o=new r(O);o[_]=_;var a=t.current;return this[d]==k?this[v].push(a,o,n,n):P(this,a,o,n,n),o},e}();j.resolve=j.resolve,j.reject=j.reject,j.race=j.race,j.all=j.all;var I=e[s]=e.Promise;e.Promise=j;var z=a("thenPatched");function R(e){var t=e.prototype,n=r(t,"then");if(!n||!1!==n.writable&&n.configurable){var o=t.then;t[u]=o,e.prototype.then=function(e,t){var n=this;return new j((function(e,t){o.call(n,e,t)})).then(e,t)},e[z]=!0}}return n.patchThen=R,I&&(R(I),C(e,"fetch",(function(e){return function t(e){return function(t,n){var r=e.apply(t,n);if(r instanceof j)return r;var o=r.constructor;return o[z]||R(o),r}}(e)}))),Promise[t.__symbol__("uncaughtPromiseErrors")]=i,j})),
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("toString",(function(e){var t=Function.prototype.toString,n=d("OriginalDelegate"),r=d("Promise"),o=d("Error"),a=function a(){if("function"==typeof this){var i=this[n];if(i)return"function"==typeof i?t.call(i):Object.prototype.toString.call(i);if(this===Promise){var c=e[r];if(c)return t.call(c)}if(this===Error){var s=e[o];if(s)return t.call(s)}}return t.call(this)};a[n]=t,Function.prototype.toString=a;var i=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":i.call(this)}}));
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
var L=!1;if("undefined"!=typeof window)try{var x=Object.defineProperty({},"passive",{get:function(){L=!0}});window.addEventListener("test",x,x),window.removeEventListener("test",x,x)}catch(e){L=!1}var A={useG:!0},H={},F={},q=new RegExp("^"+f+"(\\w+)(true|false)$"),G=d("propagationStopped");function B(e,t){var n=(t?t(e):e)+l,r=(t?t(e):e)+u,o=f+n,a=f+r;H[e]={},H[e].false=o,H[e].true=a}function U(e,t,r,o){var c=o&&o.add||a,s=o&&o.rm||i,h=o&&o.listeners||"eventListeners",p=o&&o.rmAll||"removeAllListeners",v=d(c),_="."+c+":",y=function(e,t,n){if(!e.isRemoved){var r,o=e.callback;"object"==typeof o&&o.handleEvent&&(e.callback=function(e){return o.handleEvent(e)},e.originalDelegate=o);try{e.invoke(e,t,[n])}catch(e){r=e}var a=e.options;return a&&"object"==typeof a&&a.once&&t[s].call(t,n.type,e.originalDelegate?e.originalDelegate:e.callback,a),r}};function g(n,r,o){if(r=r||e.event){var a=n||r.target||e,i=a[H[r.type][o?u:l]];if(i){var c=[];if(1===i.length)(h=y(i[0],a,r))&&c.push(h);else for(var s=i.slice(),f=0;f<s.length&&(!r||!0!==r[G]);f++){var h;(h=y(s[f],a,r))&&c.push(h)}if(1===c.length)throw c[0];var p=function(e){var n=c[e];t.nativeScheduleMicroTask((function(){throw n}))};for(f=0;f<c.length;f++)p(f)}}}var k=function(e){return g(this,e,!1)},m=function(e){return g(this,e,!0)};function b(t,r){if(!t)return!1;var o=!0;r&&void 0!==r.useG&&(o=r.useG);var a=r&&r.vh,i=!0;r&&void 0!==r.chkDup&&(i=r.chkDup);var y=!1;r&&void 0!==r.rt&&(y=r.rt);for(var g=t;g&&!g.hasOwnProperty(c);)g=n(g);if(!g&&t[c]&&(g=t),!g)return!1;if(g[v])return!1;var b,E=r&&r.eventNameToString,w={},Z=g[v]=g[c],S=g[d(s)]=g[s],P=g[d(h)]=g[h],O=g[d(p)]=g[p];function D(e,t){return!L&&"object"==typeof e&&e?!!e.capture:L&&t?"boolean"==typeof e?{capture:e,passive:!0}:e?"object"==typeof e&&!1!==e.passive?Object.assign(Object.assign({},e),{passive:!0}):e:{passive:!0}:e}r&&r.prepend&&(b=g[d(r.prepend)]=g[r.prepend]);var j=o?function(e){if(!w.isExisting)return Z.call(w.target,w.eventName,w.capture?m:k,w.options)}:function(e){return Z.call(w.target,w.eventName,e.invoke,w.options)},C=o?function(e){if(!e.isRemoved){var t=H[e.eventName],n=void 0;t&&(n=t[e.capture?u:l]);var r=n&&e.target[n];if(r)for(var o=0;o<r.length;o++)if(r[o]===e){r.splice(o,1),e.isRemoved=!0,0===r.length&&(e.allRemoved=!0,e.target[n]=null);break}}if(e.allRemoved)return S.call(e.target,e.eventName,e.capture?m:k,e.options)}:function(e){return S.call(e.target,e.eventName,e.invoke,e.options)},I=r&&r.diff?r.diff:function(e,t){var n=typeof t;return"function"===n&&e.callback===t||"object"===n&&e.originalDelegate===t},R=Zone[d("UNPATCHED_EVENTS")],M=e[d("PASSIVE_EVENTS")],N=function(t,n,c,s,f,h){return void 0===f&&(f=!1),void 0===h&&(h=!1),function(){var p=this||e,d=arguments[0];r&&r.transferEventName&&(d=r.transferEventName(d));var v=arguments[1];if(!v)return t.apply(this,arguments);if(T&&"uncaughtException"===d)return t.apply(this,arguments);var _=!1;if("function"!=typeof v){if(!v.handleEvent)return t.apply(this,arguments);_=!0}if(!a||a(t,v,p,arguments)){var y=L&&!!M&&-1!==M.indexOf(d),g=D(arguments[2],y);if(R)for(var k=0;k<R.length;k++)if(d===R[k])return y?t.call(p,d,v,g):t.apply(this,arguments);var m=!!g&&("boolean"==typeof g||g.capture),b=!(!g||"object"!=typeof g)&&g.once,Z=Zone.current,S=H[d];S||(B(d,E),S=H[d]);var P,O=S[m?u:l],j=p[O],C=!1;if(j){if(C=!0,i)for(k=0;k<j.length;k++)if(I(j[k],v))return}else j=p[O]=[];var z=p.constructor.name,N=F[z];N&&(P=N[d]),P||(P=z+n+(E?E(d):d)),w.options=g,b&&(w.options.once=!1),w.target=p,w.capture=m,w.eventName=d,w.isExisting=C;var x=o?A:void 0;x&&(x.taskData=w);var q=Z.scheduleEventTask(P,v,x,c,s);return w.target=null,x&&(x.taskData=null),b&&(g.once=!0),(L||"boolean"!=typeof q.options)&&(q.options=g),q.target=p,q.capture=m,q.eventName=d,_&&(q.originalDelegate=v),h?j.unshift(q):j.push(q),f?p:void 0}}};return g[c]=N(Z,_,j,C,y),b&&(g.prependListener=N(b,".prependListener:",(function(e){return b.call(w.target,w.eventName,e.invoke,w.options)}),C,y,!0)),g[s]=function(){var t=this||e,n=arguments[0];r&&r.transferEventName&&(n=r.transferEventName(n));var o=arguments[2],i=!!o&&("boolean"==typeof o||o.capture),c=arguments[1];if(!c)return S.apply(this,arguments);if(!a||a(S,c,t,arguments)){var s,h=H[n];h&&(s=h[i?u:l]);var p=s&&t[s];if(p)for(var d=0;d<p.length;d++){var v=p[d];if(I(v,c)){if(p.splice(d,1),v.isRemoved=!0,0===p.length&&(v.allRemoved=!0,t[s]=null,"string"==typeof n)){var _=f+"ON_PROPERTY"+n;t[_]=null}return v.zone.cancelTask(v),y?t:void 0}}return S.apply(this,arguments)}},g[h]=function(){var t=this||e,n=arguments[0];r&&r.transferEventName&&(n=r.transferEventName(n));for(var o=[],a=W(t,E?E(n):n),i=0;i<a.length;i++){var c=a[i],s=c.originalDelegate?c.originalDelegate:c.callback;o.push(s)}return o},g[p]=function(){var t=this||e,n=arguments[0];if(n){r&&r.transferEventName&&(n=r.transferEventName(n));var o=H[n];if(o){var a=o.false,i=o.true,c=t[a],u=t[i];if(c){var l=c.slice();for(d=0;d<l.length;d++)this[s].call(this,n,(f=l[d]).originalDelegate?f.originalDelegate:f.callback,f.options)}if(u)for(l=u.slice(),d=0;d<l.length;d++){var f;this[s].call(this,n,(f=l[d]).originalDelegate?f.originalDelegate:f.callback,f.options)}}}else{for(var h=Object.keys(t),d=0;d<h.length;d++){var v=h[d],_=q.exec(v),g=_&&_[1];g&&"removeListener"!==g&&this[p].call(this,g)}this[p].call(this,"removeListener")}if(y)return this},z(g[c],Z),z(g[s],S),O&&z(g[p],O),P&&z(g[h],P),!0}for(var E=[],w=0;w<r.length;w++)E[w]=b(r[w],o);return E}function W(e,t){if(!t){var n=[];for(var r in e){var o=q.exec(r),a=o&&o[1];if(a&&(!t||a===t)){var i=e[r];if(i)for(var c=0;c<i.length;c++)n.push(i[c])}}return n}var s=H[t];s||(B(t),s=H[t]);var u=e[s.false],l=e[s.true];return u?l?u.concat(l):u.slice():l?l.slice():[]}function V(e,t){var n=e.Event;n&&n.prototype&&t.patchMethod(n.prototype,"stopImmediatePropagation",(function(e){return function(t,n){t[G]=!0,e&&e.apply(t,n)}}))}
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */function X(e,t,n,r,o){var a=Zone.__symbol__(r);if(!t[a]){var i=t[a]=t[r];t[r]=function(a,c,s){return c&&c.prototype&&o.forEach((function(t){var o="".concat(n,".").concat(r,"::")+t,a=c.prototype;if(a.hasOwnProperty(t)){var i=e.ObjectGetOwnPropertyDescriptor(a,t);i&&i.value?(i.value=e.wrapWithCurrentZone(i.value,o),e._redefineProperty(c.prototype,t,i)):a[t]&&(a[t]=e.wrapWithCurrentZone(a[t],o))}else a[t]&&(a[t]=e.wrapWithCurrentZone(a[t],o))})),i.call(t,a,c,s)},e.attachOriginToPatched(t[r],i)}}
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */function Y(e,t,n){if(!n||0===n.length)return t;var r=n.filter((function(t){return t.target===e}));if(!r||0===r.length)return t;var o=r[0].ignoreProperties;return t.filter((function(e){return-1===o.indexOf(e)}))}function J(e,t,n,r){e&&P(e,Y(e,t,n),r)}function K(e){return Object.getOwnPropertyNames(e).filter((function(e){return e.startsWith("on")&&e.length>2})).map((function(e){return e.substring(2)}))}function $(e,t){if((!T||E)&&!Zone[e.symbol("patchEvents")]){var r=t.__Zone_ignore_on_properties,o=[];if(b){var a=window;o=o.concat(["Document","SVGElement","Element","HTMLElement","HTMLBodyElement","HTMLMediaElement","HTMLFrameSetElement","HTMLFrameElement","HTMLIFrameElement","HTMLMarqueeElement","Worker"]);var i=function e(){try{var e=_.navigator.userAgent;if(-1!==e.indexOf("MSIE ")||-1!==e.indexOf("Trident/"))return!0}catch(e){}return!1}()?[{target:a,ignoreProperties:["error"]}]:[];J(a,K(a),r?r.concat(i):r,n(a))}o=o.concat(["XMLHttpRequest","XMLHttpRequestEventTarget","IDBIndex","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","WebSocket"]);for(var c=0;c<o.length;c++){var s=t[o[c]];s&&s.prototype&&J(s.prototype,K(s.prototype),r)}}}
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */Zone.__load_patch("util",(function(n,c,s){var p=K(n);s.patchOnProperties=P,s.patchMethod=C,s.bindArguments=g,s.patchMacroTask=I;var d=c.__symbol__("BLACK_LISTED_EVENTS"),v=c.__symbol__("UNPATCHED_EVENTS");n[v]&&(n[d]=n[v]),n[d]&&(c[d]=c[v]=n[d]),s.patchEventPrototype=V,s.patchEventTarget=U,s.isIEOrEdge=N,s.ObjectDefineProperty=t,s.ObjectGetOwnPropertyDescriptor=e,s.ObjectCreate=r,s.ArraySlice=o,s.patchClass=D,s.wrapWithCurrentZone=h,s.filterProperties=Y,s.attachOriginToPatched=z,s._redefineProperty=Object.defineProperty,s.patchCallbacks=X,s.getGlobalObjects=function(){return{globalSources:F,zoneSymbolEventNames:H,eventNames:p,isBrowser:b,isMix:E,isNode:T,TRUE_STR:u,FALSE_STR:l,ZONE_SYMBOL_PREFIX:f,ADD_EVENT_LISTENER_STR:a,REMOVE_EVENT_LISTENER_STR:i}}}));
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
var Q=d("zoneTask");function ee(e,t,n,r){var o=null,a=null;n+=r;var i={};function c(t){var n=t.data;return n.args[0]=function(){return t.invoke.apply(this,arguments)},n.handleId=o.apply(e,n.args),t}function s(t){return a.call(e,t.data.handleId)}o=C(e,t+=r,(function(n){return function(o,a){if("function"==typeof a[0]){var u={isPeriodic:"Interval"===r,delay:"Timeout"===r||"Interval"===r?a[1]||0:void 0,args:a},l=a[0];a[0]=function e(){try{return l.apply(this,arguments)}finally{u.isPeriodic||("number"==typeof u.handleId?delete i[u.handleId]:u.handleId&&(u.handleId[Q]=null))}};var f=p(t,a[0],u,c,s);if(!f)return f;var h=f.data.handleId;return"number"==typeof h?i[h]=f:h&&(h[Q]=f),h&&h.ref&&h.unref&&"function"==typeof h.ref&&"function"==typeof h.unref&&(f.ref=h.ref.bind(h),f.unref=h.unref.bind(h)),"number"==typeof h||h?h:f}return n.apply(e,a)}})),a=C(e,n,(function(t){return function(n,r){var o,a=r[0];"number"==typeof a?o=i[a]:(o=a&&a[Q])||(o=a),o&&"string"==typeof o.type?"notScheduled"!==o.state&&(o.cancelFn&&o.data.isPeriodic||0===o.runCount)&&("number"==typeof a?delete i[a]:a&&(a[Q]=null),o.zone.cancelTask(o)):t.apply(e,r)}}))}
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
function te(e,t){if(!Zone[t.symbol("patchEventTarget")]){for(var n=t.getGlobalObjects(),r=n.eventNames,o=n.zoneSymbolEventNames,a=n.TRUE_STR,i=n.FALSE_STR,c=n.ZONE_SYMBOL_PREFIX,s=0;s<r.length;s++){var u=r[s],l=c+(u+i),f=c+(u+a);o[u]={},o[u][i]=l,o[u][a]=f}var h=e.EventTarget;if(h&&h.prototype)return t.patchEventTarget(e,t,[h&&h.prototype]),!0}}
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("legacy",(function(e){var t=e[Zone.__symbol__("legacyPatch")];t&&t()})),Zone.__load_patch("queueMicrotask",(function(e,t,n){n.patchMethod(e,"queueMicrotask",(function(e){return function(e,n){t.current.scheduleMicroTask("queueMicrotask",n[0])}}))})),Zone.__load_patch("timers",(function(e){var t="set",n="clear";ee(e,t,n,"Timeout"),ee(e,t,n,"Interval"),ee(e,t,n,"Immediate")})),Zone.__load_patch("requestAnimationFrame",(function(e){ee(e,"request","cancel","AnimationFrame"),ee(e,"mozRequest","mozCancel","AnimationFrame"),ee(e,"webkitRequest","webkitCancel","AnimationFrame")})),Zone.__load_patch("blocking",(function(e,t){for(var n=["alert","prompt","confirm"],r=0;r<n.length;r++)C(e,n[r],(function(n,r,o){return function(r,a){return t.current.run(n,e,a,o)}}))})),Zone.__load_patch("EventTarget",(function(e,t,n){!function r(e,t){t.patchEventPrototype(e,t)}(e,n),te(e,n);var o=e.XMLHttpRequestEventTarget;o&&o.prototype&&n.patchEventTarget(e,n,[o.prototype])})),Zone.__load_patch("MutationObserver",(function(e,t,n){D("MutationObserver"),D("WebKitMutationObserver")})),Zone.__load_patch("IntersectionObserver",(function(e,t,n){D("IntersectionObserver")})),Zone.__load_patch("FileReader",(function(e,t,n){D("FileReader")})),Zone.__load_patch("on_property",(function(e,t,n){$(n,e)})),Zone.__load_patch("customElements",(function(e,t,n){!function r(e,t){var n=t.getGlobalObjects();(n.isBrowser||n.isMix)&&e.customElements&&"customElements"in e&&t.patchCallbacks(t,e.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback"])}(e,n)})),Zone.__load_patch("XHR",(function(e,t){!function n(e){var n=e.XMLHttpRequest;if(n){var f=n.prototype,h=f[c],v=f[s];if(!h){var _=e.XMLHttpRequestEventTarget;if(_){var y=_.prototype;h=y[c],v=y[s]}}var g="readystatechange",k="scheduled",m=C(f,"open",(function(){return function(e,t){return e[o]=0==t[2],e[u]=t[1],m.apply(e,t)}})),T=d("fetchTaskAborting"),b=d("fetchTaskScheduling"),E=C(f,"send",(function(){return function(e,n){if(!0===t.current[b])return E.apply(e,n);if(e[o])return E.apply(e,n);var r={target:e,url:e[u],isPeriodic:!1,args:n,aborted:!1},a=p("XMLHttpRequest.send",S,r,Z,P);e&&!0===e[l]&&!r.aborted&&a.state===k&&a.invoke()}})),w=C(f,"abort",(function(){return function(e,n){var o=function a(e){return e[r]}(e);if(o&&"string"==typeof o.type){if(null==o.cancelFn||o.data&&o.data.aborted)return;o.zone.cancelTask(o)}else if(!0===t.current[T])return w.apply(e,n)}}))}function Z(e){var n=e.data,o=n.target;o[i]=!1,o[l]=!1;var u=o[a];h||(h=o[c],v=o[s]),u&&v.call(o,g,u);var f=o[a]=function(){if(o.readyState===o.DONE)if(!n.aborted&&o[i]&&e.state===k){var r=o[t.__symbol__("loadfalse")];if(0!==o.status&&r&&r.length>0){var a=e.invoke;e.invoke=function(){for(var r=o[t.__symbol__("loadfalse")],i=0;i<r.length;i++)r[i]===e&&r.splice(i,1);n.aborted||e.state!==k||a.call(e)},r.push(e)}else e.invoke()}else n.aborted||!1!==o[i]||(o[l]=!0)};return h.call(o,g,f),o[r]||(o[r]=e),E.apply(o,n.args),o[i]=!0,e}function S(){}function P(e){var t=e.data;return t.aborted=!0,w.apply(t.target,t.args)}}(e);var r=d("xhrTask"),o=d("xhrSync"),a=d("xhrListener"),i=d("xhrScheduled"),u=d("xhrURL"),l=d("xhrErrorBeforeScheduled")})),Zone.__load_patch("geolocation",(function(t){t.navigator&&t.navigator.geolocation&&function n(t,r){for(var o=t.constructor.name,a=function(n){var a=r[n],i=t[a];if(i){if(!k(e(t,a)))return"continue";t[a]=function(e){var t=function(){return e.apply(this,g(arguments,o+"."+a))};return z(t,e),t}(i)}},i=0;i<r.length;i++)a(i)}(t.navigator.geolocation,["getCurrentPosition","watchPosition"])})),Zone.__load_patch("PromiseRejectionEvent",(function(e,t){function n(t){return function(n){W(e,t).forEach((function(r){var o=e.PromiseRejectionEvent;if(o){var a=new o(t,{promise:n.promise,reason:n.rejection});r.invoke(a)}}))}}e.PromiseRejectionEvent&&(t[d("unhandledPromiseRejectionHandler")]=n("unhandledrejection"),t[d("rejectionHandledHandler")]=n("rejectionhandled"))})),
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("node_util",(function(e,t,n){n.patchOnProperties=P,n.patchMethod=C,n.bindArguments=g,n.patchMacroTask=I,function r(e){j=e}(!0)})),
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("EventEmitter",(function(e,t,n){var r,o=function(e,t){return e.callback===t||e.callback.listener===t},a=function(e){return"string"==typeof e?e:e?e.toString().replace("(","_").replace(")","_"):""};try{r=require("events")}catch(e){}r&&r.EventEmitter&&function i(t){var r=U(e,n,[t],{useG:!1,add:"addListener",rm:"removeListener",prepend:"prependListener",rmAll:"removeAllListeners",listeners:"listeners",chkDup:!1,rt:!0,diff:o,eventNameToString:a});r&&r[0]&&(t.on=t.addListener,t.off=t.removeListener)}(r.EventEmitter.prototype)})),
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("fs",(function(){var e;try{e=require("fs")}catch(e){}e&&["access","appendFile","chmod","chown","close","exists","fchmod","fchown","fdatasync","fstat","fsync","ftruncate","futimes","lchmod","lchown","link","lstat","mkdir","mkdtemp","open","read","readdir","readFile","readlink","realpath","rename","rmdir","stat","symlink","truncate","unlink","utimes","write","writeFile"].filter((function(t){return!!e[t]&&"function"==typeof e[t]})).forEach((function(t){I(e,t,(function(e,n){return{name:"fs."+t,args:n,cbIdx:n.length>0?n.length-1:-1,target:e}}))}))}));
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
var ne="set",re="clear";Zone.__load_patch("node_timers",(function(e,t){var n=!1;try{var r=require("timers");if(e.setTimeout!==r.setTimeout&&!E){var o=r.setTimeout;r.setTimeout=function(){return n=!0,o.apply(this,arguments)};var a=e.setTimeout((function(){}),100);clearTimeout(a),r.setTimeout=o}ee(r,ne,re,"Timeout"),ee(r,ne,re,"Interval"),ee(r,ne,re,"Immediate")}catch(e){}E||(n?(e[t.__symbol__("setTimeout")]=e.setTimeout,e[t.__symbol__("setInterval")]=e.setInterval,e[t.__symbol__("setImmediate")]=e.setImmediate):(ee(e,ne,re,"Timeout"),ee(e,ne,re,"Interval"),ee(e,ne,re,"Immediate")))})),Zone.__load_patch("nextTick",(function(){!function e(t,n,r){var o=null;function a(e){var t=e.data;return t.args[t.cbIdx]=function(){e.invoke.apply(this,arguments)},o.apply(t.target,t.args),e}o=C(t,n,(function(e){return function(t,n){var o=r(t,n);return o.cbIdx>=0&&"function"==typeof n[o.cbIdx]?Zone.current.scheduleMicroTask(o.name,n[o.cbIdx],o,a):e.apply(t,n)}}))}(process,"nextTick",(function(e,t){return{name:"process.nextTick",args:t,cbIdx:t.length>0&&"function"==typeof t[0]?0:-1,target:process}}))})),Zone.__load_patch("handleUnhandledPromiseRejection",(function(e,t,n){function r(e){return function(t){W(process,e).forEach((function(n){"unhandledRejection"===e?n.invoke(t.rejection,t.promise):"rejectionHandled"===e&&n.invoke(t.promise)}))}}t[n.symbol("unhandledPromiseRejectionHandler")]=r("unhandledRejection"),t[n.symbol("rejectionHandledHandler")]=r("rejectionHandled")})),Zone.__load_patch("crypto",(function(){var e;try{e=require("crypto")}catch(e){}e&&["randomBytes","pbkdf2"].forEach((function(t){I(e,t,(function(n,r){return{name:"crypto."+t,args:r,cbIdx:r.length>0&&"function"==typeof r[r.length-1]?r.length-1:-1,target:e}}))}))})),Zone.__load_patch("console",(function(e,t){["dir","log","info","error","warn","assert","debug","timeEnd","trace"].forEach((function(e){var n=console[t.__symbol__(e)]=console[e];n&&(console[e]=function(){var e=o.call(arguments);return t.current===t.root?n.apply(this,e):t.root.run(n,this,e)})}))}))}));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          "use strict";
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */!function(e){"function"==typeof define&&define.amd?define(e):e()}((function(){
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("electron",(function(e,r,t){function n(e,r,n){return t.patchMethod(e,r,(function(e){return function(r,c){return e&&e.apply(r,t.bindArguments(c,n))}}))}var c=require("electron"),o=c.desktopCapturer,i=c.shell,a=c.CallbacksRegistry,l=c.ipcRenderer;if(!a)try{a=require("@electron/remote/dist/src/renderer/callbacks-registry").CallbacksRegistry}catch(e){}o&&n(o,"getSources","electron.desktopCapturer.getSources"),i&&n(i,"openExternal","electron.shell.openExternal"),a?n(a.prototype,"add","CallbackRegistry.add"):l&&n(l,"on","ipcRenderer.on")}))}));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    'use strict';
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
        factory();
})((function () {
    'use strict';
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @fileoverview
     * @suppress {missingRequire}
     */
    Zone.__load_patch('fetch', function (global, Zone, api) {
        var fetch = global['fetch'];
        if (typeof fetch !== 'function') {
            return;
        }
        var originalFetch = global[api.symbol('fetch')];
        if (originalFetch) {
            // restore unpatched fetch first
            fetch = originalFetch;
        }
        var ZoneAwarePromise = global.Promise;
        var symbolThenPatched = api.symbol('thenPatched');
        var fetchTaskScheduling = api.symbol('fetchTaskScheduling');
        var fetchTaskAborting = api.symbol('fetchTaskAborting');
        var OriginalAbortController = global['AbortController'];
        var supportAbort = typeof OriginalAbortController === 'function';
        var abortNative = null;
        if (supportAbort) {
            global['AbortController'] = function () {
                var abortController = new OriginalAbortController();
                var signal = abortController.signal;
                signal.abortController = abortController;
                return abortController;
            };
            abortNative = api.patchMethod(OriginalAbortController.prototype, 'abort', function (delegate) { return function (self, args) {
                if (self.task) {
                    return self.task.zone.cancelTask(self.task);
                }
                return delegate.apply(self, args);
            }; });
        }
        var placeholder = function () { };
        global['fetch'] = function () {
            var _this = this;
            var args = Array.prototype.slice.call(arguments);
            var options = args.length > 1 ? args[1] : null;
            var signal = options && options.signal;
            return new Promise(function (res, rej) {
                var task = Zone.current.scheduleMacroTask('fetch', placeholder, { fetchArgs: args }, function () {
                    var fetchPromise;
                    var zone = Zone.current;
                    try {
                        zone[fetchTaskScheduling] = true;
                        fetchPromise = fetch.apply(_this, args);
                    }
                    catch (error) {
                        rej(error);
                        return;
                    }
                    finally {
                        zone[fetchTaskScheduling] = false;
                    }
                    if (!(fetchPromise instanceof ZoneAwarePromise)) {
                        var ctor = fetchPromise.constructor;
                        if (!ctor[symbolThenPatched]) {
                            api.patchThen(ctor);
                        }
                    }
                    fetchPromise.then(function (resource) {
                        if (task.state !== 'notScheduled') {
                            task.invoke();
                        }
                        res(resource);
                    }, function (error) {
                        if (task.state !== 'notScheduled') {
                            task.invoke();
                        }
                        rej(error);
                    });
                }, function () {
                    if (!supportAbort) {
                        rej('No AbortController supported, can not cancel fetch');
                        return;
                    }
                    if (signal && signal.abortController && !signal.aborted &&
                        typeof signal.abortController.abort === 'function' && abortNative) {
                        try {
                            Zone.current[fetchTaskAborting] = true;
                            abortNative.call(signal.abortController);
                        }
                        finally {
                            Zone.current[fetchTaskAborting] = false;
                        }
                    }
                    else {
                        rej('cancel fetch need a AbortController.signal');
                    }
                });
                if (signal && signal.abortController) {
                    signal.abortController.task = task;
                }
            });
        };
    });
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        INDX( 	 5          (            ~ .   t  k         \    h X     :     Jv Jv58v Jv                     Z O N E - M ~ 2 . J S ]    x b     :     Jv Jv9v Jv      3             z o n e - n o d e . u m d . j s       ^     j     :     Jv Jvl9v Jv                     z o n e - n o d e . u m d . m i n . j s       ]    h X     :     Jv Jv9v Jv      3             Z O N E - N  1 . J S ^    h X     :     Jv Jvl9v Jv                     Z O N E - N ~ 2 . J S _     r     :     Jv Jv9v Jv                     z o n e - p a t c h - c a n v a s . u m d . j s       `     z     :     Jv Jv9v Jv                     z o n e - p a t c h - c a n v a s . u m d . m i n . j s       a     t     :     Jv Jv:v Jv       ;              z o n e - p a t c h - c o r d o v a  u m d . j s vb     |     :     Jv Jv/:v Jv                     z o n e - p a t c h - c o r d o v a . u m d . m i n . j s vc     v     :     Jv Jv}:v Jv                     z o n e - p a t c h - e l e c t r o n . u m d . j s d     ~     :     Jv Jv:v Jv                     z o n e - p a t c h - e l e c t r o n . u m d . m i n . j s e     p     :     Jv Jv:v Jv        h             z o n e - p a t c h - f e t c h . u m d . j s f     x     :     Jv Jvw@;v Jv                     z o n e - p a t c h - f e t c h . u m d . m i n . j s g     p     :     Jv Jvjg;v Jv                     z o n e - p a t c h - j s o n p . u m d . j s h     x     :     Jv Jvc;v Jv       #              z o n e - p a t c h - j s o n p . u m d . m i n . j s               :     Jv JvL;v Jv                      z o n e - p a t c h - m e s s a g e - p o r t . u m d . j s j          :     Jv JvB<v Jv       J              "z o n e - p a t c h - m e s s a g e - p o r t . u m d . m i n . j s k     ~     :     Jv Jv:Q<v Jv                     z o n e - p a t c h - p r o m i s e - t e s t . u m d . j s l          :     Jv Jv$x<v Jv       3              "z o n e - p a t c h - p r o m i s e - t e s  . u m d . m i n . j s m          :     Jv Jv<v Jv        C              !z o n e - p a t c h - r e s i z e - o b s e r v e r . u m d . j s vn          :     Jv Jv<v Jv       C              %z o n e - p a t c h - r e s i z e - o b s e r v e r . u m d . m i n . j s vo          :     Jv Jv=v Jv 0      !              !z o n e - p a t c h - r x j s - f a k e - a s y n c . u m d . j s vp          :     Jv Jva=v Jv                     %z o n e - p a t c h - r x j s - f a k e - a s y n c . u m d . m i n . j s vq     n     :     Jv Jv=v Jv 0      &              z o n e - p a t c h - r x j s . u m d . j s  r     v     :     Jv Jv=v Jv       =              z o n e - p a t c h - r x j s . u m d . m i n . j s s     x     :     Jv Jv=v Jv       P              z o n e - p a t c h - s o c  e t - i o . u m d . j s _    h X     :     Jv Jv9v Jv                     Z O N E - P ~ 1 . J S `    h X     :     Jv Jv9v Jv                     Z O N E - P ~ 2 . J S a    h X     :     Jv Jv:v Jv       ;              Z O N E - P ~ 3 . J S b    h X     :     Jv Jv/:v Jv                     Z O N E - P ~ 4 . J S                                                                      "use strict";
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("fetch",(function(t,n,o){var e=t.fetch;if("function"==typeof e){var r=t[o.symbol("fetch")];r&&(e=r);var c=t.Promise,l=o.symbol("thenPatched"),a=o.symbol("fetchTaskScheduling"),f=o.symbol("fetchTaskAborting"),i=t.AbortController,u="function"==typeof i,s=null;u&&(t.AbortController=function(){var t=new i;return t.signal.abortController=t,t},s=o.patchMethod(i.prototype,"abort",(function(t){return function(n,o){return n.task?n.task.zone.cancelTask(n.task):t.apply(n,o)}})));var h=function(){};t.fetch=function(){var t=this,r=Array.prototype.slice.call(arguments),i=r.length>1?r[1]:null,b=i&&i.signal;return new Promise((function(i,d){var p=n.current.scheduleMacroTask("fetch",h,{fetchArgs:r},(function(){var f,u=n.current;try{u[a]=!0,f=e.apply(t,r)}catch(t){return void d(t)}finally{u[a]=!1}if(!(f instanceof c)){var s=f.constructor;s[l]||o.patchThen(s)}f.then((function(t){"notScheduled"!==p.state&&p.invoke(),i(t)}),(function(t){"notScheduled"!==p.state&&p.invoke(),d(t)}))}),(function(){if(u)if(b&&b.abortController&&!b.aborted&&"function"==typeof b.abortController.abort&&s)try{n.current[f]=!0,s.call(b.abortController)}finally{n.current[f]=!1}else d("cancel fetch need a AbortController.signal");else d("No AbortController supported, can not cancel fetch")}));b&&b.abortController&&(b.abortController.task=p)}))}}}))}));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        'use strict';
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
        factory();
})((function () {
    'use strict';
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    Zone.__load_patch('jsonp', function (global, Zone, api) {
        // because jsonp is not a standard api, there are a lot of
        // implementations, so zone.js just provide a helper util to
        // patch the jsonp send and onSuccess/onError callback
        // the options is an object which contains
        // - jsonp, the jsonp object which hold the send function
        // - sendFuncName, the name of the send function
        // - successFuncName, success func name
        // - failedFuncName, failed func name
        Zone[Zone.__symbol__('jsonp')] = function patchJsonp(options) {
            if (!options || !options.jsonp || !options.sendFuncName) {
                return;
            }
            var noop = function () { };
            [options.successFuncName, options.failedFuncName].forEach(function (methodName) {
                if (!methodName) {
                    return;
                }
                var oriFunc = global[methodName];
                if (oriFunc) {
                    api.patchMethod(global, methodName, function (delegate) { return function (self, args) {
                        var task = global[api.symbol('jsonTask')];
                        if (task) {
                            task.callback = delegate;
                            return task.invoke.apply(self, args);
                        }
                        else {
                            return delegate.apply(self, args);
                        }
                    }; });
                }
                else {
                    Object.defineProperty(global, methodName, {
                        configurable: true,
                        enumerable: true,
                        get: function () {
                            return function () {
                                var task = global[api.symbol('jsonpTask')];
                                var delegate = global[api.symbol("jsonp".concat(methodName, "callback"))];
                                if (task) {
                                    if (delegate) {
                                        task.callback = delegate;
                                    }
                                    global[api.symbol('jsonpTask')] = undefined;
                                    return task.invoke.apply(this, arguments);
                                }
                                else {
                                    if (delegate) {
                                        return delegate.apply(this, arguments);
                                    }
                                }
                                return null;
                            };
                        },
                        set: function (callback) {
                            this[api.symbol("jsonp".concat(methodName, "callback"))] = callback;
                        }
                    });
                }
            });
            api.patchMethod(options.jsonp, options.sendFuncName, function (delegate) { return function (self, args) {
                global[api.symbol('jsonpTask')] =
                    Zone.current.scheduleMacroTask('jsonp', noop, {}, function (task) {
                        return delegate.apply(self, args);
                    }, noop);
            }; });
        };
    });
}));
                                                                                                                                                                                                                                                                       "use strict";
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */!function(n){"function"==typeof define&&define.amd?define(n):n()}((function(){
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("jsonp",(function(n,o,c){o[o.__symbol__("jsonp")]=function e(t){if(t&&t.jsonp&&t.sendFuncName){var a=function(){};[t.successFuncName,t.failedFuncName].forEach((function(o){o&&(n[o]?c.patchMethod(n,o,(function(o){return function(e,t){var a=n[c.symbol("jsonTask")];return a?(a.callback=o,a.invoke.apply(e,t)):o.apply(e,t)}})):Object.defineProperty(n,o,{configurable:!0,enumerable:!0,get:function(){return function(){var e=n[c.symbol("jsonpTask")],t=n[c.symbol("jsonp".concat(o,"callback"))];return e?(t&&(e.callback=t),n[c.symbol("jsonpTask")]=void 0,e.invoke.apply(this,arguments)):t?t.apply(this,arguments):null}},set:function(n){this[c.symbol("jsonp".concat(o,"callback"))]=n}}))})),c.patchMethod(t.jsonp,t.sendFuncName,(function(e){return function(t,s){n[c.symbol("jsonpTask")]=o.current.scheduleMacroTask("jsonp",a,{},(function(n){return e.apply(t,s)}),a)}}))}}}))}));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             'use strict';
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
        factory();
})((function () {
    'use strict';
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Monkey patch `MessagePort.prototype.onmessage` and `MessagePort.prototype.onmessageerror`
     * properties to make the callback in the zone when the value are set.
     */
    Zone.__load_patch('MessagePort', function (global, Zone, api) {
        var MessagePort = global['MessagePort'];
        if (typeof MessagePort !== 'undefined' && MessagePort.prototype) {
            api.patchOnProperties(MessagePort.prototype, ['message', 'messageerror']);
        }
    });
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "use strict";
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */!function(e){"function"==typeof define&&define.amd?define(e):e()}((function(){
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("MessagePort",(function(e,o,t){var n=e.MessagePort;void 0!==n&&n.prototype&&t.patchOnProperties(n.prototype,["message","messageerror"])}))}));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      'use strict';
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
        factory();
})((function () {
    'use strict';
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Promise for async/fakeAsync zoneSpec test
     * can support async operation which not supported by zone.js
     * such as
     * it ('test jsonp in AsyncZone', async() => {
     *   new Promise(res => {
     *     jsonp(url, (data) => {
     *       // success callback
     *       res(data);
     *     });
     *   }).then((jsonpResult) => {
     *     // get jsonp result.
     *
     *     // user will expect AsyncZoneSpec wait for
     *     // then, but because jsonp is not zone aware
     *     // AsyncZone will finish before then is called.
     *   });
     * });
     */
    Zone.__load_patch('promisefortest', function (global, Zone, api) {
        var symbolState = api.symbol('state');
        var UNRESOLVED = null;
        var symbolParentUnresolved = api.symbol('parentUnresolved');
        // patch Promise.prototype.then to keep an internal
        // number for tracking unresolved chained promise
        // we will decrease this number when the parent promise
        // being resolved/rejected and chained promise was
        // scheduled as a microTask.
        // so we can know such kind of chained promise still
        // not resolved in AsyncTestZone
        Promise[api.symbol('patchPromiseForTest')] = function patchPromiseForTest() {
            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];
            if (oriThen) {
                return;
            }
            oriThen = Promise[Zone.__symbol__('ZonePromiseThen')] = Promise.prototype.then;
            Promise.prototype.then = function () {
                var chained = oriThen.apply(this, arguments);
                if (this[symbolState] === UNRESOLVED) {
                    // parent promise is unresolved.
                    var asyncTestZoneSpec = Zone.current.get('AsyncTestZoneSpec');
                    if (asyncTestZoneSpec) {
                        asyncTestZoneSpec.unresolvedChainedPromiseCount++;
                        chained[symbolParentUnresolved] = true;
                    }
                }
                return chained;
            };
        };
        Promise[api.symbol('unPatchPromiseForTest')] = function unpatchPromiseForTest() {
            // restore origin then
            var oriThen = Promise[Zone.__symbol__('ZonePromiseThen')];
            if (oriThen) {
                Promise.prototype.then = oriThen;
                Promise[Zone.__symbol__('ZonePromiseThen')] = undefined;
            }
        };
    });
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            "use strict";
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */!function(e){"function"==typeof define&&define.amd?define(e):e()}((function(){
/**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
Zone.__load_patch("promisefortest",(function(e,o,n){var s=n.symbol("state"),r=n.symbol("parentUnresolved");Promise[n.symbol("patchPromiseForTest")]=function e(){var n=Promise[o.__symbol__("ZonePromiseThen")];n||(n=Promise[o.__symbol__("ZonePromiseThen")]=Promise.prototype.then,Promise.prototype.then=function(){var e=n.apply(this,arguments);if(null===this[s]){var t=o.current.get("AsyncTestZoneSpec");t&&(t.unresolvedChainedPromiseCount++,e[r]=!0)}return e})},Promise[n.symbol("unPatchPromiseForTest")]=function e(){var n=Promise[o.__symbol__("ZonePromiseThen")];n&&(Promise.prototype.then=n,Promise[o.__symbol__("ZonePromiseThen")]=void 0)}}))}));                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             'use strict';
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
        factory();
})((function () {
    'use strict';
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    Zone.__load_patch('ResizeObserver', function (global, Zone, api) {
        var ResizeObserver = global['ResizeObserver'];
        if (!ResizeObserver) {
            return;
        }
        var resizeObserverSymbol = api.symbol('ResizeObserver');
        api.patchMethod(global, 'ResizeObserver', function (delegate) { return function (self, args) {
            var callback = args.length > 0 ? args[0] : null;
            if (callback) {
                args[0] = function (entries, observer) {
                    var _this = this;
                    var zones = {};
                    var currZone = Zone.current;
                    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                        var entry = entries_1[_i];
                        var zone = entry.target[resizeObserverSymbol];
                        if (!zone) {
                            zone = currZone;
                        }
                        var zoneEntriesInfo = zones[zone.name];
                        if (!zoneEntriesInfo) {
                            zones[zone.name] = zoneEntriesInfo = { entries: [], zone: zone };
                        }
                        zoneEntriesInfo.entries.push(entry);
                    }
                    Object.keys(zones).forEach(function (zoneName) {
                        var zoneEntriesInfo = zones[zoneName];
                        if (zoneEntriesInfo.zone !== Zone.current) {
                            zoneEntriesInfo.zone.run(callback, _this, [zoneEntriesInfo.entries, observer], 'ResizeObserver');
                        }
                        else {
                            callback.call(_this, zoneEntriesInfo.entries, observer);
                        }
                    });
                };
            }
            return args.length > 0 ? new ResizeObserver(args[0]) : new ResizeObserver();
        }; });
        api.patchMethod(ResizeObserver.prototype, 'observe', function (delegate) { return function (self, args) {
            var target = args.length > 0 ? args[0] : null;
            if (!target) {
                return delegate.apply(self, args);
            }
            var targets = self[resizeObserverSymbol];
            if (!targets) {
                targets = self[resizeObserverSymbol] = [];
            }
            targets.push(target);
            target[resizeObserverSymbol] = Zone.current;
            return delegate.apply(self, args);
        }; });
        api.patchMethod(ResizeObserver.prototype, 'unobserve', function (delegate) { return function (self, args) {
            var target = args.length > 0 ? args[0] : null;
            if (!target) {
                return delegate.apply(self, args);
            }
            var targets = self[resizeObserverSymbol];
            if (targets) {
                for (var i = 0; i < targets.length; i++) {
                    if (targets[i] === target) {
                        targets.splice(i, 1);
                        break;
                    }
                }
            }
            target[resizeObserverSymbol] = undefined;
            return delegate.apply(self, args);
        }; });
        api.patchMethod(ResizeObserver.prototype, 'disconnect', function (delegate) { return function (self, args) {
            var targets = self[resizeObserverSymbol];
            if (targets) {
                targets.forEach(function (target) {
                    target[resizeObserverSymbol] = undefined;
                });
                self[resizeObserverSymbol] = undefined;
            }
            return delegate.apply(self, args);
        }; });
    });
}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             (function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.acorn = {}));
})(this, (function (exports) { 'use strict';

  // This file was generated. Do not modify manually!
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  // This file was generated. Do not modify manually!
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];

  // This file was generated. Do not modify manually!
  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

  // This file was generated. Do not modify manually!
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

  // These are a run-length and offset encoded representation of the

  // Reserved word lists for various dialects of the language

  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };

  // And the keywords

  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

  var keywords$1 = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };

  var keywordRelationalOperator = /^in(stanceof)?$/;

  // ## Character categories

  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  // This has a complexity linear to the value of the code. The
  // assumption is that looking up astral identifier characters is
  // rare.
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0; i < set.length; i += 2) {
      pos += set[i];
      if (pos > code) { return false }
      pos += set[i + 1];
      if (pos >= code) { return true }
    }
  }

  // Test whether a given character code starts an identifier.

  function isIdentifierStart(code, astral) {
    if (code < 65) { return code === 36 }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes)
  }

  // Test whether a given character is part of an identifier.

  function isIdentifierChar(code, astral) {
    if (code < 48) { return code === 36 }
    if (code < 58) { return true }
    if (code < 65) { return false }
    if (code < 91) { return true }
    if (code < 97) { return code === 95 }
    if (code < 123) { return true }
    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
    if (astral === false) { return false }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // The `startsExpr` property is used to check if the token ends a
  // `yield` expression. It is set on all token types that either can
  // directly start an expression (like a quotation mark) or can
  // continue an expression (like the body of a string).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var TokenType = function TokenType(label, conf) {
    if ( conf === void 0 ) conf = {};

    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };

  function binop(name, prec) {
    return new TokenType(name, {beforeExpr: true, binop: prec})
  }
  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

  // Map keyword names to token types.

  var keywords = {};

  // Succinct definitions of keyword token types
  function kw(name, options) {
    if ( options === void 0 ) options = {};

    options.keyword = name;
    return keywords[name] = new TokenType(name, options)
  }

  var types$1 = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    privateId: new TokenType("privateId", startsExpr),
    eof: new TokenType("eof"),

    // Punctuation token types.
    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.

    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
    prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {beforeExpr: true}),
    coalesce: binop("??", 1),

    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {isLoop: true, beforeExpr: true}),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {isLoop: true}),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {isLoop: true}),
    _with: kw("with"),
    _new: kw("new", {beforeExpr: true, startsExpr: true}),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {beforeExpr: true, binop: 7}),
    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
  };

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");

  function isNewLine(code) {
    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
  }

  function nextLineBreak(code, from, end) {
    if ( end === void 0 ) end = code.length;

    for (var i = from; i < end; i++) {
      var next = code.charCodeAt(i);
      if (isNewLine(next))
        { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
    }
    return -1
  }

  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

  var ref = Object.prototype;
  var hasOwnProperty = ref.hasOwnProperty;
  var toString = ref.toString;

  var hasOwn = Object.hasOwn || (function (obj, propName) { return (
    hasOwnProperty.call(obj, propName)
  ); });

  var isArray = Array.isArray || (function (obj) { return (
    toString.call(obj) === "[object Array]"
  ); });

  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
  }

  function codePointToString(code) {
    // UTF-16 Decoding
    if (code <= 0xFFFF) { return String.fromCharCode(code) }
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
  }

  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

  // These are used when `options.locations` is on, for the
  // `startLoc` and `endLoc` properties.

  var Position = function Position(line, col) {
    this.line = line;
    this.column = col;
  };

  Position.prototype.offset = function offset (n) {
    return new Position(this.line, this.column + n)
  };

  var SourceLocation = function SourceLocation(p, start, end) {
    this.start = start;
    this.end = end;
    if (p.sourceFile !== null) { this.source = p.sourceFile; }
  };

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0;;) {
      var nextBreak = nextLineBreak(input, cur, offset);
      if (nextBreak < 0) { return new Position(line, offset - cur) }
      ++line;
      cur = nextBreak;
    }
  }

  // A second argument must be given to configure the parser process.
  // These options are recognized (only `ecmaVersion` is required):

  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
    // (2019), 11 (2020), 12 (2021), 13 (2022), or `"latest"` (the
    // latest version the library supports). This influences support
    // for strict mode, the set of reserved words, and support for
    // new syntax features.
    ecmaVersion: null,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program, and an import.meta expression
    // in a script isn't considered an error.
    allowImportExportEverywhere: false,
    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: null,
    // When enabled, super identifiers are not constrained to
    // appearing in methods and do not raise an error when they appear elsewhere.
    allowSuperOutsideMethod: null,
    // When enabled, hashbang directive in the beginning of file
    // is allowed and treated as a line comment.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callbackthat will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callbackthat will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };

  // Interpret and default an options object

  var warnedAboutEcmaVersion = false;

  function getOptions(opts) {
    var options = {};

    for (var opt in defaultOptions)
      { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

    if (options.ecmaVersion === "latest") {
      options.ecmaVersion = 1e8;
    } else if (options.ecmaVersion == null) {
      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
        warnedAboutEcmaVersion = true;
        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
      }
      options.ecmaVersion = 11;
    } else if (options.ecmaVersion >= 2015) {
      options.ecmaVersion -= 2009;
    }

    if (options.allowReserved == null)
      { options.allowReserved = options.ecmaVersion < 5; }

    if (isArray(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function (token) { return tokens.push(token); };
    }
    if (isArray(options.onComment))
      { options.onComment = pushComment(options, options.onComment); }

    return options
  }

  function pushComment(options, array) {
    return function(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text,
        start: start,
        end: end
      };
      if (options.locations)
        { comment.loc = new SourceLocation(this, startLoc, endLoc); }
      if (options.ranges)
        { comment.range = [start, end]; }
      array.push(comment);
    }
  }

  // Each scope gets a bitset that may contain these flags
  var
      SCOPE_TOP = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_ASYNC = 4,
      SCOPE_GENERATOR = 8,
      SCOPE_ARROW = 16,
      SCOPE_SIMPLE_CATCH = 32,
      SCOPE_SUPER = 64,
      SCOPE_DIRECT_SUPER = 128,
      SCOPE_CLASS_STATIC_BLOCK = 256,
      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
  }

  // Used in checkLVal* and declareName to determine the type of a binding
  var
      BIND_NONE = 0, // Not a binding
      BIND_VAR = 1, // Var-style binding
      BIND_LEXICAL = 2, // Let- or const-style binding
      BIND_FUNCTION = 3, // Function declaration
      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

  var Parser = function Parser(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved = "";
    if (options.allowReserved !== true) {
      reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
      if (options.sourceType === "module") { reserved += " await"; }
    }
    this.reservedWords = wordsRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);

    // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.
    this.containsEsc = false;

    // Set up token state

    // The current position of the tokenizer in the input.
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }

    // Properties of the current token:
    // Its type
    this.type = types$1.eof;
    // For tokens that include more information than their type, the value
    this.value = null;
    // Its start and end offset
    this.start = this.end = this.pos;
    // And, if locations are used, the {line, column} object
    // corresponding to those offsets
    this.startLoc = this.endLoc = this.curPosition();

    // Position information for the previous token
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.
    this.context = this.initialContext();
    this.exprAllowed = true;

    // Figure out if it's a module code.
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);

    // Used to signify the start of a potential arrow function
    this.potentialArrowAt = -1;
    this.potentialArrowInForAwait = false;

    // Positions to delayed-check that yield/await does not exist in default parameters.
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    // Labels in scope.
    this.labels = [];
    // Thus-far undefined exports.
    this.undefinedExports = Object.create(null);

    // If enabled, skip leading hashbang line.
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      { this.skipLineComment(2); }

    // Scope tracking for duplicate variable names (see scope.js)
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);

    // For RegExp validation
    this.regexpState = null;

    // The stack of private names.
    // Each element has two properties: 'declared' and 'used'.
    // When it exited from the outermost class definition, all used private names must be declared.
    this.privateNameStack = [];
  };

  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

  Parser.prototype.parse = function parse () {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node)
  };

  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

  prototypeAccessors.canAwait.get = function () {
    for (var i = this.scopeStack.length - 1; i >= 0; i--) {
      var scope = this.scopeStack[i];
      if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
      if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
    }
    return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
  };

  prototypeAccessors.allowSuper.get = function () {
    var ref = this.currentThisScope();
      var flags = ref.flags;
      var inClassFieldInit = ref.inClassFieldInit;
    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
  };

  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

  prototypeAccessors.allowNewDotTarget.get = function () {
    var ref = this.currentThisScope();
      var flags = ref.flags;
      var inClassFieldInit = ref.inClassFieldInit;
    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
  };

  prototypeAccessors.inClassStaticBlock.get = function () {
    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
  };

  Parser.extend = function extend () {
      var plugins = [], len = arguments.length;
      while ( len-- ) plugins[ len ] = arguments[ len ];

    var cls = this;
    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
    return cls
  };

  Parser.parse = function parse (input, options) {
    return new this(options, input).parse()
  };

  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression()
  };

  Parser.tokenizer = function tokenizer (input, options) {
    return new this(options, input)
  };

  Object.defineProperties( Parser.prototype, prototypeAccessors );

  var pp$9 = Parser.prototype;

  // ## Parser utilities

  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  pp$9.strictDirective = function(start) {
    if (this.options.ecmaVersion < 5) { return false }
    for (;;) {
      // Try to find string literal.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match) { return false }
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" ||
          (lineBreak.test(spaceAfter[0]) &&
           !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
      }
      start += match[0].length;

      // Skip semicolon, if any.
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        { start++; }
    }
  };

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  pp$9.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true
    } else {
      return false
    }
  };

  // Tests whether parsed token is a contextual keyword.

  pp$9.isContextual = function(name) {
    return this.type === types$1.name && this.value === name && !this.containsEsc
  };

  // Consumes contextual keyword if possible.

  pp$9.eatContextual = function(name) {
    if (!this.isContextual(name)) { return false }
    this.next();
    return true
  };

  // Asserts that following token is given contextual keyword.

  pp$9.expectContextual = function(name) {
    if (!this.eatContextual(name)) { this.unexpected(); }
  };

  // Test whether a semicolon can be inserted at the current position.

  pp$9.canInsertSemicolon = function() {
    return this.type === types$1.eof ||
      this.type === types$1.braceR ||
      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  pp$9.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
      return true
    }
  };

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  pp$9.semicolon = function() {
    if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
  };

  pp$9.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
      if (!notNext)
        { this.next(); }
      return true
    }
  };

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  pp$9.expect = function(type) {
    this.eat(type) || this.unexpected();
  };

  // Raise an unexpected token error.

  pp$9.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };

  var DestructuringErrors = function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.doubleProto =
      -1;
  };

  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors) { return }
    if (refDestructuringErrors.trailingComma > -1)
      { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
  };

  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors) { return false }
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
    if (shorthandAssign >= 0)
      { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
    if (doubleProto >= 0)
      { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
  };

  pp$9.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
    if (this.awaitPos)
      { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
  };

  pp$9.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      { return this.isSimpleAssignTarget(expr.expression) }
    return expr.type === "Identifier" || expr.type === "MemberExpression"
  };

  var pp$8 = Parser.prototype;

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  pp$8.parseTopLevel = function(node) {
    var exports = Object.create(null);
    if (!node.body) { node.body = []; }
    while (this.type !== types$1.eof) {
      var stmt = this.parseStatement(null, true, exports);
      node.body.push(stmt);
    }
    if (this.inModule)
      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
        {
          var name = list[i];

          this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
        } }
    this.adaptDirectivePrologue(node.body);
    this.next();
    node.sourceType = this.options.sourceType;
    return this.finishNode(node, "Program")
  };

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  pp$8.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    // For ambiguous cases, determine if a LexicalDeclaration (or only a
    // Statement) is allowed here. If context is not empty then only a Statement
    // is allowed. However, `let [` is an explicit negative lookahead for
    // ExpressionStatement, so special-case it first.
    if (nextCh === 91 || nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '[', '/', astral
    if (context) { return false }

    if (nextCh === 123) { return true } // '{'
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
      if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident)) { return true }
    }
    return false
  };

  // check 'async [no LineTerminator here] function'
  // - 'async /*foo*/ function' is OK.
  // - 'async /*\n*/ function' is invalid.
  pp$8.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      { return false }

    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, after;
    return !lineBreak.test(this.input.slice(this.pos, next)) &&
      this.input.slice(next, next + 8) === "function" &&
      (next + 8 === this.input.length ||
       !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
  };

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
  // does not help.

  pp$8.parseStatement = function(context, topLevel, exports) {
    var starttype = this.type, node = this.startNode(), kind;

    if (this.isLet(context)) {
      starttype = types$1._var;
      kind = "let";
    }

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
    case types$1._debugger: return this.parseDebuggerStatement(node)
    case types$1._do: return this.parseDoStatement(node)
    case types$1._for: return this.parseForStatement(node)
    case types$1._function:
      // Function as sole body of either an if statement or a labeled statement
      // works, but not when it is part of a labeled statement that is the sole
      // body of an if statement.
      if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
      return this.parseFunctionStatement(node, false, !context)
    case types$1._class:
      if (context) { this.unexpected(); }
      return this.parseClass(node, true)
    case types$1._if: return this.parseIfStatement(node)
    case types$1._return: return this.parseReturnStatement(node)
    case types$1._switch: return this.parseSwitchStatement(node)
    case types$1._throw: return this.parseThrowStatement(node)
    case types$1._try: return this.parseTryStatement(node)
    case types$1._const: case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") { this.unexpected(); }
      return this.parseVarStatement(node, kind)
    case types$1._while: return this.parseWhileStatement(node)
    case types$1._with: return this.parseWithStatement(node)
    case types$1.braceL: return this.parseBlock(true, node)
    case types$1.semi: return this.parseEmptyStatement(node)
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) // '(' or '.'
          { return this.parseExpressionStatement(node, this.parseExpression()) }
      }

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel)
          { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
        if (!this.inModule)
          { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) { this.unexpected(); }
        this.next();
        return this.parseFunctionStatement(node, true, !context)
      }

      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
        { return this.parseLabeledStatement(node, maybeName, expr, context) }
      else { return this.parseExpressionStatement(node, expr) }
    }
  };

  pp$8.parseBreakContinueStatement = function(node, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
    else if (this.type !== types$1.name) { this.unexpected(); }
    else {
      node.label = this.parseIdent();
      this.semicolon();
    }

    // Verify that there is an actual destination to break or
    // continue to.
    var i = 0;
    for (; i < this.labels.length; ++i) {
      var lab = this.labels[i];
      if (node.label == null || lab.name === node.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
        if (node.label && isBreak) { break }
      }
    }
    if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
  };

  pp$8.parseDebuggerStatement = function(node) {
    this.next();
    this.semicolon();
    return this.finishNode(node, "DebuggerStatement")
  };

  pp$8.parseDoStatement = function(node) {
    this.next();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types$1._while);
    node.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      { this.eat(types$1.semi); }
    else
      { this.semicolon(); }
    return this.finishNode(node, "DoWhileStatement")
  };

  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
  // loop is non-trivial. Basically, we have to parse the init `var`
  // statement or expression, disallowing the `in` operator (see
  // the second parameter to `parseExpression`), and then check
  // whether the next token is `in` or `of`. When there is no init
  // part (semicolon immediately after the opening parenthesis), it
  // is a regular `for` loop.

  pp$8.parseForStatement = function(node) {
    this.next();
    var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types$1.parenL);
    if (this.type === types$1.semi) {
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, null)
    }
    var isLet = this.isLet();
    if (this.type === types$1._var || this.type === types$1._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
          } else { node.await = awaitAt > -1; }
        }
        return this.parseForIn(node, init$1)
      }
      if (awaitAt > -1) { this.unexpected(awaitAt); }
      return this.parseFor(node, init$1)
    }
    var startsWithLet = this.isContextual("let"), isForOf = false;
    var refDestructuringErrors = new DestructuringErrors;
    var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLValPattern(init);
      return this.parseForIn(node, init)
    } else {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init)
  };

  pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
  };

  pp$8.parseIfStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    // allow function declarations in branches, but only in non-strict mode
    node.consequent = this.parseStatement("if");
    node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
    return this.finishNode(node, "IfStatement")
  };

  pp$8.parseReturnStatement = function(node) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      { this.raise(this.start, "'return' outside of function"); }
    this.next();

    // In `return` (and `break`/`continue`), the keywords with
    // optional arguments, we eagerly look for a semicolon or the
    // possibility to insert one.

    if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
    else { node.argument = this.parseExpression(); this.semicolon(); }
    return this.finishNode(node, "ReturnStatement")
  };

  pp$8.parseSwitchStatement = function(node) {
    this.next();
    node.discriminant = this.parseParenExpression();
    node.cases = [];
    this.expect(types$1.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);

    // Statements under must be grouped (by label) in SwitchCase
    // nodes. `cur` is used to keep the node that we are currently
    // adding statements to.

    var cur;
    for (var sawDefault = false; this.type !== types$1.braceR;) {
      if (this.type === types$1._case || this.type === types$1._default) {
        var isCase = this.type === types$1._case;
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        node.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase) {
          cur.test = this.parseExpression();
        } else {
          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types$1.colon);
      } else {
        if (!cur) { this.unexpected(); }
        cur.consequent.push(this.parseStatement(null));
      }
    }
    this.exitScope();
    if (cur) { this.finishNode(cur, "SwitchCase"); }
    this.next(); // Closing brace
    this.labels.pop();
    return this.finishNode(node, "SwitchStatement")
  };

  pp$8.parseThrowStatement = function(node) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
    node.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node, "ThrowStatement")
  };

  // Reused empty array added for node fields that are always empty.

  var empty$1 = [];

  pp$8.parseTryStatement = function(node) {
    this.next();
    node.block = this.parseBlock();
    node.handler = null;
    if (this.type === types$1._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types$1.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
      } else {
        if (this.options.ecmaVersion < 10) { this.unexpected(); }
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node.handler = this.finishNode(clause, "CatchClause");
    }
    node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
    if (!node.handler && !node.finalizer)
      { this.raise(node.start, "Missing catch or finally clause"); }
    return this.finishNode(node, "TryStatement")
  };

  pp$8.parseVarStatement = function(node, kind) {
    this.next();
    this.parseVar(node, false, kind);
    this.semicolon();
    return this.finishNode(node, "VariableDeclaration")
  };

  pp$8.parseWhileStatement = function(node) {
    this.next();
    node.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node, "WhileStatement")
  };

  pp$8.parseWithStatement = function(node) {
    if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
    this.next();
    node.object = this.parseParenExpression();
    node.body = this.parseStatement("with");
    return this.finishNode(node, "WithStatement")
  };

  pp$8.parseEmptyStatement = function(node) {
    this.next();
    return this.finishNode(node, "EmptyStatement")
  };

  pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
      {
      var label = list[i$1];

      if (label.name === maybeName)
        { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    } }
    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
    for (var i = this.labels.length - 1; i >= 0; i--) {
      var label$1 = this.labels[i];
      if (label$1.statementStart === node.start) {
        // Update information about previous labels on this node
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else { break }
    }
    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
    node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node.label = expr;
    return this.finishNode(node, "LabeledStatement")
  };

  pp$8.parseExpressionStatement = function(node, expr) {
    node.expression = expr;
    this.semicolon();
    return this.finishNode(node, "ExpressionStatement")
  };

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
    if ( node === void 0 ) node = this.startNode();

    node.body = [];
    this.expect(types$1.braceL);
    if (createNewLexicalScope) { this.enterScope(0); }
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    if (exitStrict) { this.strict = false; }
    this.next();
    if (createNewLexicalScope) { this.exitScope(); }
    return this.finishNode(node, "BlockStatement")
  };

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  pp$8.parseFor = function(node, init) {
    node.init = init;
    this.expect(types$1.semi);
    node.test = this.type === types$1.semi ? null : this.parseExpression();
    this.expect(types$1.semi);
    node.update = this.type === types$1.parenR ? null : this.parseExpression();
    this.expect(types$1.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, "ForStatement")
  };

  // Parse a `for`/`in` and `for`/`of` loop, which are almost
  // same from parser's perspective.

  pp$8.parseForIn = function(node, init) {
    var isForIn = this.type === types$1._in;
    this.next();

    if (
      init.type === "VariableDeclaration" &&
      init.declarations[0].init != null &&
      (
        !isForIn ||
        this.options.ecmaVersion < 8 ||
        this.strict ||
        init.kind !== "var" ||
        init.declarations[0].id.type !== "Identifier"
      )
    ) {
      this.raise(
        init.start,
        ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
      );
    }
    node.left = init;
    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types$1.parenR);
    node.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
  };

  // Parse a list of variable declarations.

  pp$8.parseVar = function(node, isFor, kind) {
    node.declarations = [];
    node.kind = kind;
    for (;;) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types$1.eq)) {
        decl.init = this.parseMaybeAssign(isFor);
      } else if (kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
        this.unexpected();
      } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      } else {
        decl.init = null;
      }
      node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types$1.comma)) { break }
    }
    return node
  };

  pp$8.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };

  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

  // Parse a function declaration or literal (depending on the
  // `statement & FUNC_STATEMENT`).

  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
  pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
    this.initFunction(node);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
        { this.unexpected(); }
      node.generator = this.eat(types$1.star);
    }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    if (statement & FUNC_STATEMENT) {
      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
      if (node.id && !(statement & FUNC_HANGING_STATEMENT))
        // If it is a regular function declaration in sloppy mode, then it is
        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
        // mode depends on properties of the current scope (see
        // treatFunctionsAsVar).
        { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
    }

    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node.async, node.generator));

    if (!(statement & FUNC_STATEMENT))
      { node.id = this.type === types$1.name ? this.parseIdent() : null; }

    this.parseFunctionParams(node);
    this.parseFunctionBody(node, allowExpressionBody, false, forInit);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
  };

  pp$8.parseFunctionParams = function(node) {
    this.expect(types$1.parenL);
    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };

  // Parse a class declaration or literal (depending on the
  // `isStatement` parameter).

  pp$8.parseClass = function(node, isStatement) {
    this.next();

    // ecma-262 14.6 Class Definitions
    // A class definition is always strict mode code.
    var oldStrict = this.strict;
    this.strict = true;

    this.parseClassId(node, isStatement);
    this.parseClassSuper(node);
    var privateNameMap = this.enterClassBody();
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types$1.braceL);
    while (this.type !== types$1.braceR) {
      var element = this.parseClassElement(node.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
          hadConstructor = true;
        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
          this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
        }
      }
    }
    this.strict = oldStrict;
    this.next();
    node.body = this.finishNode(classBody, "ClassBody");
    this.exitClassBody();
    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
  };

  pp$8.parseClassElement = function(constructorAllowsSuper) {
    if (this.eat(types$1.semi)) { return null }

    var ecmaVersion = this.options.ecmaVersion;
    var node = this.startNode();
    var keyName = "";
    var isGenerator = false;
    var isAsync = false;
    var kind = "method";
    var isStatic = false;

    if (this.eatContextual("static")) {
      // Parse static init block
      if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
        this.parseClassStaticBlock(node);
        return node
      }
      if (this.isClassElementNameStart() || this.type === types$1.star) {
        isStatic = true;
      } else {
        keyName = "static";
      }
    }
    node.static = isStatic;
    if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
        isAsync = true;
      } else {
        keyName = "async";
      }
    }
    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
      isGenerator = true;
    }
    if (!keyName && !isAsync && !isGenerator) {
      var lastValue = this.value;
      if (this.eatContextual("get") || this.eatContextual("set")) {
        if (this.isClassElementNameStart()) {
          kind = lastValue;
        } else {
          keyName = lastValue;
        }
      }
    }

    // Parse element name
    if (keyName) {
      // 'async', 'get', 'set', or 'static' were not a keyword contextually.
      // The last token is any of those. Make it the element name.
      node.computed = false;
      node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
      node.key.name = keyName;
      this.finishNode(node.key, "Identifier");
    } else {
      this.parseClassElementName(node);
    }

    // Parse element value
    if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
      var isConstructor = !node.static && checkKeyName(node, "constructor");
      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
      // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
      if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
      node.kind = isConstructor ? "constructor" : kind;
      this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
    } else {
      this.parseClassField(node);
    }

    return node
  };

  pp$8.isClassElementNameStart = function() {
    return (
      this.type === types$1.name ||
      this.type === types$1.privateId ||
      this.type === types$1.num ||
      this.type === types$1.string ||
      this.type === types$1.bracketL ||
      this.type.keyword
    )
  };

  pp$8.parseClassElementName = function(element) {
    if (this.type === types$1.privateId) {
      if (this.value === "constructor") {
        this.raise(this.start, "Classes can't have an element named '#constructor'");
      }
      element.computed = false;
      element.key = this.parsePrivateIdent();
    } else {
      this.parsePropertyName(element);
    }
  };

  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    // Check key and flags
    var key = method.key;
    if (method.kind === "constructor") {
      if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
      if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    } else if (method.static && checkKeyName(method, "prototype")) {
      this.raise(key.start, "Classes may not have a static property named prototype");
    }

    // Parse value
    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

    // Check value
    if (method.kind === "get" && value.params.length !== 0)
      { this.raiseRecoverable(value.start, "getter should have no params"); }
    if (method.kind === "set" && value.params.length !== 1)
      { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
    if (method.kind === "set" && value.params[0].type === "RestElement")
      { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

    return this.finishNode(method, "MethodDefinition")
  };

  pp$8.parseClassField = function(field) {
    if (checkKeyName(field, "constructor")) {
      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
    } else if (field.static && checkKeyName(field, "prototype")) {
      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
    }

    if (this.eat(types$1.eq)) {
      // To raise SyntaxError if 'arguments' exists in the initializer.
      var scope = this.currentThisScope();
      var inClassFieldInit = scope.inClassFieldInit;
      scope.inClassFieldInit = true;
      field.value = this.parseMaybeAssign();
      scope.inClassFieldInit = inClassFieldInit;
    } else {
      field.value = null;
    }
    this.semicolon();

    return this.finishNode(field, "PropertyDefinition")
  };

  pp$8.parseClassStaticBlock = function(node) {
    node.body = [];

    var oldLabels = this.labels;
    this.labels = [];
    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node.body.push(stmt);
    }
    this.next();
    this.exitScope();
    this.labels = oldLabels;

    return this.finishNode(node, "StaticBlock")
  };

  pp$8.parseClassId = function(node, isStatement) {
    if (this.type === types$1.name) {
      node.id = this.parseIdent();
      if (isStatement)
        { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
    } else {
      if (isStatement === true)
        { this.unexpected(); }
      node.id = null;
    }
  };

  pp$8.parseClassSuper = function(node) {
    node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
  };

  pp$8.enterClassBody = function() {
    var element = {declared: Object.create(null), used: []};
    this.privateNameStack.push(element);
    return element.declared
  };

  pp$8.exitClassBody = function() {
    var ref = this.privateNameStack.pop();
    var declared = ref.declared;
    var used = ref.used;
    var len = this.privateNameStack.length;
    var parent = len === 0 ? null : this.privateNameStack[len - 1];
    for (var i = 0; i < used.length; ++i) {
      var id = used[i];
      if (!hasOwn(declared, id.name)) {
        if (parent) {
          parent.used.push(id);
        } else {
          this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
        }
      }
    }
  };

  function isPrivateNameConflicted(privateNameMap, element) {
    var name = element.key.name;
    var curr = privateNameMap[name];

    var next = "true";
    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
      next = (element.static ? "s" : "i") + element.kind;
    }

    // `class { get #a(){}; static set #a(_){} }` is also conflict.
    if (
      curr === "iget" && next === "iset" ||
      curr === "iset" && next === "iget" ||
      curr === "sget" && next === "sset" ||
      curr === "sset" && next === "sget"
    ) {
      privateNameMap[name] = "true";
      return false
    } else if (!curr) {
      privateNameMap[name] = next;
      return false
    } else {
      return true
    }
  }

  function checkKeyName(node, name) {
    var computed = node.computed;
    var key = node.key;
    return !computed && (
      key.type === "Identifier" && key.name === name ||
      key.type === "Literal" && key.value === name
    )
  }

  // Parses module export declaration.

  pp$8.parseExport = function(node, exports) {
    this.next();
    // export * from '...'
    if (this.eat(types$1.star)) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseModuleExportName();
          this.checkExport(exports, node.exported, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration")
    }
    if (this.eat(types$1._default)) { // export default ...
      this.checkExport(exports, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) { this.next(); }
        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types$1._class) {
        var cNode = this.startNode();
        node.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node, "ExportDefaultDeclaration")
    }
    // export var|const|let|function|class ...
    if (this.shouldParseExportStatement()) {
      node.declaration = this.parseStatement(null);
      if (node.declaration.type === "VariableDeclaration")
        { this.checkVariableExport(exports, node.declaration.declarations); }
      else
        { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
      node.specifiers = [];
      node.source = null;
    } else { // export { x, y as z } [from '...']
      node.declaration = null;
      node.specifiers = this.parseExportSpecifiers(exports);
      if (this.eatContextual("from")) {
        if (this.type !== types$1.string) { this.unexpected(); }
        node.source = this.parseExprAtom();
      } else {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          // check for keywords used as local names
          var spec = list[i];

          this.checkUnreserved(spec.local);
          // check if export is defined
          this.checkLocalExport(spec.local);

          if (spec.local.type === "Literal") {
            this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
          }
        }

        node.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node, "ExportNamedDeclaration")
  };

  pp$8.checkExport = function(exports, name, pos) {
    if (!exports) { return }
    if (typeof name !== "string")
      { name = name.type === "Identifier" ? name.name : name.value; }
    if (hasOwn(exports, name))
      { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
    exports[name] = true;
  };

  pp$8.checkPatternExport = function(exports, pat) {
    var type = pat.type;
    if (type === "Identifier")
      { this.checkExport(exports, pat, pat.start); }
    else if (type === "ObjectPattern")
      { for (var i = 0, list = pat.properties; i < list.length; i += 1)
        {
          var prop = list[i];

          this.checkPatternExport(exports, prop);
        } }
    else if (type === "ArrayPattern")
      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
        var elt = list$1[i$1];

          if (elt) { this.checkPatternExport(exports, elt); }
      } }
    else if (type === "Property")
      { this.checkPatternExport(exports, pat.value); }
    else if (type === "AssignmentPattern")
      { this.checkPatternExport(exports, pat.left); }
    else if (type === "RestElement")
      { this.checkPatternExport(exports, pat.argument); }
    else if (type === "ParenthesizedExpression")
      { this.checkPatternExport(exports, pat.expression); }
  };

  pp$8.checkVariableExport = function(exports, decls) {
    if (!exports) { return }
    for (var i = 0, list = decls; i < list.length; i += 1)
      {
      var decl = list[i];

      this.checkPatternExport(exports, decl.id);
    }
  };

  pp$8.shouldParseExportStatement = function() {
    return this.type.keyword === "var" ||
      this.type.keyword === "const" ||
      this.type.keyword === "class" ||
      this.type.keyword === "function" ||
      this.isLet() ||
      this.isAsyncFunction()
  };

  // Parses a comma-separated list of module exports.

  pp$8.parseExportSpecifiers = function(exports) {
    var nodes = [], first = true;
    // export { x, y as z } [from '...']
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) { break }
      } else { first = false; }

      var node = this.startNode();
      node.local = this.parseModuleExportName();
      node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
      this.checkExport(
        exports,
        node.exported,
        node.exported.start
      );
      nodes.push(this.finishNode(node, "ExportSpecifier"));
    }
    return nodes
  };

  // Parses import declaration.

  pp$8.parseImport = function(node) {
    this.next();
    // import '...'
    if (this.type === types$1.string) {
      node.specifiers = empty$1;
      node.source = this.parseExprAtom();
    } else {
      node.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node, "ImportDeclaration")
  };

  // Parses a comma-separated list of module imports.

  pp$8.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types$1.name) {
      // import defaultObj, { x, y as z } from '...'
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLValSimple(node.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
      if (!this.eat(types$1.comma)) { return nodes }
    }
    if (this.type === types$1.star) {
      var node$1 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$1.local = this.parseIdent();
      this.checkLValSimple(node$1.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
      return nodes
    }
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR)) { break }
      } else { first = false; }

      var node$2 = this.startNode();
      node$2.imported = this.parseModuleExportName();
      if (this.eatContextual("as")) {
        node$2.local = this.parseIdent();
      } else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLValSimple(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes
  };

  pp$8.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
      var stringLiteral = this.parseLiteral(this.value);
      if (loneSurrogate.test(stringLiteral.value)) {
        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
      }
      return stringLiteral
    }
    return this.parseIdent(true)
  };

  // Set `ExpressionStatement#directive` property for directive prologues.
  pp$8.adaptDirectivePrologue = function(statements) {
    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
      statements[i].directive = statements[i].expression.raw.slice(1, -1);
    }
  };
  pp$8.isDirectiveCandidate = function(statement) {
    return (
      statement.type === "ExpressionStatement" &&
      statement.expression.type === "Literal" &&
      typeof statement.expression.value === "string" &&
      // Reject parenthesized strings.
      (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
    )
  };

  var pp$7 = Parser.prototype;

  // Convert existing expression atom to assignable pattern
  // if possible.

  pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node) {
      switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await")
          { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
        break

      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break

      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];

        this.toAssignable(prop, isBinding);
          // Early error:
          //   AssignmentRestProperty[Yield, Await] :
          //     `...` DestructuringAssignmentTarget[Yield, Await]
          //
          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
          if (
            prop.type === "RestElement" &&
            (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
          ) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break

      case "Property":
        // AssignmentProperty has type === "Property"
        if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
        this.toAssignable(node.value, isBinding);
        break

      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        this.toAssignableList(node.elements, isBinding);
        break

      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern")
          { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
        break

      case "AssignmentExpression":
        if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break

      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break

      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break

      case "MemberExpression":
        if (!isBinding) { break }

      default:
        this.raise(node.start, "Assigning to rvalue");
      }
    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
    return node
  };

  // Convert list of expression atoms to binding list.

  pp$7.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i = 0; i < end; i++) {
      var elt = exprList[i];
      if (elt) { this.toAssignable(elt, isBinding); }
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        { this.unexpected(last.argument.start); }
    }
    return exprList
  };

  // Parses spread element.

  pp$7.parseSpread = function(refDestructuringErrors) {
    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node, "SpreadElement")
  };

  pp$7.parseRestBinding = function() {
    var node = this.startNode();
    this.next();

    // RestElement inside of a function parameter must be an identifier
    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
      { this.unexpected(); }

    node.argument = this.parseBindingAtom();

    return this.finishNode(node, "RestElement")
  };

  // Parses lvalue (assignable) atom.

  pp$7.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6) {
      switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern")

      case types$1.braceL:
        return this.parseObj(true)
      }
    }
    return this.parseIdent()
  };

  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first) { first = false; }
      else { this.expect(types$1.comma); }
      if (allowEmpty && this.type === types$1.comma) {
        elts.push(null);
      } else if (allowTrailingComma && this.afterTrailingComma(close)) {
        break
      } else if (this.type === types$1.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        this.expect(close);
        break
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts
  };

  pp$7.parseBindingListItem = function(param) {
    return param
  };

  // Parses assignment pattern around given atom if possible.

  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.right = this.parseMaybeAssign();
    return this.finishNode(node, "AssignmentPattern")
  };

  // The following three functions all verify that a node is an lvalue 
  // something that can be bound, or assigned to. In order to do so, they perform
  // a variety of checks:
  //
  // - Check that none of the bound/assigned-to identifiers are reserved words.
  // - Record name declarations for bindings in the appropriate scope.
  // - Check duplicate argument names, if checkClashes is set.
  //
  // If a complex binding pattern is encountered (e.g., object and array
  // destructuring), the entire pattern is recursively checked.
  //
  // There are three versions of checkLVal*() appropriate for different
  // circumstances:
  //
  // - checkLValSimple() shall be used if the syntactic construct supports
  //   nothing other than identifiers and member expressions. Parenthesized
  //   expressions are also correctly handled. This is generally appropriate for
  //   constructs for which the spec says
  //
  //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
  //   > simple.
  //
  //   It is also appropriate for checking if an identifier is valid and not
  //   defined elsewhere, like import declarations or function/class identifiers.
  //
  //   Examples where this is used include:
  //     a += ;
  //     import a from '';
  //   where a is the node to be checked.
  //
  // - checkLValPattern() shall be used if the syntactic construct supports
  //   anything checkLValSimple() supports, as well as object and array
  //   destructuring patterns. This is generally appropriate for constructs for
  //   which the spec says
  //
  //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
  //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
  //   > simple.
  //
  //   Examples where this is used include:
  //     (a = );
  //     const a = ;
  //     try {  } catch (a) {  }
  //   where a is the node to be checked.
  //
  // - checkLValInnerPattern() shall be used if the syntactic construct supports
  //   anything checkLValPattern() supports, as well as default assignment
  //   patterns, rest elements, and other constructs that may appear within an
  //   object or array destructuring pattern.
  //
  //   As a special case, function parameters also use checkLValInnerPattern(),
  //   as they also support defaults and rest constructs.
  //
  // These functions deliberately support both assignment and binding constructs,
  // as the logic for both is exceedingly similar. If the node is the target of
  // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
  // should be set to the appropriate BIND_* constant, like BIND_VAR or
  // BIND_LEXICAL.
  //
  // If the function is called with a non-BIND_NONE bindingType, then
  // additionally a checkClashes object may be specified to allow checking for
  // duplicate argument names. checkClashes is ignored if the provided construct
  // is an assignment (i.e., bindingType is BIND_NONE).

  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    var isBind = bindingType !== BIND_NONE;

    switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
        { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let")
          { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name))
            { this.raiseRecoverable(expr.start, "Argument name clash"); }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
      }
      break

    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
      break

    case "ParenthesizedExpression":
      if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes)

    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
    }
  };

  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break

    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];

      if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
      }
      break

    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
    }
  };

  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
    if ( bindingType === void 0 ) bindingType = BIND_NONE;

    switch (expr.type) {
    case "Property":
      // AssignmentProperty has type === "Property"
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break

    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break

    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break

    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
    }
  };

  // The algorithm used to determine whether a regexp can appear at a

  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };

  var types = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };

  var pp$6 = Parser.prototype;

  pp$6.initialContext = function() {
    return [types.b_stat]
  };

  pp$6.curContext = function() {
    return this.context[this.context.length - 1]
  };

  pp$6.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types.f_expr || parent === types.f_stat)
      { return true }
    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
      { return !parent.isExpr }

    // The check for `tt.name && exprAllowed` detects whether we are
    // after a `yield` or `of` construct. See the `updateContext` for
    // `tt.name`.
    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
      { return true }
    if (prevType === types$1.braceL)
      { return parent === types.b_stat }
    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
      { return false }
    return !this.exprAllowed
  };

  pp$6.inGeneratorContext = function() {
    for (var i = this.context.length - 1; i >= 1; i--) {
      var context = this.context[i];
      if (context.token === "function")
        { return context.generator }
    }
    return false
  };

  pp$6.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types$1.dot)
      { this.exprAllowed = false; }
    else if (update = type.updateContext)
      { update.call(this, prevType); }
    else
      { this.exprAllowed = type.beforeExpr; }
  };

  // Used to handle egde case when token context could not be inferred correctly in tokenize phase
  pp$6.overrideContext = function(tokenCtx) {
    if (this.curContext() !== tokenCtx) {
      this.context[this.context.length - 1] = tokenCtx;
    }
  };

  // Token-specific context update code

  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return
    }
    var out = this.context.pop();
    if (out === types.b_stat && this.curContext().token === "function") {
      out = this.context.pop();
    }
    this.exprAllowed = !out.isExpr;
  };

  types$1.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
    this.exprAllowed = true;
  };

  types$1.dollarBraceL.updateContext = function() {
    this.context.push(types.b_tmpl);
    this.exprAllowed = true;
  };

  types$1.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
    this.context.push(statementParens ? types.p_stat : types.p_expr);
    this.exprAllowed = true;
  };

  types$1.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
  };

  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types$1._else &&
        !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
        !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
        !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
      { this.context.push(types.f_expr); }
    else
      { this.context.push(types.f_stat); }
    this.exprAllowed = false;
  };

  types$1.backQuote.updateContext = function() {
    if (this.curContext() === types.q_tmpl)
      { this.context.pop(); }
    else
      { this.context.push(types.q_tmpl); }
    this.exprAllowed = false;
  };

  types$1.star.updateContext = function(prevType) {
    if (prevType === types$1._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types.f_expr)
        { this.context[index] = types.f_expr_gen; }
      else
        { this.context[index] = types.f_gen; }
    }
    this.exprAllowed = true;
  };

  types$1.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
      if (this.value === "of" && !this.exprAllowed ||
          this.value === "yield" && this.inGeneratorContext())
        { allowed = true; }
    }
    this.exprAllowed = allowed;
  };

  // A recursive descent parser operates by defining functions for all

  var pp$5 = Parser.prototype;

  // Check if property name clashes with already added.
  // Object/class getters and setters are not allowed to clash 
  // either with each other or with an init property  and in
  // strict mode, init properties are also not allowed to be repeated.

  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      { return }
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      { return }
    var key = prop.key;
    var name;
    switch (key.type) {
    case "Identifier": name = key.name; break
    case "Literal": name = String(key.value); break
    default: return
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0) {
              refDestructuringErrors.doubleProto = key.start;
            }
          } else {
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
          }
        }
        propHash.proto = true;
      }
      return
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init") {
        redefinition = this.strict && other.init || other.get || other.set;
      } else {
        redefinition = other.init || other[kind];
      }
      if (redefinition)
        { this.raiseRecoverable(key.start, "Redefinition of property"); }
    } else {
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    }
    other[kind] = true;
  };

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The optional arguments are used to
  // forbid the `in` operator (in for loops initalization expressions)
  // and provide reference for storing '=' operator inside shorthand
  // property assignment in contexts where both object expression
  // and object pattern might appear (so it's possible to raise
  // delayed syntax error at correct position).

  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
    if (this.type === types$1.comma) {
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [expr];
      while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
      return this.finishNode(node, "SequenceExpression")
    }
    return expr
  };

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator) { return this.parseYield(forInit) }
      // The tokenizer will assume an expression is allowed after
      // `yield`, but this isn't that kind of yield
      else { this.exprAllowed = false; }
    }

    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldDoubleProto = refDestructuringErrors.doubleProto;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors;
      ownDestructuringErrors = true;
    }

    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types$1.parenL || this.type === types$1.name) {
      this.potentialArrowAt = this.start;
      this.potentialArrowInForAwait = forInit === "await";
    }
    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
    if (this.type.isAssign) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      if (this.type === types$1.eq)
        { left = this.toAssignable(left, false, refDestructuringErrors); }
      if (!ownDestructuringErrors) {
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      }
      if (refDestructuringErrors.shorthandAssign >= left.start)
        { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
      if (this.type === types$1.eq)
        { this.checkLValPattern(left); }
      else
        { this.checkLValSimple(left); }
      node.left = left;
      this.next();
      node.right = this.parseMaybeAssign(forInit);
      if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
      return this.finishNode(node, "AssignmentExpression")
    } else {
      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
    }
    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
    return left
  };

  // Parse a ternary conditional (`?:`) operator.

  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(forInit, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    if (this.eat(types$1.question)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.test = expr;
      node.consequent = this.parseMaybeAssign();
      this.expect(types$1.colon);
      node.alternate = this.parseMaybeAssign(forInit);
      return this.finishNode(node, "ConditionalExpression")
    }
    return expr
  };

  // Start the precedence parser.

  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
  };

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
    var prec = this.type.binop;
    if (prec != null && (!forInit || this.type !== types$1._in)) {
      if (prec > minPrec) {
        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
        var coalesce = this.type === types$1.coalesce;
        if (coalesce) {
          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
          prec = types$1.logicalAND.binop;
        }
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        }
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
      }
    }
    return left
  };

  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
    var node = this.startNodeAt(startPos, startLoc);
    node.left = left;
    node.operator = op;
    node.right = right;
    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
  };

  // Parse unary operators, both prefix and postfix.

  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && this.canAwait) {
      expr = this.parseAwait(forInit);
      sawUnary = true;
    } else if (this.type.prefix) {
      var node = this.startNode(), update = this.type === types$1.incDec;
      node.operator = this.value;
      node.prefix = true;
      this.next();
      node.argument = this.parseMaybeUnary(null, true, update, forInit);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update) { this.checkLValSimple(node.argument); }
      else if (this.strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
      else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
        { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
      else { sawUnary = true; }
      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    } else if (!sawUnary && this.type === types$1.privateId) {
      if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }
      expr = this.parsePrivateIdent();
      // only could be private fields in 'in', such as #x in obj
      if (this.type !== types$1._in) { this.unexpected(); }
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.operator = this.value;
        node$1.prefix = false;
        node$1.argument = expr;
        this.checkLValSimple(expr);
        this.next();
        expr = this.finishNode(node$1, "UpdateExpression");
      }
    }

    if (!incDec && this.eat(types$1.starstar)) {
      if (sawUnary)
        { this.unexpected(this.lastTokStart); }
      else
        { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
    } else {
      return expr
    }
  };

  function isPrivateFieldAccess(node) {
    return (
      node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
      node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
    )
  }

  // Parse call, dot, and `[]`-subscript expressions.

  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      { return expr }
    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
      if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
    }
    return result
  };

  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
        this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
        this.potentialArrowAt === base.start;
    var optionalChained = false;

    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

      if (element.optional) { optionalChained = true; }
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element
      }

      base = element;
    }
  };

  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types$1.questionDot);
    if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

    var computed = this.eat(types$1.bracketL);
    if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      if (computed) {
        node.property = this.parseExpression();
        this.expect(types$1.bracketR);
      } else if (this.type === types$1.privateId && base.type !== "Super") {
        node.property = this.parsePrivateIdent();
      } else {
        node.property = this.parseIdent(this.options.allowReserved !== "never");
      }
      node.computed = !!computed;
      if (optionalSupported) {
        node.optional = optional;
      }
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(types$1.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      if (optionalSupported) {
        node$1.optional = optional;
      }
      base = this.finishNode(node$1, "CallExpression");
    } else if (this.type === types$1.backQuote) {
      if (optional || optionalChained) {
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      }
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({isTagged: true});
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base
  };

  // Parse an atomic expression  either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
    // If a division operator appears in an expression position, the
    // tokenizer got confused, and we force it to read a regexp instead.
    if (this.type === types$1.slash) { this.readRegexp(); }

    var node, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
    case types$1._super:
      if (!this.allowSuper)
        { this.raise(this.start, "'super' keyword outside a method"); }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper)
        { this.raise(node.start, "super() call outside constructor of a subclass"); }
      // The `super` keyword can appear at below:
      // SuperProperty:
      //     super [ Expression ]
      //     super . IdentifierName
      // SuperCall:
      //     super ( Arguments )
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
        { this.unexpected(); }
      return this.finishNode(node, "Super")

    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression")

    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow))
          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
            (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
            { this.unexpected(); }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
        }
      }
      return id

    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = {pattern: value.pattern, flags: value.flags};
      return node

    case types$1.num: case types$1.string:
      return this.parseLiteral(this.value)

    case types$1._null: case types$1._true: case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal")

    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
          { refDestructuringErrors.parenthesizedAssign = start; }
        if (refDestructuringErrors.parenthesizedBind < 0)
          { refDestructuringErrors.parenthesizedBind = start; }
      }
      return expr

    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression")

    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors)

    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0)

    case types$1._class:
      return this.parseClass(this.startNode(), false)

    case types$1._new:
      return this.parseNew()

    case types$1.backQuote:
      return this.parseTemplate()

    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport()
      } else {
        return this.unexpected()
      }

    default:
      this.unexpected();
    }
  };

  pp$5.parseExprImport = function() {
    var node = this.startNode();

    // Consume `import` as an identifier for `import.meta`.
    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
    var meta = this.parseIdent(true);

    switch (this.type) {
    case types$1.parenL:
      return this.parseDynamicImport(node)
    case types$1.dot:
      node.meta = meta;
      return this.parseImportMeta(node)
    default:
      this.unexpected();
    }
  };

  pp$5.parseDynamicImport = function(node) {
    this.next(); // skip `(`

    // Parse node.source.
    node.source = this.parseMaybeAssign();

    // Verify ending.
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }

    return this.finishNode(node, "ImportExpression")
  };

  pp$5.parseImportMeta = function(node) {
    this.next(); // skip `.`

    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);

    if (node.property.name !== "meta")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
      { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

    return this.finishNode(node, "MetaProperty")
  };

  pp$5.parseLiteral = function(value) {
    var node = this.startNode();
    node.value = value;
    node.raw = this.input.slice(this.start, this.end);
    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
    this.next();
    return this.finishNode(node, "Literal")
  };

  pp$5.parseParenExpression = function() {
    this.expect(types$1.parenL);
    var val = this.parseExpression();
    this.expect(types$1.parenR);
    return val
  };

  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();

      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      // Do not save awaitIdentPos to allow checking awaits nested in parameters
      while (this.type !== types$1.parenR) {
        first ? first = false : this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
          lastIsComma = true;
          break
        } else if (this.type === types$1.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
          break
        } else {
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
        }
      }
      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
      this.expect(types$1.parenR);

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
      }

      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
      if (spreadStart) { this.unexpected(spreadStart); }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }
    } else {
      val = this.parseParenExpression();
    }

    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression")
    } else {
      return val
    }
  };

  pp$5.parseParenItem = function(item) {
    return item
  };

  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
  };

  // New's precedence is slightly tricky. It must allow its argument to
  // be a `[]` or dot subscript expression, but not a call  at least,
  // not without wrapping it in parentheses. Thus, it uses the noCalls
  // argument to parseSubscripts to prevent it from consuming the
  // argument list.

  var empty = [];

  pp$5.parseNew = function() {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
    var node = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
      node.meta = meta;
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "target")
        { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
      if (containsEsc)
        { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
      if (!this.allowNewDotTarget)
        { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
      return this.finishNode(node, "MetaProperty")
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
    if (isImport && node.callee.type === "ImportExpression") {
      this.raise(startPos, "Cannot use new with import()");
    }
    if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
    else { node.arguments = empty; }
    return this.finishNode(node, "NewExpression")
  };

  // Parse template expression.

  pp$5.parseTemplateElement = function(ref) {
    var isTagged = ref.isTagged;

    var elem = this.startNode();
    if (this.type === types$1.invalidTemplate) {
      if (!isTagged) {
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      }
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else {
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    }
    this.next();
    elem.tail = this.type === types$1.backQuote;
    return this.finishNode(elem, "TemplateElement")
  };

  pp$5.parseTemplate = function(ref) {
    if ( ref === void 0 ) ref = {};
    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

    var node = this.startNode();
    this.next();
    node.expressions = [];
    var curElt = this.parseTemplateElement({isTagged: isTagged});
    node.quasis = [curElt];
    while (!curElt.tail) {
      if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
      this.expect(types$1.dollarBraceL);
      node.expressions.push(this.parseExpression());
      this.expect(types$1.braceR);
      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
    }
    this.next();
    return this.finishNode(node, "TemplateLiteral")
  };

  pp$5.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
      (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  };

  // Parse an object literal or binding pattern.

  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
    var node = this.startNode(), first = true, propHash = {};
    node.properties = [];
    this.next();
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
      } else { first = false; }

      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
      node.properties.push(prop);
    }
    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
  };

  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types$1.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        return this.finishNode(prop, "RestElement")
      }
      // To disallow parenthesized identifier via `this.toAssignable()`.
      if (this.type === types$1.parenL && refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0) {
          refDestructuringErrors.parenthesizedAssign = this.start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = this.start;
        }
      }
      // Parse argument.
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      // To disallow trailing comma via `this.toAssignable()`.
      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
      // Finish
      return this.finishNode(prop, "SpreadElement")
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        { isGenerator = this.eat(types$1.star); }
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else {
      isAsync = false;
    }
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property")
  };

  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types$1.colon)
      { this.unexpected(); }

    if (this.eat(types$1.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
      if (isPattern) { this.unexpected(); }
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc &&
               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
               (prop.key.name === "get" || prop.key.name === "set") &&
               (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
      if (isGenerator || isAsync) { this.unexpected(); }
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          { this.raiseRecoverable(start, "getter should have no params"); }
        else
          { this.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
          { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
      }
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync) { this.unexpected(); }
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = startPos; }
      prop.kind = "init";
      if (isPattern) {
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else if (this.type === types$1.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          { refDestructuringErrors.shorthandAssign = this.start; }
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else {
        prop.value = this.copyNode(prop.key);
      }
      prop.shorthand = true;
    } else { this.unexpected(); }
  };

  pp$5.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types$1.bracketR);
        return prop.key
      } else {
        prop.computed = false;
      }
    }
    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
  };

  // Initialize empty function node.

  pp$5.initFunction = function(node) {
    node.id = null;
    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
    if (this.options.ecmaVersion >= 8) { node.async = false; }
  };

  // Parse object or class method.

  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.initFunction(node);
    if (this.options.ecmaVersion >= 6)
      { node.generator = isGenerator; }
    if (this.options.ecmaVersion >= 8)
      { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

    this.expect(types$1.parenL);
    node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node, false, true, false);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "FunctionExpression")
  };

  // Parse arrow function expression with given parameters.

  pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node);
    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;

    node.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node, true, false, forInit);

    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node, "ArrowFunctionExpression")
  };

  // Parse function body and check parameters.

  pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
    var isExpression = isArrowFunction && this.type !== types$1.braceL;
    var oldStrict = this.strict, useStrict = false;

    if (isExpression) {
      node.body = this.parseMaybeAssign(forInit);
      node.expression = true;
      this.checkParams(node, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        // If this is a strict mode function, verify that argument names
        // are not repeated, and it does not try to bind the words `eval`
        // or `arguments`.
        if (useStrict && nonSimple)
          { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
      }
      // Start a new scope with regard to labels and the `inFunction`
      // flag (restore them to their old value afterwards).
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict) { this.strict = true; }

      // Add the params to varDeclaredNames to ensure that an error is thrown
      // if a let/const declaration in the function clashes with one of the params.
      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
      if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
      node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
      node.expression = false;
      this.adaptDirectivePrologue(node.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };

  pp$5.isSimpleParamList = function(params) {
    for (var i = 0, list = params; i < list.length; i += 1)
      {
      var param = list[i];

      if (param.type !== "Identifier") { return false
    } }
    return true
  };

  // Checks function params for various disallowed patterns such as using "eval"
  // or "arguments" and duplicate parameters.

  pp$5.checkParams = function(node, allowDuplicates) {
    var nameHash = Object.create(null);
    for (var i = 0, list = node.params; i < list.length; i += 1)
      {
      var param = list[i];

      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(close)) { break }
      } else { first = false; }

      var elt = (void 0);
      if (allowEmpty && this.type === types$1.comma)
        { elt = null; }
      else if (this.type === types$1.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
          { refDestructuringErrors.trailingComma = this.start; }
      } else {
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      }
      elts.push(elt);
    }
    return elts
  };

  pp$5.checkUnreserved = function(ref) {
    var start = ref.start;
    var end = ref.end;
    var name = ref.name;

    if (this.inGenerator && name === "yield")
      { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
    if (this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
    if (this.currentThisScope().inClassFieldInit && name === "arguments")
      { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
    if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
      { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
    if (this.keywords.test(name))
      { this.raise(start, ("Unexpected keyword '" + name + "'")); }
    if (this.options.ecmaVersion < 6 &&
      this.input.slice(start, end).indexOf("\\") !== -1) { return }
    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re.test(name)) {
      if (!this.inAsync && name === "await")
        { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
      this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
    }
  };

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  pp$5.parseIdent = function(liberal, isBinding) {
    var node = this.startNode();
    if (this.type === types$1.name) {
      node.name = this.value;
    } else if (this.type.keyword) {
      node.name = this.type.keyword;

      // To fix https://github.com/acornjs/acorn/issues/575
      // `class` and `function` keywords push new context into this.context.
      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
      if ((node.name === "class" || node.name === "function") &&
          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
        this.context.pop();
      }
    } else {
      this.unexpected();
    }
    this.next(!!liberal);
    this.finishNode(node, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node);
      if (node.name === "await" && !this.awaitIdentPos)
        { this.awaitIdentPos = node.start; }
    }
    return node
  };

  pp$5.parsePrivateIdent = function() {
    var node = this.startNode();
    if (this.type === types$1.privateId) {
      node.name = this.value;
    } else {
      this.unexpected();
    }
    this.next();
    this.finishNode(node, "PrivateIdentifier");

    // For validating existence
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }

    return node
  };

  // Parses yield expression inside generator.

  pp$5.parseYield = function(forInit) {
    if (!this.yieldPos) { this.yieldPos = this.start; }

    var node = this.startNode();
    this.next();
    if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(types$1.star);
      node.argument = this.parseMaybeAssign(forInit);
    }
    return this.finishNode(node, "YieldExpression")
  };

  pp$5.parseAwait = function(forInit) {
    if (!this.awaitPos) { this.awaitPos = this.start; }

    var node = this.startNode();
    this.next();
    node.argument = this.parseMaybeUnary(null, true, false, forInit);
    return this.finishNode(node, "AwaitExpression")
  };

  var pp$4 = Parser.prototype;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
    throw err
  };

  pp$4.raiseRecoverable = pp$4.raise;

  pp$4.curPosition = function() {
    if (this.options.locations) {
      return new Position(this.curLine, this.pos - this.lineStart)
    }
  };

  var pp$3 = Parser.prototype;

  var Scope = function Scope(flags) {
    this.flags = flags;
    // A list of var-declared names in the current lexical scope
    this.var = [];
    // A list of lexically-declared names in the current lexical scope
    this.lexical = [];
    // A list of lexically-declared FunctionDeclaration names in the current lexical scope
    this.functions = [];
    // A switch to disallow the identifier reference 'arguments'
    this.inClassFieldInit = false;
  };

  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

  pp$3.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };

  pp$3.exitScope = function() {
    this.scopeStack.pop();
  };

  // The spec says:
  // > At the top level of a function, or script, function declarations are
  // > treated like var declarations rather than like lexical declarations.
  pp$3.treatFunctionsAsVarInScope = function(scope) {
    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
  };

  pp$3.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope = this.currentScope();
      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
      scope.lexical.push(name);
      if (this.inModule && (scope.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        { redeclared = scope$2.lexical.indexOf(name) > -1; }
      else
        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
      scope$2.functions.push(name);
    } else {
      for (var i = this.scopeStack.length - 1; i >= 0; --i) {
        var scope$3 = this.scopeStack[i];
        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break
        }
        scope$3.var.push(name);
        if (this.inModule && (scope$3.flags & SCOPE_TOP))
          { delete this.undefinedExports[name]; }
        if (scope$3.flags & SCOPE_VAR) { break }
      }
    }
    if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
  };

  pp$3.checkLocalExport = function(id) {
    // scope.functions must be empty as Module code is always strict.
    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
        this.scopeStack[0].var.indexOf(id.name) === -1) {
      this.undefinedExports[id.name] = id;
    }
  };

  pp$3.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1]
  };

  pp$3.currentVarScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR) { return scope }
    }
  };

  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
  pp$3.currentThisScope = function() {
    for (var i = this.scopeStack.length - 1;; i--) {
      var scope = this.scopeStack[i];
      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
    }
  };

  var Node = function Node(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      { this.loc = new SourceLocation(parser, loc); }
    if (parser.options.directSourceFile)
      { this.sourceFile = parser.options.directSourceFile; }
    if (parser.options.ranges)
      { this.range = [pos, 0]; }
  };

  // Start an AST node, attaching a start offset.

  var pp$2 = Parser.prototype;

  pp$2.startNode = function() {
    return new Node(this, this.start, this.startLoc)
  };

  pp$2.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc)
  };

  // Finish an AST node, adding `type` and `end` properties.

  function finishNodeAt(node, type, pos, loc) {
    node.type = type;
    node.end = pos;
    if (this.options.locations)
      { node.loc.end = loc; }
    if (this.options.ranges)
      { node.range[1] = pos; }
    return node
  }

  pp$2.finishNode = function(node, type) {
    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
  };

  // Finish node at given position

  pp$2.finishNodeAt = function(node, type, pos, loc) {
    return finishNodeAt.call(this, node, type, pos, loc)
  };

  pp$2.copyNode = function(node) {
    var newNode = new Node(this, node.start, this.startLoc);
    for (var prop in node) { newNode[prop] = node[prop]; }
    return newNode
  };

  // This file contains Unicode properties extracted from the ECMAScript
  // specification. The lists are extracted like so:
  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

  // #table-binary-unicode-properties
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
  var ecma13BinaryProperties = ecma12BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties,
    12: ecma12BinaryProperties,
    13: ecma13BinaryProperties
  };

  // #table-unicode-general-category-values
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

  // #table-unicode-script-values
  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues,
    12: ecma12ScriptValues,
    13: ecma13ScriptValues
  };

  var data = {};
  function buildUnicodeData(ecmaVersion) {
    var d = data[ecmaVersion] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;

    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }

  for (var i = 0, list = [9, 10, 11, 12, 13]; i < list.length; i += 1) {
    var ecmaVersion = list[i];

    buildUnicodeData(ecmaVersion);
  }

  var pp$1 = Parser.prototype;

  var RegExpValidationState = function RegExpValidationState(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };

  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };

  RegExpValidationState.prototype.raise = function raise (message) {
    this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
  };

  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
  RegExpValidationState.prototype.at = function at (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return -1
    }
    var c = s.charCodeAt(i);
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
      return c
    }
    var next = s.charCodeAt(i + 1);
    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
  };

  RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
      if ( forceU === void 0 ) forceU = false;

    var s = this.source;
    var l = s.length;
    if (i >= l) {
      return l
    }
    var c = s.charCodeAt(i), next;
    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
        (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
      return i + 1
    }
    return i + 2
  };

  RegExpValidationState.prototype.current = function current (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.pos, forceU)
  };

  RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
      if ( forceU === void 0 ) forceU = false;

    return this.at(this.nextIndex(this.pos, forceU), forceU)
  };

  RegExpValidationState.prototype.advance = function advance (forceU) {
      if ( forceU === void 0 ) forceU = false;

    this.pos = this.nextIndex(this.pos, forceU);
  };

  RegExpValidationState.prototype.eat = function eat (ch, forceU) {
      if ( forceU === void 0 ) forceU = false;

    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true
    }
    return false
  };

  /**
   * Validate the flags part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$1.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;

    for (var i = 0; i < flags.length; i++) {
      var flag = flags.charAt(i);
      if (validFlags.indexOf(flag) === -1) {
        this.raise(state.start, "Invalid regular expression flag");
      }
      if (flags.indexOf(flag, i + 1) > -1) {
        this.raise(state.start, "Duplicate regular expression flag");
      }
    }
  };

  /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */
  pp$1.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);

    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
    // parsing contains a |GroupName|, reparse with the goal symbol
    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
    // exception if _P_ did not conform to the grammar, if any elements of _P_
    // were not matched by the parse, or if any Early Error conditions exist.
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
  pp$1.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;

    this.regexp_disjunction(state);

    if (state.pos !== state.source.length) {
      // Make the same messages as V8.
      if (state.eat(0x29 /* ) */)) {
        state.raise("Unmatched ')'");
      }
      if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
        state.raise("Lone quantifier brackets");
      }
    }
    if (state.maxBackReference > state.numCapturingParens) {
      state.raise("Invalid escape");
    }
    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
      var name = list[i];

      if (state.groupNames.indexOf(name) === -1) {
        state.raise("Invalid named capture referenced");
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
  pp$1.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(0x7C /* | */)) {
      this.regexp_alternative(state);
    }

    // Make the same message as V8.
    if (this.regexp_eatQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    if (state.eat(0x7B /* { */)) {
      state.raise("Lone quantifier brackets");
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
  pp$1.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      { }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
  pp$1.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      // Handle `QuantifiableAssertion Quantifier` alternative.
      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
      // is a QuantifiableAssertion.
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        // Make the same message as V8.
        if (state.switchU) {
          state.raise("Invalid quantifier");
        }
      }
      return true
    }

    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
  pp$1.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;

    // ^, $
    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
      return true
    }

    // \b \B
    if (state.eat(0x5C /* \ */)) {
      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
        return true
      }
      state.pos = start;
    }

    // Lookahead / Lookbehind
    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9) {
        lookbehind = state.eat(0x3C /* < */);
      }
      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
        this.regexp_disjunction(state);
        if (!state.eat(0x29 /* ) */)) {
          state.raise("Unterminated group");
        }
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true
      }
    }

    state.pos = start;
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
  pp$1.regexp_eatQuantifier = function(state, noError) {
    if ( noError === void 0 ) noError = false;

    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(0x3F /* ? */);
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
    return (
      state.eat(0x2A /* * */) ||
      state.eat(0x2B /* + */) ||
      state.eat(0x3F /* ? */) ||
      this.regexp_eatBracedQuantifier(state, noError)
    )
  };
  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(0x7B /* { */)) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
          max = state.lastIntValue;
        }
        if (state.eat(0x7D /* } */)) {
          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
          if (max !== -1 && max < min && !noError) {
            state.raise("numbers out of order in {} quantifier");
          }
          return true
        }
      }
      if (state.switchU && !noError) {
        state.raise("Incomplete quantifier");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
  pp$1.regexp_eatAtom = function(state) {
    return (
      this.regexp_eatPatternCharacters(state) ||
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state)
    )
  };
  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatAtomEscape(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$1.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(0x28 /* ( */)) {
      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
        this.regexp_disjunction(state);
        if (state.eat(0x29 /* ) */)) {
          return true
        }
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false
  };
  pp$1.regexp_eatCapturingGroup = function(state) {
    if (state.eat(0x28 /* ( */)) {
      if (this.options.ecmaVersion >= 9) {
        this.regexp_groupSpecifier(state);
      } else if (state.current() === 0x3F /* ? */) {
        state.raise("Invalid group");
      }
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        state.numCapturingParens += 1;
        return true
      }
      state.raise("Unterminated group");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
  pp$1.regexp_eatExtendedAtom = function(state) {
    return (
      state.eat(0x2E /* . */) ||
      this.regexp_eatReverseSolidusAtomEscape(state) ||
      this.regexp_eatCharacterClass(state) ||
      this.regexp_eatUncapturingGroup(state) ||
      this.regexp_eatCapturingGroup(state) ||
      this.regexp_eatInvalidBracedQuantifier(state) ||
      this.regexp_eatExtendedPatternCharacter(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true)) {
      state.raise("Nothing to repeat");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
  pp$1.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }
    return false
  };
  function isSyntaxCharacter(ch) {
    return (
      ch === 0x24 /* $ */ ||
      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
      ch === 0x2E /* . */ ||
      ch === 0x3F /* ? */ ||
      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
      ch >= 0x7B /* { */ && ch <= 0x7D /* } */
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
  // But eat eager.
  pp$1.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
      state.advance();
    }
    return state.pos !== start
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (
      ch !== -1 &&
      ch !== 0x24 /* $ */ &&
      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
      ch !== 0x2E /* . */ &&
      ch !== 0x3F /* ? */ &&
      ch !== 0x5B /* [ */ &&
      ch !== 0x5E /* ^ */ &&
      ch !== 0x7C /* | */
    ) {
      state.advance();
      return true
    }
    return false
  };

  // GroupSpecifier ::
  //   [empty]
  //   `?` GroupName
  pp$1.regexp_groupSpecifier = function(state) {
    if (state.eat(0x3F /* ? */)) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
          state.raise("Duplicate capture group name");
        }
        state.groupNames.push(state.lastStringValue);
        return
      }
      state.raise("Invalid group");
    }
  };

  // GroupName ::
  //   `<` RegExpIdentifierName `>`
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$1.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(0x3C /* < */)) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
        return true
      }
      state.raise("Invalid capture group name");
    }
    return false
  };

  // RegExpIdentifierName ::
  //   RegExpIdentifierStart
  //   RegExpIdentifierName RegExpIdentifierPart
  // Note: this updates `state.lastStringValue` property with the eaten name.
  pp$1.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
      }
      return true
    }
    return false
  };

  // RegExpIdentifierStart ::
  //   UnicodeIDStart
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
  }

  // RegExpIdentifierPart ::
  //   UnicodeIDContinue
  //   `$`
  //   `_`
  //   `\` RegExpUnicodeEscapeSequence[+U]
  //   <ZWNJ>
  //   <ZWJ>
  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);

    if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
      ch = state.lastIntValue;
    }
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true
    }

    state.pos = start;
    return false
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
  pp$1.regexp_eatAtomEscape = function(state) {
    if (
      this.regexp_eatBackReference(state) ||
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state) ||
      (state.switchN && this.regexp_eatKGroupName(state))
    ) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      if (state.current() === 0x63 /* c */) {
        state.raise("Invalid unicode escape");
      }
      state.raise("Invalid escape");
    }
    return false
  };
  pp$1.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n = state.lastIntValue;
      if (state.switchU) {
        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
        if (n > state.maxBackReference) {
          state.maxBackReference = n;
        }
        return true
      }
      if (n <= state.numCapturingParens) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$1.regexp_eatKGroupName = function(state) {
    if (state.eat(0x6B /* k */)) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true
      }
      state.raise("Invalid named reference");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
  pp$1.regexp_eatCharacterEscape = function(state) {
    return (
      this.regexp_eatControlEscape(state) ||
      this.regexp_eatCControlLetter(state) ||
      this.regexp_eatZero(state) ||
      this.regexp_eatHexEscapeSequence(state) ||
      this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
      this.regexp_eatIdentityEscape(state)
    )
  };
  pp$1.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(0x63 /* c */)) {
      if (this.regexp_eatControlLetter(state)) {
        return true
      }
      state.pos = start;
    }
    return false
  };
  pp$1.regexp_eatZero = function(state) {
    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
  pp$1.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 0x74 /* t */) {
      state.lastIntValue = 0x09; /* \t */
      state.advance();
      return true
    }
    if (ch === 0x6E /* n */) {
      state.lastIntValue = 0x0A; /* \n */
      state.advance();
      return true
    }
    if (ch === 0x76 /* v */) {
      state.lastIntValue = 0x0B; /* \v */
      state.advance();
      return true
    }
    if (ch === 0x66 /* f */) {
      state.lastIntValue = 0x0C; /* \f */
      state.advance();
      return true
    }
    if (ch === 0x72 /* r */) {
      state.lastIntValue = 0x0D; /* \r */
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
  pp$1.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };
  function isControlLetter(ch) {
    return (
      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
    )
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if ( forceU === void 0 ) forceU = false;

    var start = state.pos;
    var switchU = forceU || state.switchU;

    if (state.eat(0x75 /* u */)) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 0xDC00 && trail <= 0xDFFF) {
              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
              return true
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true
      }
      if (
        switchU &&
        state.eat(0x7B /* { */) &&
        this.regexp_eatHexDigits(state) &&
        state.eat(0x7D /* } */) &&
        isValidUnicode(state.lastIntValue)
      ) {
        return true
      }
      if (switchU) {
        state.raise("Invalid unicode escape");
      }
      state.pos = start;
    }

    return false
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 0x10FFFF
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
  pp$1.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state)) {
        return true
      }
      if (state.eat(0x2F /* / */)) {
        state.lastIntValue = 0x2F; /* / */
        return true
      }
      return false
    }

    var ch = state.current();
    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
  pp$1.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
        state.advance();
      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
  pp$1.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();

    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true
    }

    if (
      state.switchU &&
      this.options.ecmaVersion >= 9 &&
      (ch === 0x50 /* P */ || ch === 0x70 /* p */)
    ) {
      state.lastIntValue = -1;
      state.advance();
      if (
        state.eat(0x7B /* { */) &&
        this.regexp_eatUnicodePropertyValueExpression(state) &&
        state.eat(0x7D /* } */)
      ) {
        return true
      }
      state.raise("Invalid property name");
    }

    return false
  };
  function isCharacterClassEscape(ch) {
    return (
      ch === 0x64 /* d */ ||
      ch === 0x44 /* D */ ||
      ch === 0x73 /* s */ ||
      ch === 0x53 /* S */ ||
      ch === 0x77 /* w */ ||
      ch === 0x57 /* W */
    )
  }

  // UnicodePropertyValueExpression ::
  //   UnicodePropertyName `=` UnicodePropertyValue
  //   LoneUnicodePropertyNameOrValue
  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;

    // UnicodePropertyName `=` UnicodePropertyValue
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
        return true
      }
    }
    state.pos = start;

    // LoneUnicodePropertyNameOrValue
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true
    }
    return false
  };
  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
    if (!hasOwn(state.unicodeProperties.nonBinary, name))
      { state.raise("Invalid property name"); }
    if (!state.unicodeProperties.nonBinary[name].test(value))
      { state.raise("Invalid property value"); }
  };
  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      { state.raise("Invalid property name"); }
  };

  // UnicodePropertyName ::
  //   UnicodePropertyNameCharacters
  pp$1.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 0x5F /* _ */
  }

  // UnicodePropertyValue ::
  //   UnicodePropertyValueCharacters
  pp$1.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== ""
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
  }

  // LoneUnicodePropertyNameOrValue ::
  //   UnicodePropertyValueCharacters
  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state)
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
  pp$1.regexp_eatCharacterClass = function(state) {
    if (state.eat(0x5B /* [ */)) {
      state.eat(0x5E /* ^ */);
      this.regexp_classRanges(state);
      if (state.eat(0x5D /* ] */)) {
        return true
      }
      // Unreachable since it threw "unterminated regular expression" error before.
      state.raise("Unterminated character class");
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
  pp$1.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1)) {
          state.raise("Invalid character class");
        }
        if (left !== -1 && right !== -1 && left > right) {
          state.raise("Range out of order in character class");
        }
      }
    }
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
  pp$1.regexp_eatClassAtom = function(state) {
    var start = state.pos;

    if (state.eat(0x5C /* \ */)) {
      if (this.regexp_eatClassEscape(state)) {
        return true
      }
      if (state.switchU) {
        // Make the same message as V8.
        var ch$1 = state.current();
        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
          state.raise("Invalid class escape");
        }
        state.raise("Invalid escape");
      }
      state.pos = start;
    }

    var ch = state.current();
    if (ch !== 0x5D /* ] */) {
      state.lastIntValue = ch;
      state.advance();
      return true
    }

    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
  pp$1.regexp_eatClassEscape = function(state) {
    var start = state.pos;

    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }

    if (state.switchU && state.eat(0x2D /* - */)) {
      state.lastIntValue = 0x2D; /* - */
      return true
    }

    if (!state.switchU && state.eat(0x63 /* c */)) {
      if (this.regexp_eatClassControlLetter(state)) {
        return true
      }
      state.pos = start;
    }

    return (
      this.regexp_eatCharacterClassEscape(state) ||
      this.regexp_eatCharacterEscape(state)
    )
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
  pp$1.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
      state.lastIntValue = ch % 0x20;
      state.advance();
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$1.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(0x78 /* x */)) {
      if (this.regexp_eatFixedHexDigits(state, 2)) {
        return true
      }
      if (state.switchU) {
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
  pp$1.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    }
    return state.pos !== start
  };
  function isDecimalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
  pp$1.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start
  };
  function isHexDigit(ch) {
    return (
      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
    )
  }
  function hexToInt(ch) {
    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
      return 10 + (ch - 0x41 /* A */)
    }
    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
      return 10 + (ch - 0x61 /* a */)
    }
    return ch - 0x30 /* 0 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
  // Allows only 0-377(octal) i.e. 0-255(decimal).
  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        } else {
          state.lastIntValue = n1 * 8 + n2;
        }
      } else {
        state.lastIntValue = n1;
      }
      return true
    }
    return false
  };

  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
  pp$1.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 0x30; /* 0 */
      state.advance();
      return true
    }
    state.lastIntValue = 0;
    return false
  };
  function isOctalDigit(ch) {
    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
  }

  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
  pp$1.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i = 0; i < length; ++i) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true
  };

  // Object type used to represent tokens. Note that normally, tokens
  // simply exist as properties on the parser object. This is only
  // used for the onToken callback and the external tokenizer.

  var Token = function Token(p) {
    this.type = p.type;
    this.value = p.value;
    this.start = p.start;
    this.end = p.end;
    if (p.options.locations)
      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
    if (p.options.ranges)
      { this.range = [p.start, p.end]; }
  };

  // ## Tokenizer

  var pp = Parser.prototype;

  // Move to the next token

  pp.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
    if (this.options.onToken)
      { this.options.onToken(new Token(this)); }

    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };

  pp.getToken = function() {
    this.next();
    return new Token(this)
  };

  // If we're in an ES6 environment, make parsers iterable
  if (typeof Symbol !== "undefined")
    { pp[Symbol.iterator] = function() {
      var this$1$1 = this;

      return {
        next: function () {
          var token = this$1$1.getToken();
          return {
            done: token.type === types$1.eof,
            value: token
          }
        }
      }
    }; }

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  // Read a single token, updating the parser object's token-related
  // properties.

  pp.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

    this.start = this.pos;
    if (this.options.locations) { this.startLoc = this.curPosition(); }
    if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

    if (curContext.override) { return curContext.override(this) }
    else { this.readToken(this.fullCharCodeAtPos()); }
  };

  pp.readToken = function(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
      { return this.readWord() }

    return this.getTokenFromCode(code)
  };

  pp.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 0xd7ff || code >= 0xdc00) { return code }
    var next = this.input.charCodeAt(this.pos + 1);
    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
  };

  pp.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
    this.pos = end + 2;
    if (this.options.locations) {
      for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
        ++this.curLine;
        pos = this.lineStart = nextBreak;
      }
    }
    if (this.options.onComment)
      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  pp.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch)) {
      ch = this.input.charCodeAt(++this.pos);
    }
    if (this.options.onComment)
      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                             startLoc, this.curPosition()); }
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  pp.skipSpace = function() {
    loop: while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
      case 32: case 160: // ' '
        ++this.pos;
        break
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10: case 8232: case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break
      case 47: // '/'
        switch (this.input.charCodeAt(this.pos + 1)) {
        case 42: // '*'
          this.skipBlockComment();
          break
        case 47:
          this.skipLineComment(2);
          break
        default:
          break loop
        }
        break
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop
        }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  pp.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations) { this.endLoc = this.curPosition(); }
    var prevType = this.type;
    this.type = type;
    this.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  pp.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57) { return this.readNumber(true) }
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
      this.pos += 3;
      return this.finishToken(types$1.ellipsis)
    } else {
      ++this.pos;
      return this.finishToken(types$1.dot)
    }
  };

  pp.readToken_slash = function() { // '/'
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
    if (next === 61) { return this.finishOp(types$1.assign, 2) }
    return this.finishOp(types$1.slash, 1)
  };

  pp.readToken_mult_modulo_exp = function(code) { // '%*'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types$1.star : types$1.modulo;

    // exponentiation operator ** and **=
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types$1.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }

    if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
    return this.finishOp(tokentype, size)
  };

  pp.readToken_pipe_amp = function(code) { // '|&'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
      }
      return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
    }
    if (next === 61) { return this.finishOp(types$1.assign, 2) }
    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
  };

  pp.readToken_caret = function() { // '^'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types$1.assign, 2) }
    return this.finishOp(types$1.bitwiseXOR, 1)
  };

  pp.readToken_plus_min = function(code) { // '+-'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken()
      }
      return this.finishOp(types$1.incDec, 2)
    }
    if (next === 61) { return this.finishOp(types$1.assign, 2) }
    return this.finishOp(types$1.plusMin, 1)
  };

  pp.readToken_lt_gt = function(code) { // '<>'
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
      return this.finishOp(types$1.bitShift, size)
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
        this.input.charCodeAt(this.pos + 3) === 45) {
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken()
    }
    if (next === 61) { size = 2; }
    return this.finishOp(types$1.relational, size)
  };

  pp.readToken_eq_excl = function(code) { // '=!'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
      this.pos += 2;
      return this.finishToken(types$1.arrow)
    }
    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
  };

  pp.readToken_question = function() { // '?'
    var ecmaVersion = this.options.ecmaVersion;
    if (ecmaVersion >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
      }
      if (next === 63) {
        if (ecmaVersion >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
        }
        return this.finishOp(types$1.coalesce, 2)
      }
    }
    return this.finishOp(types$1.question, 1)
  };

  pp.readToken_numberSign = function() { // '#'
    var ecmaVersion = this.options.ecmaVersion;
    var code = 35; // '#'
    if (ecmaVersion >= 13) {
      ++this.pos;
      code = this.fullCharCodeAtPos();
      if (isIdentifierStart(code, true) || code === 92 /* '\' */) {
        return this.finishToken(types$1.privateId, this.readWord1())
      }
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
  };

  pp.getTokenFromCode = function(code) {
    switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46: // '.'
      return this.readToken_dot()

    // Punctuation tokens.
    case 40: ++this.pos; return this.finishToken(types$1.parenL)
    case 41: ++this.pos; return this.finishToken(types$1.parenR)
    case 59: ++this.pos; return this.finishToken(types$1.semi)
    case 44: ++this.pos; return this.finishToken(types$1.comma)
    case 91: ++this.pos; return this.finishToken(types$1.bracketL)
    case 93: ++this.pos; return this.finishToken(types$1.bracketR)
    case 123: ++this.pos; return this.finishToken(types$1.braceL)
    case 125: ++this.pos; return this.finishToken(types$1.braceR)
    case 58: ++this.pos; return this.finishToken(types$1.colon)

    case 96: // '`'
      if (this.options.ecmaVersion < 6) { break }
      ++this.pos;
      return this.finishToken(types$1.backQuote)

    case 48: // '0'
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
      }

    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return this.readNumber(false)

    // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47: // '/'
      return this.readToken_slash()

    case 37: case 42: // '%*'
      return this.readToken_mult_modulo_exp(code)

    case 124: case 38: // '|&'
      return this.readToken_pipe_amp(code)

    case 94: // '^'
      return this.readToken_caret()

    case 43: case 45: // '+-'
      return this.readToken_plus_min(code)

    case 60: case 62: // '<>'
      return this.readToken_lt_gt(code)

    case 61: case 33: // '=!'
      return this.readToken_eq_excl(code)

    case 63: // '?'
      return this.readToken_question()

    case 126: // '~'
      return this.finishOp(types$1.prefix, 1)

    case 35: // '#'
      return this.readToken_numberSign()
    }

    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
  };

  pp.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str)
  };

  pp.readRegexp = function() {
    var escaped, inClass, start = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
      if (!escaped) {
        if (ch === "[") { inClass = true; }
        else if (ch === "]" && inClass) { inClass = false; }
        else if (ch === "/" && !inClass) { break }
        escaped = ch === "\\";
      } else { escaped = false; }
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc) { this.unexpected(flagsStart); }

    // Validate pattern
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);

    // Create Literal#value property value.
    var value = null;
    try {
      value = new RegExp(pattern, flags);
    } catch (e) {
      // ESTree requires null if it failed to instantiate RegExp object.
      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
    }

    return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    // `len` is used for character escape sequences. In that case, disallow separators.
    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
    // and isn't fraction part nor exponent part. In that case, if the first digit
    // is zero then disallow separators.
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

    var start = this.pos, total = 0, lastCode = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
      var code = this.input.charCodeAt(this.pos), val = (void 0);

      if (allowSeparators && code === 95) {
        if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
        if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
        if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
        lastCode = code;
        continue
      }

      if (code >= 97) { val = code - 97 + 10; } // a
      else if (code >= 65) { val = code - 65 + 10; } // A
      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
      else { val = Infinity; }
      if (val >= radix) { break }
      lastCode = code;
      total = total * radix + val;
    }

    if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
    if (this.pos === start || len != null && this.pos - start !== len) { return null }

    return total
  };

  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral) {
      return parseInt(str, 8)
    }

    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
    return parseFloat(str.replace(/_/g, ""))
  }

  function stringToBigInt(str) {
    if (typeof BigInt !== "function") {
      return null
    }

    // `BigInt(value)` throws syntax error if the string contains numeric separators.
    return BigInt(str.replace(/_/g, ""))
  }

  pp.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types$1.num, val)
  };

  // Read an integer, octal integer, or floating-point number.

  pp.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict) { this.raise(start, "Invalid number"); }
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
      return this.finishToken(types$1.num, val$1)
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
    if (next === 46 && !octal) { // '.'
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) { // 'eE'
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45) { ++this.pos; } // '+-'
      if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types$1.num, val)
  };

  // Read a string value, interpreting backslash-escapes.

  pp.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;

    if (ch === 123) { // '{'
      if (this.options.ecmaVersion < 6) { this.unexpected(); }
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
    } else {
      code = this.readHexChar(4);
    }
    return code
  };

  pp.readString = function(quote) {
    var out = "", chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) { break }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else if (ch === 0x2028 || ch === 0x2029) {
        if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
        if (this.options.locations) {
          this.curLine++;
          this.lineStart = this.pos;
        }
      } else {
        if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types$1.string, out)
  };

  // Reads template string tokens.

  var INVALID_TEMPLATE_ESCAPE_ERROR = {};

  pp.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
        this.readInvalidTemplateToken();
      } else {
        throw err
      }
    }

    this.inTemplateElement = false;
  };

  pp.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
      throw INVALID_TEMPLATE_ESCAPE_ERROR
    } else {
      this.raise(position, message);
    }
  };

  pp.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types$1.dollarBraceL)
          } else {
            ++this.pos;
            return this.finishToken(types$1.backQuote)
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types$1.template, out)
      }
      if (ch === 92) { // '\'
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
        case 10:
          out += "\n";
          break
        default:
          out += String.fromCharCode(ch);
          break
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
  };

  // Reads a template token to search for the end, without validating any escape sequences
  pp.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++) {
      switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break

      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break
        }

      // falls through
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

      // no default
      }
    }
    this.raise(this.start, "Unterminated template");
  };

  // Used to read escaped characters

  pp.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
    case 110: return "\n" // 'n' -> '\n'
    case 114: return "\r" // 'r' -> '\r'
    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
    case 117: return codePointToString(this.readCodePoint()) // 'u'
    case 116: return "\t" // 't' -> '\t'
    case 98: return "\b" // 'b' -> '\b'
    case 118: return "\u000b" // 'v' -> '\u000b'
    case 102: return "\f" // 'f' -> '\f'
    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
    case 10: // ' \n'
      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
      return ""
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;

        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );

        return null
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate
              ? "Octal literal in template string"
              : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal)
      }
      if (isNewLine(ch)) {
        // Unicode new line characters after \ get removed from output in both
        // template literals and strings
        return ""
      }
      return String.fromCharCode(ch)
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  pp.readHexChar = function(len) {
    var codePos = this.pos;
    var n = this.readInt(16, len);
    if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
    return n
  };

  // Read an identifier, and return it as a string. Sets `this.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  pp.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral)) {
        this.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) { // "\"
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117) // "u"
          { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
        word += codePointToString(esc);
        chunkStart = this.pos;
      } else {
        break
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos)
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  pp.readWord = function() {
    var word = this.readWord1();
    var type = types$1.name;
    if (this.keywords.test(word)) {
      type = keywords[word];
    }
    return this.finishToken(type, word)
  };

  // Acorn is a tiny, fast JavaScript parser written in JavaScript.

  var version = "8.7.1";

  Parser.acorn = {
    Parser: Parser,
    version: version,
    defaultOptions: defaultOptions,
    Position: Position,
    SourceLocation: SourceLocation,
    getLineInfo: getLineInfo,
    Node: Node,
    TokenType: TokenType,
    tokTypes: types$1,
    keywordTypes: keywords,
    TokContext: TokContext,
    tokContexts: types,
    isIdentifierChar: isIdentifierChar,
    isIdentifierStart: isIdentifierStart,
    Token: Token,
    isNewLine: isNewLine,
    lineBreak: lineBreak,
    lineBreakG: lineBreakG,
    nonASCIIwhitespace: nonASCIIwhitespace
  };

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api].
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  function parse(input, options) {
    return Parser.parse(input, options)
  }

  // This function tries to parse a single expression at a given
  // offset in a string. Useful for parsing mixed-language formats
  // that embed JavaScript expressions.

  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options)
  }

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenizer` export provides an interface to the tokenizer.

  function tokenizer(input, options) {
    return Parser.tokenizer(input, options)
  }

  exports.Node = Node;
  exports.Parser = Parser;
  exports.Position = Position;
  exports.SourceLocation = SourceLocation;
  exports.TokContext = TokContext;
  exports.Token = Token;
  exports.TokenType = TokenType;
  exports.defaultOptions = defaultOptions;
  exports.getLineInfo = getLineInfo;
  exports.isIdentifierChar = isIdentifierChar;
  exports.isIdentifierStart = isIdentifierStart;
  exports.isNewLine = isNewLine;
  exports.keywordTypes = keywords;
  exports.lineBreak = lineBreak;
  exports.lineBreakG = lineBreakG;
  exports.nonASCIIwhitespace = nonASCIIwhitespace;
  exports.parse = parse;
  exports.parseExpressionAt = parseExpressionAt;
  exports.tokContexts = types;
  exports.tokTypes = types$1;
  exports.tokenizer = tokenizer;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /***********************************************************************

  A JavaScript tokenizer / parser / beautifier / compressor.
  https://github.com/mishoo/UglifyJS2

  -------------------------------- (C) ---------------------------------

                           Author: Mihai Bazon
                         <mihai.bazon@gmail.com>
                       http://mihai.bazon.net/blog

  Distributed under the BSD license:

    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 ***********************************************************************/

"use strict";

import {
    defaults,
    makePredicate,
    noop,
    regexp_source_fix,
    sort_regexp_flags,
    return_false,
    return_true,
} from "./utils/index.js";
import { first_in_statement, left_is_object } from "./utils/first_in_statement.js";
import {
    AST_Array,
    AST_Arrow,
    AST_Assign,
    AST_Await,
    AST_BigInt,
    AST_Binary,
    AST_BlockStatement,
    AST_Break,
    AST_Call,
    AST_Case,
    AST_Catch,
    AST_Chain,
    AST_Class,
    AST_ClassExpression,
    AST_ClassPrivateProperty,
    AST_ClassProperty,
    AST_ConciseMethod,
    AST_PrivateGetter,
    AST_PrivateMethod,
    AST_PrivateSetter,
    AST_Conditional,
    AST_Const,
    AST_Constant,
    AST_Continue,
    AST_Debugger,
    AST_Default,
    AST_DefaultAssign,
    AST_Definitions,
    AST_Defun,
    AST_Destructuring,
    AST_Directive,
    AST_Do,
    AST_Dot,
    AST_DotHash,
    AST_EmptyStatement,
    AST_Exit,
    AST_Expansion,
    AST_Export,
    AST_Finally,
    AST_For,
    AST_ForIn,
    AST_ForOf,
    AST_Function,
    AST_Hole,
    AST_If,
    AST_Import,
    AST_ImportMeta,
    AST_Jump,
    AST_LabeledStatement,
    AST_Lambda,
    AST_Let,
    AST_LoopControl,
    AST_NameMapping,
    AST_New,
    AST_NewTarget,
    AST_Node,
    AST_Number,
    AST_Object,
    AST_ObjectGetter,
    AST_ObjectKeyVal,
    AST_ObjectProperty,
    AST_ObjectSetter,
    AST_PrefixedTemplateString,
    AST_PropAccess,
    AST_RegExp,
    AST_Return,
    AST_Scope,
    AST_Sequence,
    AST_SimpleStatement,
    AST_Statement,
    AST_StatementWithBody,
    AST_String,
    AST_Sub,
    AST_Super,
    AST_Switch,
    AST_SwitchBranch,
    AST_Symbol,
    AST_SymbolClassProperty,
    AST_SymbolMethod,
    AST_SymbolRef,
    AST_TemplateSegment,
    AST_TemplateString,
    AST_This,
    AST_Throw,
    AST_Toplevel,
    AST_Try,
    AST_Unary,
    AST_UnaryPostfix,
    AST_UnaryPrefix,
    AST_Var,
    AST_VarDef,
    AST_While,
    AST_With,
    AST_Yield,
    TreeWalker,
    walk,
    walk_abort
} from "./ast.js";
import {
    get_full_char_code,
    get_full_char,
    is_identifier_char,
    is_basic_identifier_string,
    is_identifier_string,
    PRECEDENCE,
    ALL_RESERVED_WORDS,
} from "./parse.js";

const EXPECT_DIRECTIVE = /^$|[;{][\s\n]*$/;
const CODE_LINE_BREAK = 10;
const CODE_SPACE = 32;

const r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/g;

function is_some_comments(comment) {
    // multiline comment
    return (
        (comment.type === "comment2" || comment.type === "comment1")
        && /@preserve|@lic|@cc_on|^\**!/i.test(comment.value)
    );
}

class Rope {
    constructor() {
        this.committed = "";
        this.current = "";
    }

    append(str) {
        this.current += str;
    }

    insertAt(char, index) {
        const { committed, current } = this;
        if (index < committed.length) {
            this.committed = committed.slice(0, index) + char + committed.slice(index);
        } else if (index === committed.length) {
            this.committed += char;
        } else {
            index -= committed.length;
            this.committed += current.slice(0, index) + char;
            this.current = current.slice(index);
        }
    }

    charAt(index) {
        const { committed } = this;
        if (index < committed.length) return committed[index];
        return this.current[index - committed.length];
    }

    curLength() {
        return this.current.length;
    }

    length() {
        return this.committed.length + this.current.length;
    }

    toString() {
        return this.committed + this.current;
    }
}

function OutputStream(options) {

    var readonly = !options;
    options = defaults(options, {
        ascii_only           : false,
        beautify             : false,
        braces               : false,
        comments             : "some",
        ecma                 : 5,
        ie8                  : false,
        indent_level         : 4,
        indent_start         : 0,
        inline_script        : true,
        keep_numbers         : false,
        keep_quoted_props    : false,
        max_line_len         : false,
        preamble             : null,
        preserve_annotations : false,
        quote_keys           : false,
        quote_style          : 0,
        safari10             : false,
        semicolons           : true,
        shebang              : true,
        shorthand            : undefined,
        source_map           : null,
        webkit               : false,
        width                : 80,
        wrap_iife            : false,
        wrap_func_args       : true,
    }, true);

    if (options.shorthand === undefined)
        options.shorthand = options.ecma > 5;

    // Convert comment option to RegExp if neccessary and set up comments filter
    var comment_filter = return_false; // Default case, throw all comments away
    if (options.comments) {
        let comments = options.comments;
        if (typeof options.comments === "string" && /^\/.*\/[a-zA-Z]*$/.test(options.comments)) {
            var regex_pos = options.comments.lastIndexOf("/");
            comments = new RegExp(
                options.comments.substr(1, regex_pos - 1),
                options.comments.substr(regex_pos + 1)
            );
        }
        if (comments instanceof RegExp) {
            comment_filter = function(comment) {
                return comment.type != "comment5" && comments.test(comment.value);
            };
        } else if (typeof comments === "function") {
            comment_filter = function(comment) {
                return comment.type != "comment5" && comments(this, comment);
            };
        } else if (comments === "some") {
            comment_filter = is_some_comments;
        } else { // NOTE includes "all" option
            comment_filter = return_true;
        }
    }

    var indentation = 0;
    var current_col = 0;
    var current_line = 1;
    var current_pos = 0;
    var OUTPUT = new Rope();
    let printed_comments = new Set();

    var to_utf8 = options.ascii_only ? function(str, identifier = false, regexp = false) {
        if (options.ecma >= 2015 && !options.safari10 && !regexp) {
            str = str.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function(ch) {
                var code = get_full_char_code(ch, 0).toString(16);
                return "\\u{" + code + "}";
            });
        }
        return str.replace(/[\u0000-\u001f\u007f-\uffff]/g, function(ch) {
            var code = ch.charCodeAt(0).toString(16);
            if (code.length <= 2 && !identifier) {
                while (code.length < 2) code = "0" + code;
                return "\\x" + code;
            } else {
                while (code.length < 4) code = "0" + code;
                return "\\u" + code;
            }
        });
    } : function(str) {
        return str.replace(/[\ud800-\udbff][\udc00-\udfff]|([\ud800-\udbff]|[\udc00-\udfff])/g, function(match, lone) {
            if (lone) {
                return "\\u" + lone.charCodeAt(0).toString(16);
            }
            return match;
        });
    };

    function make_string(str, quote) {
        var dq = 0, sq = 0;
        str = str.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g,
          function(s, i) {
            switch (s) {
              case '"': ++dq; return '"';
              case "'": ++sq; return "'";
              case "\\": return "\\\\";
              case "\n": return "\\n";
              case "\r": return "\\r";
              case "\t": return "\\t";
              case "\b": return "\\b";
              case "\f": return "\\f";
              case "\x0B": return options.ie8 ? "\\x0B" : "\\v";
              case "\u2028": return "\\u2028";
              case "\u2029": return "\\u2029";
              case "\ufeff": return "\\ufeff";
              case "\0":
                  return /[0-9]/.test(get_full_char(str, i+1)) ? "\\x00" : "\\0";
            }
            return s;
        });
        function quote_single() {
            return "'" + str.replace(/\x27/g, "\\'") + "'";
        }
        function quote_double() {
            return '"' + str.replace(/\x22/g, '\\"') + '"';
        }
        function quote_template() {
            return "`" + str.replace(/`/g, "\\`") + "`";
        }
        str = to_utf8(str);
        if (quote === "`") return quote_template();
        switch (options.quote_style) {
          case 1:
            return quote_single();
          case 2:
            return quote_double();
          case 3:
            return quote == "'" ? quote_single() : quote_double();
          default:
            return dq > sq ? quote_single() : quote_double();
        }
    }

    function encode_string(str, quote) {
        var ret = make_string(str, quote);
        if (options.inline_script) {
            ret = ret.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2");
            ret = ret.replace(/\x3c!--/g, "\\x3c!--");
            ret = ret.replace(/--\x3e/g, "--\\x3e");
        }
        return ret;
    }

    function make_name(name) {
        name = name.toString();
        name = to_utf8(name, true);
        return name;
    }

    function make_indent(back) {
        return " ".repeat(options.indent_start + indentation - back * options.indent_level);
    }

    /* -----[ beautification/minification ]----- */

    var has_parens = false;
    var might_need_space = false;
    var might_need_semicolon = false;
    var might_add_newline = 0;
    var need_newline_indented = false;
    var need_space = false;
    var newline_insert = -1;
    var last = "";
    var mapping_token, mapping_name, mappings = options.source_map && [];

    var do_add_mapping = mappings ? function() {
        mappings.forEach(function(mapping) {
            try {
                let { name, token } = mapping;
                if (token.type == "name" || token.type === "privatename") {
                    name = token.value;
                } else if (name instanceof AST_Symbol) {
                    name = token.type === "string" ? token.value : name.name;
                }
                options.source_map.add(
                    mapping.token.file,
                    mapping.line, mapping.col,
                    mapping.token.line, mapping.token.col,
                    is_basic_identifier_string(name) ? name : undefined
                );
            } catch(ex) {
                // Ignore bad mapping
            }
        });
        mappings = [];
    } : noop;

    var ensure_line_len = options.max_line_len ? function() {
        if (current_col > options.max_line_len) {
            if (might_add_newline) {
                OUTPUT.insertAt("\n", might_add_newline);
                const curLength = OUTPUT.curLength();
                if (mappings) {
                    var delta = curLength - current_col;
                    mappings.forEach(function(mapping) {
                        mapping.line++;
                        mapping.col += delta;
                    });
                }
                current_line++;
                current_pos++;
                current_col = curLength;
            }
        }
        if (might_add_newline) {
            might_add_newline = 0;
            do_add_mapping();
        }
    } : noop;

    var requireSemicolonChars = makePredicate("( [ + * / - , . `");

    function print(str) {
        str = String(str);
        var ch = get_full_char(str, 0);
        if (need_newline_indented && ch) {
            need_newline_indented = false;
            if (ch !== "\n") {
                print("\n");
                indent();
            }
        }
        if (need_space && ch) {
            need_space = false;
            if (!/[\s;})]/.test(ch)) {
                space();
            }
        }
        newline_insert = -1;
        var prev = last.charAt(last.length - 1);
        if (might_need_semicolon) {
            might_need_semicolon = false;

            if (prev === ":" && ch === "}" || (!ch || !";}".includes(ch)) && prev !== ";") {
                if (options.semicolons || requireSemicolonChars.has(ch)) {
                    OUTPUT.append(";");
                    current_col++;
                    current_pos++;
                } else {
                    ensure_line_len();
                    if (current_col > 0) {
                        OUTPUT.append("\n");
                        current_pos++;
                        current_line++;
                        current_col = 0;
                    }

                    if (/^\s+$/.test(str)) {
                        // reset the semicolon flag, since we didn't print one
                        // now and might still have to later
                        might_need_semicolon = true;
                    }
                }

                if (!options.beautify)
                    might_need_space = false;
            }
        }

        if (might_need_space) {
            if ((is_identifier_char(prev)
                    && (is_identifier_char(ch) || ch == "\\"))
                || (ch == "/" && ch == prev)
                || ((ch == "+" || ch == "-") && ch == last)
            ) {
                OUTPUT.append(" ");
                current_col++;
                current_pos++;
            }
            might_need_space = false;
        }

        if (mapping_token) {
            mappings.push({
                token: mapping_token,
                name: mapping_name,
                line: current_line,
                col: current_col
            });
            mapping_token = false;
            if (!might_add_newline) do_add_mapping();
        }

        OUTPUT.append(str);
        has_parens = str[str.length - 1] == "(";
        current_pos += str.length;
        var a = str.split(/\r?\n/), n = a.length - 1;
        current_line += n;
        current_col += a[0].length;
        if (n > 0) {
            ensure_line_len();
            current_col = a[n].length;
        }
        last = str;
    }

    var star = function() {
        print("*");
    };

    var space = options.beautify ? function() {
        print(" ");
    } : function() {
        might_need_space = true;
    };

    var indent = options.beautify ? function(half) {
        if (options.beautify) {
            print(make_indent(half ? 0.5 : 0));
        }
    } : noop;

    var with_indent = options.beautify ? function(col, cont) {
        if (col === true) col = next_indent();
        var save_indentation = indentation;
        indentation = col;
        var ret = cont();
        indentation = save_indentation;
        return ret;
    } : function(col, cont) { return cont(); };

    var newline = options.beautify ? function() {
        if (newline_insert < 0) return print("\n");
        if (OUTPUT.charAt(newline_insert) != "\n") {
            OUTPUT.insertAt("\n", newline_insert);
            current_pos++;
            current_line++;
        }
        newline_insert++;
    } : options.max_line_len ? function() {
        ensure_line_len();
        might_add_newline = OUTPUT.length();
    } : noop;

    var semicolon = options.beautify ? function() {
        print(";");
    } : function() {
        might_need_semicolon = true;
    };

    function force_semicolon() {
        might_need_semicolon = false;
        print(";");
    }

    function next_indent() {
        return indentation + options.indent_level;
    }

    function with_block(cont) {
        var ret;
        print("{");
        newline();
        with_indent(next_indent(), function() {
            ret = cont();
        });
        indent();
        print("}");
        return ret;
    }

    function with_parens(cont) {
        print("(");
        //XXX: still nice to have that for argument lists
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print(")");
        return ret;
    }

    function with_square(cont) {
        print("[");
        //var ret = with_indent(current_col, cont);
        var ret = cont();
        print("]");
        return ret;
    }

    function comma() {
        print(",");
        space();
    }

    function colon() {
        print(":");
        space();
    }

    var add_mapping = mappings ? function(token, name) {
        mapping_token = token;
        mapping_name = name;
    } : noop;

    function get() {
        if (might_add_newline) {
            ensure_line_len();
        }
        return OUTPUT.toString();
    }

    function has_nlb() {
        const output = OUTPUT.toString();
        let n = output.length - 1;
        while (n >= 0) {
            const code = output.charCodeAt(n);
            if (code === CODE_LINE_BREAK) {
                return true;
            }

            if (code !== CODE_SPACE) {
                return false;
            }
            n--;
        }
        return true;
    }

    function filter_comment(comment) {
        if (!options.preserve_annotations) {
            comment = comment.replace(r_annotation, " ");
        }
        if (/^\s*$/.test(comment)) {
            return "";
        }
        return comment.replace(/(<\s*\/\s*)(script)/i, "<\\/$2");
    }

    function prepend_comments(node) {
        var self = this;
        var start = node.start;
        if (!start) return;
        var printed_comments = self.printed_comments;

        // There cannot be a newline between return and its value.
        const return_with_value = node instanceof AST_Exit && node.value;

        if (
            start.comments_before
            && printed_comments.has(start.comments_before)
        ) {
            if (return_with_value) {
                start.comments_before = [];
            } else {
                return;
            }
        }

        var comments = start.comments_before;
        if (!comments) {
            comments = start.comments_before = [];
        }
        printed_comments.add(comments);

        if (return_with_value) {
            var tw = new TreeWalker(function(node) {
                var parent = tw.parent();
                if (parent instanceof AST_Exit
                    || parent instanceof AST_Binary && parent.left === node
                    || parent.TYPE == "Call" && parent.expression === node
                    || parent instanceof AST_Conditional && parent.condition === node
                    || parent instanceof AST_Dot && parent.expression === node
                    || parent instanceof AST_Sequence && parent.expressions[0] === node
                    || parent instanceof AST_Sub && parent.expression === node
                    || parent instanceof AST_UnaryPostfix) {
                    if (!node.start) return;
                    var text = node.start.comments_before;
                    if (text && !printed_comments.has(text)) {
                        printed_comments.add(text);
                        comments = comments.concat(text);
                    }
                } else {
                    return true;
                }
            });
            tw.push(node);
            node.value.walk(tw);
        }

        if (current_pos == 0) {
            if (comments.length > 0 && options.shebang && comments[0].type === "comment5"
                && !printed_comments.has(comments[0])) {
                print("#!" + comments.shift().value + "\n");
                indent();
            }
            var preamble = options.preamble;
            if (preamble) {
                print(preamble.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
            }
        }

        comments = comments.filter(comment_filter, node).filter(c => !printed_comments.has(c));
        if (comments.length == 0) return;
        var last_nlb = has_nlb();
        comments.forEach(function(c, i) {
            printed_comments.add(c);
            if (!last_nlb) {
                if (c.nlb) {
                    print("\n");
                    indent();
                    last_nlb = true;
                } else if (i > 0) {
                    space();
                }
            }

            if (/comment[134]/.test(c.type)) {
                var value = filter_comment(c.value);
                if (value) {
                    print("//" + value + "\n");
                    indent();
                }
                last_nlb = true;
            } else if (c.type == "comment2") {
                var value = filter_comment(c.value);
                if (value) {
                    print("/*" + value + "*/");
                }
                last_nlb = false;
            }
        });
        if (!last_nlb) {
            if (start.nlb) {
                print("\n");
                indent();
            } else {
                space();
            }
        }
    }

    function append_comments(node, tail) {
        var self = this;
        var token = node.end;
        if (!token) return;
        var printed_comments = self.printed_comments;
        var comments = token[tail ? "comments_before" : "comments_after"];
        if (!comments || printed_comments.has(comments)) return;
        if (!(node instanceof AST_Statement || comments.every((c) =>
            !/comment[134]/.test(c.type)
        ))) return;
        printed_comments.add(comments);
        var insert = OUTPUT.length();
        comments.filter(comment_filter, node).forEach(function(c, i) {
            if (printed_comments.has(c)) return;
            printed_comments.add(c);
            need_space = false;
            if (need_newline_indented) {
                print("\n");
                indent();
                need_newline_indented = false;
            } else if (c.nlb && (i > 0 || !has_nlb())) {
                print("\n");
                indent();
            } else if (i > 0 || !tail) {
                space();
            }
            if (/comment[134]/.test(c.type)) {
                const value = filter_comment(c.value);
                if (value) {
                    print("//" + value);
                }
                need_newline_indented = true;
            } else if (c.type == "comment2") {
                const value = filter_comment(c.value);
                if (value) {
                    print("/*" + value + "*/");
                }
                need_space = true;
            }
        });
        if (OUTPUT.length() > insert) newline_insert = insert;
    }

    var stack = [];
    return {
        get             : get,
        toString        : get,
        indent          : indent,
        in_directive    : false,
        use_asm         : null,
        active_scope    : null,
        indentation     : function() { return indentation; },
        current_width   : function() { return current_col - indentation; },
        should_break    : function() { return options.width && this.current_width() >= options.width; },
        has_parens      : function() { return has_parens; },
        newline         : newline,
        print           : print,
        star            : star,
        space           : space,
        comma           : comma,
        colon           : colon,
        last            : function() { return last; },
        semicolon       : semicolon,
        force_semicolon : force_semicolon,
        to_utf8         : to_utf8,
        print_name      : function(name) { print(make_name(name)); },
        print_string    : function(str, quote, escape_directive) {
            var encoded = encode_string(str, quote);
            if (escape_directive === true && !encoded.includes("\\")) {
                // Insert semicolons to break directive prologue
                if (!EXPECT_DIRECTIVE.test(OUTPUT.toString())) {
                    force_semicolon();
                }
                force_semicolon();
            }
            print(encoded);
        },
        print_template_string_chars: function(str) {
            var encoded = encode_string(str, "`").replace(/\${/g, "\\${");
            return print(encoded.substr(1, encoded.length - 2));
        },
        encode_string   : encode_string,
        next_indent     : next_indent,
        with_indent     : with_indent,
        with_block      : with_block,
        with_parens     : with_parens,
        with_square     : with_square,
        add_mapping     : add_mapping,
        option          : function(opt) { return options[opt]; },
        printed_comments: printed_comments,
        prepend_comments: readonly ? noop : prepend_comments,
        append_comments : readonly || comment_filter === return_false ? noop : append_comments,
        line            : function() { return current_line; },
        col             : function() { return current_col; },
        pos             : function() { return current_pos; },
        push_node       : function(node) { stack.push(node); },
        pop_node        : function() { return stack.pop(); },
        parent          : function(n) {
            return stack[stack.length - 2 - (n || 0)];
        }
    };

}

/* -----[ code generators ]----- */

(function() {

    /* -----[ utils ]----- */

    function DEFPRINT(nodetype, generator) {
        nodetype.DEFMETHOD("_codegen", generator);
    }

    AST_Node.DEFMETHOD("print", function(output, force_parens) {
        var self = this, generator = self._codegen;
        if (self instanceof AST_Scope) {
            output.active_scope = self;
        } else if (!output.use_asm && self instanceof AST_Directive && self.value == "use asm") {
            output.use_asm = output.active_scope;
        }
        function doit() {
            output.prepend_comments(self);
            self.add_source_map(output);
            generator(self, output);
            output.append_comments(self);
        }
        output.push_node(self);
        if (force_parens || self.needs_parens(output)) {
            output.with_parens(doit);
        } else {
            doit();
        }
        output.pop_node();
        if (self === output.use_asm) {
            output.use_asm = null;
        }
    });
    AST_Node.DEFMETHOD("_print", AST_Node.prototype.print);

    AST_Node.DEFMETHOD("print_to_string", function(options) {
        var output = OutputStream(options);
        this.print(output);
        return output.get();
    });

    /* -----[ PARENTHESES ]----- */

    function PARENS(nodetype, func) {
        if (Array.isArray(nodetype)) {
            nodetype.forEach(function(nodetype) {
                PARENS(nodetype, func);
            });
        } else {
            nodetype.DEFMETHOD("needs_parens", func);
        }
    }

    PARENS(AST_Node, return_false);

    // a function expression needs parens around it when it's provably
    // the first token to appear in a statement.
    PARENS(AST_Function, function(output) {
        if (!output.has_parens() && first_in_statement(output)) {
            return true;
        }

        if (output.option("webkit")) {
            var p = output.parent();
            if (p instanceof AST_PropAccess && p.expression === this) {
                return true;
            }
        }

        if (output.option("wrap_iife")) {
            var p = output.parent();
            if (p instanceof AST_Call && p.expression === this) {
                return true;
            }
        }

        if (output.option("wrap_func_args")) {
            var p = output.parent();
            if (p instanceof AST_Call && p.args.includes(this)) {
                return true;
            }
        }

        return false;
    });

    PARENS(AST_Arrow, function(output) {
        var p = output.parent();

        if (
            output.option("wrap_func_args")
            && p instanceof AST_Call
            && p.args.includes(this)
        ) {
            return true;
        }
        return p instanceof AST_PropAccess && p.expression === this;
    });

    // same goes for an object literal (as in AST_Function), because
    // otherwise {...} would be interpreted as a block of code.
    PARENS(AST_Object, function(output) {
        return !output.has_parens() && first_in_statement(output);
    });

    PARENS(AST_ClassExpression, first_in_statement);

    PARENS(AST_Unary, function(output) {
        var p = output.parent();
        return p instanceof AST_PropAccess && p.expression === this
            || p instanceof AST_Call && p.expression === this
            || p instanceof AST_Binary
                && p.operator === "**"
                && this instanceof AST_UnaryPrefix
                && p.left === this
                && this.operator !== "++"
                && this.operator !== "--";
    });

    PARENS(AST_Await, function(output) {
        var p = output.parent();
        return p instanceof AST_PropAccess && p.expression === this
            || p instanceof AST_Call && p.expression === this
            || p instanceof AST_Binary && p.operator === "**" && p.left === this
            || output.option("safari10") && p instanceof AST_UnaryPrefix;
    });

    PARENS(AST_Sequence, function(output) {
        var p = output.parent();
        return p instanceof AST_Call                          // (foo, bar)() or foo(1, (2, 3), 4)
            || p instanceof AST_Unary                         // !(foo, bar, baz)
            || p instanceof AST_Binary                        // 1 + (2, 3) + 4 ==> 8
            || p instanceof AST_VarDef                        // var a = (1, 2), b = a + a; ==> b == 4
            || p instanceof AST_PropAccess                    // (1, {foo:2}).foo or (1, {foo:2})["foo"] ==> 2
            || p instanceof AST_Array                         // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]
            || p instanceof AST_ObjectProperty                // { foo: (1, 2) }.foo ==> 2
            || p instanceof AST_Conditional                   /* (false, true) ? (a = 10, b = 20) : (c = 30)
                                                               * ==> 20 (side effect, set a := 10 and b := 20) */
            || p instanceof AST_Arrow                         // x => (x, x)
            || p instanceof AST_DefaultAssign                 // x => (x = (0, function(){}))
            || p instanceof AST_Expansion                     // [...(a, b)]
            || p instanceof AST_ForOf && this === p.object    // for (e of (foo, bar)) {}
            || p instanceof AST_Yield                         // yield (foo, bar)
            || p instanceof AST_Export                        // export default (foo, bar)
        ;
    });

    PARENS(AST_Binary, function(output) {
        var p = output.parent();
        // (foo && bar)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // typeof (foo && bar)
        if (p instanceof AST_Unary)
            return true;
        // (foo && bar)["prop"], (foo && bar).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        // this deals with precedence: 3 * (2 + 1)
        if (p instanceof AST_Binary) {
            const po = p.operator;
            const so = this.operator;

            if (so === "??" && (po === "||" || po === "&&")) {
                return true;
            }

            if (po === "??" && (so === "||" || so === "&&")) {
                return true;
            }

            const pp = PRECEDENCE[po];
            const sp = PRECEDENCE[so];
            if (pp > sp
                || (pp == sp
                    && (this === p.right || po == "**"))) {
                return true;
            }
        }
    });

    PARENS(AST_Yield, function(output) {
        var p = output.parent();
        // (yield 1) + (yield 2)
        // a = yield 3
        if (p instanceof AST_Binary && p.operator !== "=")
            return true;
        // (yield 1)()
        // new (yield 1)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // (yield 1) ? yield 2 : yield 3
        if (p instanceof AST_Conditional && p.condition === this)
            return true;
        // -(yield 4)
        if (p instanceof AST_Unary)
            return true;
        // (yield x).foo
        // (yield x)['foo']
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
    });

    PARENS(AST_PropAccess, function(output) {
        var p = output.parent();
        if (p instanceof AST_New && p.expression === this) {
            // i.e. new (foo.bar().baz)
            //
            // if there's one call into this subtree, then we need
            // parens around it too, otherwise the call will be
            // interpreted as passing the arguments to the upper New
            // expression.
            return walk(this, node => {
                if (node instanceof AST_Scope) return true;
                if (node instanceof AST_Call) {
                    return walk_abort;  // makes walk() return true.
                }
            });
        }
    });

    PARENS(AST_Call, function(output) {
        var p = output.parent(), p1;
        if (p instanceof AST_New && p.expression === this
            || p instanceof AST_Export && p.is_default && this.expression instanceof AST_Function)
            return true;

        // workaround for Safari bug.
        // https://bugs.webkit.org/show_bug.cgi?id=123506
        return this.expression instanceof AST_Function
            && p instanceof AST_PropAccess
            && p.expression === this
            && (p1 = output.parent(1)) instanceof AST_Assign
            && p1.left === p;
    });

    PARENS(AST_New, function(output) {
        var p = output.parent();
        if (this.args.length === 0
            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)["getTime"]()
                || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)
            return true;
    });

    PARENS(AST_Number, function(output) {
        var p = output.parent();
        if (p instanceof AST_PropAccess && p.expression === this) {
            var value = this.getValue();
            if (value < 0 || /^0/.test(make_num(value))) {
                return true;
            }
        }
    });

    PARENS(AST_BigInt, function(output) {
        var p = output.parent();
        if (p instanceof AST_PropAccess && p.expression === this) {
            var value = this.getValue();
            if (value.startsWith("-")) {
                return true;
            }
        }
    });

    PARENS([ AST_Assign, AST_Conditional ], function(output) {
        var p = output.parent();
        // !(a = false)  true
        if (p instanceof AST_Unary)
            return true;
        // 1 + (a = 2) + 3  6, side effect setting a = 2
        if (p instanceof AST_Binary && !(p instanceof AST_Assign))
            return true;
        // (a = func)() or new (a = Object)()
        if (p instanceof AST_Call && p.expression === this)
            return true;
        // (a = foo) ? bar : baz
        if (p instanceof AST_Conditional && p.condition === this)
            return true;
        // (a = foo)["prop"] or (a = foo).prop
        if (p instanceof AST_PropAccess && p.expression === this)
            return true;
        // ({a, b} = {a: 1, b: 2}), a destructuring assignment
        if (this instanceof AST_Assign && this.left instanceof AST_Destructuring && this.left.is_array === false)
            return true;
    });

    /* -----[ PRINTERS ]----- */

    DEFPRINT(AST_Directive, function(self, output) {
        output.print_string(self.value, self.quote);
        output.semicolon();
    });

    DEFPRINT(AST_Expansion, function (self, output) {
        output.print("...");
        self.expression.print(output);
    });

    DEFPRINT(AST_Destructuring, function (self, output) {
        output.print(self.is_array ? "[" : "{");
        var len = self.names.length;
        self.names.forEach(function (name, i) {
            if (i > 0) output.comma();
            name.print(output);
            // If the final element is a hole, we need to make sure it
            // doesn't look like a trailing comma, by inserting an actual
            // trailing comma.
            if (i == len - 1 && name instanceof AST_Hole) output.comma();
        });
        output.print(self.is_array ? "]" : "}");
    });

    DEFPRINT(AST_Debugger, function(self, output) {
        output.print("debugger");
        output.semicolon();
    });

    /* -----[ statements ]----- */

    function display_body(body, is_toplevel, output, allow_directives) {
        var last = body.length - 1;
        output.in_directive = allow_directives;
        body.forEach(function(stmt, i) {
            if (output.in_directive === true && !(stmt instanceof AST_Directive ||
                stmt instanceof AST_EmptyStatement ||
                (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)
            )) {
                output.in_directive = false;
            }
            if (!(stmt instanceof AST_EmptyStatement)) {
                output.indent();
                stmt.print(output);
                if (!(i == last && is_toplevel)) {
                    output.newline();
                    if (is_toplevel) output.newline();
                }
            }
            if (output.in_directive === true &&
                stmt instanceof AST_SimpleStatement &&
                stmt.body instanceof AST_String
            ) {
                output.in_directive = false;
            }
        });
        output.in_directive = false;
    }

    AST_StatementWithBody.DEFMETHOD("_do_print_body", function(output) {
        force_statement(this.body, output);
    });

    DEFPRINT(AST_Statement, function(self, output) {
        self.body.print(output);
        output.semicolon();
    });
    DEFPRINT(AST_Toplevel, function(self, output) {
        display_body(self.body, true, output, true);
        output.print("");
    });
    DEFPRINT(AST_LabeledStatement, function(self, output) {
        self.label.print(output);
        output.colon();
        self.body.print(output);
    });
    DEFPRINT(AST_SimpleStatement, function(self, output) {
        self.body.print(output);
        output.semicolon();
    });
    function print_braced_empty(self, output) {
        output.print("{");
        output.with_indent(output.next_indent(), function() {
            output.append_comments(self, true);
        });
        output.print("}");
    }
    function print_braced(self, output, allow_directives) {
        if (self.body.length > 0) {
            output.with_block(function() {
                display_body(self.body, false, output, allow_directives);
            });
        } else print_braced_empty(self, output);
    }
    DEFPRINT(AST_BlockStatement, function(self, output) {
        print_braced(self, output);
    });
    DEFPRINT(AST_EmptyStatement, function(self, output) {
        output.semicolon();
    });
    DEFPRINT(AST_Do, function(self, output) {
        output.print("do");
        output.space();
        make_block(self.body, output);
        output.space();
        output.print("while");
        output.space();
        output.with_parens(function() {
            self.condition.print(output);
        });
        output.semicolon();
    });
    DEFPRINT(AST_While, function(self, output) {
        output.print("while");
        output.space();
        output.with_parens(function() {
            self.condition.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_For, function(self, output) {
        output.print("for");
        output.space();
        output.with_parens(function() {
            if (self.init) {
                if (self.init instanceof AST_Definitions) {
                    self.init.print(output);
                } else {
                    parenthesize_for_noin(self.init, output, true);
                }
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.condition) {
                self.condition.print(output);
                output.print(";");
                output.space();
            } else {
                output.print(";");
            }
            if (self.step) {
                self.step.print(output);
            }
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_ForIn, function(self, output) {
        output.print("for");
        if (self.await) {
            output.space();
            output.print("await");
        }
        output.space();
        output.with_parens(function() {
            self.init.print(output);
            output.space();
            output.print(self instanceof AST_ForOf ? "of" : "in");
            output.space();
            self.object.print(output);
        });
        output.space();
        self._do_print_body(output);
    });
    DEFPRINT(AST_With, function(self, output) {
        output.print("with");
        output.space();
        output.with_parens(function() {
            self.expression.print(output);
        });
        output.space();
        self._do_print_body(output);
    });

    /* -----[ functions ]----- */
    AST_Lambda.DEFMETHOD("_do_print", function(output, nokeyword) {
        var self = this;
        if (!nokeyword) {
            if (self.async) {
                output.print("async");
                output.space();
            }
            output.print("function");
            if (self.is_generator) {
                output.star();
            }
            if (self.name) {
                output.space();
            }
        }
        if (self.name instanceof AST_Symbol) {
            self.name.print(output);
        } else if (nokeyword && self.name instanceof AST_Node) {
            output.with_square(function() {
                self.name.print(output); // Computed method name
            });
        }
        output.with_parens(function() {
            self.argnames.forEach(function(arg, i) {
                if (i) output.comma();
                arg.print(output);
            });
        });
        output.space();
        print_braced(self, output, true);
    });
    DEFPRINT(AST_Lambda, function(self, output) {
        self._do_print(output);
    });

    DEFPRINT(AST_PrefixedTemplateString, function(self, output) {
        var tag = self.prefix;
        var parenthesize_tag = tag instanceof AST_Lambda
            || tag instanceof AST_Binary
            || tag instanceof AST_Conditional
            || tag instanceof AST_Sequence
            || tag instanceof AST_Unary
            || tag instanceof AST_Dot && tag.expression instanceof AST_Object;
        if (parenthesize_tag) output.print("(");
        self.prefix.print(output);
        if (parenthesize_tag) output.print(")");
        self.template_string.print(output);
    });
    DEFPRINT(AST_TemplateString, function(self, output) {
        var is_tagged = output.parent() instanceof AST_PrefixedTemplateString;

        output.print("`");
        for (var i = 0; i < self.segments.length; i++) {
            if (!(self.segments[i] instanceof AST_TemplateSegment)) {
                output.print("${");
                self.segments[i].print(output);
                output.print("}");
            } else if (is_tagged) {
                output.print(self.segments[i].raw);
            } else {
                output.print_template_string_chars(self.segments[i].value);
            }
        }
        output.print("`");
    });
    DEFPRINT(AST_TemplateSegment, function(self, output) {
        output.print_template_string_chars(self.value);
    });

    AST_Arrow.DEFMETHOD("_do_print", function(output) {
        var self = this;
        var parent = output.parent();
        var needs_parens = (parent instanceof AST_Binary && !(parent instanceof AST_Assign)) ||
            parent instanceof AST_Unary ||
            (parent instanceof AST_Call && self === parent.expression);
        if (needs_parens) { output.print("("); }
        if (self.async) {
            output.print("async");
            output.space();
        }
        if (self.argnames.length === 1 && self.argnames[0] instanceof AST_Symbol) {
            self.argnames[0].print(output);
        } else {
            output.with_parens(function() {
                self.argnames.forEach(function(arg, i) {
                    if (i) output.comma();
                    arg.print(output);
                });
            });
        }
        output.space();
        output.print("=>");
        output.space();
        const first_statement = self.body[0];
        if (
            self.body.length === 1
            && first_statement instanceof AST_Return
        ) {
            const returned = first_statement.value;
            if (!returned) {
                output.print("{}");
            } else if (left_is_object(returned)) {
                output.print("(");
                returned.print(output);
                output.print(")");
            } else {
                returned.print(output);
            }
        } else {
            print_braced(self, output);
        }
        if (needs_parens) { output.print(")"); }
    });

    /* -----[ exits ]----- */
    AST_Exit.DEFMETHOD("_do_print", function(output, kind) {
        output.print(kind);
        if (this.value) {
            output.space();
            const comments = this.value.start.comments_before;
            if (comments && comments.length && !output.printed_comments.has(comments)) {
                output.print("(");
                this.value.print(output);
                output.print(")");
            } else {
                this.value.print(output);
            }
        }
        output.semicolon();
    });
    DEFPRINT(AST_Return, function(self, output) {
        self._do_print(output, "return");
    });
    DEFPRINT(AST_Throw, function(self, output) {
        self._do_print(output, "throw");
    });

    /* -----[ yield ]----- */

    DEFPRINT(AST_Yield, function(self, output) {
        var star = self.is_star ? "*" : "";
        output.print("yield" + star);
        if (self.expression) {
            output.space();
            self.expression.print(output);
        }
    });

    DEFPRINT(AST_Await, function(self, output) {
        output.print("await");
        output.space();
        var e = self.expression;
        var parens = !(
               e instanceof AST_Call
            || e instanceof AST_SymbolRef
            || e instanceof AST_PropAccess
            || e instanceof AST_Unary
            || e instanceof AST_Constant
            || e instanceof AST_Await
            || e instanceof AST_Object
        );
        if (parens) output.print("(");
        self.expression.print(output);
        if (parens) output.print(")");
    });

    /* -----[ loop control ]----- */
    AST_LoopControl.DEFMETHOD("_do_print", function(output, kind) {
        output.print(kind);
        if (this.label) {
            output.space();
            this.label.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_Break, function(self, output) {
        self._do_print(output, "break");
    });
    DEFPRINT(AST_Continue, function(self, output) {
        self._do_print(output, "continue");
    });

    /* -----[ if ]----- */
    function make_then(self, output) {
        var b = self.body;
        if (output.option("braces")
            || output.option("ie8") && b instanceof AST_Do)
            return make_block(b, output);
        // The squeezer replaces "block"-s that contain only a single
        // statement with the statement itself; technically, the AST
        // is correct, but this can create problems when we output an
        // IF having an ELSE clause where the THEN clause ends in an
        // IF *without* an ELSE block (then the outer ELSE would refer
        // to the inner IF).  This function checks for this case and
        // adds the block braces if needed.
        if (!b) return output.force_semicolon();
        while (true) {
            if (b instanceof AST_If) {
                if (!b.alternative) {
                    make_block(self.body, output);
                    return;
                }
                b = b.alternative;
            } else if (b instanceof AST_StatementWithBody) {
                b = b.body;
            } else break;
        }
        force_statement(self.body, output);
    }
    DEFPRINT(AST_If, function(self, output) {
        output.print("if");
        output.space();
        output.with_parens(function() {
            self.condition.print(output);
        });
        output.space();
        if (self.alternative) {
            make_then(self, output);
            output.space();
            output.print("else");
            output.space();
            if (self.alternative instanceof AST_If)
                self.alternative.print(output);
            else
                force_statement(self.alternative, output);
        } else {
            self._do_print_body(output);
        }
    });

    /* -----[ switch ]----- */
    DEFPRINT(AST_Switch, function(self, output) {
        output.print("switch");
        output.space();
        output.with_parens(function() {
            self.expression.print(output);
        });
        output.space();
        var last = self.body.length - 1;
        if (last < 0) print_braced_empty(self, output);
        else output.with_block(function() {
            self.body.forEach(function(branch, i) {
                output.indent(true);
                branch.print(output);
                if (i < last && branch.body.length > 0)
                    output.newline();
            });
        });
    });
    AST_SwitchBranch.DEFMETHOD("_do_print_body", function(output) {
        output.newline();
        this.body.forEach(function(stmt) {
            output.indent();
            stmt.print(output);
            output.newline();
        });
    });
    DEFPRINT(AST_Default, function(self, output) {
        output.print("default:");
        self._do_print_body(output);
    });
    DEFPRINT(AST_Case, function(self, output) {
        output.print("case");
        output.space();
        self.expression.print(output);
        output.print(":");
        self._do_print_body(output);
    });

    /* -----[ exceptions ]----- */
    DEFPRINT(AST_Try, function(self, output) {
        output.print("try");
        output.space();
        print_braced(self, output);
        if (self.bcatch) {
            output.space();
            self.bcatch.print(output);
        }
        if (self.bfinally) {
            output.space();
            self.bfinally.print(output);
        }
    });
    DEFPRINT(AST_Catch, function(self, output) {
        output.print("catch");
        if (self.argname) {
            output.space();
            output.with_parens(function() {
                self.argname.print(output);
            });
        }
        output.space();
        print_braced(self, output);
    });
    DEFPRINT(AST_Finally, function(self, output) {
        output.print("finally");
        output.space();
        print_braced(self, output);
    });

    /* -----[ var/const ]----- */
    AST_Definitions.DEFMETHOD("_do_print", function(output, kind) {
        output.print(kind);
        output.space();
        this.definitions.forEach(function(def, i) {
            if (i) output.comma();
            def.print(output);
        });
        var p = output.parent();
        var in_for = p instanceof AST_For || p instanceof AST_ForIn;
        var output_semicolon = !in_for || p && p.init !== this;
        if (output_semicolon)
            output.semicolon();
    });
    DEFPRINT(AST_Let, function(self, output) {
        self._do_print(output, "let");
    });
    DEFPRINT(AST_Var, function(self, output) {
        self._do_print(output, "var");
    });
    DEFPRINT(AST_Const, function(self, output) {
        self._do_print(output, "const");
    });
    DEFPRINT(AST_Import, function(self, output) {
        output.print("import");
        output.space();
        if (self.imported_name) {
            self.imported_name.print(output);
        }
        if (self.imported_name && self.imported_names) {
            output.print(",");
            output.space();
        }
        if (self.imported_names) {
            if (self.imported_names.length === 1 && self.imported_names[0].foreign_name.name === "*") {
                self.imported_names[0].print(output);
            } else {
                output.print("{");
                self.imported_names.forEach(function (name_import, i) {
                    output.space();
                    name_import.print(output);
                    if (i < self.imported_names.length - 1) {
                        output.print(",");
                    }
                });
                output.space();
                output.print("}");
            }
        }
        if (self.imported_name || self.imported_names) {
            output.space();
            output.print("from");
            output.space();
        }
        self.module_name.print(output);
        if (self.assert_clause) {
            output.print("assert");
            self.assert_clause.print(output);
        }
        output.semicolon();
    });
    DEFPRINT(AST_ImportMeta, function(self, output) {
        output.print("import.meta");
    });

    DEFPRINT(AST_NameMapping, function(self, output) {
        var is_import = output.parent() instanceof AST_Import;
        var definition = self.name.definition();
        var names_are_different =
            (definition && definition.mangled_name || self.name.name) !==
            self.foreign_name.name;
        if (names_are_different) {
            if (is_import) {
                output.print(self.foreign_name.name);
            } else {
                self.name.print(output);
            }
            output.space();
            output.print("as");
            output.space();
            if (is_import) {
                self.name.print(output);
            } else {
                output.print(self.foreign_name.name);
            }
        } else {
            self.name.print(output);
        }
    });

    DEFPRINT(AST_Export, function(self, output) {
        output.print("export");
        output.space();
        if (self.is_default) {
            output.print("default");
            output.space();
        }
        if (self.exported_names) {
            if (self.exported_names.length === 1 && self.exported_names[0].name.name === "*") {
                self.exported_names[0].print(output);
            } else {
                output.print("{");
                self.exported_names.forEach(function(name_export, i) {
                    output.space();
                    name_export.print(output);
                    if (i < self.exported_names.length - 1) {
                        output.print(",");
                    }
                });
                output.space();
                output.print("}");
            }
        } else if (self.exported_value) {
            self.exported_value.print(output);
        } else if (self.exported_definition) {
            self.exported_definition.print(output);
            if (self.exported_definition instanceof AST_Definitions) return;
        }
        if (self.module_name) {
            output.space();
            output.print("from");
            output.space();
            self.module_name.print(output);
        }
        if (self.assert_clause) {
            output.print("assert");
            self.assert_clause.print(output);
        }
        if (self.exported_value
                && !(self.exported_value instanceof AST_Defun ||
                    self.exported_value instanceof AST_Function ||
                    self.exported_value instanceof AST_Class)
            || self.module_name
            || self.exported_names
        ) {
            output.semicolon();
        }
    });

    function parenthesize_for_noin(node, output, noin) {
        var parens = false;
        // need to take some precautions here:
        //    https://github.com/mishoo/UglifyJS2/issues/60
        if (noin) {
            parens = walk(node, node => {
                // Don't go into scopes -- except arrow functions:
                // https://github.com/terser/terser/issues/1019#issuecomment-877642607
                if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {
                    return true;
                }
                if (node instanceof AST_Binary && node.operator == "in") {
                    return walk_abort;  // makes walk() return true
                }
            });
        }
        node.print(output, parens);
    }

    DEFPRINT(AST_VarDef, function(self, output) {
        self.name.print(output);
        if (self.value) {
            output.space();
            output.print("=");
            output.space();
            var p = output.parent(1);
            var noin = p instanceof AST_For || p instanceof AST_ForIn;
            parenthesize_for_noin(self.value, output, noin);
        }
    });

    /* -----[ other expressions ]----- */
    DEFPRINT(AST_Call, function(self, output) {
        self.expression.print(output);
        if (self instanceof AST_New && self.args.length === 0)
            return;
        if (self.expression instanceof AST_Call || self.expression instanceof AST_Lambda) {
            output.add_mapping(self.start);
        }
        if (self.optional) output.print("?.");
        output.with_parens(function() {
            self.args.forEach(function(expr, i) {
                if (i) output.comma();
                expr.print(output);
            });
        });
    });
    DEFPRINT(AST_New, function(self, output) {
        output.print("new");
        output.space();
        AST_Call.prototype._codegen(self, output);
    });

    AST_Sequence.DEFMETHOD("_do_print", function(output) {
        this.expressions.forEach(function(node, index) {
            if (index > 0) {
                output.comma();
                if (output.should_break()) {
                    output.newline();
                    output.indent();
                }
            }
            node.print(output);
        });
    });
    DEFPRINT(AST_Sequence, function(self, output) {
        self._do_print(output);
        // var p = output.parent();
        // if (p instanceof AST_Statement) {
        //     output.with_indent(output.next_indent(), function(){
        //         self._do_print(output);
        //     });
        // } else {
        //     self._do_print(output);
        // }
    });
    DEFPRINT(AST_Dot, function(self, output) {
        var expr = self.expression;
        expr.print(output);
        var prop = self.property;
        var print_computed = ALL_RESERVED_WORDS.has(prop)
            ? output.option("ie8")
            : !is_identifier_string(
                prop,
                output.option("ecma") >= 2015 || output.option("safari10")
            );

        if (self.optional) output.print("?.");

        if (print_computed) {
            output.print("[");
            output.add_mapping(self.end);
            output.print_string(prop);
            output.print("]");
        } else {
            if (expr instanceof AST_Number && expr.getValue() >= 0) {
                if (!/[xa-f.)]/i.test(output.last())) {
                    output.print(".");
                }
            }
            if (!self.optional) output.print(".");
            // the name after dot would be mapped about here.
            output.add_mapping(self.end);
            output.print_name(prop);
        }
    });
    DEFPRINT(AST_DotHash, function(self, output) {
        var expr = self.expression;
        expr.print(output);
        var prop = self.property;

        if (self.optional) output.print("?");
        output.print(".#");
        output.add_mapping(self.end);
        output.print_name(prop);
    });
    DEFPRINT(AST_Sub, function(self, output) {
        self.expression.print(output);
        if (self.optional) output.print("?.");
        output.print("[");
        self.property.print(output);
        output.print("]");
    });
    DEFPRINT(AST_Chain, function(self, output) {
        self.expression.print(output);
    });
    DEFPRINT(AST_UnaryPrefix, function(self, output) {
        var op = self.operator;
        output.print(op);
        if (/^[a-z]/i.test(op)
            || (/[+-]$/.test(op)
                && self.expression instanceof AST_UnaryPrefix
                && /^[+-]/.test(self.expression.operator))) {
            output.space();
        }
        self.expression.print(output);
    });
    DEFPRINT(AST_UnaryPostfix, function(self, output) {
        self.expression.print(output);
        output.print(self.operator);
    });
    DEFPRINT(AST_Binary, function(self, output) {
        var op = self.operator;
        self.left.print(output);
        if (op[0] == ">" /* ">>" ">>>" ">" ">=" */
            && self.left instanceof AST_UnaryPostfix
            && self.left.operator == "--") {
            // space is mandatory to avoid outputting -->
            output.print(" ");
        } else {
            // the space is optional depending on "beautify"
            output.space();
        }
        output.print(op);
        if ((op == "<" || op == "<<")
            && self.right instanceof AST_UnaryPrefix
            && self.right.operator == "!"
            && self.right.expression instanceof AST_UnaryPrefix
            && self.right.expression.operator == "--") {
            // space is mandatory to avoid outputting <!--
            output.print(" ");
        } else {
            // the space is optional depending on "beautify"
            output.space();
        }
        self.right.print(output);
    });
    DEFPRINT(AST_Conditional, function(self, output) {
        self.condition.print(output);
        output.space();
        output.print("?");
        output.space();
        self.consequent.print(output);
        output.space();
        output.colon();
        self.alternative.print(output);
    });

    /* -----[ literals ]----- */
    DEFPRINT(AST_Array, function(self, output) {
        output.with_square(function() {
            var a = self.elements, len = a.length;
            if (len > 0) output.space();
            a.forEach(function(exp, i) {
                if (i) output.comma();
                exp.print(output);
                // If the final element is a hole, we need to make sure it
                // doesn't look like a trailing comma, by inserting an actual
                // trailing comma.
                if (i === len - 1 && exp instanceof AST_Hole)
                  output.comma();
            });
            if (len > 0) output.space();
        });
    });
    DEFPRINT(AST_Object, function(self, output) {
        if (self.properties.length > 0) output.with_block(function() {
            self.properties.forEach(function(prop, i) {
                if (i) {
                    output.print(",");
                    output.newline();
                }
                output.indent();
                prop.print(output);
            });
            output.newline();
        });
        else print_braced_empty(self, output);
    });
    DEFPRINT(AST_Class, function(self, output) {
        output.print("class");
        output.space();
        if (self.name) {
            self.name.print(output);
            output.space();
        }
        if (self.extends) {
            var parens = (
                   !(self.extends instanceof AST_SymbolRef)
                && !(self.extends instanceof AST_PropAccess)
                && !(self.extends instanceof AST_ClassExpression)
                && !(self.extends instanceof AST_Function)
            );
            output.print("extends");
            if (parens) {
                output.print("(");
            } else {
                output.space();
            }
            self.extends.print(output);
            if (parens) {
                output.print(")");
            } else {
                output.space();
            }
        }
        if (self.properties.length > 0) output.with_block(function() {
            self.properties.forEach(function(prop, i) {
                if (i) {
                    output.newline();
                }
                output.indent();
                prop.print(output);
            });
            output.newline();
        });
        else output.print("{}");
    });
    DEFPRINT(AST_NewTarget, function(self, output) {
        output.print("new.target");
    });

    function print_property_name(key, quote, output) {
        if (output.option("quote_keys")) {
            return output.print_string(key);
        }
        if ("" + +key == key && key >= 0) {
            if (output.option("keep_numbers")) {
                return output.print(key);
            }
            return output.print(make_num(key));
        }
        var print_string = ALL_RESERVED_WORDS.has(key)
            ? output.option("ie8")
            : (
                output.option("ecma") < 2015 || output.option("safari10")
                    ? !is_basic_identifier_string(key)
                    : !is_identifier_string(key, true)
            );
        if (print_string || (quote && output.option("keep_quoted_props"))) {
            return output.print_string(key, quote);
        }
        return output.print_name(key);
    }

    DEFPRINT(AST_ObjectKeyVal, function(self, output) {
        function get_name(self) {
            var def = self.definition();
            return def ? def.mangled_name || def.name : self.name;
        }

        var allowShortHand = output.option("shorthand");
        if (allowShortHand &&
            self.value instanceof AST_Symbol &&
            is_identifier_string(
                self.key,
                output.option("ecma") >= 2015 || output.option("safari10")
            ) &&
            get_name(self.value) === self.key &&
            !ALL_RESERVED_WORDS.has(self.key)
        ) {
            print_property_name(self.key, self.quote, output);

        } else if (allowShortHand &&
            self.value instanceof AST_DefaultAssign &&
            self.value.left instanceof AST_Symbol &&
            is_identifier_string(
                self.key,
                output.option("ecma") >= 2015 || output.option("safari10")
            ) &&
            get_name(self.value.left) === self.key
        ) {
            print_property_name(self.key, self.quote, output);
            output.space();
            output.print("=");
            output.space();
            self.value.right.print(output);
        } else {
            if (!(self.key instanceof AST_Node)) {
                print_property_name(self.key, self.quote, output);
            } else {
                output.with_square(function() {
                    self.key.print(output);
                });
            }
            output.colon();
            self.value.print(output);
        }
    });
    DEFPRINT(AST_ClassPrivateProperty, (self, output) => {
        if (self.static) {
            output.print("static");
            output.space();
        }

        output.print("#");
        
        print_property_name(self.key.name, self.quote, output);

        if (self.value) {
            output.print("=");
            self.value.print(output);
        }

        output.semicolon();
    });
    DEFPRINT(AST_ClassProperty, (self, output) => {
        if (self.static) {
            output.print("static");
            output.space();
        }

        if (self.key instanceof AST_SymbolClassProperty) {
            print_property_name(self.key.name, self.quote, output);
        } else {
            output.print("[");
            self.key.print(output);
            output.print("]");
        }

        if (self.value) {
            output.print("=");
            self.value.print(output);
        }

        output.semicolon();
    });
    AST_ObjectProperty.DEFMETHOD("_print_getter_setter", function(type, is_private, output) {
        var self = this;
        if (self.static) {
            output.print("static");
            output.space();
        }
        if (type) {
            output.print(type);
            output.space();
        }
        if (self.key instanceof AST_SymbolMethod) {
            if (is_private) output.print("#");
            print_property_name(self.key.name, self.quote, output);
        } else {
            output.with_square(function() {
                self.key.print(output);
            });
        }
        self.value._do_print(output, true);
    });
    DEFPRINT(AST_ObjectSetter, function(self, output) {
        self._print_getter_setter("set", false, output);
    });
    DEFPRINT(AST_ObjectGetter, function(self, output) {
        self._print_getter_setter("get", false, output);
    });
    DEFPRINT(AST_PrivateSetter, function(self, output) {
        self._print_getter_setter("set", true, output);
    });
    DEFPRINT(AST_PrivateGetter, function(self, output) {
        self._print_getter_setter("get", true, output);
    });
    DEFPRINT(AST_PrivateMethod, function(self, output) {
        var type;
        if (self.is_generator && self.async) {
            type = "async*";
        } else if (self.is_generator) {
            type = "*";
        } else if (self.async) {
            type = "async";
        }
        self._print_getter_setter(type, true, output);
    });
    DEFPRINT(AST_ConciseMethod, function(self, output) {
        var type;
        if (self.is_generator && self.async) {
            type = "async*";
        } else if (self.is_generator) {
            type = "*";
        } else if (self.async) {
            type = "async";
        }
        self._print_getter_setter(type, false, output);
    });
    AST_Symbol.DEFMETHOD("_do_print", function(output) {
        var def = this.definition();
        output.print_name(def ? def.mangled_name || def.name : this.name);
    });
    DEFPRINT(AST_Symbol, function (self, output) {
        self._do_print(output);
    });
    DEFPRINT(AST_Hole, noop);
    DEFPRINT(AST_This, function(self, output) {
        output.print("this");
    });
    DEFPRINT(AST_Super, function(self, output) {
        output.print("super");
    });
    DEFPRINT(AST_Constant, function(self, output) {
        output.print(self.getValue());
    });
    DEFPRINT(AST_String, function(self, output) {
        output.print_string(self.getValue(), self.quote, output.in_directive);
    });
    DEFPRINT(AST_Number, function(self, output) {
        if ((output.option("keep_numbers") || output.use_asm) && self.raw) {
            output.print(self.raw);
        } else {
            output.print(make_num(self.getValue()));
        }
    });
    DEFPRINT(AST_BigInt, function(self, output) {
        output.print(self.getValue() + "n");
    });

    const r_slash_script = /(<\s*\/\s*script)/i;
    const slash_script_replace = (_, $1) => $1.replace("/", "\\/");
    DEFPRINT(AST_RegExp, function(self, output) {
        let { source, flags } = self.getValue();
        source = regexp_source_fix(source);
        flags = flags ? sort_regexp_flags(flags) : "";
        source = source.replace(r_slash_script, slash_script_replace);

        output.print(output.to_utf8(`/${source}/${flags}`, false, true));

        const parent = output.parent();
        if (
            parent instanceof AST_Binary
            && /^\w/.test(parent.operator)
            && parent.left === self
        ) {
            output.print(" ");
        }
    });

    function force_statement(stat, output) {
        if (output.option("braces")) {
            make_block(stat, output);
        } else {
            if (!stat || stat instanceof AST_EmptyStatement)
                output.force_semicolon();
            else
                stat.print(output);
        }
    }

    function best_of(a) {
        var best = a[0], len = best.length;
        for (var i = 1; i < a.length; ++i) {
            if (a[i].length < len) {
                best = a[i];
                len = best.length;
            }
        }
        return best;
    }

    function make_num(num) {
        var str = num.toString(10).replace(/^0\./, ".").replace("e+", "e");
        var candidates = [ str ];
        if (Math.floor(num) === num) {
            if (num < 0) {
                candidates.push("-0x" + (-num).toString(16).toLowerCase());
            } else {
                candidates.push("0x" + num.toString(16).toLowerCase());
            }
        }
        var match, len, digits;
        if (match = /^\.0+/.exec(str)) {
            len = match[0].length;
            digits = str.slice(len);
            candidates.push(digits + "e-" + (digits.length + len - 1));
        } else if (match = /0+$/.exec(str)) {
            len = match[0].length;
            candidates.push(str.slice(0, -len) + "e" + len);
        } else if (match = /^(\d)\.(\d+)e(-?\d+)$/.exec(str)) {
            candidates.push(match[1] + match[2] + "e" + (match[3] - match[2].length));
        }
        return best_of(candidates);
    }

    function make_block(stmt, output) {
        if (!stmt || stmt instanceof AST_EmptyStatement)
            output.print("{}");
        else if (stmt instanceof AST_BlockStatement)
            stmt.print(output);
        else output.with_block(function() {
            output.indent();
            stmt.print(output);
            output.newline();
        });
    }

    /* -----[ source map generators ]----- */

    function DEFMAP(nodetype, generator) {
        nodetype.forEach(function(nodetype) {
            nodetype.DEFMETHOD("add_source_map", generator);
        });
    }

    DEFMAP([
        // We could easily add info for ALL nodes, but it seems to me that
        // would be quite wasteful, hence this noop in the base class.
        AST_Node,
        // since the label symbol will mark it
        AST_LabeledStatement,
        AST_Toplevel,
    ], noop);

    // XXX: I'm not exactly sure if we need it for all of these nodes,
    // or if we should add even more.
    DEFMAP([
        AST_Array,
        AST_BlockStatement,
        AST_Catch,
        AST_Class,
        AST_Constant,
        AST_Debugger,
        AST_Definitions,
        AST_Directive,
        AST_Finally,
        AST_Jump,
        AST_Lambda,
        AST_New,
        AST_Object,
        AST_StatementWithBody,
        AST_Symbol,
        AST_Switch,
        AST_SwitchBranch,
        AST_TemplateString,
        AST_TemplateSegment,
        AST_Try,
    ], function(output) {
        output.add_mapping(this.start);
    });

    DEFMAP([
        AST_ObjectGetter,
        AST_ObjectSetter,
        AST_PrivateGetter,
        AST_PrivateSetter,
    ], function(output) {
        output.add_mapping(this.key.end, this.key.name);
    });

    DEFMAP([ AST_ObjectProperty ], function(output) {
        output.add_mapping(this.start, this.key);
    });
})();

export {
    OutputStream,
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           // This file was generated. Do not modify manually!
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

// This file was generated. Do not modify manually!
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];

// This file was generated. Do not modify manually!
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

// This file was generated. Do not modify manually!
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

// These are a run-length and offset encoded representation of the

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords[name] = new TokenType(name, options)
}

var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),
  coalesce: binop("??", 1),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

function nextLineBreak(code, from, end) {
  if ( end === void 0 ) end = code.length;

  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next))
      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
  }
  return -1
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

var hasOwn = Object.hasOwn || (function (obj, propName) { return (
  hasOwnProperty.call(obj, propName)
); });

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    var nextBreak = nextLineBreak(input, cur, offset);
    if (nextBreak < 0) { return new Position(line, offset - cur) }
    ++line;
    cur = nextBreak;
  }
}

// A second argument must be given to configure the parser process.
// These options are recognized (only `ecmaVersion` is required):

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), or `"latest"` (the
  // latest version the library supports). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

var warnedAboutEcmaVersion = false;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS_STATIC_BLOCK = 256,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal* and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types$1.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = Object.create(null);

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;

  // The stack of private names.
  // Each element has two properties: 'declared' and 'used'.
  // When it exited from the outermost class definition, all used private names must be declared.
  this.privateNameStack = [];
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.canAwait.get = function () {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
    if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
  }
  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
};

prototypeAccessors.allowSuper.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
};

prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

prototypeAccessors.allowNewDotTarget.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
};

prototypeAccessors.inClassStaticBlock.get = function () {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
};

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp$9 = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) { return false }
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" ||
        (lineBreak.test(spaceAfter[0]) &&
         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
    }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof ||
    this.type === types$1.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

var DestructuringErrors = function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
};

pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$8 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$8.parseTopLevel = function(node) {
  var exports = Object.create(null);
  if (!node.body) { node.body = []; }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91 || nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '[', '/', astral
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length ||
     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types$1._debugger: return this.parseDebuggerStatement(node)
  case types$1._do: return this.parseDoStatement(node)
  case types$1._for: return this.parseForStatement(node)
  case types$1._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types$1._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types$1._if: return this.parseIfStatement(node)
  case types$1._return: return this.parseReturnStatement(node)
  case types$1._switch: return this.parseSwitchStatement(node)
  case types$1._throw: return this.parseThrowStatement(node)
  case types$1._try: return this.parseTryStatement(node)
  case types$1._const: case types$1._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types$1._while: return this.parseWhileStatement(node)
  case types$1._with: return this.parseWithStatement(node)
  case types$1.braceL: return this.parseBlock(true, node)
  case types$1.semi: return this.parseEmptyStatement(node)
  case types$1._export:
  case types$1._import:
    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40 || nextCh === 46) // '(' or '.'
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types$1.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types$1.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR;) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty$1 = [];

pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$8.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$8.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) { this.strict = false; }
  this.next();
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$8.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) { break }
  }
  return node
};

pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types$1.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$8.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) { return null }

  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;

  if (this.eatContextual("static")) {
    // Parse static init block
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }

  // Parse element name
  if (keyName) {
    // 'async', 'get', 'set', or 'static' were not a keyword contextually.
    // The last token is any of those. Make it the element name.
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }

  // Parse element value
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
    if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }

  return node
};

pp$8.isClassElementNameStart = function() {
  return (
    this.type === types$1.name ||
    this.type === types$1.privateId ||
    this.type === types$1.num ||
    this.type === types$1.string ||
    this.type === types$1.bracketL ||
    this.type.keyword
  )
};

pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};

pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  // Check key and flags
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  // Parse value
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

  // Check value
  if (method.kind === "get" && value.params.length !== 0)
    { this.raiseRecoverable(value.start, "getter should have no params"); }
  if (method.kind === "set" && value.params.length !== 1)
    { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && value.params[0].type === "RestElement")
    { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

  return this.finishNode(method, "MethodDefinition")
};

pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }

  if (this.eat(types$1.eq)) {
    // To raise SyntaxError if 'arguments' exists in the initializer.
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();

  return this.finishNode(field, "PropertyDefinition")
};

pp$8.parseClassStaticBlock = function(node) {
  node.body = [];

  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;

  return this.finishNode(node, "StaticBlock")
};

pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
};

pp$8.enterClassBody = function() {
  var element = {declared: Object.create(null), used: []};
  this.privateNameStack.push(element);
  return element.declared
};

pp$8.exitClassBody = function() {
  var ref = this.privateNameStack.pop();
  var declared = ref.declared;
  var used = ref.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
      }
    }
  }
};

function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];

  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }

  // `class { get #a(){}; static set #a(_){} }` is also conflict.
  if (
    curr === "iget" && next === "iset" ||
    curr === "iset" && next === "iget" ||
    curr === "sget" && next === "sset" ||
    curr === "sset" && next === "sget"
  ) {
    privateNameMap[name] = "true";
    return false
  } else if (!curr) {
    privateNameMap[name] = next;
    return false
  } else {
    return true
  }
}

function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (
    key.type === "Identifier" && key.name === name ||
    key.type === "Literal" && key.value === name
  )
}

// Parses module export declaration.

pp$8.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node.exported = this.parseModuleExportName();
        this.checkExport(exports, node.exported, this.lastTokStart);
      } else {
        node.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types$1._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);

        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$8.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (typeof name !== "string")
    { name = name.type === "Identifier" ? name.name : name.value; }
  if (hasOwn(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseModuleExportName();
    node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
    this.checkExport(
      exports,
      node.exported,
      node.exported.start
    );
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$8.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLValSimple(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) { return nodes }
  }
  if (this.type === types$1.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLValSimple(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral
  }
  return this.parseIdent(true)
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$7 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "AssignmentPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "ChainExpression":
      this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types$1.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types$1.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types$1.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types$1.comma); }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$7.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// The following three functions all verify that a node is an lvalue 
// something that can be bound, or assigned to. In order to do so, they perform
// a variety of checks:
//
// - Check that none of the bound/assigned-to identifiers are reserved words.
// - Record name declarations for bindings in the appropriate scope.
// - Check duplicate argument names, if checkClashes is set.
//
// If a complex binding pattern is encountered (e.g., object and array
// destructuring), the entire pattern is recursively checked.
//
// There are three versions of checkLVal*() appropriate for different
// circumstances:
//
// - checkLValSimple() shall be used if the syntactic construct supports
//   nothing other than identifiers and member expressions. Parenthesized
//   expressions are also correctly handled. This is generally appropriate for
//   constructs for which the spec says
//
//   > It is a Syntax Error if AssignmentTargetType of [the production] is not
//   > simple.
//
//   It is also appropriate for checking if an identifier is valid and not
//   defined elsewhere, like import declarations or function/class identifiers.
//
//   Examples where this is used include:
//     a += ;
//     import a from '';
//   where a is the node to be checked.
//
// - checkLValPattern() shall be used if the syntactic construct supports
//   anything checkLValSimple() supports, as well as object and array
//   destructuring patterns. This is generally appropriate for constructs for
//   which the spec says
//
//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
//   > an ArrayLiteral and AssignmentTargetType of [the production] is not
//   > simple.
//
//   Examples where this is used include:
//     (a = );
//     const a = ;
//     try {  } catch (a) {  }
//   where a is the node to be checked.
//
// - checkLValInnerPattern() shall be used if the syntactic construct supports
//   anything checkLValPattern() supports, as well as default assignment
//   patterns, rest elements, and other constructs that may appear within an
//   object or array destructuring pattern.
//
//   As a special case, function parameters also use checkLValInnerPattern(),
//   as they also support defaults and rest constructs.
//
// These functions deliberately support both assignment and binding constructs,
// as the logic for both is exceedingly similar. If the node is the target of
// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
// should be set to the appropriate BIND_* constant, like BIND_VAR or
// BIND_LEXICAL.
//
// If the function is called with a non-BIND_NONE bindingType, then
// additionally a checkClashes object may be specified to allow checking for
// duplicate argument names. checkClashes is ignored if the provided construct
// is an assignment (i.e., bindingType is BIND_NONE).

pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  var isBind = bindingType !== BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (isBind) {
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (checkClashes) {
        if (hasOwn(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    }
    break

  case "ChainExpression":
    this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
    break

  case "MemberExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ParenthesizedExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
    return this.checkLValSimple(expr.expression, bindingType, checkClashes)

  default:
    this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};

pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1) {
      var prop = list[i];

    this.checkLValInnerPattern(prop, bindingType, checkClashes);
    }
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
    }
    break

  default:
    this.checkLValSimple(expr, bindingType, checkClashes);
  }
};

pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
    break

  case "AssignmentPattern":
    this.checkLValPattern(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLValPattern(expr.argument, bindingType, checkClashes);
    break

  default:
    this.checkLValPattern(expr, bindingType, checkClashes);
  }
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$6 = Parser.prototype;

pp$6.initialContext = function() {
  return [types.b_stat]
};

pp$6.curContext = function() {
  return this.context[this.context.length - 1]
};

pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat)
    { return true }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
    { return true }
  if (prevType === types$1.braceL)
    { return parent === types.b_stat }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
    { return false }
  return !this.exprAllowed
};

pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Used to handle egde case when token context could not be inferred correctly in tokenize phase
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};

// Token-specific context update code

types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

types$1.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else &&
      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
    { this.context.push(types.f_expr); }
  else
    { this.context.push(types.f_stat); }
  this.exprAllowed = false;
};

types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types.q_tmpl); }
  this.exprAllowed = false;
};

types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr)
      { this.context[index] = types.f_expr_gen; }
    else
      { this.context[index] = types.f_gen; }
  }
  this.exprAllowed = true;
};

types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// A recursive descent parser operates by defining functions for all

var pp$5 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(forInit) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq)
      { left = this.toAssignable(left, false, refDestructuringErrors); }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start)
      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
    if (this.type === types$1.eq)
      { this.checkLValPattern(left); }
    else
      { this.checkLValSimple(left); }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
    }
  }
  return left
};

pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLValSimple(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
      { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }
    expr = this.parsePrivateIdent();
    // only could be private fields in 'in', such as #x in obj
    if (this.type !== types$1._in) { this.unexpected(); }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary)
      { this.unexpected(this.lastTokStart); }
    else
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
  } else {
    return expr
  }
};

function isPrivateFieldAccess(node) {
  return (
    node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
    node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
  )
}

// Parse call, dot, and `[]`-subscript expressions.

pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
  }
  return result
};

pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
      this.potentialArrowAt === base.start;
  var optionalChained = false;

  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

    if (element.optional) { optionalChained = true; }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element
    }

    base = element;
  }
};

pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

  var computed = this.eat(types$1.bracketL);
  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types$1.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types$1._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types$1.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super ( Arguments )
    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types$1._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types$1.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
      this.overrideContext(types.f_expr);
      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
    }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types$1.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
          (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
      }
    }
    return id

  case types$1.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types$1.num: case types$1.string:
    return this.parseLiteral(this.value)

  case types$1._null: case types$1._true: case types$1._false:
    node = this.startNode();
    node.value = this.type === types$1._null ? null : this.type === types$1._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types$1.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types$1.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types$1.braceL:
    this.overrideContext(types.b_expr);
    return this.parseObj(false, refDestructuringErrors)

  case types$1._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types$1._class:
    return this.parseClass(this.startNode(), false)

  case types$1._new:
    return this.parseNew()

  case types$1.backQuote:
    return this.parseTemplate()

  case types$1._import:
    if (this.options.ecmaVersion >= 11) {
      return this.parseExprImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$5.parseExprImport = function() {
  var node = this.startNode();

  // Consume `import` as an identifier for `import.meta`.
  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
  var meta = this.parseIdent(true);

  switch (this.type) {
  case types$1.parenL:
    return this.parseDynamicImport(node)
  case types$1.dot:
    node.meta = meta;
    return this.parseImportMeta(node)
  default:
    this.unexpected();
  }
};

pp$5.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  // Verify ending.
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$5.parseImportMeta = function(node) {
  this.next(); // skip `.`

  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);

  if (node.property.name !== "meta")
    { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
  if (containsEsc)
    { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
    { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

  return this.finishNode(node, "MetaProperty")
};

pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val
};

pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$5.parseParenItem = function(item) {
  return item
};

pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call  at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty = [];

pp$5.parseNew = function() {
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
    if (!this.allowNewDotTarget)
      { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$5.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$5.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types$1.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types$1.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon)
    { this.unexpected(); }

  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};

pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types$1.comma)
      { elt = null; }
    else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$5.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.currentThisScope().inClassFieldInit && name === "arguments")
    { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
    { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$5.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");

  // For validating existence
  if (this.privateNameStack.length === 0) {
    this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
  }

  return node
};

// Parses yield expression inside generator.

pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$3 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
  // A switch to disallow the identifier reference 'arguments'
  this.inClassFieldInit = false;
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$3.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$3.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$2 = Parser.prototype;

pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) { newNode[prop] = node[prop]; }
  return newNode
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}

for (var i = 0, list = [9, 10, 11, 12, 13]; i < list.length; i += 1) {
  var ecmaVersion = lis