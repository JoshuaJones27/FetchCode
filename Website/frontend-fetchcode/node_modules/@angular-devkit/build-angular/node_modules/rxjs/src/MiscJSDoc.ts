      );

      if (dependencyExtractor.getCacheKey) {
        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());
      }
    }

    this._cachePath = HasteMap.getCacheFilePath(
      this._options.cacheDirectory,
      `haste-map-${this._options.id}-${rootDirHash}`,
      VERSION,
      this._options.id,
      this._options.roots
        .map(root => fastPath.relative(options.rootDir, root))
        .join(':'),
      this._options.extensions.join(':'),
      this._options.platforms.join(':'),
      this._options.computeSha1.toString(),
      options.mocksPattern || '',
      (options.ignorePattern || '').toString(),
      hasteImplHash,
      dependencyExtractorHash,
      this._options.computeDependencies.toString()
    );
  }

  static getCacheFilePath(tmpdir, id, ...extra) {
    const hash = (0, _crypto().createHash)('sha256').update(extra.join(''));
    return path().join(
      tmpdir,
      `${id.replace(/\W/g, '-')}-${hash.digest('hex').substring(0, 32)}`
    );
  }

  static getModuleMapFromJSON(json) {
    return _ModuleMap.default.fromJSON(json);
  }

  getCacheFilePath() {
    return this._cachePath;
  }

  build() {
    if (!this._buildPromise) {
      this._buildPromise = (async () => {
        const data = await this._buildFileMap(); // Persist when we don't know if files changed (changedFiles undefined)
        // or when we know a file was changed or deleted.

        let hasteMap;

        if (
          data.changedFiles === undefined ||
          data.changedFiles.size > 0 ||
          data.removedFiles.size > 0
        ) {
          hasteMap = await this._buildHasteMap(data);

          this._persist(hasteMap);
        } else {
          hasteMap = data.hasteMap;
        }

        const rootDir = this._options.rootDir;
        const hasteFS = new _HasteFS.default({
          files: hasteMap.files,
          rootDir
        });
        const moduleMap = new _ModuleMap.default({
          duplicates: hasteMap.duplicates,
          map: hasteMap.map,
          mocks: hasteMap.mocks,
          rootDir
        });

        const __hasteMapForTest =
          (process.env.NODE_ENV === 'test' && hasteMap) || null;

        await this._watch(hasteMap);
        return {
          __hasteMapForTest,
          hasteFS,
          moduleMap
        };
      })();
    }

    return this._buildPromise;
  }
  /**
   * 1. read data from the cache or create an empty structure.
   */

  read() {
    let hasteMap;

    try {
      hasteMap = (0, _v().deserialize)(
        (0, _gracefulFs().readFileSync)(this._cachePath)
      );
    } catch {
      hasteMap = this._createEmptyMap();
    }

    return hasteMap;
  }

  readModuleMap() {
    const data = this.read();
    return new _ModuleMap.default({
      duplicates: data.duplicates,
      map: data.map,
      mocks: data.mocks,
      rootDir: this._options.rootDir
    });
  }
  /**
   * 2. crawl the file system.
   */

  async _buildFileMap() {
    let hasteMap;

    try {
      const read = this._options.resetCache ? this._createEmptyMap : this.read;
      hasteMap = read.call(this);
    } catch {
      hasteMap = this._createEmptyMap();
    }

    return this._crawl(hasteMap);
  }
  /**
   * 3. parse and extract metadata from changed files.
   */

  _processFile(hasteMap, map, mocks, filePath, workerOptions) {
    const rootDir = this._options.rootDir;

    const setModule = (id, module) => {
      let moduleMap = map.get(id);

      if (!moduleMap) {
        moduleMap = Object.create(null);
        map.set(id, moduleMap);
      }

      const platform =
        (0, _getPlatformExtension.default)(
          module[_constants.default.PATH],
          this._options.platforms
        ) || _constants.default.GENERIC_PLATFORM;

      const existingModule = moduleMap[platform];

      if (
        existingModule &&
        existingModule[_constants.default.PATH] !==
          module[_constants.default.PATH]
      ) {
        const method = this._options.throwOnModuleCollision ? 'error' : 'warn';

        this._console[method](
          [
            `jest-haste-map: Haste module naming collision: ${id}`,
            '  The following files share their name; please adjust your hasteImpl:',
            `    * <rootDir>${path().sep}${
              existingModule[_constants.default.PATH]
            }`,
            `    * <rootDir>${path().sep}${module[_constants.default.PATH]}`,
            ''
          ].join('\n')
        );

        if (this._options.throwOnModuleCollision) {
          throw new DuplicateError(
            existingModule[_constants.default.PATH],
            module[_constants.default.PATH]
          );
        } // We do NOT want consumers to use a module that is ambiguous.

        delete moduleMap[platform];

        if (Object.keys(moduleMap).length === 1) {
          map.delete(id);
        }

        let dupsByPlatform = hasteMap.duplicates.get(id);

        if (dupsByPlatform == null) {
          dupsByPlatform = new Map();
          hasteMap.duplicates.set(id, dupsByPlatform);
        }

        const dups = new Map([
          [module[_constants.default.PATH], module[_constants.default.TYPE]],
          [
            existingModule[_constants.default.PATH],
            existingModule[_constants.default.TYPE]
          ]
        ]);
        dupsByPlatform.set(platform, dups);
        return;
      }

      const dupsByPlatform = hasteMap.duplicates.get(id);

      if (dupsByPlatform != null) {
        const dups = dupsByPlatform.get(platform);

        if (dups != null) {
          dups.set(
            module[_constants.default.PATH],
            module[_constants.default.TYPE]
          );
        }

        return;
      }

      moduleMap[platform] = module;
    };

    const relativeFilePath = fastPath.relative(rootDir, filePath);
    const fileMetadata = hasteMap.files.get(relativeFilePath);

    if (!fileMetadata) {
      throw new Error(
        'jest-haste-map: File to process was not found in the haste map.'
      );
    }

    const moduleMetadata = hasteMap.map.get(
      fileMetadata[_constants.default.ID]
    );
    const computeSha1 =
      this._options.computeSha1 && !fileMetadata[_constants.default.SHA1]; // Callback called when the response from the worker is successful.

    const workerReply = metadata => {
      // `1` for truthy values instead of `true` to save cache space.
      fileMetadata[_constants.default.VISITED] = 1;
      const metadataId = metadata.id;
      const metadataModule = metadata.module;

      if (metadataId && metadataModule) {
        fileMetadata[_constants.default.ID] = metadataId;
        setModule(metadataId, metadataModule);
      }

      fileMetadata[_constants.default.DEPENDENCIES] = metadata.dependencies
        ? metadata.dependencies.join(_constants.default.DEPENDENCY_DELIM)
        : '';

      if (computeSha1) {
        fileMetadata[_constants.default.SHA1] = metadata.sha1;
      }
    }; // Callback called when the response from the worker is an error.

    const workerError = error => {
      if (typeof error !== 'object' || !error.message || !error.stack) {
        error = new Error(error);
        error.stack = ''; // Remove stack for stack-less errors.
      }

      if (!['ENOENT', 'EACCES'].includes(error.code)) {
        throw error;
      } // If a file cannot be read we remove it from the file list and
      // ignore the failure silently.

      hasteMap.files.delete(relativeFilePath);
    }; // If we retain all files in the virtual HasteFS representation, we avoid
    // reading them if they aren't important (node_modules).

    if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {
      if (computeSha1) {
        return this._getWorker(workerOptions)
          .getSha1({
            computeDependencies: this._options.computeDependencies,
            computeSha1,
            dependencyExtractor: this._options.dependencyExtractor,
            filePath,
            hasteImplModulePath: this._options.hasteImplModulePath,
            rootDir
          })
          .then(workerReply, workerError);
      }

      return null;
    }

    if (
      this._options.mocksPattern &&
      this._options.mocksPattern.test(filePath)
    ) {
      const mockPath = (0, _getMockName.default)(filePath);
      const existingMockPath = mocks.get(mockPath);

      if (existingMockPath) {
        const secondMockPath = fastPath.relative(rootDir, filePath);

        if (existingMockPath !== secondMockPath) {
          const method = this._options.throwOnModuleCollision
            ? 'error'
            : 'warn';

          this._console[method](
            [
              `jest-haste-map: duplicate manual mock found: ${mockPath}`,
              '  The following files share their name; please delete one of them:',
              `    * <rootDir>${path().sep}${existingMockPath}`,
              `    * <rootDir>${path().sep}${secondMockPath}`,
              ''
            ].join('\n')
          );

          if (this._options.throwOnModuleCollision) {
            throw new DuplicateError(existingMockPath, secondMockPath);
          }
        }
      }

      mocks.set(mockPath, relativeFilePath);
    }

    if (fileMetadata[_constants.default.VISITED]) {
      if (!fileMetadata[_constants.default.ID]) {
        return null;
      }

      if (moduleMetadata != null) {
        const platform =
          (0, _getPlatformExtension.default)(
            filePath,
            this._options.platforms
          ) || _constants.default.GENERIC_PLATFORM;

        const module = moduleMetadata[platform];

        if (module == null) {
          return null;
        }

        const moduleId = fileMetadata[_constants.default.ID];
        let modulesByPlatform = map.get(moduleId);

        if (!modulesByPlatform) {
          modulesByPlatform = Object.create(null);
          map.set(moduleId, modulesByPlatform);
        }

        modulesByPlatform[platform] = module;
        return null;
      }
    }

    return this._getWorker(workerOptions)
      .worker({
        computeDependencies: this._options.computeDependencies,
        computeSha1,
        dependencyExtractor: this._options.dependencyExtractor,
        filePath,
        hasteImplModulePath: this._options.hasteImplModulePath,
        rootDir
      })
      .then(workerReply, workerError);
  }

  _buildHasteMap(data) {
    const {removedFiles, changedFiles, hasteMap} = data; // If any files were removed or we did not track what files changed, process
    // every file looking for changes. Otherwise, process only changed files.

    let map;
    let mocks;
    let filesToProcess;

    if (changedFiles === undefined || removedFiles.size) {
      map = new Map();
      mocks = new Map();
      filesToProcess = hasteMap.files;
    } else {
      map = hasteMap.map;
      mocks = hasteMap.mocks;
      filesToProcess = changedFiles;
    }

    for (const [relativeFilePath, fileMetadata] of removedFiles) {
      this._recoverDuplicates(
        hasteMap,
        relativeFilePath,
        fileMetadata[_constants.default.ID]
      );
    }

    const promises = [];

    for (const relativeFilePath of filesToProcess.keys()) {
      if (
        this._options.skipPackageJson &&
        relativeFilePath.endsWith(PACKAGE_JSON)
      ) {
        continue;
      } // SHA-1, if requested, should already be present thanks to the crawler.

      const filePath = fastPath.resolve(
        this._options.rootDir,
        relativeFilePath
      );

      const promise = this._processFile(hasteMap, map, mocks, filePath);

      if (promise) {
        promises.push(promise);
      }
    }

    return Promise.all(promises).then(
      () => {
        this._cleanup();

        hasteMap.map = map;
        hasteMap.mocks = mocks;
        return hasteMap;
      },
      error => {
        this._cleanup();

        throw error;
      }
    );
  }

  _cleanup() {
    const worker = this._worker;

    if (worker && 'end' in worker) {
      worker.end();
    }

    this._worker = null;
  }
  /**
   * 4. serialize the new `HasteMap` in a cache file.
   */

  _persist(hasteMap) {
    (0, _gracefulFs().writeFileSync)(
      this._cachePath,
      (0, _v().serialize)(hasteMap)
    );
  }
  /**
   * Creates workers or parses files and extracts metadata in-process.
   */

  _getWorker(
    options = {
      forceInBand: false
    }
  ) {
    if (!this._worker) {
      if (options.forceInBand || this._options.maxWorkers <= 1) {
        this._worker = {
          getSha1: _worker.getSha1,
          worker: _worker.worker
        };
      } else {
        this._worker = new (_jestWorker().Worker)(require.resolve('./worker'), {
          exposedMethods: ['getSha1', 'worker'],
          // @ts-expect-error: option does not exist on the node 12 types
          forkOptions: {
            serialization: 'json'
          },
          maxRetries: 3,
          numWorkers: this._options.maxWorkers
        });
      }
    }

    return this._worker;
  }

  async _crawl(hasteMap) {
    const options = this._options;

    const ignore = this._ignore.bind(this);

    const crawl = (await this._shouldUseWatchman())
      ? _watchman.watchmanCrawl
      : _node.nodeCrawl;
    const crawlerOptions = {
      computeSha1: options.computeSha1,
      data: hasteMap,
      enableSymlinks: options.enableSymlinks,
      extensions: options.extensions,
      forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
      ignore,
      rootDir: options.rootDir,
      roots: options.roots
    };

    const retry = error => {
      if (crawl === _watchman.watchmanCrawl) {
        this._console.warn(
          'jest-haste-map: Watchman crawl failed. Retrying once with node ' +
            'crawler.\n' +
            "  Usually this happens when watchman isn't running. Create an " +
            "empty `.watchmanconfig` file in your project's root folder or " +
            'initialize a git or hg repository in your project.\n' +
            `  ${error}`
        );

        return (0, _node.nodeCrawl)(crawlerOptions).catch(e => {
          throw new Error(
            'Crawler retry failed:\n' +
              `  Original error: ${error.message}\n` +
              `  Retry error: ${e.message}\n`
          );
        });
      }

      throw error;
    };

    try {
      return crawl(crawlerOptions).catch(retry);
    } catch (error) {
      return retry(error);
    }
  }
  /**
   * Watch mode
   */

  async _watch(hasteMap) {
    if (!this._options.watch) {
      return Promise.resolve();
    } // In watch mode, we'll only warn about module collisions and we'll retain
    // all files, even changes to node_modules.

    this._options.throwOnModuleCollision = false;
    this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher

    const Watcher = (await this._shouldUseWatchman())
      ? _WatchmanWatcher.default
      : _FSEventsWatcher.FSEventsWatcher.isSupported()
      ? _FSEventsWatcher.FSEventsWatcher
      : _NodeWatcher.default;
    const exten