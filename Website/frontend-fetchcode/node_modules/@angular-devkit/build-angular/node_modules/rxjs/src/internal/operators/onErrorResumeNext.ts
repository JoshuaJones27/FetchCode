                   }
                    if (ts.isFunctionLike(current)) {
                        return true;
                    }
                    if (ts.isClassStaticBlockDeclaration(current)) {
                        return declaration.pos < usage.pos;
                    }
                    var propertyDeclaration = ts.tryCast(current.parent, ts.isPropertyDeclaration);
                    if (propertyDeclaration) {
                        var initializerOfProperty = propertyDeclaration.initializer === current;
                        if (initializerOfProperty) {
                            if (ts.isStatic(current.parent)) {
                                if (declaration.kind === 168 /* MethodDeclaration */) {
                                    return true;
                                }
                                if (ts.isPropertyDeclaration(declaration) && ts.getContainingClass(usage) === ts.getContainingClass(declaration)) {
                                    var propName = declaration.name;
                                    if (ts.isIdentifier(propName) || ts.isPrivateIdentifier(propName)) {
                                        var type = getTypeOfSymbol(getSymbolOfNode(declaration));
                                        var staticBlocks = ts.filter(declaration.parent.members, ts.isClassStaticBlockDeclaration);
                                        if (isPropertyInitializedInStaticBlocks(propName, type, staticBlocks, declaration.parent.pos, current.pos)) {
                                            return true;
                                        }
                                    }
                                }
                            }
                            else {
                                var isDeclarationInstanceProperty = declaration.kind === 166 /* PropertyDeclaration */ && !ts.isStatic(declaration);
                                if (!isDeclarationInstanceProperty || ts.getContainingClass(usage) !== ts.getContainingClass(declaration)) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                });
            }
            /** stopAtAnyPropertyDeclaration is used for detecting ES-standard class field use-before-def errors */
            function isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, stopAtAnyPropertyDeclaration) {
                // always legal if usage is after declaration
                if (usage.end > declaration.end) {
                    return false;
                }
                // still might be legal if usage is deferred (e.g. x: any = () => this.x)
                // otherwise illegal if immediately referenced within the declaration (e.g. x: any = this.x)
                var ancestorChangingReferenceScope = ts.findAncestor(usage, function (node) {
                    if (node === declaration) {
                        return "quit";
                    }
                    switch (node.kind) {
                        case 213 /* ArrowFunction */:
                            return true;
                        case 166 /* PropertyDeclaration */:
                            // even when stopping at any property declaration, they need to come from the same class
                            return stopAtAnyPropertyDeclaration &&
                                (ts.isPropertyDeclaration(declaration) && node.parent === declaration.parent
                                    || ts.isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)
                                ? "quit" : true;
                        case 234 /* Block */:
                            switch (node.parent.kind) {
                                case 171 /* GetAccessor */:
                                case 168 /* MethodDeclaration */:
                                case 172 /* SetAccessor */:
                                    return true;
                                default:
                                    return false;
                            }
                        default:
                            return false;
                    }
                });
                return ancestorChangingReferenceScope === undefined;
            }
        }
        function useOuterVariableScopeInParameter(result, location, lastLocation) {
            var target = ts.getEmitScriptTarget(compilerOptions);
            var functionLocation = location;
            if (ts.isParameter(lastLocation)
                && functionLocation.body
                && result.valueDeclaration
                && result.valueDeclaration.pos >= functionLocation.body.pos
                && result.valueDeclaration.end <= functionLocation.body.end) {
                // check for several cases where we introduce temporaries that require moving the name/initializer of the parameter to the body
                // - static field in a class expression
                // - optional chaining pre-es2020
                // - nullish coalesce pre-es2020
                // - spread assignment in binding pattern pre-es2017
                if (target >= 2 /* ES2015 */) {
                    var links = getNodeLinks(functionLocation);
                    if (links.declarationRequiresScopeChange === undefined) {
                        links.declarationRequiresScopeChange = ts.forEach(functionLocation.parameters, requiresScopeChange) || false;
                    }
                    return !links.declarationRequiresScopeChange;
                }
            }
            return false;
            function requiresScopeChange(node) {
                return requiresScopeChangeWorker(node.name)
                    || !!node.initializer && requiresScopeChangeWorker(node.initializer);
            }
            function requiresScopeChangeWorker(node) {
                switch (node.kind) {
                    case 213 /* ArrowFunction */:
                    case 212 /* FunctionExpression */:
                    case 255 /* FunctionDeclaration */:
                    case 170 /* Constructor */:
                        // do not descend into these
                        return false;
                    case 168 /* MethodDeclaration */:
                    case 171 /* GetAccessor */:
                    case 172 /* SetAccessor */:
                    case 294 /* PropertyAssignment */:
                        return requiresScopeChangeWorker(node.name);
                    case 166 /* PropertyDeclaration */:
                        // static properties in classes introduce temporary variables
                        if (ts.hasStaticModifier(node)) {
                            return target < 99 /* ESNext */ || !useDefineForClassFields;
                        }
                        return requiresScopeChangeWorker(node.name);
                    default:
                        // null coalesce and optional chain pre-es2020 produce temporary variables
                        if (ts.isNullishCoalesce(node) || ts.isOptionalChain(node)) {
                            return target < 7 /* ES2020 */;
                        }
                        if (ts.isBindingElement(node) && node.dotDotDotToken && ts.isObjectBindingPattern(node.parent)) {
                            return target < 4 /* ES2017 */;
                        }
                        if (ts.isTypeNode(node))
                            return false;
                        return ts.forEachChild(node, requiresScopeChangeWorker) || false;
                }
            }
        }
        /**
         * Resolve a given name for a given meaning at a given location. An error is reported if the name was not found and
         * the nameNotFoundMessage argument is not undefined. Returns the resolved symbol, or undefined if no symbol with
         * the given name can be found.
         *
         * @param isUse If true, this will count towards --noUnusedLocals / --noUnusedParameters.
         */
        function resolveName(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSpellingSuggstions) {
            if (excludeGlobals === void 0) { excludeGlobals = false; }
        