function isESMFormatImportImportingCommonjsFormatFile(usageMode, targetMode) {
            return usageMode === ts.ModuleKind.ESNext && targetMode === ts.ModuleKind.CommonJS;
        }
        function isOnlyImportedAsDefault(usage) {
            var usageMode = getUsageModeForExpression(usage);
            return usageMode === ts.ModuleKind.ESNext && ts.endsWith(usage.text, ".json" /* Json */);
        }
        function canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, usage) {
            var usageMode = file && getUsageModeForExpression(usage);
            if (file && usageMode !== undefined) {
                var result = isESMFormatImportImportingCommonjsFormatFile(usageMode, file.impliedNodeFormat);
                if (usageMode === ts.ModuleKind.ESNext || result) {
                    return result;
                }
                // fallthrough on cjs usages so we imply defaults for interop'd imports, too
            }
            if (!allowSyntheticDefaultImports) {
                return false;
            }
            // Declaration files (and ambient modules)
            if (!file || file.isDeclarationFile) {
                // Definitely cannot have a synthetic default if they have a syntactic default member specified
                var defaultExportSymbol = resolveExportByName(moduleSymbol, "default" /* Default */, /*sourceNode*/ undefined, /*dontResolveAlias*/ true); // Dont resolve alias because we want the immediately exported symbol's declaration
                if (defaultExportSymbol && ts.some(defaultExportSymbol.declarations, isSyntacticDefault)) {
                    return false;
                }
                // It _might_ still be incorrect to assume there is no __esModule marker on the import at runtime, even if there is no `default` member
                // So we check a bit more,
                if (resolveExportByName(moduleSymbol, ts.escapeLeadingUnderscores("__esModule"), /*sourceNode*/ undefined, dontResolveAlias)) {
                    // If there is an `__esModule` specified in the declaration (meaning someone explicitly added it or wrote it in their code),
                    // it definitely is a module and does not have a synthetic default
                    return false;
                }
                // There are _many_ declaration files not written with esmodules in mind that still get compiled into a format with __esModule set
                // Meaning there may be no default at runtime - however to be on the permissive side, we allow access to a synthetic default member
                // as there is no marker to indicate if the accompanying JS has `__esModule` or not, or is even native esm
                return true;
            }
            // TypeScript files never have a synthetic default (as they are always emitted with an __esModule marker) _unless_ they contain an export= statement
            if (!ts.isSourceFileJS(file)) {
                return hasExportAssignmentSymbol(moduleSymbol);
            }
            // JS files have a synthetic default if they do not contain ES