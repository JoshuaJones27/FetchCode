/ undefined));
                            addPropertyToElementList(properties[properties.length - 1], context, typeElements);
                            break;
                        }
                        addPropertyToElementList(propertySymbol, context, typeElements);
                    }
                    return typeElements.length ? typeElements : undefined;
                }
            }
            function createElidedInformationPlaceholder(context) {
                context.approximateLength += 3;
                if (!(context.flags & 1 /* NoTruncation */)) {
                    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("..."), /*typeArguments*/ undefined);
                }
                return ts.factory.createKeywordTypeNode(130 /* AnyKeyword */);
            }
            function shouldUsePlaceholderForProperty(propertySymbol, context) {
                var _a;
                // Use placeholders for reverse mapped types we've either already descended into, or which
                // are nested reverse mappings within a mapping over a non-anonymous type. The later is a restriction mostly just to
                // reduce the blowup in printback size from doing, eg, a deep reverse mapping over `Window`.
                // Since anonymous types usually come from expressions, this allows us to preserve the output
                // for deep mappings which likely come from expressions, while truncating those parts which
                // come from mappings over library functions.
                return !!(ts.getCheckFlags(propertySymbol) & 8192 /* ReverseMapped */)
                    && (ts.contains(context.reverseMappedStack, propertySymbol)
                        || (((_a = context.reverseMappedStack) === null || _a === void 0 ? void 0 : _a[0])
                            && !(ts.getObjectFlags(ts.last(context.reverseMappedStack).propertyType) & 16 /* Anonymous */)));
            }
            function addPropertyToElementList(propertySymbol, context, typeElements) {
                var _a, _b;
                var propertyIsReverseMapped = !!(ts.getCheckFlags(propertySymbol) & 8192 /* ReverseMapped */);
                var propertyType = shouldUsePlaceholderForProperty(propertySymbol, context) ?
                    anyType : getNonMissingTypeOfSymbol(propertySymbol);
                var saveEnclosingDeclaration = context.enclosingDeclaration;
                context.enclosingDeclaration = undefined;
                if (context.tracker.trackSymbol && ts.getCheckFlags(propertySymbol) & 4096 /* Late */ && isLateBoundName(propertySymbol.escapedName)) {
                    if (propertySymbol.declarations) {
                        var decl = ts.first(propertySymbol.declarations);
                        if (hasLateBindableName(decl)) {
                            if (ts.isBinaryExpression(decl)) {
                                var name = ts.getNameOfDeclaration(decl);
                                if (name && ts.isElementAccessExpression(name) && ts.isPropertyAccessEntityNameExpression(name.argumentExpression)) {
                                    trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context);
                                }
                            }
                            else {
                                trackComputedName(decl.name.expression, saveEnclosingDeclaration, context);
                            }
                        }
                    }
                    else if ((_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportNonSerializableProperty) {
                        context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol));
                    }
                }
                context.enclosingDeclaration = propertySymbol.valueDeclaration || ((_b = propertySymbol.declarations) === null || _b === void 0 ? void 0 : _b[0]) || saveEnclosingDeclaration;
                var propertyName = getPropertyNameNodeForSymbol(propertySymbol, context);
                context.enclosingDeclaration = saveEnclosingDeclaration;
                context.approximateLength += (ts.symbolName(propertySymbol).length + 1);
                var optionalToken = propertySymbol.flags & 16777216 /* Optional */ ? ts.factory.createToken(57 /* QuestionToken */) : undefined;
                if (propertySymbol.flags & (16 /* Function */ | 8192 /* Method */) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol)) {
                    var signatures = getSignaturesOfType(filterType(propertyType, function (t) { return !(t.flags & 32768 /* Undefined */); }), 0 /* Call */);
                    for (var _i = 0, signatures_1 = signatures; _i < signatures_1.length; _i++) {
                        var signature = signatures_1[_i];
                        var methodDeclaration = signatureToSignatureDeclarationHelper(signature, 167 /* MethodSignature */, context, { name: propertyName, questionToken: optionalToken });
                        typeElements.push(preserveCommentsOn(methodDeclaration));
                    }
                }
                else {
                    var propertyTypeNode = void 0;
                    if (shouldUsePlaceholderForProperty(propertySymbol, context)) {
                        propertyTypeNode = createElidedInformationPlaceholder(context);
                    }
                    else {
                        if (propertyIsReverseMapped) {
                            context.reverseMappedStack || (context.reverseMappedStack = []);
                            context.reverseMappedStack.push(propertySymbol);
                        }
                        propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, propertyType, propertySymbol, saveEnclosingDeclaration) : ts.factory.createKeywordTypeNode(130 /* AnyKeyword */);
                        if (propertyIsReverseMapped) {
                            context.reverseMappedStack.pop();
                        }
                    }
                    var modifiers = isReadonlySymbol(propertySymbol) ? [ts.factory.createToken(144 /* ReadonlyKeyword */)] : undefined;
                    if (modifiers) {
          