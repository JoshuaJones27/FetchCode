 ts.factory.createTypeReferenceNode("... ".concat(types.length - 2, " more ..."), /*typeArguments*/ undefined),
                                typeToTypeNodeHelper(types[types.length - 1], context)
                            ];
                        }
                    }
                    var mayHaveNameCollisions = !(context.flags & 64 /* UseFullyQualifiedType */);
                    /** Map from type reference identifier text to [type, index in `result` where the type node is] */
                    var seenNames = mayHaveNameCollisions ? ts.createUnderscoreEscapedMultiMap() : undefined;
                    var result_5 = [];
                    var i = 0;
                    for (var _i = 0, types_2 = types; _i < types_2.length; _i++) {
                        var type = types_2[_i];
                        i++;
                        if (checkTruncationLength(context) && (i + 2 < types.length - 1)) {
                            result_5.push(ts.factory.createTypeReferenceNode("... ".concat(types.length - i, " more ..."), /*typeArguments*/ undefined));
                            var typeNode_1 = typeToTypeNodeHelper(types[types.length - 1], context);
                            if (typeNode_1) {
                                result_5.push(typeNode_1);
                            }
                            break;
                        }
                        context.approximateLength += 2; // Account for whitespace + separator
                        var typeNode = typeToTypeNodeHelper(type, context);
                        if (typeNode) {
                            result_5.push(typeNode);
                            if (seenNames && ts.isIdentifierTypeRef