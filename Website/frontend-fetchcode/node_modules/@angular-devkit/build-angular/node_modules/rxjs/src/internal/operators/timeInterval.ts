de = typeToTypeNodeHelper(typeArguments[0], context);
                            return ts.factory.createTypeReferenceNode(type.target === globalArrayType ? "Array" : "ReadonlyArray", [typeArgumentNode]);
                        }
                        var elementType = typeToTypeNodeHelper(typeArguments[0], context);
                        var arrayType = ts.factory.createArrayTypeNode(elementType);
                        return type.target === globalArrayType ? arrayType : ts.factory.createTypeOperatorNode(144 /* ReadonlyKeyword */, arrayType);
                    }
                    else if (type.target.objectFlags & 8 /* Tuple */) {
                        typeArguments = ts.sameMap(typeArguments, function (t, i) { return removeMissingType(t, !!(type.target.elementFlags[i] & 2 /* Optional */)); });
                        if (typeArguments.length > 0) {
                            var arity = getTypeReferenceArity(type);
                            var tupleConstituentNodes = mapToTypeNodes(typeArguments.slice(0, arity), context);
                            if (tupleConstituentNodes) {
                                if (type.target.labeledElementDeclarations) {
                                    for (var i = 0; i < tupleConstituentNodes.length; i++) {
                                        var flags = type.target.elementFlags[i];
                                        tupleConstituentNodes[i] = ts.factory.createNamedTupleMember(flags & 12 /* Variable */ ? ts.factory.createToken(25 /* DotDotDotToken */) : undefined, ts.factory.createIdentifier(ts.unescapeLeadingUnderscores(getTupleElementLabel(type.target.labeledElementDeclarations[i]))), flags & 2 /* Optional */ ? ts.factory.createToken(57 /* QuestionToken */) : undefined, flags & 4 /* Rest */ ? ts.factory.createArrayTypeNode(tupleConstituentNodes[i]) :
                                            tupleConstituentNodes[i]);
                                    }
                                }
                                else {
                                    for (var i = 0; i < Math.min(arity, tupleConstituentNodes.length); i++) {
                                        var flags = type.target.elementFlags[i];
                                        tupleConstituentNodes[i] =
                                            flags & 12 /* Variable */ ? ts.factory.createRestTypeNode(flags & 4 /* Rest */ ? ts.factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :
                                                f