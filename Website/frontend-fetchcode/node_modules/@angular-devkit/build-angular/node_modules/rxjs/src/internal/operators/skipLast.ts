iesOfExternalModuleAsExports(type)) {
                    ts.addRange(exports, getPropertiesOfType(type));
                }
            }
            return exports;
        }
        function forEachExportAndPropertyOfModule(moduleSymbol, cb) {
            var exports = getExportsOfModule(moduleSymbol);
            exports.forEach(function (symbol, key) {
                if (!isReservedMemberName(key)) {
                    cb(symbol, key);
                }
            });
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals !== moduleSymbol) {
                var type = getTypeOfSymbol(exportEquals);
                if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                    forEachPropertyOfType(type, function (symbol, escapedName) {
                        cb(symbol, escapedName);
                    });
                }
            }
        }
        function tryGetMemberInModuleExports(memberName, moduleSymbol) {
            var symbolTable = getExportsOfModule(moduleSymbol);
            if (symbolTable) {
                return symbolTable.get(memberName);
            }
        }
        function tryGetMemberInModuleExportsAndProperties(memberName, moduleSymbol) {
            var symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
            if (symbol) {
                return symbol;
            }
            var exportEquals = resolveExternalModuleSymbol(moduleSymbol);
            if (exportEquals === moduleSymbol) {
                return undefined;
            }
            var type = getTypeOfSymbol(exportEquals);
            return shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined;
        }
        function shouldTreatPropertiesOfExternalModuleAsExports(resolvedExternalModuleType) {
            return !(resolvedExternalModuleType.flags & 131068 /* Primitive */ ||
                ts.getObjectFlags(resolvedExternalModuleType) & 1 /* Class */ ||
                // `isArrayOrTupleLikeType` is too expensive to use in this auto-imports hot path
                isArrayType(resolvedExternalModuleType) ||
                isTupleType(resolvedExternalModuleType));
        }
        function getExportsOfSymbol(symbol) {
            return symbol.flags & 6256 /* LateBindingContainer */ ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedExports" /* resolvedExports */) :
                symbol.flags & 1536 /* Module */ ? getExportsOfModule(symbol) :
                    symbol.exports || emptySymbols;
        }
        function getExportsOfModule(moduleSymbol) {
            var links = getSymbolLinks(moduleSymbol);
            return links.resolvedExports || (links.resolvedExports = getExportsOfModuleWorker(moduleSymbol));
        }
        /**
         * Extends one symbol table with anoth