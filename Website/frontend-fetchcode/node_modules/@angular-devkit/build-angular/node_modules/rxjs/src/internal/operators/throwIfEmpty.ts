pe.containsError) {
                        return createMappedTypeNodeFromType(type);
                    }
                    var resolved = resolveStructuredTypeMembers(type);
                    if (!resolved.properties.length && !resolved.indexInfos.length) {
                        if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                            context.approximateLength += 2;
                            return ts.setEmitFlags(ts.factory.createTypeLiteralNode(/*members*/ undefined), 1 /* SingleLine */);
                        }
                        if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                            var signature = resolved.callSignatures[0];
                            var signatureNode = signatureToSignatureDeclarationHelper(signature, 178 /* FunctionType */, context);
                            return signatureNode;
                        }
                        if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                            var signature = resolved.constructSignatures[0];
                            var signatureNode = signatureToSignatureDeclarationHelper(signature, 179 /* ConstructorType */, context);
                            return signatureNode;
                        }
                    }
                    var abstractSignatures = ts.filter(resolved.constructSignatures, function (signature) { return !!(signature.flags & 4 /* Abstract */); });
                    if (ts.some(abstractSignatures)) {
                        var types = ts.map(abstractSignatures, getOrCreateTypeFromSignature);
                        // count the number of type elements excluding abstract constructors
                        var typeElementCount = resolved.callSignatures.length +
                            (resolved.constructSignatures.length - abstractSignatures.length) +
                            resolved.indexInfos.length +
                            // exclude `prototype` when writing a class expression as a type literal, as per
                            // the logic in `createTypeNodesFromResolvedType`.
                            (conte