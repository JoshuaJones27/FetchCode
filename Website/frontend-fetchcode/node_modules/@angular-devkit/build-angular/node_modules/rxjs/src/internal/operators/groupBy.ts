fSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, getFirstIdentifier, getTypeArguments) {
        return getSymbolWalker;
        function getSymbolWalker(accept) {
            if (accept === void 0) { accept = function () { return true; }; }
            var visitedTypes = []; // Sparse array from id to type
            var visitedSymbols = []; // Sparse array from id to symbol
            return {
                walkType: function (type) {
                    try {
                        visitType(type);
                        return { visitedTypes: ts.getOwnValues(visitedTypes), visitedSymbols: ts.getOwnValues(visitedSymbols) };
                    }
                    finally {
                        ts.clear(visitedTypes);
                        ts.clear(visitedSymbols);
                    }
                },
                walkSymbol: function (symbol) {
                    try {
                        visitSymbol(symbol);
                        return { visitedTypes: ts.getOwnValues(visitedTypes), visitedSymbols: ts.getOwnValues(visitedSymbols) };
                    }
                    finally {
                        ts.clear(visitedTypes);
                        ts.clear(visitedSymbols);
                    }
                },
            };
            function visitType(type) {
                if (!type) {
                    return;
                }
                if (visitedTypes[type.id]) {
                    return;
                }
                visitedTypes[type.id] = type;
                // Reuse visitSymbol to visit the type's symbol,
                //  but be sure to bail on recuring into the type if accept declines the symbol.
                var shouldBail = visitSymbol(type.symbol);
                if (shouldBail)
                    return;
                // Visit the type's related types, if any
                if (type.flags & 524288 /* Object */) {
                    var objectType = type;
                    var objectFlags = objectType.objectFlags;
                    if (objectFlags & 4 /* Reference */) {
                        visitTypeReference(type);
                    }
                    if (objectFlags & 32 /* Mapped */) {
                        visitMappedType(type);
                    }
                    if (objectFlags & (1 /* Class */ | 2 /* Interface */)) {
                        visitInterfaceType(type);
                    }
                    if (objectFlags & (8 /* Tuple */ | 16 /* Anonymous */)) {
                        visitObjectType(objectType);
                    }
                }
                if (type.flags & 262144 /* TypeParameter */) {
                    visitTypeParameter(type);
                }
                if (type.flags & 3145728 /* UnionOrIntersection */) {
                    visitUnionOrIntersectionType(type);
                }
                if (type.flags & 4194304 /* Index */) {
                    visitIndexType(type);
                }
                if (type.flags & 8388608 /* IndexedAccess */) {
                    visitIndexedAccessType(type);
                }
            }
            function visitTypeReference(type) {
                visitType(type.target);
                ts.forEach(getTypeArguments(type), visitType);
            }
            function visitTypeParameter(type) {
                visitType(getConstraintOfTypeParameter(type));
            }
            function visitUnionOrIntersectionType(type) {
                ts.forEach(type.types, visitType);
            }
            function visitIndexType(type) {
                visitType(type.type);
            }
            function visitIndexedAccessType(type) {
                visitType(type.objectType);
                visitType(type.indexType);
                visitType(type.constraint);
            }
            function visitMappedType(type) {
                visitType(type.typeParameter);
                visitType(type.constraintType);
                visitType(type.templateType);
                visitType(type.modifiersType);
            }
            function visitSignature(signature) {
                var typePredicate = getTypePredicateOfSignature(signature);
                if (typePredicate) {
                    visitType(typePredicate.type);
                }
                ts.forEach(signature.typeParameters, visitType);
                for (var _i = 0, _a = signature.parameters; _i < _a.length; _i++) {
                    var parameter = _a[_i];
                    visitSymbol(parameter);
                }
                visitType(getRestTypeOfSignature(signature));
                visitType(getReturnTypeOfSignature(signature));
            }
            function visitInterfaceType(interfaceT) {
                visitObjectType(interfaceT);
                ts.forEach(interfaceT.typeParameters, visitType);
                ts.forEach(getBaseTypes(interfaceT), visitType);
                visitType(interfaceT.thisType);
            }
            function visitObjectType(type) {
                var resolved = resolveStructuredTypeMembers(type);
                for (var _i = 0, _a = resolved.indexInfos; _i < _a.length; _i++) {
                    var info = _a[_i];
                    visitType(info.keyType);
                    visitType(info.type);
                }
                for (var _b = 0, _c = resolved.callSignatures; _b < _c.length; _b++) {
                    var signature = _c[_b];
                    visitSignature(signature);
                }
                for (var _d = 0, _e = resolved.constructSignatures; _d < _e.length; _d++) {
                    var signature = _e[_d];
                    visitSignature(signature);
                }
                for (var _f = 0, _g = resolved.properties; _f < _g.length; _f++) {
                    var p = _g[_f];
                    visitSymbol(p);
                }
            }
            function visitSymbol(symbol) {
                if (!symbol) {
                    return false;
                }
                var symbolId = ts.getSymbolId(symbol);
                if (visitedSymbols[symbolId]) {
                    return false;
                }
                visitedSymbols[symbolId] = symbol;
                if (!accept(symbol)) {
                    return true;
                }
                var t = getTypeOfSymbol(symbol);
                visitType(t); // Should handle members on classes and such
                if (symbol.exports) {
                    symbol.exports.forEach(visitSymbol);
                }
                ts.forEach(symbol.declarations, function (d) {
                    // Type queries are too far resolved when we just visit the symbol's type
                    //  (their type resolved directly to the member deeply referenced)
                    // So to get the intervening symbols, we need to check if there's a type
                    // query node on any of the symbol's declarations and get symbols there
                    if (d.type && d.type.kind === 180 /* TypeQuery */) {
                        var query = d.type;
                        var entity = getResolvedSymbol(getFirstIdentifier(query.exprName));
                        visitSymbol(entity);
                    }
                });
                return false;
            }
        }
    }
    ts.createGetSymbolWalker = createGetSymbolWalker;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var ambientModuleSymbolRegex = /^".+"$/;
    var anon = "(anonymous)";
    var nextSymbolId = 1;
    var nextNodeId = 1;
    var nextMergeId = 1;
    var nextFlowId = 1;
    var IterationUse;
    (function (IterationUse) {
        IterationUse[IterationUse["AllowsSyncIterablesFlag"] = 1] = "AllowsSyncIterablesFlag";
        IterationUse[IterationUse["AllowsAsyncIterablesFlag"] = 2] = "AllowsAsyncIterablesFlag";
        IterationUse[IterationUse["AllowsStringInputFlag"] = 4] = "AllowsStringInputFlag";
        IterationUse[IterationUse["ForOfFlag"] = 8] = "ForOfFlag";
        IterationUse[IterationUse["YieldStarFlag"] = 16] = "YieldStarFlag";
        IterationUse[IterationUse["SpreadFlag"] = 32] = "SpreadFlag";
        IterationUse[IterationUse["DestructuringFlag"] = 64] = "DestructuringFlag";
        IterationUse[IterationUse["PossiblyOutOfBounds"] = 128] = "PossiblyOutOfBounds";
        // Spread, Destructuring, Array element assignment
        IterationUse[IterationUse["Element"] = 1] = "Element";
        IterationUse[IterationUse["Spread"] = 33] = "Spread";
        IterationUse[IterationUse["Destructuring"] = 65] = "Destructuring";
        IterationUse[IterationUse["ForOf"] = 13] = "ForOf";
        IterationUse[IterationUse["ForAwaitOf"] = 15] = "ForAwaitOf";
        IterationUse[IterationUse["YieldStar"] = 17] = "YieldStar";
        IterationUse[IterationUse["AsyncYieldStar"] = 19] = "AsyncYieldStar";
        IterationUse[IterationUse["GeneratorReturnType"] = 1] = "GeneratorReturnType";
        IterationUse[IterationUse["AsyncGeneratorReturnType"] = 2] = "AsyncGeneratorReturnType";
    })(IterationUse || (IterationUse = {}));
    var IterationTypeKind;
    (function (IterationTypeKind) {
        IterationTypeKind[IterationTypeKind["Yield"] = 0] = "Yield";
        IterationTypeKind[IterationTypeKind["Return"] = 1] = "Return";
        IterationTypeKind[IterationTypeKind["Next"] = 2] = "Next";
    })(IterationTypeKind || (IterationTypeKind = {}));
    var WideningKind;
    (function (WideningKind) {
        WideningKind[WideningKind["Normal"] = 0] = "Normal";
        WideningKind[WideningKind["FunctionReturn"] = 1] = "FunctionReturn";
        WideningKind[WideningKind["GeneratorNext"] = 2] = "GeneratorNext";
        WideningKind[WideningKind["GeneratorYield"] = 3] = "GeneratorYield";
    })(WideningKind || (WideningKind = {}));
    var TypeFacts;
    (function (TypeFacts) {
        TypeFacts[TypeFacts["None"] = 0] = "None";
        TypeFacts[TypeFacts["TypeofEQString"] = 1] = "TypeofEQString";
        TypeFacts[TypeFacts["TypeofEQNumber"] = 2