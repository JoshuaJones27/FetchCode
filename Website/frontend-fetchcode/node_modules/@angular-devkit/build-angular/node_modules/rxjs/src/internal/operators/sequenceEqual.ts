d === 160 /* QualifiedName */ ? name.right : name.name;
                var namespace = resolveEntityName(left, namespaceMeaning, ignoreErrors, /*dontResolveAlias*/ false, location);
                if (!namespace || ts.nodeIsMissing(right)) {
                    return undefined;
                }
                else if (namespace === unknownSymbol) {
                    return namespace;
                }
                if (namespace.valueDeclaration &&
                    ts.isInJSFile(namespace.valueDeclaration) &&
                    ts.isVariableDeclaration(namespace.valueDeclaration) &&
                    namespace.valueDeclaration.initializer &&
                    isCommonJsRequire(namespace.valueDeclaration.initializer)) {
                    var moduleName = namespace.valueDeclaration.initializer.arguments[0];
                    var moduleSym = resolveExternalModuleName(moduleName, moduleName);
                    if (moduleSym) {
                        var resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                        if (resolvedModuleSymbol) {
                            namespace = resolvedModuleSymbol;
                        }
                    }
                }
                symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning));
                if (!symbol) {
                    if (!ignoreErrors) {
                        var namespaceName = getFullyQualifiedName(namespace);
                        var declarationName = ts.declarationNameToString(right);
                        var suggestionForNonexistentModule = getSuggestedSymbolForNonexistentModule(right, namespace);
                        if (suggestionForNonexistentModule) {
                            error(right, ts.Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule));
                            return undefined;
                        }
                        var containingQualifiedName = ts.isQualifiedName(name) && getContainingQualifiedNameNode(name);
                        var canSuggestTypeof = globalObjectType // <-- can't pull on types if global types aren't initialized yet
                            && (meaning & 788968 /* Type */)
                            && containingQualifiedName
                            && !ts.isTypeOfExpression(containingQualifiedName.parent)
                            && tryGetQualifiedNameAsValue(containingQualifiedName);
                        if (canSuggestTypeof) {
                            error(containingQualifiedName, ts.Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, ts.entityNameToString(containingQualifiedName));
                            return undefined;
                        }
                        if (meaning & 1920 /* Namespace */ && ts.isQualifiedName(name.parent)) {
                            var exportedTypeSymbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, 788968 /* Type */));
                            if (exportedTypeSymbol) {
                                error(name.parent.right, ts.Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), ts.unescapeLeadingUnderscores(name.parent.right.escapedText));
                                return undefined;
                            }
                        }
                        error(right, ts.Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName);
                    }
                    return undefined;
                }
            }
            else {
                throw ts.Debug.assertNever(name, "Unknown entity name kind.");
            }
            ts.Debug.assert((ts.getCheckFlags(symbol) & 1 /* Instantiated */) === 0, "Should never get an instantiated symbol here.");
            if (!ts.nodeIsSynthesized(name) && ts.isEntityName(name) && (symbol.flags & 2097152 /* Alias */ || name.parent.kind === 270 /* ExportAssignment */)) {
                markSymbolOfAliasDeclarationIfTypeOnly(ts.getAliasDeclarationFromName(name), symbol, /*finalTarget*/ undefined, /*overwriteEmpty*/ true);
            }
            return (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol);
        }
        /**
         * 1. For prototype-property methods like `A.prototype.m = function () ...`, try to resolve names in the scope of `A` too.
         * Note that prototype-property assignment to locations outside the current file (eg globals) doesn't work, so
         * name resolution won't work either.
         * 2. For property assignments like `{ x: function f () { } }`, try to resolve names in the scope of `f` too.
         */
        function resolveEntityNameFromAssignmentDeclaration(name, meaning) {
            if (isJSDocTypeReference(name.parent)) {
                var secondaryLocation = getAssignmentDeclarationLocation(name.parent);
                if (secondaryLocation) {
                    return resolveName(secondaryLocation, name.escapedText, meaning, /*nameNotFoundMessage*/ undefi