1 /* NoTruncation */) {
                    (_b = (_a = context.tracker) === null || _a === void 0 ? void 0 : _a.reportTruncationError) === null || _b === void 0 ? void 0 : _b.call(_a);
                }
                return context.encounteredError ? undefined : resultingNode;
            }
            function wrapSymbolTrackerToReportForContext(context, tracker) {
                var oldTrackSymbol = tracker.trackSymbol;
                return __assign(__assign({}, tracker), { reportCyclicStructureError: wrapReportedDiagnostic(tracker.reportCyclicStructureError), reportInaccessibleThisError: wrapReportedDiagnostic(tracker.reportInaccessibleThisError), reportInaccessibleUniqueSymbolError: wrapReportedDiagnostic(tracker.reportInaccessibleUniqueSymbolError), reportLikelyUnsafeImportRequiredError: wrapReportedDiagnostic(tracker.reportLikelyUnsafeImportRequiredError), reportNonlocalAugmentation: wrapReportedDiagnostic(tracker.reportNonlocalAugmentation), reportPrivateInBaseOfClassExpression: wrapReportedDiagnostic(tracker.reportPrivateInBaseOfClassExpression), reportNonSerializableProperty: wrapReportedDiagnostic(tracker.reportNonSerializableProperty), trackSymbol: oldTrackSymbol && (function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var result = oldTrackSymbol.apply(void 0, args);
                        if (result) {
                            context.reportedDiagnostic = true;
                        }
                        return result;
                    }) });
                function wrapReportedDiagnostic(method) {
                    if (!method) {
                        return method;
                    }
                    return (function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        context.reportedDiagnostic = true;
                        return method.apply(void 0, args);
                    });
                }
            }
            function checkTruncationLength(context) {
                if (context.truncating)
                    return context.truncating;
                return context.truncating = context.approximateLength > ((context.flags & 1 /* NoTruncation */) ? ts.noTruncationMaximumTruncationLength : ts.defaultMaximumTruncationLength);
            }
            function typeToTypeNodeHelper(type, context) {
                if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                    cancellationToken.throwIfCancellationRequested();
                }
                var inTypeAlias = context.flags & 8388608 /* InTypeAlias */;
                context.flags &= ~8388608 /* InTypeAlias */;
                if (!type) {
                    if (!(context.flags & 262144 /* AllowEmptyUnionOrIntersection */)) {
                        context.encounteredError = true;
                        return undefined; // TODO: GH#18217
                    }
                    context.approximateLength += 3;
                    return ts.factory.createKeywordTypeNode(130 /* AnyKeyword */);
                }
                if (!(context.flags & 536870912 /* NoTypeReduction */)) {
                    type = getReducedType(type);
                }
                if (type.flags & 1 /* Any */) {
                    if (type.aliasSymbol) {
                        return ts.factory.createTypeReferenceNode(symbolToEntityNameNode(type.aliasSymbol), mapToTypeNodes(type.aliasTypeArguments, context));
                    }
                    if (type === unresolvedType) {
                        return ts.addSyntheticLeadingComment(ts.factory.createKeywordTypeNode(130 /* AnyKeyword */), 3 /* MultiLineCommentTrivia */, "unresolved");
                    }
                    context.approximateLength += 3;
                    return ts.factory.createKeywordTypeNode(type === intrinsicMarkerType ? 138 /* IntrinsicKeyword */ : 130 /* AnyKeyword */);
                }
                if (type.flags & 2 /* Unknown */) {
                    return ts.factory.createKeywordTypeNode(154 /* UnknownKeyword */);
                }
                if (type.flags & 4 /* String */) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(149 /* StringKeyword */);
                }
                if (type.flags & 8 /* Number */) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(146 /* NumberKeyword */);
                }
                if (type.flags & 64 /* BigInt */) {
                    context.approximateLength += 6;
                    return ts.factory.createKeywordTypeNode(157 /* BigIntKeyword */);
                }
                if (type.flags & 16 /* Boolean */ && !type.aliasSymbol) {
                    context.approximateLength += 7;
                    return ts.factory.createKeywordTypeNode(133 /* BooleanKeyword */);
                }
                if (type.flags & 1024 /* EnumLiteral */ && !(type.flags & 1048576 /* Union */)) {
                    var parentSymbol = getParentOfSymbol(type.symbol);
                    var parentName = symbolToTy