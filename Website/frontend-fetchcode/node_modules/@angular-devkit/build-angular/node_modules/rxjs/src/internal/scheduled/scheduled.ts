 }
                            else if (oldcontext.tracker && oldcontext.tracker.trackSymbol) {
                                return oldcontext.tracker.trackSymbol(sym, decl, meaning);
                            }
                            return false;
                        } }) });
                context.tracker = wrapSymbolTrackerToReportForContext(context, context.tracker);
                ts.forEachEntry(symbolTable, function (symbol, name) {
                    var baseName = ts.unescapeLeadingUnderscores(name);
                    void getInternalSymbolName(symbol, baseName); // Called to cache values into `usedSymbolNames` and `remappedSymbolNames`
                });
                var addingDeclare = !bundled;
                var exportEquals = symbolTable.get("export=" /* ExportEquals */);
                if (exportEquals && symbolTable.size > 1 && exportEquals.flags & 2097152 /* Alias */) {
                    symbolTable = ts.createSymbolTable();
                    // Remove extraneous elements from root symbol table (they'll be mixed back in when the target of the `export=` is looked up)
                    symbolTable.set("export=" /* ExportEquals */, exportEquals);
                }
                visitSymbolTable(symbolTable);
                return mergeRedundantStatements(results);
                function isIdentifierAndNotUndefined(node) {
                    return !!node && node.kind === 79 /* Identifier */;
                }
 