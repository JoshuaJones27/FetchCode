Element");
            }
            return _jsxNamespace;
        }
        function getLocalJsxNamespace(file) {
            if (file.localJsxNamespace) {
                return file.localJsxNamespace;
            }
            var jsxPragma = file.pragmas.get("jsx");
            if (jsxPragma) {
                var chosenPragma = ts.isArray(jsxPragma) ? jsxPragma[0] : jsxPragma;
                file.localJsxFactory = ts.parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
                ts.visitNode(file.localJsxFactory, markAsSynthetic);
                if (file.localJsxFactory) {
                    return file.localJsxNamespace = ts.getFirstIdentifier(file.localJsxFactory).escapedText;
                }
            }
        }
        function markAsSynthetic(node) {
            ts.setTextRangePosEnd(node, -1, -1);
            return ts.visitEachChild(node, markAsSynthetic, ts.nullTransformationContext);
        }
        function getEmitResolver(sourceFile, cancellationToken) {
            // Ensure we have all the type information in place for this file so that all the
            // emitter questions of this resolver will return the right information.
            getDiagnostics(sourceFile, cancellationToken);
            return emitResolver;
        }
        function lookupOrIssueError(location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = location
                ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3)
                : ts.createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
            var existing = diagnostics.lookup(diagnostic);
            if (existing) {
                return existing;
            }
            else {
                diagnostics.add(diagnostic);
                return diagnostic;
            }
        }
        function errorSkippedOn(key, location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = error(location, message, arg0, arg1, arg2, arg3);
            diagnostic.skippedOn = key;
            return diagnostic;
        }
        function createError(location, message, arg0, arg1, arg2, arg3) {
            return location
                ? ts.createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3)
                : ts.createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
        }
        function error(location, message, arg0, arg1, arg2, arg3) {
            var diagnostic = createError(location, message, arg0, arg1, arg2, arg3);
            diagnostics.add(diagnostic);
            return diagnostic;
        }
        function addE