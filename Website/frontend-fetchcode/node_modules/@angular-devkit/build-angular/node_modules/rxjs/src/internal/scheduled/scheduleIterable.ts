                              _loop_9(group_1);
                            }
                        }
                    }
                    return statements;
                }
                function inlineExportModifiers(statements) {
                    // Pass 3: Move all `export {}`'s to `export` modifiers where possible
                    var index = ts.findIndex(statements, function (d) { return ts.isExportDeclaration(d) && !d.moduleSpecifier && !d.assertClause && !!d.exportClause && ts.isNamedExports(d.exportClause); });
                    if (index >= 0) {
                        var exportDecl = statements[index];
                        var replacements = ts.mapDefined(exportDecl.exportClause.elements, function (e) {
                            if (!e.propertyName) {
                                // export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it
                                var indices = ts.indicesOf(statements);
                                var associatedIndices = ts.filter(indices, function (i) { return ts.nodeHasName(statements[i], e.name); });
                                if (ts.length(associatedIndices) && ts.every(as